{"version":3,"file":"utils.cjs.production.min.js","sources":["../src/types/message.ts","../src/helpers.ts","../src/url.ts","../src/math.ts","../src/canned.ts","../src/sla.ts","../src/fileUploadRules.ts","../src/date.ts","../src/typingStatus.ts","../src/debounce.ts","../src/email.ts","../src/string.ts"],"sourcesContent":["export type EmailAttributes = {\n  bcc: string[] | null;\n  cc: string[] | null;\n  content_type: string;\n  date: string;\n  from: string[] | null;\n  html_content: {\n    full: string;\n    reply: string;\n    quoted: string;\n  };\n  in_reply_to: null;\n  message_id: string;\n  multipart: boolean;\n  number_of_attachments: number;\n  subject: string;\n  text_content: {\n    full: string;\n    reply: string;\n    quoted: string;\n  };\n  to: string[] | null;\n};\n\nexport type IncomingContentAttribute = {\n  email: EmailAttributes | null;\n};\n\nexport type OutgoingContentAttribute = {\n  cc_emails: string[] | null;\n  bcc_emails: string[] | null;\n  to_emails: string[] | null;\n  external_error: string;\n};\n\nexport type MessageContentAttributes =\n  | IncomingContentAttribute\n  | OutgoingContentAttribute;\n\nexport type MessageConversation = {\n  id: number;\n  assignee_id: number;\n  custom_attributes: Record<string, any>;\n  first_reply_created_at: number;\n  waiting_since: number;\n  status: string;\n  unread_count: number;\n  last_activity_at: number;\n  contact_inbox: { source_id: string };\n};\n\nexport type MessageAttachment = {\n  id: number;\n  message_id: number;\n  file_type: string;\n  account_id: number;\n  extension: null;\n  data_url: string;\n  thumb_url: string;\n  file_size: number;\n  width: null;\n  height: null;\n};\n\nexport type MessageSender = {\n  custom_attributes: {};\n  email: null;\n  id: number;\n  identifier: null;\n  name: string;\n  phone_number: null;\n  thumbnail: string;\n  type: string;\n};\n\nexport enum MessageType {\n  INCOMING = 0,\n  OUTGOING = 1,\n  ACTIVITY = 2,\n  TEMPLATE = 3,\n}\n\nexport type BaseEmailMessage = {\n  id: number;\n  content: null;\n  account_id: number;\n  inbox_id: number;\n  conversation_id: number;\n  message_type: MessageType;\n  created_at: number;\n  updated_at: string;\n  private: boolean;\n  status: string;\n  source_id: null;\n  content_type: string;\n  content_attributes: MessageContentAttributes;\n  sender_type: string;\n  sender_id: number;\n  external_source_ids: {};\n  additional_attributes: {};\n  processed_message_content: null;\n  sentiment: {};\n  conversation: MessageConversation;\n  attachments: MessageAttachment[];\n  sender: MessageSender;\n};\n\nexport type IncomingEmailMessage = BaseEmailMessage & {\n  message_type: MessageType.INCOMING;\n  content_attributes: IncomingContentAttribute;\n};\n\nexport type OutgoingEmailMessage = BaseEmailMessage & {\n  message_type: MessageType.OUTGOING;\n  content_attributes: OutgoingContentAttribute;\n};\n\nexport type EmailMessage = IncomingEmailMessage | OutgoingEmailMessage;\n","import isToday from 'date-fns/isToday';\nimport isYesterday from 'date-fns/isYesterday';\n/**\n * @name Get contrasting text color\n * @description Get contrasting text color from a text color\n * @param bgColor  Background color of text.\n * @returns contrasting text color\n */\nexport const getContrastingTextColor = (bgColor: string): string => {\n  const color = bgColor.replace('#', '');\n  const r = parseInt(color.slice(0, 2), 16);\n  const g = parseInt(color.slice(2, 4), 16);\n  const b = parseInt(color.slice(4, 6), 16);\n  // http://stackoverflow.com/a/3943023/112731\n  return r * 0.299 + g * 0.587 + b * 0.114 > 186 ? '#000000' : '#FFFFFF';\n};\n\n/**\n * @name Get formatted date\n * @description Get date in today, yesterday or any other date format\n * @param date  date\n * @param todayText  Today text\n * @param yesterdayText  Yesterday text\n * @returns formatted date\n */\nexport const formatDate = ({\n  date,\n  todayText,\n  yesterdayText,\n}: {\n  date: string;\n  todayText: string;\n  yesterdayText: string;\n}) => {\n  const dateValue = new Date(date);\n  if (isToday(dateValue)) return todayText;\n  if (isYesterday(dateValue)) return yesterdayText;\n  return date;\n};\n\n/**\n * @name formatTime\n * @description Format time to Hour, Minute and Second\n * @param timeInSeconds  number\n * @returns formatted time\n */\n\nexport const formatTime = (timeInSeconds: number) => {\n  let formattedTime = '';\n  if (timeInSeconds >= 60 && timeInSeconds < 3600) {\n    const minutes = Math.floor(timeInSeconds / 60);\n    formattedTime = `${minutes} Min`;\n    const seconds = minutes === 60 ? 0 : Math.floor(timeInSeconds % 60);\n    return formattedTime + `${seconds > 0 ? ' ' + seconds + ' Sec' : ''}`;\n  }\n  if (timeInSeconds >= 3600 && timeInSeconds < 86400) {\n    const hours = Math.floor(timeInSeconds / 3600);\n    formattedTime = `${hours} Hr`;\n    const minutes =\n      timeInSeconds % 3600 < 60 || hours === 24\n        ? 0\n        : Math.floor((timeInSeconds % 3600) / 60);\n    return formattedTime + `${minutes > 0 ? ' ' + minutes + ' Min' : ''}`;\n  }\n  if (timeInSeconds >= 86400) {\n    const days = Math.floor(timeInSeconds / 86400);\n    formattedTime = `${days} Day`;\n    const hours =\n      timeInSeconds % 86400 < 3600 || days >= 364\n        ? 0\n        : Math.floor((timeInSeconds % 86400) / 3600);\n    return formattedTime + `${hours > 0 ? ' ' + hours + ' Hr' : ''}`;\n  }\n  return `${Math.floor(timeInSeconds)} Sec`;\n};\n\n/**\n * @name trimContent\n * @description Trim a string to max length\n * @param content String to trim\n * @param maxLength Length of the string to trim, default 1024\n * @param ellipsis Boolean to add dots at the end of the string, default false\n * @returns trimmed string\n */\nexport const trimContent = (\n  content: string = '',\n  maxLength: number = 1024,\n  ellipsis: boolean = false\n) => {\n  let trimmedContent = content;\n  if (content.length > maxLength) {\n    trimmedContent = content.substring(0, maxLength);\n  }\n  if (ellipsis) {\n    trimmedContent = trimmedContent + '...';\n  }\n  return trimmedContent;\n};\n\n/**\n * @name convertSecondsToTimeUnit\n * @description Convert seconds to time unit\n * @param seconds  number\n * @param unitNames  object\n * @returns time and unit\n * @example\n * convertToUnit(60, { minute: 'm', hour: 'h', day: 'd' }); // { time: 1, unit: 'm' }\n * convertToUnit(60, { minute: 'Minutes', hour: 'Hours', day: 'Days' }); // { time: 1, unit: 'Minutes' }\n */\n\nexport const convertSecondsToTimeUnit = (\n  seconds: number,\n  unitNames: { minute: string; hour: string; day: string }\n) => {\n  if (seconds === null || seconds === 0) return { time: '', unit: '' };\n  if (seconds < 3600)\n    return { time: Number((seconds / 60).toFixed(1)), unit: unitNames.minute };\n  if (seconds < 86400)\n    return { time: Number((seconds / 3600).toFixed(1)), unit: unitNames.hour };\n  return { time: Number((seconds / 86400).toFixed(1)), unit: unitNames.day };\n};\n\n/**\n * @name fileNameWithEllipsis\n * @description Truncates a filename while preserving the extension\n * @param {Object} file - File object containing filename or name property\n * @param {number} [maxLength=26] - Maximum length of the filename (excluding extension)\n * @param {string} [ellipsis='…'] - Character to use for truncation\n * @returns {string} Truncated filename with extension\n * @example\n * fileNameWithEllipsis({ filename: 'very-long-filename.pdf' }, 10) // 'very-long-f….pdf'\n * fileNameWithEllipsis({ name: 'short.txt' }, 10) // 'short.txt'\n */\nexport const fileNameWithEllipsis = (\n  file: { filename?: string; name?: string },\n  maxLength: number = 26,\n  ellipsis: string = '…'\n): string => {\n  const fullName = file?.filename ?? file?.name ?? 'Untitled';\n\n  const dotIndex = fullName.lastIndexOf('.');\n  if (dotIndex === -1) return fullName;\n\n  const [name, extension] = [\n    fullName.slice(0, dotIndex),\n    fullName.slice(dotIndex),\n  ];\n\n  if (name.length <= maxLength) return fullName;\n\n  return `${name.slice(0, maxLength)}${ellipsis}${extension}`;\n};\n\n/**\n * @name splitName\n * @description Splits a full name into firstName and lastName\n * @param {string} name - Full name of the user\n * @returns {Object} Object with firstName and lastName\n * @example\n * splitName('Mary Jane Smith') // { firstName: 'Mary Jane', lastName: 'Smith' }\n * splitName('Alice') // { firstName: 'Alice', lastName: '' }\n * splitName('John Doe') // { firstName: 'John', lastName: 'Doe' }\n * splitName('') // { firstName: '', lastName: '' }\n */\nexport const splitName = (\n  fullName: string\n): { firstName: string; lastName: string } => {\n  const trimmedName = fullName.trim();\n  if (!trimmedName) {\n    return {\n      firstName: '',\n      lastName: '',\n    };\n  }\n\n  // Split the name by spaces\n  const nameParts = trimmedName.split(/\\s+/);\n\n  // If only one word, treat it as firstName\n  if (nameParts.length === 1) {\n    return {\n      firstName: nameParts[0],\n      lastName: '',\n    };\n  }\n\n  // Last element is lastName, everything else is firstName\n  const lastName = nameParts.pop() || '';\n  const firstName = nameParts.join(' ');\n\n  return { firstName, lastName };\n};\n\ninterface DownloadFileOptions {\n  url: string;\n  type: string;\n  extension?: string | null;\n}\n/**\n * Downloads a file from a URL with proper file type handling\n * @name downloadFile\n * @description Downloads file from URL with proper type handling and cleanup\n * @param {Object} options Download configuration options\n * @param {string} options.url File URL to download\n * @param {string} options.type File type identifier\n * @param {string} [options.extension] Optional file extension\n * @returns {Promise<boolean>} Returns true if download successful, false otherwise\n */\nexport const downloadFile = async ({\n  url,\n  type,\n  extension = null,\n}: DownloadFileOptions): Promise<void> => {\n  if (!url || !type) {\n    throw new Error('Invalid download parameters');\n  }\n\n  try {\n    const response = await fetch(url, { cache: 'no-store' });\n\n    if (!response.ok) {\n      throw new Error(`Download failed: ${response.status}`);\n    }\n\n    const blobData = await response.blob();\n\n    const contentType = response.headers.get('content-type');\n\n    const fileExtension =\n      extension || (contentType ? contentType.split('/')[1] : type);\n\n    const dispositionHeader = response.headers.get('content-disposition');\n    const filenameMatch = dispositionHeader?.match(/filename=\"(.*?)\"/);\n\n    const filename =\n      filenameMatch?.[1] ?? `attachment_${Date.now()}.${fileExtension}`;\n\n    const blobUrl = URL.createObjectURL(blobData);\n    const link = Object.assign(document.createElement('a'), {\n      href: blobUrl,\n      download: filename,\n      style: 'display: none',\n    });\n\n    document.body.append(link);\n    link.click();\n    link.remove();\n    URL.revokeObjectURL(blobUrl);\n  } catch (error) {\n    throw error instanceof Error ? error : new Error('Download failed');\n  }\n};\n\ninterface FileInfo {\n  name: string; // Full filename with extension\n  type: string; // File extension only\n  base: string; // Filename without extension\n}\n/**\n * Extracts file information from a URL or file path.\n *\n * @param {string} url - The URL or file path to process\n * @returns {FileInfo} Object containing file information\n *\n * @example\n * getFileInfo('https://example.com/path/Document%20Name.PDF')\n * returns {\n *   name: 'Document Name.PDF',\n *   type: 'pdf',\n *   base: 'Document Name'\n * }\n *\n * getFileInfo('invalid/url')\n * returns {\n *   name: 'Unknown File',\n *   type: '',\n *   base: 'Unknown File'\n * }\n */\nexport const getFileInfo = (url: string): FileInfo => {\n  const defaultInfo: FileInfo = {\n    name: 'Unknown File',\n    type: '',\n    base: 'Unknown File',\n  };\n\n  if (!url || typeof url !== 'string') {\n    return defaultInfo;\n  }\n\n  try {\n    // Handle both URL and file path cases\n    const cleanUrl = url\n      .split(/[?#]/)[0] // Remove query params and hash\n      .replace(/\\\\/g, '/'); // Normalize path separators\n\n    const encodedFilename = cleanUrl.split('/').pop();\n    if (!encodedFilename) {\n      return defaultInfo;\n    }\n\n    const fileName = decodeURIComponent(encodedFilename);\n\n    // Handle hidden files (starting with dot)\n    if (fileName.startsWith('.') && !fileName.includes('.', 1)) {\n      return { name: fileName, type: '', base: fileName };\n    }\n\n    // last index is where the file extension starts\n    // This will handle cases where the file name has multiple dots\n    const lastDotIndex = fileName.lastIndexOf('.');\n    if (lastDotIndex === -1 || lastDotIndex === 0) {\n      return { name: fileName, type: '', base: fileName };\n    }\n\n    const base = fileName.slice(0, lastDotIndex);\n    const type = fileName.slice(lastDotIndex + 1).toLowerCase();\n\n    return { name: fileName, type, base };\n  } catch (error) {\n    console.error('Error processing file info:', error);\n    return defaultInfo;\n  }\n};\n\n/**\n * Formats a number with K/M/B/T suffixes using Intl.NumberFormat\n * @param {number | string | null | undefined} num - The number to format\n * @returns {string} Formatted string (e.g., \"1.2K\", \"2.3M\", \"999\")\n * @example\n * formatNumber(1234)     // \"1.2K\"\n * formatNumber(1000000)  // \"1M\"\n * formatNumber(999)      // \"999\"\n * formatNumber(12344)    // \"12.3K\"\n */\nexport const formatNumber = (\n  num: number | string | null | undefined\n): string => {\n  const n = Number(num) || 0;\n  return new Intl.NumberFormat('en', {\n    notation: 'compact',\n    maximumFractionDigits: 1,\n  } as Intl.NumberFormatOptions).format(n);\n};\n","/**\n * URL related helper functions\n */\n\n/**\n * Converts various input formats to URL objects.\n * Handles URL objects, domain strings, relative paths, and full URLs.\n * @param {string|URL} input - Input to convert to URL object\n * @returns {URL|null} URL object or null if input is invalid\n */\nexport const toURL = (input: string | URL | null | undefined): URL | null => {\n  if (!input) return null;\n  if (input instanceof URL) return input;\n\n  if (\n    typeof input === 'string' &&\n    !input.includes('://') &&\n    !input.startsWith('/')\n  ) {\n    return new URL(`https://${input}`);\n  }\n\n  if (typeof input === 'string' && input.startsWith('/')) {\n    return new URL(input, window.location.origin);\n  }\n\n  return new URL(input as string);\n};\n\n/**\n * Determines if two URLs belong to the same host by comparing their normalized URL objects.\n * Handles various input formats including URL objects, domain strings, relative paths, and full URLs.\n * Returns false if either URL cannot be parsed or normalized.\n * @param {string|URL} url1 - First URL to compare\n * @param {string|URL} url2 - Second URL to compare\n * @returns {boolean} True if both URLs have the same host, false otherwise\n */\nexport const isSameHost = (\n  url1: string | URL | null | undefined,\n  url2: string | URL | null | undefined\n): boolean => {\n  try {\n    const urlObj1 = toURL(url1);\n    const urlObj2 = toURL(url2);\n\n    if (!urlObj1 || !urlObj2) return false;\n\n    return urlObj1.hostname === urlObj2.hostname;\n  } catch (error) {\n    return false;\n  }\n};\n\n/**\n * Check if a string is a valid domain name.\n * An empty string is allowed and considered valid.\n *\n * @param domain Domain to validate.\n * @returns Whether the domain matches the rules.\n */\nexport const isValidDomain = (domain: string): boolean => {\n  if (domain === '') return true;\n\n  const domainRegex = /^(?!-)(?!.*--)[\\p{L}0-9-]{1,63}(?<!-)(?:\\.(?!-)(?!.*--)[\\p{L}0-9-]{1,63}(?<!-))*\\.[\\p{L}]{2,63}$/u;\n\n  return domainRegex.test(domain) && domain.length <= 253;\n};\n","/**\n * Sorts an array of numbers in ascending order.\n * @param {number[]} arr - The array of numbers to be sorted.\n * @returns {number[]} - The sorted array.\n */\nexport function sortAsc(arr: number[]) {\n  // .slice() is used to create a copy of the array so that the original array is not mutated\n  return arr.slice().sort((a, b) => a - b);\n}\n\n/**\n * Calculates the quantile value of an array at a specified percentile.\n * @param {number[]} arr - The array of numbers to calculate the quantile value from.\n * @param {number} q - The percentile to calculate the quantile value for.\n * @returns {number} - The quantile value.\n */\nexport function quantile(arr: number[], q: number) {\n  const sorted = sortAsc(arr); // Sort the array in ascending order\n  return _quantileForSorted(sorted, q); // Calculate the quantile value\n}\n\n/**\n * Clamps a value between a minimum and maximum range.\n * @param {number} min - The minimum range.\n * @param {number} max - The maximum range.\n * @param {number} value - The value to be clamped.\n * @returns {number} - The clamped value.\n */\nexport function clamp(min: number, max: number, value: number) {\n  if (value < min) {\n    return min;\n  }\n  if (value > max) {\n    return max;\n  }\n  return value;\n}\n\n/**\n * This method assumes the the array provided is already sorted in ascending order.\n * It's a helper method for the quantile method and should not be exported as is.\n *\n * @param {number[]} arr - The array of numbers to calculate the quantile value from.\n * @param {number} q - The percentile to calculate the quantile value for.\n * @returns {number} - The quantile value.\n */\nfunction _quantileForSorted(sorted: number[], q: number) {\n  const clamped = clamp(0, 1, q); // Clamp the percentile between 0 and 1\n  const pos = (sorted.length - 1) * clamped; // Calculate the index of the element at the specified percentile\n  const base = Math.floor(pos); // Find the index of the closest element to the specified percentile\n  const rest = pos - base; // Calculate the decimal value between the closest elements\n\n  // Interpolate the quantile value between the closest elements\n  // Most libraries don't to the interpolation, but I'm just having fun here\n  // also see https://en.wikipedia.org/wiki/Quantile#Estimating_quantiles_from_a_sample\n  if (sorted[base + 1] !== undefined) {\n    // in case the position was a integer, the rest will be 0 and the interpolation will be skipped\n    return sorted[base] + rest * (sorted[base + 1] - sorted[base]);\n  }\n\n  // Return the closest element if there is no interpolation possible\n  return sorted[base];\n}\n\n/**\n * Calculates the quantile values for an array of intervals.\n * @param {number[]} data - The array of numbers to calculate the quantile values from.\n * @param {number[]} intervals - The array of intervals to calculate the quantile values for.\n * @returns {number[]} - The array of quantile values for the intervals.\n */\nexport const getQuantileIntervals = (data: number[], intervals: number[]) => {\n  // Sort the array in ascending order before looping through the intervals.\n  // depending on the size of the array and the number of intervals, this can speed up the process by at least twice\n  // for a random array of 100 numbers and 5 intervals, the speedup is 3x\n  const sorted = sortAsc(data);\n\n  return intervals.map(interval => {\n    return _quantileForSorted(sorted, interval);\n  });\n};\n\n/**\n * Calculates the relative position of a point from the center of an element\n *\n * @param {number} mouseX - The x-coordinate of the mouse pointer\n * @param {number} mouseY - The y-coordinate of the mouse pointer\n * @param {DOMRect} rect - The bounding client rectangle of the target element\n * @returns {{relativeX: number, relativeY: number}} Object containing x and y distances from center\n */\nexport const calculateCenterOffset = (\n  mouseX: number,\n  mouseY: number,\n  rect: DOMRect\n) => {\n  const centerX = rect.left + rect.width / 2;\n  const centerY = rect.top + rect.height / 2;\n\n  return {\n    relativeX: mouseX - centerX,\n    relativeY: mouseY - centerY,\n  };\n};\n\n/**\n * Applies a rotation matrix to coordinates\n * Used to adjust mouse coordinates based on the current rotation of the image\n * This function implements a standard 2D rotation matrix transformation:\n * [x']   [cos(θ) -sin(θ)] [x]\n * [y'] = [sin(θ)  cos(θ)] [y]\n *\n * @see {@link https://mathworld.wolfram.com/RotationMatrix.html} for mathematical derivation\n *\n * @param {number} relativeX - X-coordinate relative to center before rotation\n * @param {number} relativeY - Y-coordinate relative to center before rotation\n * @param {number} angle - Rotation angle in degrees\n * @returns {{rotatedX: number, rotatedY: number}} Coordinates after applying rotation matrix\n */\nexport const applyRotationTransform = (\n  relativeX: number,\n  relativeY: number,\n  angle: number\n) => {\n  const radians = (angle * Math.PI) / 180;\n  const cos = Math.cos(-radians);\n  const sin = Math.sin(-radians);\n\n  return {\n    rotatedX: relativeX * cos - relativeY * sin,\n    rotatedY: relativeX * sin + relativeY * cos,\n  };\n};\n\n/**\n * Converts absolute rotated coordinates to percentage values relative to image dimensions\n * Ensures values are clamped between 0-100% for valid CSS transform-origin properties\n *\n * @param {number} rotatedX - X-coordinate after rotation transformation\n * @param {number} rotatedY - Y-coordinate after rotation transformation\n * @param {number} width - Width of the target element\n * @param {number} height - Height of the target element\n * @returns {{x: number, y: number}} Normalized coordinates as percentages (0-100%)\n */\nexport const normalizeToPercentage = (\n  rotatedX: number,\n  rotatedY: number,\n  width: number,\n  height: number\n) => {\n  // Convert to percentages (0-100%) relative to image dimensions\n  // 50% represents the center point\n  // The division by (width/2) maps the range [-width/2, width/2] to [-50%, 50%]\n  // Adding 50% shifts this to [0%, 100%]\n  return {\n    x: Math.max(0, Math.min(100, 50 + (rotatedX / (width / 2)) * 50)),\n    y: Math.max(0, Math.min(100, 50 + (rotatedY / (height / 2)) * 50)),\n  };\n};\n","import {\n  Conversation,\n  Sender,\n  Variables,\n  CustomAttributes,\n  Contact,\n  Inbox,\n} from './types/conversation';\nconst MESSAGE_VARIABLES_REGEX = /{{(.*?)}}/g;\n\nconst skipCodeBlocks = (str: string) => str.replace(/```(?:.|\\n)+?```/g, '');\n\nexport const capitalizeName = (name: string | null): string => {\n  if (!name) return ''; // Return empty string for null or undefined input\n\n  return name\n    .split(' ') // Split the name into words based on spaces\n    .map(word => {\n      if (!word) return ''; // Handle empty strings that might result from multiple spaces\n\n      // Capitalize only the first character, leaving the rest unchanged\n      // This correctly handles accented characters like 'í' in 'Aríel'\n      return word.charAt(0).toUpperCase() + word.slice(1);\n    })\n    .join(' '); // Rejoin the words with spaces\n};\n\nexport const getFirstName = ({ user }: { user: Sender }) => {\n  const firstName = user?.name ? user.name.split(' ').shift() : '';\n  return capitalizeName(firstName as string);\n};\n\nexport const getLastName = ({ user }: { user: Sender }) => {\n  if (user && user.name) {\n    const lastName =\n      user.name.split(' ').length > 1 ? user.name.split(' ').pop() : '';\n    return capitalizeName(lastName as string);\n  }\n  return '';\n};\n\nexport const getMessageVariables = ({\n  conversation,\n  contact,\n  inbox,\n}: {\n  conversation: Conversation;\n  contact?: Contact;\n  inbox?: Inbox;\n}) => {\n  const {\n    meta: { assignee, sender },\n    id,\n    custom_attributes: conversationCustomAttributes = {},\n  } = conversation;\n  const { custom_attributes: contactCustomAttributes } = contact || {};\n\n  const standardVariables = {\n    'contact.name': capitalizeName(sender?.name || ''),\n    'contact.first_name': getFirstName({ user: sender }),\n    'contact.last_name': getLastName({ user: sender }),\n    'contact.email': sender?.email,\n    'contact.phone': sender?.phone_number,\n    'contact.id': sender?.id,\n    'conversation.id': id,\n    'inbox.id': inbox?.id,\n    'inbox.name': inbox?.name,\n    'agent.name': capitalizeName(assignee?.name || ''),\n    'agent.first_name': getFirstName({ user: assignee }),\n    'agent.last_name': getLastName({ user: assignee }),\n    'agent.email': assignee?.email ?? '',\n  };\n  const conversationCustomAttributeVariables = Object.entries(\n    conversationCustomAttributes ?? {}\n  ).reduce((acc: CustomAttributes, [key, value]) => {\n    acc[`conversation.custom_attribute.${key}`] = value;\n    return acc;\n  }, {});\n\n  const contactCustomAttributeVariables = Object.entries(\n    contactCustomAttributes ?? {}\n  ).reduce((acc: CustomAttributes, [key, value]) => {\n    acc[`contact.custom_attribute.${key}`] = value;\n    return acc;\n  }, {});\n\n  const variables = {\n    ...standardVariables,\n    ...conversationCustomAttributeVariables,\n    ...contactCustomAttributeVariables,\n  };\n\n  return variables;\n};\n\nexport const replaceVariablesInMessage = ({\n  message,\n  variables,\n}: {\n  message: string;\n  variables: Variables;\n}) => {\n  // @ts-ignore\n  return message?.replace(MESSAGE_VARIABLES_REGEX, (_, replace) => {\n    return variables[replace.trim()]\n      ? variables[replace.trim().toLowerCase()]\n      : '';\n  });\n};\n\nexport const getUndefinedVariablesInMessage = ({\n  message,\n  variables,\n}: {\n  message: string;\n  variables: Variables;\n}) => {\n  const messageWithOutCodeBlocks = skipCodeBlocks(message);\n  const matches = messageWithOutCodeBlocks.match(MESSAGE_VARIABLES_REGEX);\n  if (!matches) return [];\n\n  return matches\n    .map(match => {\n      return match\n        .replace('{{', '')\n        .replace('}}', '')\n        .trim();\n    })\n    .filter(variable => {\n      return variables[variable] === undefined;\n    });\n};\n","import { Conversation } from './types/conversation';\nimport { AppliedSla, SLAStatus } from './types/sla';\n\n/**\n * Calculates the threshold for an SLA based on the current time and the provided threshold.\n * @param timeOffset - The time offset in seconds.\n * @param threshold - The threshold in seconds or null if not applicable.\n * @returns The calculated threshold in seconds or null if the threshold is null.\n */\nconst calculateThreshold = (\n  timeOffset: number,\n  threshold: number | null\n): number | null => {\n  // Calculate the time left for the SLA to breach or the time since the SLA has missed\n  if (threshold === null) return null;\n  const currentTime = Math.floor(Date.now() / 1000);\n  return timeOffset + threshold - currentTime;\n};\n\n/**\n * Finds the most urgent SLA status based on the threshold.\n * @param SLAStatuses - An array of SLAStatus objects.\n * @returns The most urgent SLAStatus object.\n */\nconst findMostUrgentSLAStatus = (SLAStatuses: SLAStatus[]): SLAStatus => {\n  // Sort the SLAs based on the threshold and return the most urgent SLA\n  SLAStatuses.sort(\n    (sla1, sla2) => Math.abs(sla1.threshold) - Math.abs(sla2.threshold)\n  );\n  return SLAStatuses[0];\n};\n\n/**\n * Formats the SLA time in a human-readable format.\n * @param seconds - The time in seconds.\n * @returns A formatted string representing the time.\n */\nconst formatSLATime = (seconds: number): string => {\n  const units: { [key: string]: number } = {\n    y: 31536000, // 60 * 60 * 24 * 365\n    mo: 2592000, // 60 * 60 * 24 * 30\n    d: 86400, // 60 * 60 * 24\n    h: 3600, // 60 * 60\n    m: 60,\n  };\n\n  if (seconds < 60) {\n    return '1m';\n  }\n\n  // we will only show two parts, two max granularity's, h-m, y-d, d-h, m, but no seconds\n  const parts: string[] = [];\n\n  Object.keys(units).forEach(unit => {\n    const value = Math.floor(seconds / units[unit]);\n    if (seconds < 60 && parts.length > 0) return;\n    if (parts.length === 2) return;\n    if (value > 0) {\n      parts.push(value + unit);\n      seconds -= value * units[unit];\n    }\n  });\n  return parts.join(' ');\n};\n\n/**\n * Creates an SLA object based on the type, applied SLA, and chat details.\n * @param type - The type of SLA (FRT, NRT, RT).\n * @param appliedSla - The applied SLA details.\n * @param chat - The chat details.\n * @returns An object containing the SLA status or null if conditions are not met.\n */\nconst createSLAObject = (\n  type: string,\n  appliedSla: AppliedSla,\n  chat: Conversation\n): { threshold: number | null; type: string; condition: boolean } | null => {\n  const {\n    sla_first_response_time_threshold: frtThreshold,\n    sla_next_response_time_threshold: nrtThreshold,\n    sla_resolution_time_threshold: rtThreshold,\n    created_at: createdAt,\n  } = appliedSla;\n\n  const {\n    first_reply_created_at: firstReplyCreatedAt,\n    waiting_since: waitingSince,\n    status,\n  } = chat;\n\n  const SLATypes: {\n    [key: string]: { threshold: number | null; condition: boolean };\n  } = {\n    FRT: {\n      threshold: calculateThreshold(createdAt, frtThreshold),\n      //   Check FRT only if threshold is not null and first reply hasn't been made\n      condition:\n        frtThreshold !== null &&\n        (!firstReplyCreatedAt || firstReplyCreatedAt === 0),\n    },\n    NRT: {\n      threshold: calculateThreshold(waitingSince, nrtThreshold),\n      // Check NRT only if threshold is not null, first reply has been made and we are waiting since\n      condition:\n        nrtThreshold !== null && !!firstReplyCreatedAt && !!waitingSince,\n    },\n    RT: {\n      threshold: calculateThreshold(createdAt, rtThreshold),\n      // Check RT only if the conversation is open and threshold is not null\n      condition: status === 'open' && rtThreshold !== null,\n    },\n  };\n\n  const SLAStatus = SLATypes[type];\n  return SLAStatus ? { ...SLAStatus, type } : null;\n};\n\n/**\n * Evaluates SLA conditions and returns an array of SLAStatus objects.\n * @param appliedSla - The applied SLA details.\n * @param chat - The chat details.\n * @returns An array of SLAStatus objects.\n */\nconst evaluateSLAConditions = (\n  appliedSla: AppliedSla,\n  chat: Conversation\n): {\n  threshold: number;\n  type: string;\n  icon: string;\n  isSlaMissed: boolean;\n}[] => {\n  // Filter out the SLA based on conditions and update the object with the breach status(icon, isSlaMissed)\n  const SLATypes = ['FRT', 'NRT', 'RT'];\n  return SLATypes.map(type => createSLAObject(type, appliedSla, chat))\n    .filter(\n      (\n        SLAStatus\n      ): SLAStatus is { threshold: number; type: string; condition: boolean } =>\n        !!SLAStatus && SLAStatus.condition\n    )\n    .map(SLAStatus => ({\n      ...SLAStatus,\n      icon: SLAStatus.threshold <= 0 ? 'flame' : 'alarm',\n      isSlaMissed: SLAStatus.threshold <= 0,\n    }));\n};\n\n/**\n * Evaluates the SLA status for a given chat and applied SLA.\n * @param {Object} params - The parameters object.\n * @param params.appliedSla - The applied SLA details.\n * @param params.chat - The chat details.\n * @returns An object containing the most urgent SLA status.\n */\nexport const evaluateSLAStatus = ({\n  appliedSla,\n  chat,\n}: {\n  appliedSla: AppliedSla;\n  chat: Conversation;\n}): { type: string; threshold: string; icon: string; isSlaMissed: boolean } => {\n  if (!appliedSla || !chat)\n    return { type: '', threshold: '', icon: '', isSlaMissed: false };\n\n  // Filter out the SLA and create the object for each breach\n  const SLAStatuses = evaluateSLAConditions(appliedSla, chat) as SLAStatus[];\n\n  // Return the most urgent SLA which is latest to breach or has missed\n  const mostUrgent = findMostUrgentSLAStatus(SLAStatuses);\n  return mostUrgent\n    ? {\n        type: mostUrgent?.type,\n        threshold: formatSLATime(\n          mostUrgent.threshold <= 0\n            ? -mostUrgent.threshold\n            : mostUrgent.threshold\n        ),\n        icon: mostUrgent.icon,\n        isSlaMissed: mostUrgent.isSlaMissed,\n      }\n    : { type: '', threshold: '', icon: '', isSlaMissed: false };\n};\n","// ---------- Types ----------\ninterface MimeGroups {\n  image?: string[];\n  audio?: string[];\n  video?: string[];\n  text?: string[];\n  application?: string[];\n}\n\ninterface ChannelNodeConfig {\n  mimeGroups?: MimeGroups;\n  extensions?: string[];\n  max?: number;\n  maxByCategory?: {\n    image?: number;\n    video?: number;\n    audio?: number;\n    document?: number;\n  };\n}\n\ntype DefaultNodeConfig = Omit<ChannelNodeConfig, 'max'> & { max: number };\n\ninterface ChannelConfig {\n  [medium: string]: ChannelNodeConfig | undefined; // includes '*'\n}\n\ntype CategoryType = 'image' | 'video' | 'audio' | 'document' | undefined;\n\ninterface GetChannelParams {\n  channelType?: ChannelKey; // align with ChannelKey\n  medium?: string;\n}\n\ninterface GetMaxUploadParams extends GetChannelParams {\n  mime?: string;\n}\n\n// ---------- Channels ----------\nexport const INBOX_TYPES = {\n  WEB: 'Channel::WebWidget',\n  FB: 'Channel::FacebookPage',\n  TWITTER: 'Channel::TwitterProfile',\n  TWILIO: 'Channel::TwilioSms',\n  WHATSAPP: 'Channel::Whatsapp',\n  API: 'Channel::Api',\n  EMAIL: 'Channel::Email',\n  TELEGRAM: 'Channel::Telegram',\n  LINE: 'Channel::Line',\n  SMS: 'Channel::Sms',\n  INSTAGRAM: 'Channel::Instagram',\n  VOICE: 'Channel::Voice',\n} as const;\n\n// derive key type AFTER INBOX_TYPES is declared\ntype ChannelKey = typeof INBOX_TYPES[keyof typeof INBOX_TYPES];\n\n// CHANNEL_CONFIGS shape: channels are optional; default node requires max\ntype ChannelConfigs = Partial<Record<ChannelKey, ChannelConfig>> & {\n  default: DefaultNodeConfig;\n};\n\n// ---------- Docs ----------\n/**\n * LINE: https://developers.line.biz/en/reference/messaging-api/#image-message, https://developers.line.biz/en/reference/messaging-api/#video-message\n * INSTAGRAM: https://developers.facebook.com/docs/instagram-platform/instagram-api-with-instagram-login/messaging-api#requirements\n * WHATSAPP CLOUD: https://developers.facebook.com/docs/whatsapp/cloud-api/reference/media#supported-media-types\n * TWILIO WHATSAPP: https://www.twilio.com/docs/whatsapp/guidance-whatsapp-media-messages\n * TWILIO SMS: https://www.twilio.com/docs/messaging/guides/accepted-mime-types\n */\n\n// ---------- Central config ----------\n/**\n * Upload rules configuration.\n *\n * Each node can define:\n * - mimeGroups: { prefix: [exts] }\n *   Example: { image: [\"png\",\"jpeg\"] } → [\"image/png\",\"image/jpeg\"]\n *   Special: [\"*\"] → allow all (e.g. \"image/*\").\n * - extensions: Raw file extensions (e.g. [\".3gpp\"]).\n * - max: Default maximum size in MB for this channel.\n * - maxByCategory: Override per category (image, video, audio, document).\n *\n * Resolution order:\n *  1. channel + medium (e.g. TWILIO.whatsapp)\n *  2. channel + \"*\" fallback\n *  3. global default\n */\nconst CHANNEL_CONFIGS: ChannelConfigs = {\n  default: {\n    mimeGroups: {\n      image: ['*'],\n      audio: ['*'],\n      video: ['*'],\n      text: ['csv', 'plain', 'rtf', 'xml'],\n      application: [\n        'json',\n        'pdf',\n        'xml',\n        'zip',\n        'x-7z-compressed',\n        'vnd.rar',\n        'x-tar',\n        'msword',\n        'vnd.ms-excel',\n        'vnd.ms-powerpoint',\n        'vnd.oasis.opendocument.text',\n        'vnd.openxmlformats-officedocument.presentationml.presentation',\n        'vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n        'vnd.openxmlformats-officedocument.wordprocessingml.document',\n      ],\n    },\n    extensions: ['.3gpp'],\n    max: 40,\n  },\n\n  [INBOX_TYPES.WHATSAPP]: {\n    '*': {\n      mimeGroups: {\n        audio: ['aac', 'amr', 'mp3', 'm4a', 'ogg'],\n        image: ['jpeg', 'png'],\n        video: ['3gp', 'mp4'],\n        text: ['plain'],\n        application: [\n          'pdf',\n          'vnd.ms-excel',\n          'vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n          'msword',\n          'vnd.openxmlformats-officedocument.wordprocessingml.document',\n          'vnd.ms-powerpoint',\n          'vnd.openxmlformats-officedocument.presentationml.presentation',\n        ],\n      },\n      maxByCategory: { image: 5, video: 16, audio: 16, document: 100 },\n    },\n  },\n\n  [INBOX_TYPES.INSTAGRAM]: {\n    '*': {\n      mimeGroups: {\n        audio: ['aac', 'm4a', 'wav', 'mp4'],\n        image: ['png', 'jpeg', 'gif'],\n        video: ['mp4', 'ogg', 'avi', 'mov', 'webm'],\n      },\n      maxByCategory: { image: 16, video: 25, audio: 25 },\n    },\n  },\n\n  [INBOX_TYPES.FB]: {\n    '*': {\n      mimeGroups: {\n        audio: ['aac', 'm4a', 'wav', 'mp4'],\n        image: ['png', 'jpeg', 'gif'],\n        video: ['mp4', 'ogg', 'avi', 'mov', 'webm'],\n        text: ['plain'],\n        application: [\n          'pdf',\n          'vnd.ms-excel',\n          'vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n          'msword',\n          'vnd.openxmlformats-officedocument.wordprocessingml.document',\n          'vnd.ms-powerpoint',\n          'vnd.openxmlformats-officedocument.presentationml.presentation',\n        ],\n      },\n      maxByCategory: { image: 8, audio: 25, video: 25, document: 25 },\n    },\n  },\n\n  [INBOX_TYPES.LINE]: {\n    '*': {\n      mimeGroups: {\n        image: ['png', 'jpeg'],\n        video: ['mp4'],\n      },\n      maxByCategory: { image: 10 },\n    },\n  },\n\n  [INBOX_TYPES.TWILIO]: {\n    sms: { max: 5 },\n    whatsapp: {\n      mimeGroups: {\n        image: ['png', 'jpeg'],\n        audio: ['mpeg', 'opus', 'ogg', 'amr'],\n        video: ['mp4'],\n        application: ['pdf'],\n      },\n      max: 5,\n    },\n  },\n};\n\n// ---------- Helpers ----------\n/**\n * @name DOC_HEADS\n * @description MIME type categories that should be considered \"document\"\n */\nconst DOC_HEADS = new Set<string>(['application', 'text']);\n\n/**\n * @name categoryFromMime\n * @description Gets a high-level category name from a MIME type.\n *\n * @param {string} mime - MIME type string (e.g. \"image/png\").\n * @returns {\"image\"|\"video\"|\"audio\"|\"document\"|undefined} Category name.\n */\nconst categoryFromMime = (mime?: string): CategoryType => {\n  const head = mime?.split('/')?.[0] ?? '';\n  return DOC_HEADS.has(head) ? 'document' : (head as CategoryType);\n};\n\n/**\n * @name getNode\n * @description Finds the matching rule node for a channel and optional medium.\n *\n * @param {ChannelKey} [channelType] - One of INBOX_TYPES.\n * @param {string}      [medium]     - Optional sub-medium (e.g. \"sms\",\"whatsapp\").\n * @returns {ChannelNodeConfig} Config node with rules.\n */\nconst getNode = (\n  channelType?: ChannelKey,\n  medium?: string\n): ChannelNodeConfig => {\n  if (!channelType) return CHANNEL_CONFIGS.default;\n\n  const channelCfg = CHANNEL_CONFIGS[channelType];\n  if (!channelCfg) return CHANNEL_CONFIGS.default;\n\n  return (\n    channelCfg[medium ?? '*'] ?? channelCfg['*'] ?? CHANNEL_CONFIGS.default\n  );\n};\n\n/**\n * @name expandMimeGroups\n * @description Expands MIME groups and extensions into a list of strings.\n *\n * Examples:\n *  { image: [\"*\"] }         → [\"image/*\"]\n *  { image: [\"png\"] }       → [\"image/png\"]\n *  { application: [\"pdf\"] } → [\"application/pdf\"]\n *  extensions: [\".3gpp\"]    → [\".3gpp\"]\n *\n * @param {Object} mimeGroups - Grouped MIME suffixes by prefix.\n * @param {string[]} extensions - Extra raw extensions.\n * @returns {string[]} Expanded list of MIME/extension strings.\n */\nconst expandMimeGroups = (\n  mimeGroups: MimeGroups = {},\n  extensions: string[] = []\n): string[] => {\n  const mimes = Object.entries(mimeGroups).flatMap(([prefix, exts]) =>\n    (exts ?? []).map((ext: string) =>\n      ext === '*' ? `${prefix}/*` : `${prefix}/${ext}`\n    )\n  );\n  return [...mimes, ...extensions];\n};\n\n// ---------- Public API ----------\n/**\n * @name getAllowedFileTypesByChannel\n * @description Builds the full \"accept\" string for <input type=\"file\">,\n * based on channel + medium rules.\n *\n * @param {Object} params\n * @param {string} [params.channelType] - Channel type (from INBOX_TYPES).\n * @param {string} [params.medium] - Medium under the channel.\n * @returns {string} Comma-separated list of allowed MIME types/extensions.\n *\n * @example\n * getAllowedFileTypesByChannel({ channelType: INBOX_TYPES.WHATSAPP });\n * → \"audio/aac, audio/amr, image/jpeg, image/png, video/3gp, ...\"\n */\nexport const getAllowedFileTypesByChannel = ({\n  channelType,\n  medium,\n}: GetChannelParams = {}): string => {\n  const node = getNode(channelType, medium);\n  const { mimeGroups, extensions } =\n    !node.mimeGroups && !node.extensions ? CHANNEL_CONFIGS.default : node;\n\n  return expandMimeGroups(mimeGroups, extensions).join(', ');\n};\n\n/**\n * @name getMaxUploadSizeByChannel\n * @description Gets the maximum allowed file size (in MB) for a channel, medium, and MIME type.\n *\n * Priority:\n * - Category-specific size (image/video/audio/document).\n * - Channel/medium-level max.\n * - Global default max.\n *\n * @param {Object} params\n * @param {string} [params.channelType] - Channel type (from INBOX_TYPES).\n * @param {string} [params.medium] - Medium under the channel.\n * @param {string} [params.mime] - MIME type string (for category lookup).\n * @returns {number} Maximum file size in MB.\n *\n * @example\n * getMaxUploadSizeByChannel({ channelType: INBOX_TYPES.WHATSAPP, mime: \"image/png\" });\n * → 5\n */\nexport const getMaxUploadSizeByChannel = ({\n  channelType,\n  medium,\n  mime,\n}: GetMaxUploadParams = {}): number => {\n  const node = getNode(channelType, medium);\n  const cat = categoryFromMime(mime);\n  const catMax = cat ? node.maxByCategory?.[cat] : undefined;\n  return catMax ?? node.max ?? CHANNEL_CONFIGS.default.max;\n};\n","/**\n * Parses various date formats into a JavaScript Date object\n *\n * This function handles different date input formats commonly found in conversation data:\n * - 10-digit timestamps (Unix seconds) - automatically converted to milliseconds\n * - 13-digit timestamps (Unix milliseconds) - used directly\n * - String representations of timestamps\n * - ISO date strings (e.g., \"2025-06-01T12:30:00Z\")\n * - Simple date strings (e.g., \"2025-06-01\") - time defaults to 00:00:00\n * - Date strings with space-separated time (e.g., \"2025-06-01 12:30:00\")\n *\n * Note: This function follows JavaScript Date constructor behavior for date parsing.\n * Some invalid dates like \"2025-02-30\" auto-correct to valid dates (becomes \"2025-03-02\"),\n * while malformed strings like \"2025-13-01\" or \"2025-06-01T25:00:00\" return null.\n *\n * @example\n * coerceToDate('2025-06-01') // Returns Date object set to 2025-06-01 00:00:00\n * coerceToDate('2025-06-01T12:30:00Z') // Returns Date object with specified time\n * coerceToDate(1748834578) // Returns Date object (10-digit timestamp in seconds)\n * coerceToDate(1748834578000) // Returns Date object (13-digit timestamp in milliseconds)\n * coerceToDate('1748834578') // Returns Date object (string timestamp converted)\n * coerceToDate(null) // Returns null\n * coerceToDate('invalid-date') // Returns null\n */\nexport const coerceToDate = (\n  dateInput: string | number | null | undefined\n): Date | null => {\n  if (dateInput == null) return null;\n\n  let timestamp = typeof dateInput === 'number' ? dateInput : null;\n\n  // Handle string inputs that represent numeric timestamps\n  if (\n    timestamp === null &&\n    typeof dateInput === 'string' &&\n    /^\\d+$/.test(dateInput)\n  ) {\n    timestamp = Number(dateInput);\n  }\n\n  // Process numeric timestamps\n  if (timestamp !== null) {\n    // Convert 10-digit timestamps (seconds) to milliseconds\n    const timestampMs =\n      timestamp.toString().length === 10 ? timestamp * 1000 : timestamp;\n    return new Date(timestampMs);\n  }\n\n  // Process string date inputs\n  if (typeof dateInput === 'string') {\n    const dateObj = new Date(dateInput);\n\n    // Return null for invalid dates\n    if (Number.isNaN(dateObj.getTime())) return null;\n\n    // If no time component is specified, set time to 00:00:00\n    // this is because by default JS will set the time to midnight UTC for that date\n    const hasTimeComponent =\n      /T\\d{2}:\\d{2}(:\\d{2})?/.test(dateInput) || /\\d{2}:\\d{2}/.test(dateInput);\n    if (!hasTimeComponent) {\n      dateObj.setHours(0, 0, 0, 0);\n    }\n\n    return dateObj;\n  }\n\n  return null;\n};\n","/**\n * Creates a typing indicator utility.\n * @param onStartTyping Callback function to be called when typing starts\n * @param onStopTyping Callback function to be called when typing stops after delay\n * @param idleTime Delay for idle time in ms before considering typing stopped\n * @returns An object with start and stop methods for typing indicator\n */\n\ntype CallbackFunction = () => void;\ntype Timeout = ReturnType<typeof setTimeout>;\n\nexport const createTypingIndicator = (\n  onStartTyping: CallbackFunction,\n  onStopTyping: CallbackFunction,\n  idleTime: number\n) => {\n  let timer: Timeout | null = null;\n\n  const start = (): void => {\n    if (!timer) {\n      onStartTyping();\n    }\n    reset();\n  };\n\n  const stop = (): void => {\n    if (timer) {\n      clearTimeout(timer as Timeout);\n      timer = null;\n      onStopTyping();\n    }\n  };\n\n  const reset = (): void => {\n    if (timer) {\n      clearTimeout(timer as Timeout);\n    }\n    timer = setTimeout(() => {\n      stop();\n    }, idleTime) as Timeout;\n  };\n\n  return { start, stop };\n};\n","/**\n * Creates a debounced version of a function that delays invoking the provided function\n * until after a specified wait time has elapsed since the last time it was invoked.\n *\n * @param {Function} func - The function to debounce. Will receive any arguments passed to the debounced function.\n * @param {number} wait - The number of milliseconds to delay execution after the last call.\n * @param {boolean} [immediate] - If true, the function will execute immediately on the first call,\n *                               then start the debounce behavior for subsequent calls.\n * @param {number} [maxWait] - The maximum time the function can be delayed before it's forcibly executed.\n *                            If specified, the function will be called after this many milliseconds\n *                            have passed since its last execution, regardless of the debounce wait time.\n *\n * @returns {Function} A debounced version of the original function that has the following behavior:\n *   - Delays execution until `wait` milliseconds have passed since the last call\n *   - If `immediate` is true, executes on the leading edge of the first call\n *   - If `maxWait` is provided, ensures the function is called at least once every `maxWait` milliseconds\n *   - Preserves the `this` context and arguments of the most recent call\n *   - Cancels pending executions when called again within the wait period\n *\n * @example\n * // Basic debounce\n * const debouncedSearch = debounce(searchAPI, 300);\n *\n * // With immediate execution\n * const debouncedSave = debounce(saveData, 1000, true);\n *\n * // With maximum wait time\n * const debouncedUpdate = debounce(updateUI, 200, false, 1000);\n */\nexport const debounce = (\n  func: (...args: any[]) => void,\n  wait: number,\n  immediate?: boolean,\n  maxWait?: number\n) => {\n  let timeout: ReturnType<typeof setTimeout> | null = null;\n  let lastInvokeTime = 0;\n\n  return function(this: any, ...args: any[]) {\n    const time = Date.now();\n    const isFirstCall = lastInvokeTime === 0;\n\n    // Check if this is the first call and immediate execution is requested\n    if (isFirstCall && immediate) {\n      lastInvokeTime = time;\n      func.apply(this, args);\n      return;\n    }\n\n    // Clear any existing timeout\n    if (timeout !== null) {\n      clearTimeout(timeout);\n      timeout = null;\n    }\n\n    // Calculate if maxWait threshold has been reached\n    const timeSinceLastInvoke = time - lastInvokeTime;\n    const shouldInvokeNow =\n      maxWait !== undefined && timeSinceLastInvoke >= maxWait;\n\n    if (shouldInvokeNow) {\n      lastInvokeTime = time;\n      func.apply(this, args);\n      return;\n    }\n\n    // Set a new timeout\n    timeout = setTimeout(() => {\n      lastInvokeTime = Date.now();\n      timeout = null;\n      func.apply(this, args);\n    }, wait);\n  };\n};\n","import {\n  EmailMessage,\n  MessageType,\n  IncomingEmailMessage,\n  OutgoingEmailMessage,\n} from './types/message';\n\nexport function getRecipients(\n  lastEmail: EmailMessage,\n  conversationContact: string,\n  inboxEmail: string,\n  forwardToEmail: string\n) {\n  let to = [] as string[];\n  let cc = [] as string[];\n  let bcc = [] as string[];\n\n  // Reset emails if there's no lastEmail\n  if (!lastEmail) {\n    return { to, cc, bcc };\n  }\n\n  // Extract values from lastEmail and current conversation context\n  const { message_type: messageType } = lastEmail;\n\n  const isIncoming = messageType === MessageType.INCOMING;\n\n  let emailAttributes = {} as {\n    cc: string[] | null;\n    bcc: string[] | null;\n    from: string[] | null;\n    to: string[] | null;\n  };\n\n  if (isIncoming) {\n    const {\n      content_attributes: contentAttributes,\n    } = lastEmail as IncomingEmailMessage;\n    const email = contentAttributes.email;\n    emailAttributes = {\n      cc: email?.cc || [],\n      bcc: email?.bcc || [],\n      from: email?.from || [],\n      to: [],\n    };\n  } else {\n    const {\n      content_attributes: contentAttributes,\n    } = lastEmail as OutgoingEmailMessage;\n\n    const {\n      cc_emails: ccEmails = [],\n      bcc_emails: bccEmails = [],\n      to_emails: toEmails = [],\n    } = contentAttributes ?? {};\n\n    emailAttributes = {\n      cc: ccEmails,\n      bcc: bccEmails,\n      to: toEmails,\n      from: [],\n    };\n  }\n\n  let isLastEmailFromContact = false;\n  // this will be false anyway if the last email was outgoing\n  isLastEmailFromContact =\n    isIncoming && (emailAttributes.from ?? []).includes(conversationContact);\n\n  if (isIncoming) {\n    // Reply to sender if incoming\n    to.push(...(emailAttributes.from ?? []));\n  } else {\n    // Otherwise, reply to the last recipient (for outgoing message)\n    // If there is no to_emails, reply to the conversation contact\n    to.push(...(emailAttributes.to ?? [conversationContact]));\n  }\n\n  // Start building the cc list, including additional recipients\n  // If the email had multiple recipients, include them in the cc list\n  cc = emailAttributes.cc ? [...emailAttributes.cc] : [];\n  // Only include 'to' recipients in cc for incoming emails, not for outgoing\n  if (Array.isArray(emailAttributes.to) && isIncoming) {\n    cc.push(...emailAttributes.to);\n  }\n\n  // Add the conversation contact to cc if the last email wasn't sent by them\n  // Ensure the message is an incoming one\n  if (!isLastEmailFromContact && isIncoming) {\n    cc.push(conversationContact);\n  }\n\n  // Process BCC: Remove conversation contact from bcc as it is already in cc\n  bcc = (emailAttributes.bcc || []).filter(\n    emailAddress => emailAddress !== conversationContact\n  );\n\n  // Filter out undesired emails from cc:\n  // - Remove conversation contact from cc if they sent the last email\n  // - Remove inbox and forward-to email to prevent loops\n  // - Remove emails matching the reply UUID pattern\n  const replyUUIDPattern = /^reply\\+([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/i;\n  cc = cc.filter(email => {\n    if (email === conversationContact && isLastEmailFromContact) {\n      return false;\n    }\n    if (email === inboxEmail || email === forwardToEmail) {\n      return false;\n    }\n    if (replyUUIDPattern.test(email)) {\n      return false;\n    }\n    return true;\n  });\n\n  bcc = bcc.filter(email => {\n    if (\n      email === inboxEmail ||\n      email === forwardToEmail ||\n      replyUUIDPattern.test(email)\n    ) {\n      return false;\n    }\n\n    return true;\n  });\n\n  // Deduplicate each recipient list by converting to a Set then back to an array\n  to = Array.from(new Set(to));\n  cc = Array.from(new Set(cc));\n  bcc = Array.from(new Set(bcc));\n\n  return {\n    to,\n    cc,\n    bcc,\n  };\n}\n","/**\n * Function that parses a string boolean value and returns the corresponding boolean value\n * @param {string | number} candidate - The string boolean value to be parsed\n * @return {boolean} - The parsed boolean value\n */\nexport function parseBoolean(candidate: string | number) {\n  try {\n    // lowercase the string, so TRUE becomes true\n    const candidateString = String(candidate).toLowerCase();\n\n    // wrap in boolean to ensure that the return value\n    // is a boolean even if values like 0 or 1 are passed\n    return Boolean(JSON.parse(candidateString));\n  } catch (error) {\n    return false;\n  }\n}\n\n/**\n * Sanitizes text for safe HTML rendering by escaping potentially dangerous characters\n * while preserving valid HTML tags.\n *\n * This function performs the following transformations:\n * - Converts newline characters (\\n) to HTML line breaks (<br>)\n * - Escapes stray '<' characters that are not part of valid HTML tags (e.g., \"x < 5\" → \"x &lt; 5\")\n * - Escapes stray '>' characters that are not part of valid HTML tags (e.g., \"x > 5\" → \"x &gt; 5\")\n * - Preserves valid HTML tags and their attributes (e.g., <div>, <span class=\"test\">, </p>)\n *\n * LIMITATIONS: This regex-based approach has known limitations:\n * - Cannot properly handle '>' characters inside HTML attributes (e.g., <div title=\"x > 5\"> may not work correctly)\n * - Complex nested quotes or edge cases may not be handled perfectly\n * - For more complex HTML sanitization needs, consider using a proper HTML parser\n *\n * @param {string | null | undefined} text - The text to sanitize. Can be null or undefined.\n * @returns {string} The sanitized text safe for HTML rendering, or the original value if null/undefined.\n *\n * @example\n * sanitizeTextForRender('Hello\\nWorld') // 'Hello<br>World'\n * sanitizeTextForRender('if x < 5') // 'if x &lt; 5'\n * sanitizeTextForRender('<div>Hello</div>') // '<div>Hello</div>'\n * sanitizeTextForRender('Price < $100 <strong>Sale!</strong>') // 'Price &lt; $100 <strong>Sale!</strong>'\n */\nexport function sanitizeTextForRender(text: string | null | undefined) {\n  if (!text) return '';\n\n  return (\n    text\n      .replace(/\\n/g, '<br>')\n\n      // Escape < that doesn't start a valid HTML tag\n      // Regex breakdown:\n      // <          - matches '<'\n      // (?!        - negative lookahead (not followed by)\n      //   \\/?      - optional forward slash for closing tags\n      //   \\w+      - one or more word characters (tag name)\n      //   (?:      - non-capturing group for attributes\n      //     \\s+    - whitespace before attributes\n      //     [^>]*  - any characters except '>' (attribute content)\n      //   )?       - attributes are optional\n      //   \\/?>     - optional self-closing slash, then '>'\n      // )          - end lookahead\n      .replace(/<(?!\\/?\\w+(?:\\s+[^>]*)?\\/?>)/g, '&lt;')\n\n      // Escape > that isn't part of an HTML tag\n      // Regex breakdown:\n      // (?<!       - negative lookbehind (not preceded by)\n      //   <        - opening '<'\n      //   \\/?      - optional forward slash for closing tags\n      //   \\w+      - one or more word characters (tag name)\n      //   (?:      - non-capturing group for attributes\n      //     \\s+    - whitespace before attributes\n      //     [^>]*  - any characters except '>' (attribute content)\n      //   )?       - attributes are optional\n      //   \\/?      - optional self-closing slash before >\n      // )          - end lookbehind\n      // >          - matches '>'\n      .replace(/(?<!<\\/?\\w+(?:\\s+[^>]*)?\\/?)>/g, '&gt;')\n  );\n}\n"],"names":["MessageType","downloadFile","_ref5","_asyncToGenerator","_regeneratorRuntime","mark","_callee","_ref4","url","type","_ref4$extension","extension","_filenameMatch$","response","blobData","contentType","fileExtension","dispositionHeader","filenameMatch","filename","blobUrl","link","wrap","_context","prev","next","Error","fetch","cache","sent","ok","status","blob","headers","get","split","match","Date","now","URL","createObjectURL","Object","assign","document","createElement","href","download","style","body","append","click","remove","revokeObjectURL","t0","stop","_x","apply","arguments","toURL","input","includes","startsWith","window","location","origin","sortAsc","arr","slice","sort","a","b","clamp","min","max","value","_quantileForSorted","sorted","q","clamped","pos","length","base","Math","floor","undefined","MESSAGE_VARIABLES_REGEX","capitalizeName","name","map","word","charAt","toUpperCase","join","getFirstName","_ref","user","firstName","shift","getLastName","_ref2","lastName","pop","calculateThreshold","timeOffset","threshold","formatSLATime","seconds","units","y","mo","d","h","m","parts","keys","forEach","unit","push","CHANNEL_CONFIGS","_CHANNEL_CONFIGS","default","mimeGroups","image","audio","video","text","application","extensions","*","maxByCategory","sms","whatsapp","DOC_HEADS","Set","getNode","channelType","medium","channelCfg","_channelCfg","relativeX","relativeY","angle","radians","PI","cos","sin","rotatedX","rotatedY","mouseX","mouseY","rect","left","width","top","height","dateInput","timestamp","test","Number","timestampMs","toString","dateObj","isNaN","getTime","setHours","unitNames","time","toFixed","minute","hour","day","onStartTyping","onStopTyping","idleTime","timer","clearTimeout","start","setTimeout","func","wait","immediate","maxWait","timeout","lastInvokeTime","args","Array","_len","_key","isFirstCall","this","timeSinceLastInvoke","shouldInvokeNow","_this","appliedSla","chat","icon","isSlaMissed","SLAStatuses","mostUrgent","frtThreshold","sla_first_response_time_threshold","nrtThreshold","sla_next_response_time_threshold","rtThreshold","sla_resolution_time_threshold","createdAt","created_at","firstReplyCreatedAt","first_reply_created_at","waitingSince","waiting_since","SLAStatus","FRT","condition","NRT","RT","_extends","createSLAObject","filter","evaluateSLAConditions","sla1","sla2","abs","file","maxLength","ellipsis","fullName","_file$filename","dotIndex","lastIndexOf","_ref3","date","todayText","yesterdayText","dateValue","isToday","isYesterday","num","n","Intl","NumberFormat","notation","maximumFractionDigits","format","timeInSeconds","formattedTime","minutes","hours","days","_temp","node","mimes","entries","flatMap","prefix","exts","ext","concat","expandMimeGroups","bgColor","color","replace","parseInt","defaultInfo","encodedFilename","fileName","decodeURIComponent","lastDotIndex","toLowerCase","error","console","_temp2","mime","cat","head","_mime$split$","_mime$split","has","categoryFromMime","catMax","_node$maxByCategory","_ref6","conversation","inbox","_conversation$meta","meta","assignee","sender","id","_conversation$custom_","custom_attributes","conversationCustomAttributes","contactCustomAttributes","contact","contact.name","contact.first_name","contact.last_name","contact.email","email","contact.phone","phone_number","contact.id","conversation.id","inbox.id","inbox.name","agent.name","agent.first_name","agent.last_name","agent.email","_assignee$email","reduce","acc","data","intervals","interval","lastEmail","conversationContact","inboxEmail","forwardToEmail","to","cc","bcc","isLastEmailFromContact","_to","_emailAttributes$from2","_to2","_emailAttributes$to","_cc","isIncoming","message_type","INCOMING","emailAttributes","content_attributes","from","contentAttributes","_ref$cc_emails","cc_emails","_ref$bcc_emails","bcc_emails","_ref$to_emails","to_emails","_emailAttributes$from","isArray","emailAddress","replyUUIDPattern","_ref8","variables","matches","message","trim","variable","url1","url2","urlObj1","urlObj2","hostname","domain","x","candidate","candidateString","String","Boolean","JSON","parse","_ref7","_","trimmedName","nameParts","content","trimmedContent","substring"],"mappings":"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"}