{"version":3,"file":"AsYouTypeFormatter.js","names":["DUMMY_DIGIT","LONGEST_NATIONAL_PHONE_NUMBER_LENGTH","LONGEST_DUMMY_PHONE_NUMBER","repeat","NATIONAL_PREFIX_SEPARATORS_PATTERN","SUPPORT_LEGACY_FORMATTING_PATTERNS","CREATE_CHARACTER_CLASS_PATTERN","CREATE_STANDALONE_DIGIT_PATTERN","NON_ALTERING_FORMAT_REG_EXP","RegExp","VALID_PUNCTUATION","MIN_LEADING_DIGITS_LENGTH","AsYouTypeFormatter","state","metadata","resetFormat","chosenFormat","undefined","template","nationalNumberTemplate","populatedNationalNumberTemplate","populatedNationalNumberTemplatePosition","numberingPlan","isNANP","callingCode","matchingFormats","formats","nationalSignificantNumber","narrowDownMatchingFormats","nextDigits","canFormatCompleteNumber","format","formattedCompleteNumber","formatCompleteNumber","shouldTryNationalPrefixFormattingRule","international","nationalPrefix","getSeparatorAfterNationalPrefix","setNationalNumberTemplate","replace","DIGIT_PLACEHOLDER","lastIndexOf","formatNationalNumberWithNextDigits","previouslyChosenFormat","newlyChosenFormat","chooseFormat","formatNextNationalNumberDigits","getNationalDigits","leadingDigits","leadingDigitsPatternIndex","length","filter","formatSuits","formatMatches","indexOf","usesNationalPrefix","nationalPrefixIsOptionalWhenFormattingInNationalFormat","nationalPrefixIsMandatoryWhenFormattingInNationalFormat","leadingDigitsPatternsCount","leadingDigitsPatterns","Math","min","leadingDigitsPattern","PatternMatcher","match","allowOverflow","error","console","test","internationalFormat","getFormatFormat","createTemplateForFormat","_","slice","pattern","getTemplateForFormat","nationalPrefixFormattingRule","options","IDDPrefix","missingPlus","spacing","index","i","internationalPrefix","getInternationalPrefixBeforeCountryCallingCode","getDigitsWithoutInternationalPrefix","cutAndStripNonPairedParens","complexPrefixBeforeNationalSignificantNumber","digits","strictPattern","nationalNumberDummyDigits","numberFormat","nationalPrefixIncludedInTemplate","numberFormatWithNationalPrefix","FIRST_GROUP_PATTERN","parseDigits","applyInternationalSeparatorStyle","result","populateTemplateWithDigits"],"sources":["../source/AsYouTypeFormatter.js"],"sourcesContent":["import {\r\n\tDIGIT_PLACEHOLDER,\r\n\tcountOccurences,\r\n\trepeat,\r\n\tcutAndStripNonPairedParens,\r\n\tcloseNonPairedParens,\r\n\tstripNonPairedParens,\r\n\tpopulateTemplateWithDigits\r\n} from './AsYouTypeFormatter.util.js'\r\n\r\nimport formatCompleteNumber, {\r\n\tcanFormatCompleteNumber\r\n} from './AsYouTypeFormatter.complete.js'\r\n\r\nimport PatternMatcher from './AsYouTypeFormatter.PatternMatcher.js'\r\n\r\nimport parseDigits from './helpers/parseDigits.js'\r\nexport { DIGIT_PLACEHOLDER } from './AsYouTypeFormatter.util.js'\r\nimport { FIRST_GROUP_PATTERN } from './helpers/formatNationalNumberUsingFormat.js'\r\nimport { VALID_PUNCTUATION } from './constants.js'\r\nimport applyInternationalSeparatorStyle from './helpers/applyInternationalSeparatorStyle.js'\r\n\r\n// Used in phone number format template creation.\r\n// Could be any digit, I guess.\r\nconst DUMMY_DIGIT = '9'\r\n// I don't know why is it exactly `15`\r\nconst LONGEST_NATIONAL_PHONE_NUMBER_LENGTH = 15\r\n// Create a phone number consisting only of the digit 9 that matches the\r\n// `number_pattern` by applying the pattern to the \"longest phone number\" string.\r\nconst LONGEST_DUMMY_PHONE_NUMBER = repeat(DUMMY_DIGIT, LONGEST_NATIONAL_PHONE_NUMBER_LENGTH)\r\n\r\n// A set of characters that, if found in a national prefix formatting rules, are an indicator to\r\n// us that we should separate the national prefix from the number when formatting.\r\nconst NATIONAL_PREFIX_SEPARATORS_PATTERN = /[- ]/\r\n\r\n// Deprecated: Google has removed some formatting pattern related code from their repo.\r\n// https://github.com/googlei18n/libphonenumber/commit/a395b4fef3caf57c4bc5f082e1152a4d2bd0ba4c\r\n// \"We no longer have numbers in formatting matching patterns, only \\d.\"\r\n// Because this library supports generating custom metadata\r\n// some users may still be using old metadata so the relevant\r\n// code seems to stay until some next major version update.\r\nconst SUPPORT_LEGACY_FORMATTING_PATTERNS = true\r\n\r\n// A pattern that is used to match character classes in regular expressions.\r\n// An example of a character class is \"[1-4]\".\r\nconst CREATE_CHARACTER_CLASS_PATTERN = SUPPORT_LEGACY_FORMATTING_PATTERNS && (() => /\\[([^\\[\\]])*\\]/g)\r\n\r\n// Any digit in a regular expression that actually denotes a digit. For\r\n// example, in the regular expression \"80[0-2]\\d{6,10}\", the first 2 digits\r\n// (8 and 0) are standalone digits, but the rest are not.\r\n// Two look-aheads are needed because the number following \\\\d could be a\r\n// two-digit number, since the phone number can be as long as 15 digits.\r\nconst CREATE_STANDALONE_DIGIT_PATTERN = SUPPORT_LEGACY_FORMATTING_PATTERNS && (() => /\\d(?=[^,}][^,}])/g)\r\n\r\n// A regular expression that is used to determine if a `format` is\r\n// suitable to be used in the \"as you type formatter\".\r\n// A `format` is suitable when the resulting formatted number has\r\n// the same digits as the user has entered.\r\n//\r\n// In the simplest case, that would mean that the format\r\n// doesn't add any additional digits when formatting a number.\r\n// Google says that it also shouldn't add \"star\" (`*`) characters,\r\n// like it does in some Israeli formats.\r\n// Such basic format would only contain \"valid punctuation\"\r\n// and \"captured group\" identifiers ($1, $2, etc).\r\n//\r\n// An example of a format that adds additional digits:\r\n//\r\n// Country: `AR` (Argentina).\r\n// Format:\r\n// {\r\n//    \"pattern\": \"(\\\\d)(\\\\d{2})(\\\\d{4})(\\\\d{4})\",\r\n//    \"leading_digits_patterns\": [\"91\"],\r\n//    \"national_prefix_formatting_rule\": \"0$1\",\r\n//    \"format\": \"$2 15-$3-$4\",\r\n//    \"international_format\": \"$1 $2 $3-$4\"\r\n// }\r\n//\r\n// In the format above, the `format` adds `15` to the digits when formatting a number.\r\n// A sidenote: this format actually is suitable because `national_prefix_for_parsing`\r\n// has previously removed `15` from a national number, so re-adding `15` in `format`\r\n// doesn't actually result in any extra digits added to user's input.\r\n// But verifying that would be a complex procedure, so the code chooses a simpler path:\r\n// it simply filters out all `format`s that contain anything but \"captured group\" ids.\r\n//\r\n// This regular expression is called `ELIGIBLE_FORMAT_PATTERN` in Google's\r\n// `libphonenumber` code.\r\n//\r\nconst NON_ALTERING_FORMAT_REG_EXP = new RegExp(\r\n\t'[' + VALID_PUNCTUATION + ']*' +\r\n\t// Google developers say:\r\n\t// \"We require that the first matching group is present in the\r\n\t//  output pattern to ensure no data is lost while formatting.\"\r\n\t'\\\\$1' +\r\n\t'[' + VALID_PUNCTUATION + ']*' +\r\n\t'(\\\\$\\\\d[' + VALID_PUNCTUATION + ']*)*' +\r\n\t'$'\r\n)\r\n\r\n// This is the minimum length of the leading digits of a phone number\r\n// to guarantee the first \"leading digits pattern\" for a phone number format\r\n// to be preemptive.\r\nconst MIN_LEADING_DIGITS_LENGTH = 3\r\n\r\nexport default class AsYouTypeFormatter {\r\n\tconstructor({\r\n\t\tstate,\r\n\t\tmetadata\r\n\t}) {\r\n\t\tthis.metadata = metadata\r\n\t\tthis.resetFormat()\r\n\t}\r\n\r\n\tresetFormat() {\r\n\t\tthis.chosenFormat = undefined\r\n\t\tthis.template = undefined\r\n\t\tthis.nationalNumberTemplate = undefined\r\n\t\tthis.populatedNationalNumberTemplate = undefined\r\n\t\tthis.populatedNationalNumberTemplatePosition = -1\r\n\t}\r\n\r\n\treset(numberingPlan, state) {\r\n\t\tthis.resetFormat()\r\n\t\tif (numberingPlan) {\r\n\t\t\tthis.isNANP = numberingPlan.callingCode() === '1'\r\n\t\t\tthis.matchingFormats = numberingPlan.formats()\r\n\t\t\tif (state.nationalSignificantNumber) {\r\n\t\t\t\tthis.narrowDownMatchingFormats(state)\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tthis.isNANP = undefined\r\n\t\t\tthis.matchingFormats = []\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Formats an updated phone number.\r\n\t * @param  {string} nextDigits — Additional phone number digits.\r\n\t * @param  {object} state — `AsYouType` state.\r\n\t * @return {[string]} Returns undefined if the updated phone number can't be formatted using any of the available formats.\r\n\t */\r\n\tformat(nextDigits, state) {\r\n\t\t// See if the phone number digits can be formatted as a complete phone number.\r\n\t\t// If not, use the results from `formatNationalNumberWithNextDigits()`,\r\n\t\t// which formats based on the chosen formatting pattern.\r\n\t\t//\r\n\t\t// Attempting to format complete phone number first is how it's done\r\n\t\t// in Google's `libphonenumber`, so this library just follows it.\r\n\t\t// Google's `libphonenumber` code doesn't explain in detail why does it\r\n\t\t// attempt to format digits as a complete phone number\r\n\t\t// instead of just going with a previoulsy (or newly) chosen `format`:\r\n\t\t//\r\n\t\t// \"Checks to see if there is an exact pattern match for these digits.\r\n\t\t//  If so, we should use this instead of any other formatting template\r\n\t\t//  whose leadingDigitsPattern also matches the input.\"\r\n\t\t//\r\n\t\tif (canFormatCompleteNumber(state.nationalSignificantNumber, this.metadata)) {\r\n\t\t\tfor (const format of this.matchingFormats) {\r\n\t\t\t\tconst formattedCompleteNumber = formatCompleteNumber(\r\n\t\t\t\t\tstate,\r\n\t\t\t\t\tformat,\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tmetadata: this.metadata,\r\n\t\t\t\t\t\tshouldTryNationalPrefixFormattingRule: (format) => this.shouldTryNationalPrefixFormattingRule(format, {\r\n\t\t\t\t\t\t\tinternational: state.international,\r\n\t\t\t\t\t\t\tnationalPrefix: state.nationalPrefix\r\n\t\t\t\t\t\t}),\r\n\t\t\t\t\t\tgetSeparatorAfterNationalPrefix: (format) => this.getSeparatorAfterNationalPrefix(format)\r\n\t\t\t\t\t}\r\n\t\t\t\t)\r\n\t\t\t\tif (formattedCompleteNumber) {\r\n\t\t\t\t\tthis.resetFormat()\r\n\t\t\t\t\tthis.chosenFormat = format\r\n\t\t\t\t\tthis.setNationalNumberTemplate(formattedCompleteNumber.replace(/\\d/g, DIGIT_PLACEHOLDER), state)\r\n\t\t\t\t\tthis.populatedNationalNumberTemplate = formattedCompleteNumber\r\n\t\t\t\t\t// With a new formatting template, the matched position\r\n\t\t\t\t\t// using the old template needs to be reset.\r\n\t\t\t\t\tthis.populatedNationalNumberTemplatePosition = this.template.lastIndexOf(DIGIT_PLACEHOLDER)\r\n\t\t\t\t\treturn formattedCompleteNumber\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Format the digits as a partial (incomplete) phone number\r\n\t\t// using the previously chosen formatting pattern (or a newly chosen one).\r\n\t\treturn this.formatNationalNumberWithNextDigits(nextDigits, state)\r\n\t}\r\n\r\n\t// Formats the next phone number digits.\r\n\tformatNationalNumberWithNextDigits(nextDigits, state) {\r\n\t\tconst previouslyChosenFormat = this.chosenFormat\r\n\r\n\t\t// Choose a format from the list of matching ones.\r\n\t\tconst newlyChosenFormat = this.chooseFormat(state)\r\n\r\n\t\tif (newlyChosenFormat) {\r\n\t\t\tif (newlyChosenFormat === previouslyChosenFormat) {\r\n\t\t\t\t// If it can format the next (current) digits\r\n\t\t\t\t// using the previously chosen phone number format\r\n\t\t\t\t// then return the updated formatted number.\r\n\t\t\t\treturn this.formatNextNationalNumberDigits(nextDigits)\r\n\t\t\t} else {\r\n\t\t\t\t// If a more appropriate phone number format\r\n\t\t\t\t// has been chosen for these \"leading digits\",\r\n\t\t\t\t// then re-format the national phone number part\r\n\t\t\t\t// using the newly selected format.\r\n\t\t\t\treturn this.formatNextNationalNumberDigits(state.getNationalDigits())\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tnarrowDownMatchingFormats({\r\n\t\tnationalSignificantNumber,\r\n\t\tnationalPrefix,\r\n\t\tinternational\r\n\t}) {\r\n\t\tconst leadingDigits = nationalSignificantNumber\r\n\r\n\t\t// \"leading digits\" pattern list starts with a\r\n\t\t// \"leading digits\" pattern fitting a maximum of 3 leading digits.\r\n\t\t// So, after a user inputs 3 digits of a national (significant) phone number\r\n\t\t// this national (significant) number can already be formatted.\r\n\t\t// The next \"leading digits\" pattern is for 4 leading digits max,\r\n\t\t// and the \"leading digits\" pattern after it is for 5 leading digits max, etc.\r\n\r\n\t\t// This implementation is different from Google's\r\n\t\t// in that it searches for a fitting format\r\n\t\t// even if the user has entered less than\r\n\t\t// `MIN_LEADING_DIGITS_LENGTH` digits of a national number.\r\n\t\t// Because some leading digit patterns already match for a single first digit.\r\n\t\tlet leadingDigitsPatternIndex = leadingDigits.length - MIN_LEADING_DIGITS_LENGTH\r\n\t\tif (leadingDigitsPatternIndex < 0) {\r\n\t\t\tleadingDigitsPatternIndex = 0\r\n\t\t}\r\n\r\n\t\tthis.matchingFormats = this.matchingFormats.filter(\r\n\t\t\tformat => this.formatSuits(format, international, nationalPrefix)\r\n\t\t\t\t&& this.formatMatches(format, leadingDigits, leadingDigitsPatternIndex)\r\n\t\t)\r\n\r\n\t\t// If there was a phone number format chosen\r\n\t\t// and it no longer holds given the new leading digits then reset it.\r\n\t\t// The test for this `if` condition is marked as:\r\n\t\t// \"Reset a chosen format when it no longer holds given the new leading digits\".\r\n\t\t// To construct a valid test case for this one can find a country\r\n\t\t// in `PhoneNumberMetadata.xml` yielding one format for 3 `<leadingDigits>`\r\n\t\t// and yielding another format for 4 `<leadingDigits>` (Australia in this case).\r\n\t\tif (this.chosenFormat && this.matchingFormats.indexOf(this.chosenFormat) === -1) {\r\n\t\t\tthis.resetFormat()\r\n\t\t}\r\n\t}\r\n\r\n\tformatSuits(format, international, nationalPrefix) {\r\n\t\t// When a prefix before a national (significant) number is\r\n\t\t// simply a national prefix, then it's parsed as `this.nationalPrefix`.\r\n\t\t// In more complex cases, a prefix before national (significant) number\r\n\t\t// could include a national prefix as well as some \"capturing groups\",\r\n\t\t// and in that case there's no info whether a national prefix has been parsed.\r\n\t\t// If national prefix is not used when formatting a phone number\r\n\t\t// using this format, but a national prefix has been entered by the user,\r\n\t\t// and was extracted, then discard such phone number format.\r\n\t\t// In Google's \"AsYouType\" formatter code, the equivalent would be this part:\r\n\t\t// https://github.com/google/libphonenumber/blob/0a45cfd96e71cad8edb0e162a70fcc8bd9728933/java/libphonenumber/src/com/google/i18n/phonenumbers/AsYouTypeFormatter.java#L175-L184\r\n\t\tif (nationalPrefix &&\r\n\t\t\t!format.usesNationalPrefix() &&\r\n\t\t\t// !format.domesticCarrierCodeFormattingRule() &&\r\n\t\t\t!format.nationalPrefixIsOptionalWhenFormattingInNationalFormat()) {\r\n\t\t\treturn false\r\n\t\t}\r\n\t\t// If national prefix is mandatory for this phone number format\r\n\t\t// and there're no guarantees that a national prefix is present in user input\r\n\t\t// then discard this phone number format as not suitable.\r\n\t\t// In Google's \"AsYouType\" formatter code, the equivalent would be this part:\r\n\t\t// https://github.com/google/libphonenumber/blob/0a45cfd96e71cad8edb0e162a70fcc8bd9728933/java/libphonenumber/src/com/google/i18n/phonenumbers/AsYouTypeFormatter.java#L185-L193\r\n\t\tif (!international &&\r\n\t\t\t!nationalPrefix &&\r\n\t\t\tformat.nationalPrefixIsMandatoryWhenFormattingInNationalFormat()) {\r\n\t\t\treturn false\r\n\t\t}\r\n\t\treturn true\r\n\t}\r\n\r\n\tformatMatches(format, leadingDigits, leadingDigitsPatternIndex) {\r\n\t\tconst leadingDigitsPatternsCount = format.leadingDigitsPatterns().length\r\n\r\n\t\t// If this format is not restricted to a certain\r\n\t\t// leading digits pattern then it fits.\r\n\t\t// The test case could be found by searching for \"leadingDigitsPatternsCount === 0\".\r\n\t\tif (leadingDigitsPatternsCount === 0) {\r\n\t\t\treturn true\r\n\t\t}\r\n\r\n\t\t// Start narrowing down the list of possible formats based on the leading digits.\r\n\t\t// (only previously matched formats take part in the narrowing down process)\r\n\r\n\t\t// `leading_digits_patterns` start with 3 digits min\r\n\t\t// and then go up from there one digit at a time.\r\n\t\tleadingDigitsPatternIndex = Math.min(leadingDigitsPatternIndex, leadingDigitsPatternsCount - 1)\r\n\t\tconst leadingDigitsPattern = format.leadingDigitsPatterns()[leadingDigitsPatternIndex]\r\n\r\n\t\t// Google imposes a requirement on the leading digits\r\n\t\t// to be minimum 3 digits long in order to be eligible\r\n\t\t// for checking those with a leading digits pattern.\r\n\t\t//\r\n\t\t// Since `leading_digits_patterns` start with 3 digits min,\r\n\t\t// Google's original `libphonenumber` library only starts\r\n\t\t// excluding any non-matching formats only when the\r\n\t\t// national number entered so far is at least 3 digits long,\r\n\t\t// otherwise format matching would give false negatives.\r\n\t\t//\r\n\t\t// For example, when the digits entered so far are `2`\r\n\t\t// and the leading digits pattern is `21` –\r\n\t\t// it's quite obvious in this case that the format could be the one\r\n\t\t// but due to the absence of further digits it would give false negative.\r\n\t\t//\r\n\t\t// Also, `leading_digits_patterns` doesn't always correspond to a single\r\n\t\t// digits count. For example, `60|8` pattern would already match `8`\r\n\t\t// but the `60` part would require having at least two leading digits,\r\n\t\t// so the whole pattern would require inputting two digits first in order to\r\n\t\t// decide on whether it matches the input, even when the input is \"80\".\r\n\t\t//\r\n\t\t// This library — `libphonenumber-js` — allows filtering by `leading_digits_patterns`\r\n\t\t// even when there's only 1 or 2 digits of the national (significant) number.\r\n\t\t// To do that, it uses a non-strict pattern matcher written specifically for that.\r\n\t\t//\r\n\t\tif (leadingDigits.length < MIN_LEADING_DIGITS_LENGTH) {\r\n\t\t\t// Before leading digits < 3 matching was implemented:\r\n\t\t\t// return true\r\n\t\t\t//\r\n\t\t\t// After leading digits < 3 matching was implemented:\r\n\t\t\ttry {\r\n\t\t\t\treturn new PatternMatcher(leadingDigitsPattern).match(leadingDigits, { allowOverflow: true }) !== undefined\r\n\t\t\t} catch (error) /* istanbul ignore next */ {\r\n\t\t\t\t// There's a slight possibility that there could be some undiscovered bug\r\n\t\t\t\t// in the pattern matcher code. Since the \"leading digits < 3 matching\"\r\n\t\t\t\t// feature is not \"essential\" for operation, it can fall back to the old way\r\n\t\t\t\t// in case of any issues rather than halting the application's execution.\r\n\t\t\t\tconsole.error(error)\r\n\t\t\t\treturn true\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// If at least `MIN_LEADING_DIGITS_LENGTH` digits of a national number are\r\n\t\t// available then use the usual regular expression matching.\r\n\t\t//\r\n\t\t// The whole pattern is wrapped in round brackets (`()`) because\r\n\t\t// the pattern can use \"or\" operator (`|`) at the top level of the pattern.\r\n\t\t//\r\n\t\treturn new RegExp(`^(${leadingDigitsPattern})`).test(leadingDigits)\r\n\t}\r\n\r\n\tgetFormatFormat(format, international) {\r\n\t\treturn international ? format.internationalFormat() : format.format()\r\n\t}\r\n\r\n\tchooseFormat(state) {\r\n\t\t// When there are multiple available formats, the formatter uses the first\r\n\t\t// format where a formatting template could be created.\r\n\t\t//\r\n\t\t// For some weird reason, `istanbul` says \"else path not taken\"\r\n\t\t// for the `for of` line below. Supposedly that means that\r\n\t\t// the loop doesn't ever go over the last element in the list.\r\n\t\t// That's true because there always is `this.chosenFormat`\r\n\t\t// when `this.matchingFormats` is non-empty.\r\n\t\t// And, for some weird reason, it doesn't think that the case\r\n\t\t// with empty `this.matchingFormats` qualifies for a valid \"else\" path.\r\n\t\t// So simply muting this `istanbul` warning.\r\n\t\t// It doesn't skip the contents of the `for of` loop,\r\n\t\t// it just skips the `for of` line.\r\n\t\t//\r\n\t\t/* istanbul ignore next */\r\n\t\tfor (const format of this.matchingFormats.slice()) {\r\n\t\t\t// If this format is currently being used\r\n\t\t\t// and is still suitable, then stick to it.\r\n\t\t\tif (this.chosenFormat === format) {\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t\t// Sometimes, a formatting rule inserts additional digits in a phone number,\r\n\t\t\t// and \"as you type\" formatter can't do that: it should only use the digits\r\n\t\t\t// that the user has input.\r\n\t\t\t//\r\n\t\t\t// For example, in Argentina, there's a format for mobile phone numbers:\r\n\t\t\t//\r\n\t\t\t// {\r\n\t\t\t//    \"pattern\": \"(\\\\d)(\\\\d{2})(\\\\d{4})(\\\\d{4})\",\r\n\t\t\t//    \"leading_digits_patterns\": [\"91\"],\r\n\t\t\t//    \"national_prefix_formatting_rule\": \"0$1\",\r\n\t\t\t//    \"format\": \"$2 15-$3-$4\",\r\n\t\t\t//    \"international_format\": \"$1 $2 $3-$4\"\r\n\t\t\t// }\r\n\t\t\t//\r\n\t\t\t// In that format, `international_format` is used instead of `format`\r\n\t\t\t// because `format` inserts `15` in the formatted number,\r\n\t\t\t// and `AsYouType` formatter should only use the digits\r\n\t\t\t// the user has actually input, without adding any extra digits.\r\n\t\t\t// In this case, it wouldn't make a difference, because the `15`\r\n\t\t\t// is first stripped when applying `national_prefix_for_parsing`\r\n\t\t\t// and then re-added when using `format`, so in reality it doesn't\r\n\t\t\t// add any new digits to the number, but to detect that, the code\r\n\t\t\t// would have to be more complex: it would have to try formatting\r\n\t\t\t// the digits using the format and then see if any digits have\r\n\t\t\t// actually been added or removed, and then, every time a new digit\r\n\t\t\t// is input, it should re-check whether the chosen format doesn't\r\n\t\t\t// alter the digits.\r\n\t\t\t//\r\n\t\t\t// Google's code doesn't go that far, and so does this library:\r\n\t\t\t// it simply requires that a `format` doesn't add any additonal\r\n\t\t\t// digits to user's input.\r\n\t\t\t//\r\n\t\t\t// Also, people in general should move from inputting phone numbers\r\n\t\t\t// in national format (possibly with national prefixes)\r\n\t\t\t// and use international phone number format instead:\r\n\t\t\t// it's a logical thing in the modern age of mobile phones,\r\n\t\t\t// globalization and the internet.\r\n\t\t\t//\r\n\t\t\t/* istanbul ignore if */\r\n\t\t\tif (!NON_ALTERING_FORMAT_REG_EXP.test(this.getFormatFormat(format, state.international))) {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\tif (!this.createTemplateForFormat(format, state)) {\r\n\t\t\t\t// Remove the format if it can't generate a template.\r\n\t\t\t\tthis.matchingFormats = this.matchingFormats.filter(_ => _ !== format)\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\tthis.chosenFormat = format\r\n\t\t\tbreak\r\n\t\t}\r\n\t\tif (!this.chosenFormat) {\r\n\t\t\t// No format matches the national (significant) phone number.\r\n\t\t\tthis.resetFormat()\r\n\t\t}\r\n\t\treturn this.chosenFormat\r\n\t}\r\n\r\n\tcreateTemplateForFormat(format, state) {\r\n\t\t// The formatter doesn't format numbers when numberPattern contains '|', e.g.\r\n\t\t// (20|3)\\d{4}. In those cases we quickly return.\r\n\t\t// (Though there's no such format in current metadata)\r\n\t\t/* istanbul ignore if */\r\n\t\tif (SUPPORT_LEGACY_FORMATTING_PATTERNS && format.pattern().indexOf('|') >= 0) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\t// Get formatting template for this phone number format\r\n\t\tconst template = this.getTemplateForFormat(format, state)\r\n\t\t// If the national number entered is too long\r\n\t\t// for any phone number format, then abort.\r\n\t\tif (template) {\r\n\t\t\tthis.setNationalNumberTemplate(template, state)\r\n\t\t\treturn true\r\n\t\t}\r\n\t}\r\n\r\n\tgetSeparatorAfterNationalPrefix(format) {\r\n\t\t// `US` metadata doesn't have a `national_prefix_formatting_rule`,\r\n\t\t// so the `if` condition below doesn't apply to `US`,\r\n\t\t// but in reality there shoudl be a separator\r\n\t\t// between a national prefix and a national (significant) number.\r\n\t\t// So `US` national prefix separator is a \"special\" \"hardcoded\" case.\r\n\t\tif (this.isNANP) {\r\n\t\t\treturn ' '\r\n\t\t}\r\n\t\t// If a `format` has a `national_prefix_formatting_rule`\r\n\t\t// and that rule has a separator after a national prefix,\r\n\t\t// then it means that there should be a separator\r\n\t\t// between a national prefix and a national (significant) number.\r\n\t\tif (format &&\r\n\t\t\tformat.nationalPrefixFormattingRule() &&\r\n\t\t\tNATIONAL_PREFIX_SEPARATORS_PATTERN.test(format.nationalPrefixFormattingRule())) {\r\n\t\t\treturn ' '\r\n\t\t}\r\n\t\t// At this point, there seems to be no clear evidence that\r\n\t\t// there should be a separator between a national prefix\r\n\t\t// and a national (significant) number. So don't insert one.\r\n\t\treturn ''\r\n\t}\r\n\r\n\tgetInternationalPrefixBeforeCountryCallingCode({ IDDPrefix, missingPlus }, options) {\r\n\t\tif (IDDPrefix) {\r\n\t\t\treturn options && options.spacing === false ? IDDPrefix : IDDPrefix + ' '\r\n\t\t}\r\n\t\tif (missingPlus) {\r\n\t\t\treturn ''\r\n\t\t}\r\n\t\treturn '+'\r\n\t}\r\n\r\n\tgetTemplate(state) {\r\n\t\tif (!this.template) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\t// `this.template` holds the template for a \"complete\" phone number.\r\n\t\t// The currently entered phone number is most likely not \"complete\",\r\n\t\t// so trim all non-populated digits.\r\n\t\tlet index = -1\r\n\t\tlet i = 0\r\n\t\tconst internationalPrefix = state.international ? this.getInternationalPrefixBeforeCountryCallingCode(state, { spacing: false }) : ''\r\n\t\twhile (i < internationalPrefix.length + state.getDigitsWithoutInternationalPrefix().length) {\r\n\t\t\tindex = this.template.indexOf(DIGIT_PLACEHOLDER, index + 1)\r\n\t\t\ti++\r\n\t\t}\r\n\t\treturn cutAndStripNonPairedParens(this.template, index + 1)\r\n\t}\r\n\r\n\tsetNationalNumberTemplate(template, state) {\r\n\t\tthis.nationalNumberTemplate = template\r\n\t\tthis.populatedNationalNumberTemplate = template\r\n\t\t// With a new formatting template, the matched position\r\n\t\t// using the old template needs to be reset.\r\n\t\tthis.populatedNationalNumberTemplatePosition = -1\r\n\t\t// For convenience, the public `.template` property\r\n\t\t// contains the whole international number\r\n\t\t// if the phone number being input is international:\r\n\t\t// 'x' for the '+' sign, 'x'es for the country phone code,\r\n\t\t// a spacebar and then the template for the formatted national number.\r\n\t\tif (state.international) {\r\n\t\t\tthis.template =\r\n\t\t\t\tthis.getInternationalPrefixBeforeCountryCallingCode(state).replace(/[\\d\\+]/g, DIGIT_PLACEHOLDER) +\r\n\t\t\t\trepeat(DIGIT_PLACEHOLDER, state.callingCode.length) +\r\n\t\t\t\t' ' +\r\n\t\t\t\ttemplate\r\n\t\t} else {\r\n\t\t\tthis.template = template\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Generates formatting template for a national phone number,\r\n\t * optionally containing a national prefix, for a format.\r\n\t * @param  {Format} format\r\n\t * @param  {string} nationalPrefix\r\n\t * @return {string}\r\n\t */\r\n\tgetTemplateForFormat(format, {\r\n\t\tnationalSignificantNumber,\r\n\t\tinternational,\r\n\t\tnationalPrefix,\r\n\t\tcomplexPrefixBeforeNationalSignificantNumber\r\n\t}) {\r\n\t\tlet pattern = format.pattern()\r\n\r\n\t\t/* istanbul ignore else */\r\n\t\tif (SUPPORT_LEGACY_FORMATTING_PATTERNS) {\r\n\t\t\tpattern = pattern\r\n\t\t\t\t// Replace anything in the form of [..] with \\d\r\n\t\t\t\t.replace(CREATE_CHARACTER_CLASS_PATTERN(), '\\\\d')\r\n\t\t\t\t// Replace any standalone digit (not the one in `{}`) with \\d\r\n\t\t\t\t.replace(CREATE_STANDALONE_DIGIT_PATTERN(), '\\\\d')\r\n\t\t}\r\n\r\n\t\t// Generate a dummy national number (consisting of `9`s)\r\n\t\t// that fits this format's `pattern`.\r\n\t\t//\r\n\t\t// This match will always succeed,\r\n\t\t// because the \"longest dummy phone number\"\r\n\t\t// has enough length to accomodate any possible\r\n\t\t// national phone number format pattern.\r\n\t\t//\r\n\t\tlet digits = LONGEST_DUMMY_PHONE_NUMBER.match(pattern)[0]\r\n\r\n\t\t// If the national number entered is too long\r\n\t\t// for any phone number format, then abort.\r\n\t\tif (nationalSignificantNumber.length > digits.length) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\t// Get a formatting template which can be used to efficiently format\r\n\t\t// a partial number where digits are added one by one.\r\n\r\n\t\t// Below `strictPattern` is used for the\r\n\t\t// regular expression (with `^` and `$`).\r\n\t\t// This wasn't originally in Google's `libphonenumber`\r\n\t\t// and I guess they don't really need it\r\n\t\t// because they're not using \"templates\" to format phone numbers\r\n\t\t// but I added `strictPattern` after encountering\r\n\t\t// South Korean phone number formatting bug.\r\n\t\t//\r\n\t\t// Non-strict regular expression bug demonstration:\r\n\t\t//\r\n\t\t// this.nationalSignificantNumber : `111111111` (9 digits)\r\n\t\t//\r\n\t\t// pattern : (\\d{2})(\\d{3,4})(\\d{4})\r\n\t\t// format : `$1 $2 $3`\r\n\t\t// digits : `9999999999` (10 digits)\r\n\t\t//\r\n\t\t// '9999999999'.replace(new RegExp(/(\\d{2})(\\d{3,4})(\\d{4})/g), '$1 $2 $3') = \"99 9999 9999\"\r\n\t\t//\r\n\t\t// template : xx xxxx xxxx\r\n\t\t//\r\n\t\t// But the correct template in this case is `xx xxx xxxx`.\r\n\t\t// The template was generated incorrectly because of the\r\n\t\t// `{3,4}` variability in the `pattern`.\r\n\t\t//\r\n\t\t// The fix is, if `this.nationalSignificantNumber` has already sufficient length\r\n\t\t// to satisfy the `pattern` completely then `this.nationalSignificantNumber`\r\n\t\t// is used instead of `digits`.\r\n\r\n\t\tconst strictPattern = new RegExp('^' + pattern + '$')\r\n\t\tconst nationalNumberDummyDigits = nationalSignificantNumber.replace(/\\d/g, DUMMY_DIGIT)\r\n\r\n\t\t// If `this.nationalSignificantNumber` has already sufficient length\r\n\t\t// to satisfy the `pattern` completely then use it\r\n\t\t// instead of `digits`.\r\n\t\tif (strictPattern.test(nationalNumberDummyDigits)) {\r\n\t\t\tdigits = nationalNumberDummyDigits\r\n\t\t}\r\n\r\n\t\tlet numberFormat = this.getFormatFormat(format, international)\r\n\t\tlet nationalPrefixIncludedInTemplate\r\n\r\n\t\t// If a user did input a national prefix (and that's guaranteed),\r\n\t\t// and if a `format` does have a national prefix formatting rule,\r\n\t\t// then see if that national prefix formatting rule\r\n\t\t// prepends exactly the same national prefix the user has input.\r\n\t\t// If that's the case, then use the `format` with the national prefix formatting rule.\r\n\t\t// Otherwise, use  the `format` without the national prefix formatting rule,\r\n\t\t// and prepend a national prefix manually to it.\r\n\t\tif (this.shouldTryNationalPrefixFormattingRule(format, { international, nationalPrefix })) {\r\n\t\t\tconst numberFormatWithNationalPrefix = numberFormat.replace(\r\n\t\t\t\tFIRST_GROUP_PATTERN,\r\n\t\t\t\tformat.nationalPrefixFormattingRule()\r\n\t\t\t)\r\n\t\t\t// If `national_prefix_formatting_rule` of a `format` simply prepends\r\n\t\t\t// national prefix at the start of a national (significant) number,\r\n\t\t\t// then such formatting can be used with `AsYouType` formatter.\r\n\t\t\t// There seems to be no `else` case: everywhere in metadata,\r\n\t\t\t// national prefix formatting rule is national prefix + $1,\r\n\t\t\t// or `($1)`, in which case such format isn't even considered\r\n\t\t\t// when the user has input a national prefix.\r\n\t\t\t/* istanbul ignore else */\r\n\t\t\tif (parseDigits(format.nationalPrefixFormattingRule()) === (nationalPrefix || '') + parseDigits('$1')) {\r\n\t\t\t\tnumberFormat = numberFormatWithNationalPrefix\r\n\t\t\t\tnationalPrefixIncludedInTemplate = true\r\n\t\t\t\t// Replace all digits of the national prefix in the formatting template\r\n\t\t\t\t// with `DIGIT_PLACEHOLDER`s.\r\n\t\t\t\tif (nationalPrefix) {\r\n\t\t\t\t\tlet i = nationalPrefix.length\r\n\t\t\t\t\twhile (i > 0) {\r\n\t\t\t\t\t\tnumberFormat = numberFormat.replace(/\\d/, DIGIT_PLACEHOLDER)\r\n\t\t\t\t\t\ti--\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Generate formatting template for this phone number format.\r\n\t\tlet template = digits\r\n\t\t\t// Format the dummy phone number according to the format.\r\n\t\t\t.replace(new RegExp(pattern), numberFormat)\r\n\t\t\t// Replace each dummy digit with a DIGIT_PLACEHOLDER.\r\n\t\t\t.replace(new RegExp(DUMMY_DIGIT, 'g'), DIGIT_PLACEHOLDER)\r\n\r\n\t\t// If a prefix of a national (significant) number is not as simple\r\n\t\t// as just a basic national prefix, then just prepend such prefix\r\n\t\t// before the national (significant) number, optionally spacing\r\n\t\t// the two with a whitespace.\r\n\t\tif (!nationalPrefixIncludedInTemplate) {\r\n\t\t\tif (complexPrefixBeforeNationalSignificantNumber) {\r\n\t\t\t\t// Prepend the prefix to the template manually.\r\n\t\t\t\ttemplate = repeat(DIGIT_PLACEHOLDER, complexPrefixBeforeNationalSignificantNumber.length) +\r\n\t\t\t\t\t' ' +\r\n\t\t\t\t\ttemplate\r\n\t\t\t} else if (nationalPrefix) {\r\n\t\t\t\t// Prepend national prefix to the template manually.\r\n\t\t\t\ttemplate = repeat(DIGIT_PLACEHOLDER, nationalPrefix.length) +\r\n\t\t\t\t\tthis.getSeparatorAfterNationalPrefix(format) +\r\n\t\t\t\t\ttemplate\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (international) {\r\n\t\t\ttemplate = applyInternationalSeparatorStyle(template)\r\n\t\t}\r\n\r\n\t\treturn template\r\n\t}\r\n\r\n\tformatNextNationalNumberDigits(digits) {\r\n\t\tconst result = populateTemplateWithDigits(\r\n\t\t\tthis.populatedNationalNumberTemplate,\r\n\t\t\tthis.populatedNationalNumberTemplatePosition,\r\n\t\t\tdigits\r\n\t\t)\r\n\r\n\t\tif (!result) {\r\n\t\t\t// Reset the format.\r\n\t\t\tthis.resetFormat()\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tthis.populatedNationalNumberTemplate = result[0]\r\n\t\tthis.populatedNationalNumberTemplatePosition = result[1]\r\n\r\n\t\t// Return the formatted phone number so far.\r\n\t\treturn cutAndStripNonPairedParens(this.populatedNationalNumberTemplate, this.populatedNationalNumberTemplatePosition + 1)\r\n\r\n\t\t// The old way which was good for `input-format` but is not so good\r\n\t\t// for `react-phone-number-input`'s default input (`InputBasic`).\r\n\t\t// return closeNonPairedParens(this.populatedNationalNumberTemplate, this.populatedNationalNumberTemplatePosition + 1)\r\n\t\t// \t.replace(new RegExp(DIGIT_PLACEHOLDER, 'g'), ' ')\r\n\t}\r\n\r\n\tshouldTryNationalPrefixFormattingRule(format, { international, nationalPrefix }) {\r\n\t\tif (format.nationalPrefixFormattingRule()) {\r\n\t\t\t// In some countries, `national_prefix_formatting_rule` is `($1)`,\r\n\t\t\t// so it applies even if the user hasn't input a national prefix.\r\n\t\t\t// `format.usesNationalPrefix()` detects such cases.\r\n\t\t\tconst usesNationalPrefix = format.usesNationalPrefix()\r\n\t\t\tif ((usesNationalPrefix && nationalPrefix) ||\r\n\t\t\t\t(!usesNationalPrefix && !international)) {\r\n\t\t\t\treturn true\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}"],"mappings":"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"}