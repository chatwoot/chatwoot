{"version":3,"sources":["../src/index.ts"],"names":["events","res"],"mappings":"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","sourcesContent":["/**\n * FormKit Observer is a utility to wrap a FormKitNode in a dependency tracking observer proxy.\n *\n * @packageDocumentation\n */\n\nimport { has } from '@formkit/utils'\nimport {\n  FormKitNode,\n  isNode,\n  FormKitEventListener,\n  FormKitProps,\n  FormKitLedger,\n} from '@formkit/core'\n\n/**\n * An API-compatible FormKitNode that is able to determine the full dependency\n * tree of nodes and their values.\n * @public\n */\nexport interface FormKitObservedNode extends FormKitNode {\n  _node: FormKitNode\n  deps: FormKitDependencies\n  kill: () => undefined\n  observe: () => void\n  receipts: FormKitObserverReceipts\n  stopObserve: () => FormKitDependencies\n  watch: <T extends FormKitWatchable>(\n    block: T,\n    after?: (value: ReturnType<T>) => void,\n    pos?: 'push' | 'unshift'\n  ) => void\n}\n\n/**\n * The dependent nodes and the events that are required to watch for changes.\n *\n * @public\n */\nexport type FormKitDependencies = Map<FormKitNode, Set<string>> & {\n  active?: boolean\n}\n\n/**\n * A Map of nodes with the values being Maps of eventsName: receipt\n *\n * @public\n */\nexport type FormKitObserverReceipts = Map<\n  FormKitNode,\n  { [index: string]: string[] }\n>\n\n/**\n * A callback to watch for nodes.\n * @public\n */\nexport interface FormKitWatchable<T = unknown> {\n  (node: FormKitObservedNode): T\n}\n\n/**\n * A registry of all revoked observers.\n */\nconst revokedObservers = new WeakSet()\n\n/**\n * Creates the observer.\n * @param node - The {@link @formkit/core#FormKitNode | FormKitNode} to observe.\n * @param dependencies - The dependent nodes and the events that are required to\n * watch for changes.\n * @returns Returns a {@link @formkit/observer#FormKitObservedNode | FormKitObservedNode}.\n * @public\n */\nexport function createObserver(\n  node: FormKitNode,\n  dependencies?: FormKitDependencies\n): FormKitObservedNode {\n  // The dependencies touched during tracking\n  const deps: FormKitDependencies =\n    dependencies || Object.assign(new Map(), { active: false })\n  // A registry of event receipts returned by the event system\n  const receipts: FormKitObserverReceipts = new Map()\n\n  /**\n   * Simple function to add a dependency to the deps map.\n   * @param event - The name of the event type (like commit/input etc)\n   */\n  const addDependency = function (event: string) {\n    if (!deps.active) return\n    if (!deps.has(node)) deps.set(node, new Set())\n    deps.get(node)?.add(event)\n  }\n\n  /**\n   * Proxies the props of a node so we know which ones were messed with, could\n   * potentially be more generalized in the future if we want to support\n   * more sub-objects.\n   * @param props - The props object from a node\n   * @returns\n   */\n  const observeProps = function (props: FormKitProps) {\n    return new Proxy(props, {\n      get(...args) {\n        typeof args[1] === 'string' && addDependency(`prop:${args[1]}`)\n        return Reflect.get(...args)\n      },\n    })\n  }\n\n  /**\n   * Observes the FormKit ledger \"value\".\n   * @param ledger - A formkit ledger counter.\n   */\n  const observeLedger = function (ledger: FormKitLedger) {\n    return new Proxy(ledger, {\n      get(...args) {\n        if (args[1] === 'value') {\n          return (key: string) => {\n            addDependency(`count:${key}`)\n            return ledger.value(key)\n          }\n        }\n        return Reflect.get(...args)\n      },\n    })\n  }\n\n  /**\n   * Return values from our observer proxy first pass through this function\n   * which gives us a chance to listen sub-dependencies and properties.\n   */\n  const observe = function (value: any, property: string | symbol) {\n    if (isNode(value)) {\n      return createObserver(value, deps)\n    }\n    if (property === 'value') addDependency('commit')\n    if (property === '_value') addDependency('input')\n    if (property === 'props') return observeProps(value)\n    if (property === 'ledger') return observeLedger(value)\n    if (property === 'children') {\n      addDependency('child')\n      addDependency('childRemoved')\n    }\n    return value\n  }\n\n  /**\n   * The actual proxy object of the original node.\n   */\n  const {\n    proxy: observed,\n    revoke,\n  }: { proxy: FormKitNode; revoke: () => void } = Proxy.revocable(node, {\n    get(...args) {\n      switch (args[1]) {\n        case '_node':\n          return node\n        case 'deps':\n          return deps\n        case 'watch':\n          return <T extends FormKitWatchable>(\n            block: T,\n            after?: (value: unknown) => void,\n            pos?: 'push' | 'unshift'\n          ) => watch(observed as FormKitObservedNode, block, after, pos)\n        case 'observe':\n          return () => {\n            const old = new Map(deps)\n            deps.clear()\n            deps.active = true\n            return old\n          }\n        case 'stopObserve':\n          return () => {\n            const newDeps = new Map(deps)\n            deps.active = false\n            return newDeps\n          }\n        case 'receipts':\n          return receipts\n        case 'kill':\n          return (): undefined => {\n            removeListeners(receipts)\n            revokedObservers.add(args[2])\n            revoke()\n            return undefined\n          }\n      }\n      const value = Reflect.get(...args)\n      // If we're dealing with a function, we need to sub-call the function\n      // get that return value, and pass it through the same logic.\n      if (typeof value === 'function') {\n        return (...subArgs: any[]) => {\n          const subValue = value(...subArgs)\n          return observe(subValue, args[1])\n        }\n      }\n      return observe(value, args[1])\n    },\n  })\n  return observed as unknown as FormKitObservedNode\n}\n\n/**\n * Given two maps (`toAdd` and `toRemove`), apply the dependencies as event\n * listeners on the underlying nodes.\n * @param node - The node to apply dependencies to.\n * @param deps - A tuple of toAdd and toRemove FormKitDependencies maps.\n * @param callback - The callback to add or remove.\n * @internal\n */\nexport function applyListeners(\n  node: FormKitObservedNode,\n  [toAdd, toRemove]: [FormKitDependencies, FormKitDependencies],\n  callback: FormKitEventListener,\n  pos?: 'unshift' | 'push'\n): void {\n  toAdd.forEach((events, depNode) => {\n    events.forEach((event) => {\n      node.receipts.has(depNode) || node.receipts.set(depNode, {})\n      const events = node.receipts.get(depNode) ?? {}\n      events[event] = events[event] ?? []\n      events[event].push(depNode.on(event, callback, pos))\n      node.receipts.set(depNode, events)\n    })\n  })\n  toRemove.forEach((events, depNode) => {\n    events.forEach((event) => {\n      if (node.receipts.has(depNode)) {\n        const nodeReceipts = node.receipts.get(depNode)\n        if (nodeReceipts && has(nodeReceipts, event)) {\n          nodeReceipts[event].map(depNode.off)\n          delete nodeReceipts[event]\n          node.receipts.set(depNode, nodeReceipts)\n        }\n      }\n    })\n  })\n}\n\n/**\n * Remove all the receipts from the observed node and subtree.\n * @param receipts - The FormKit observer receipts to remove.\n * @public\n */\nexport function removeListeners(receipts: FormKitObserverReceipts): void {\n  receipts.forEach((events, node) => {\n    for (const event in events) {\n      events[event].map(node.off)\n    }\n  })\n  receipts.clear()\n}\n\n/**\n * Observes a chunk of code to dependencies, and then re-calls that chunk of\n * code when those dependencies are manipulated.\n * @param node - The node to observer\n * @param block - The block of code to observe\n * @param after - A function to call after a effect has been run.\n * @public\n */\nfunction watch<T extends FormKitWatchable>(\n  node: FormKitObservedNode,\n  block: T,\n  after?: (value: unknown) => void,\n  pos?: 'push' | 'unshift'\n): void {\n  const doAfterObservation = (res: unknown) => {\n    const newDeps = node.stopObserve()\n    applyListeners(\n      node,\n      diffDeps(oldDeps, newDeps),\n      () => watch(node, block, after, pos),\n      pos\n    )\n    if (after) after(res)\n  }\n  const oldDeps = new Map(node.deps)\n  node.observe()\n  const res = block(node)\n  if (res instanceof Promise) res.then((val) => doAfterObservation(val))\n  else doAfterObservation(res)\n}\n\n/**\n * Determines which nodes should be added as dependencies and which should be\n * removed.\n * @param previous - The previous watcher dependencies.\n * @param current - The new/current watcher dependencies.\n * @returns A tuple of maps: `toAdd` and `toRemove`.\n * @public\n */\nexport function diffDeps(\n  previous: FormKitDependencies,\n  current: FormKitDependencies\n): [FormKitDependencies, FormKitDependencies] {\n  const toAdd: FormKitDependencies = new Map()\n  const toRemove: FormKitDependencies = new Map()\n  current.forEach((events, node) => {\n    if (!previous.has(node)) {\n      toAdd.set(node, events)\n    } else {\n      const eventsToAdd = new Set<string>()\n      const previousEvents = previous.get(node)\n      events.forEach(\n        (event) => !previousEvents?.has(event) && eventsToAdd.add(event)\n      )\n      toAdd.set(node, eventsToAdd)\n    }\n  })\n  previous.forEach((events, node) => {\n    if (!current.has(node)) {\n      toRemove.set(node, events)\n    } else {\n      const eventsToRemove = new Set<string>()\n      const newEvents = current.get(node)\n      events.forEach(\n        (event) => !newEvents?.has(event) && eventsToRemove.add(event)\n      )\n      toRemove.set(node, eventsToRemove)\n    }\n  })\n  return [toAdd, toRemove]\n}\n\n/**\n * Checks if the given node is revoked.\n * @param node - Any observed node to check.\n * @returns A `boolean` indicating if the node is revoked.\n * @public\n */\nexport function isKilled(node: FormKitNode | FormKitObservedNode): boolean {\n  return revokedObservers.has(node)\n}\n"]}