{"version":3,"file":"browserTracingIntegration.js","sources":["../../src/browserTracingIntegration.ts"],"sourcesContent":["import {\n  browserTracingIntegration as originalBrowserTracingIntegration,\n  startBrowserTracingNavigationSpan,\n} from '@sentry/browser';\nimport type { Integration, StartSpanOptions } from '@sentry/types';\nimport { instrumentVueRouter } from './router';\n\n// The following type is an intersection of the Route type from VueRouter v2, v3, and v4.\n// This is not great, but kinda necessary to make it work with all versions at the same time.\nexport type Route = {\n  /** Unparameterized URL */\n  path: string;\n  /**\n   * Query params (keys map to null when there is no value associated, e.g. \"?foo\" and to an array when there are\n   * multiple query params that have the same key, e.g. \"?foo&foo=bar\")\n   */\n  query: Record<string, string | null | (string | null)[]>;\n  /** Route name (VueRouter provides a way to give routes individual names) */\n  name?: string | symbol | null | undefined;\n  /** Evaluated parameters */\n  params: Record<string, string | string[]>;\n  /** All the matched route objects as defined in VueRouter constructor */\n  matched: { path: string }[];\n};\n\ninterface VueRouter {\n  onError: (fn: (err: Error) => void) => void;\n  beforeEach: (fn: (to: Route, from: Route, next?: () => void) => void) => void;\n}\n\ntype VueBrowserTracingIntegrationOptions = Parameters<typeof originalBrowserTracingIntegration>[0] & {\n  /**\n   * If a router is specified, navigation spans will be created based on the router.\n   */\n  router?: VueRouter;\n\n  /**\n   * What to use for route labels.\n   * By default, we use route.name (if set) and else the path.\n   *\n   * Default: 'name'\n   */\n  routeLabel?: 'name' | 'path';\n};\n\n/**\n * A custom browser tracing integrations for Vue.\n */\nexport function browserTracingIntegration(options: VueBrowserTracingIntegrationOptions = {}): Integration {\n  // If router is not passed, we just use the normal implementation\n  if (!options.router) {\n    return originalBrowserTracingIntegration(options);\n  }\n\n  const integration = originalBrowserTracingIntegration({\n    ...options,\n    instrumentNavigation: false,\n  });\n\n  const { router, instrumentNavigation = true, instrumentPageLoad = true, routeLabel = 'name' } = options;\n\n  return {\n    ...integration,\n    afterAllSetup(client) {\n      integration.afterAllSetup(client);\n\n      const startNavigationSpan = (options: StartSpanOptions): void => {\n        startBrowserTracingNavigationSpan(client, options);\n      };\n\n      instrumentVueRouter(router, { routeLabel, instrumentNavigation, instrumentPageLoad }, startNavigationSpan);\n    },\n  };\n}\n"],"names":["originalBrowserTracingIntegration"],"mappings":";;;AAOA;AACA;;AAqCA;AACA;AACA;AACO,SAAS,yBAAyB,CAAC,OAAO,GAAwC,EAAE,EAAe;AAC1G;AACA,EAAE,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE;AACvB,IAAI,OAAOA,2BAAiC,CAAC,OAAO,CAAC,CAAA;AACrD,GAAE;AACF;AACA,EAAE,MAAM,WAAA,GAAcA,2BAAiC,CAAC;AACxD,IAAI,GAAG,OAAO;AACd,IAAI,oBAAoB,EAAE,KAAK;AAC/B,GAAG,CAAC,CAAA;AACJ;AACA,EAAE,MAAM,EAAE,MAAM,EAAE,oBAAA,GAAuB,IAAI,EAAE,kBAAmB,GAAE,IAAI,EAAE,UAAA,GAAa,MAAO,EAAA,GAAI,OAAO,CAAA;AACzG;AACA,EAAE,OAAO;AACT,IAAI,GAAG,WAAW;AAClB,IAAI,aAAa,CAAC,MAAM,EAAE;AAC1B,MAAM,WAAW,CAAC,aAAa,CAAC,MAAM,CAAC,CAAA;AACvC;AACA,MAAM,MAAM,mBAAA,GAAsB,CAAC,OAAO,KAA6B;AACvE,QAAQ,iCAAiC,CAAC,MAAM,EAAE,OAAO,CAAC,CAAA;AAC1D,OAAO,CAAA;AACP;AACA,MAAM,mBAAmB,CAAC,MAAM,EAAE,EAAE,UAAU,EAAE,oBAAoB,EAAE,kBAAA,EAAoB,EAAE,mBAAmB,CAAC,CAAA;AAChH,KAAK;AACL,GAAG,CAAA;AACH;;;;"}