{"version":3,"sources":["../src/index.ts"],"names":["format","spread","el"],"mappings":"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","sourcesContent":["/**\n * Commonly shared utility functions between official FormKit packages.\n *\n * You can add this package by using `npm install @formkit/utils` or `yarn add @formkit/utils`.\n *\n * @packageDocumentation\n */\n\nconst isBrowser = typeof window !== 'undefined'\n\n/**\n * Explicit keys that should always be cloned.\n */\nconst explicitKeys = [\n  '__key',\n  '__init',\n  '__shim',\n  '__original',\n  '__index',\n  '__prevKey',\n]\n\n/**\n * Generates a random string.\n *\n * @example\n *\n * ```javascript\n * import { token } from '@formkit/utils'\n *\n * const tk = token()\n * // 'jkbyqnphqm'\n * ```\n *\n * @returns string\n *\n * @public\n */\nexport function token(): string {\n  return Math.random().toString(36).substring(2, 15)\n}\n\n/**\n * Creates a new set of the specified type and uses the values from an Array or\n * an existing Set.\n *\n * @example\n *\n * ```javascript\n * import { setify } from '@formkit/utils'\n *\n * const tk = setify(['a', 'b'])\n * // Set(2) {'a', 'b'}\n * ```\n *\n * @param items - An array or a Set.\n *\n * @returns `Set<T>`\n *\n * @public\n */\nexport function setify<T>(items: Set<T> | T[] | null | undefined): Set<T> {\n  return items instanceof Set ? items : new Set<T>(items)\n}\n\n/**\n * Given 2 arrays, return them as a combined array with no duplicates.\n *\n * @param arr1 - First array.\n * @param arr2 - Second array.\n *\n * @returns `any[]`\n *\n * @public\n */\nexport function dedupe<T extends any[] | Set<any>, X extends any[] | Set<any>>(\n  arr1: T,\n  arr2?: X\n): any[] {\n  const original = arr1 instanceof Set ? arr1 : new Set(arr1)\n  if (arr2) arr2.forEach((item: any) => original.add(item))\n  return [...original]\n}\n\n/**\n * Checks if the given property exists on the given object.\n *\n * @param obj - An object to check.\n * @param property - The property to check.\n *\n * @returns `boolean`\n *\n * @public\n */\nexport function has(\n  obj: {\n    [index: string]: any\n    [index: number]: any\n  },\n  property: string | symbol | number\n): boolean {\n  return Object.prototype.hasOwnProperty.call(obj, property)\n}\n\n/**\n * Compare two values for equality, optionally at depth.\n *\n * @param valA - First value.\n * @param valB - Second value.\n * @param deep - If it will compare deeply if it's an object.\n * @param explicit - An array of keys to explicity check.\n *\n * @returns `boolean`\n *\n * @public\n */\nexport function eq(\n  valA: any, // eslint-disable-line\n  valB: any, // eslint-disable-line\n  deep = true,\n  explicit: string[] = ['__key']\n): boolean {\n  if (valA === valB) return true\n  if (typeof valB === 'object' && typeof valA === 'object') {\n    if (valA instanceof Map) return false\n    if (valA instanceof Set) return false\n    if (valA instanceof Date && valB instanceof Date)\n      return valA.getTime() === valB.getTime()\n    if (valA instanceof RegExp && valB instanceof RegExp)\n      return eqRegExp(valA, valB)\n    if (valA === null || valB === null) return false\n    if (Object.keys(valA).length !== Object.keys(valB).length) return false\n    for (const k of explicit) {\n      if ((k in valA || k in valB) && valA[k] !== valB[k]) return false\n    }\n    for (const key in valA) {\n      if (!(key in valB)) return false\n      if (valA[key] !== valB[key] && !deep) return false\n      if (deep && !eq(valA[key], valB[key], deep, explicit)) return false\n    }\n    return true\n  }\n  return false\n}\n\n/**\n * A regular expression to test for a valid date string.\n * @param x - A RegExp to compare.\n * @param y - A RegExp to compare.\n * @public\n */\nexport function eqRegExp(x: RegExp, y: RegExp): boolean {\n  return (\n    x.source === y.source &&\n    x.flags.split('').sort().join('') === y.flags.split('').sort().join('')\n  )\n}\n\n/**\n * Determines if a value is empty or not.\n *\n * @param value - The value to check if it's empty.\n *\n * @returns `boolean`\n *\n * @public\n */\nexport function empty(\n  value: any // eslint-disable-line\n): boolean {\n  const type = typeof value\n  if (type === 'number') return false\n  if (value === undefined) return true\n  if (type === 'string') {\n    return value === ''\n  }\n  if (type === 'object') {\n    if (value === null) return true\n    for (const _i in value) return false\n    if (value instanceof RegExp) return false\n    if (value instanceof Date) return false\n    return true\n  }\n  return false\n}\n\n/**\n * Escape a string for use in regular expressions.\n *\n * @param string - String to be escaped.\n *\n * @returns `string`\n *\n * @public\n */\nexport function escapeExp(string: string): string {\n  // $& means the whole matched string\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n}\n\n/**\n * The date token strings that can be used for date formatting.\n *\n * @public\n */\nexport type FormKitDateTokens = 'MM' | 'M' | 'DD' | 'D' | 'YYYY' | 'YY'\n\n/**\n * Given a string date format, return a regex to match against.\n *\n * @param format - String to be transformed to RegExp.\n *\n * @example\n *\n * ```javascript\n * regexForFormat('MM') // returns '(0[1-9]|1[012])'\n * ```\n *\n * @returns `RegExp`\n *\n * @public\n */\nexport function regexForFormat(format: string): RegExp {\n  const escaped = `^${escapeExp(format)}$`\n  const formats: Record<FormKitDateTokens, string> = {\n    MM: '(0[1-9]|1[012])',\n    M: '([1-9]|1[012])',\n    DD: '([012][0-9]|3[01])',\n    D: '([012]?[0-9]|3[01])',\n    YYYY: '\\\\d{4}',\n    YY: '\\\\d{2}',\n  }\n  const tokens = Object.keys(formats) as FormKitDateTokens[]\n  return new RegExp(\n    tokens.reduce((regex, format) => {\n      return regex.replace(format, formats[format])\n    }, escaped)\n  )\n}\n\n/**\n * Given a FormKit input type, returns the correct lowerCased() type.\n *\n * @param type - String to return to check for correct type\n *\n * @returns `'list' | 'group' | 'input'`\n *\n * @public\n */\nexport function nodeType(type: string): 'list' | 'group' | 'input' {\n  const t = type.toLowerCase()\n  if (t === 'list') return 'list'\n  if (t === 'group') return 'group'\n  return 'input'\n}\n\n/**\n * Determines if an object is an object.\n *\n * @param o - The value to be checked.\n *\n * @returns `boolean`\n *\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function isRecord(o: unknown): o is Record<PropertyKey, unknown> {\n  return Object.prototype.toString.call(o) === '[object Object]'\n}\n\n/**\n * Checks if an object is a simple array or record.\n *\n * @param o - Value to be checked.\n *\n * @returns `boolean`\n *\n * @public\n */\nexport function isObject(\n  o: unknown\n): o is Record<PropertyKey, unknown> | unknown[] {\n  return isRecord(o) || Array.isArray(o)\n}\n\n/**\n * Attempts to determine if an object is a POJO (Plain Old JavaScript Object).\n * Mostly lifted from is-plain-object: https://github.com/jonschlinkert/is-plain-object\n * Copyright (c) 2014-2017, Jon Schlinkert.\n *\n * @param o - The value to be checked.\n *\n * @returns `boolean`\n *\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function isPojo(o: any): o is Record<string, any> {\n  if (isRecord(o) === false) return false\n  if (o.__FKNode__ || o.__POJO__ === false) return false\n  const ctor = o.constructor\n  if (ctor === undefined) return true\n  const prot = ctor.prototype\n  if (isRecord(prot) === false) return false\n  if (prot.hasOwnProperty('isPrototypeOf') === false) {\n    return false\n  }\n  return true\n}\n\n/**\n * Recursively merge data from additional into original returning a new object.\n *\n * @param original - The original array.\n * @param additional - The array to merge.\n * @param extendArrays - If it will extend/concatenate array values instead of\n * replacing them.\n * @param ignoreUndefined - If it will preserve values from the original object\n * even if the additional object has those values set to undefined.\n *\n * @returns `Record<string, any> | string | null`\n *\n * @public\n *\n */\nexport const extend = /*#__NO_SIDE_EFFECTS__*/ (\n  original: Record<string, any>,\n  additional: Record<string, any> | string | null,\n  extendArrays = false,\n  ignoreUndefined = false\n): Record<string, any> | string | null => {\n  if (additional === null) return null\n  const merged: Record<string, any> = {}\n  if (typeof additional === 'string') return additional\n  for (const key in original) {\n    if (\n      has(additional, key) &&\n      (additional[key] !== undefined || !ignoreUndefined)\n    ) {\n      if (\n        extendArrays &&\n        Array.isArray(original[key]) &&\n        Array.isArray(additional[key])\n      ) {\n        merged[key] = original[key].concat(additional[key])\n        continue\n      }\n      if (additional[key] === undefined) {\n        continue\n      }\n      if (isPojo(original[key]) && isPojo(additional[key])) {\n        merged[key] = extend(\n          original[key],\n          additional[key],\n          extendArrays,\n          ignoreUndefined\n        )\n      } else {\n        merged[key] = additional[key]\n      }\n    } else {\n      merged[key] = original[key]\n    }\n  }\n  for (const key in additional) {\n    if (!has(merged, key) && additional[key] !== undefined) {\n      merged[key] = additional[key]\n    }\n  }\n  return merged\n}\n\n/**\n * Determine if the given string is fully quoted.\n *\n * @example\n *\n * ```javascript\n * hello - false\n * \"hello\" - true\n * 'world' - true\n * \"hello\"==\"world\" - false\n * \"hello'this'\" - false\n * \"hello\"'there' - false\n * \"hello\"\"there\" - false\n * 'hello === world' - true\n * ```\n *\n * @param str - The string to check.\n *\n * @returns `boolean`\n *\n * @public\n */\nexport function isQuotedString(str: string): boolean {\n  // quickly return false if the value is note quoted\n  if (str[0] !== '\"' && str[0] !== \"'\") return false\n  if (str[0] !== str[str.length - 1]) return false\n  const quoteType = str[0]\n  for (let p = 1; p < str.length; p++) {\n    if (\n      str[p] === quoteType &&\n      (p === 1 || str[p - 1] !== '\\\\') &&\n      p !== str.length - 1\n    ) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * Remove extra escape characters.\n *\n * @param str - String to remove extra escape characters from.\n *\n * @returns `string`\n *\n * @public\n */\nexport function rmEscapes(str: string): string {\n  if (!str.length) return ''\n  let clean = ''\n  let lastChar = ''\n  for (let p = 0; p < str.length; p++) {\n    const char = str.charAt(p)\n    if (char !== '\\\\' || lastChar === '\\\\') {\n      clean += char\n    }\n    lastChar = char\n  }\n  return clean\n}\n\n/**\n * Performs a recursive `Object.assign`-like operation.\n *\n * @param a - An object to be assigned.\n * @param b - An object to get values from.\n *\n * @returns `A & B`\n *\n * @public\n */\nexport function assignDeep<\n  A extends Record<PropertyKey, any>,\n  B extends Record<PropertyKey, any>\n>(a: A, b: B): A & B {\n  for (const key in a) {\n    if (\n      has(b, key) &&\n      (a[key] as any) !== b[key] &&\n      !(isPojo(a[key]) && isPojo(b[key]))\n    ) {\n      a[key] = b[key]\n    } else if (isPojo(a[key]) && isPojo(b[key])) {\n      assignDeep(a[key], b[key])\n    }\n  }\n  for (const key in b) {\n    if (!has(a, key)) {\n      a[key] = b[key]\n    }\n  }\n  return a\n}\n\n/**\n * Filters out values from an object that should not be considered \"props\" of\n * a core node, like \"value\" and \"name\".\n *\n * @param sets - The arrays to get values filtered out of.\n *\n * @returns `Record<string, any>`\n *\n * @public\n */\nexport function nodeProps(\n  ...sets: Array<Record<string, any>>\n): Record<string, any> {\n  return sets.reduce((valid, props) => {\n    const { value, name, modelValue, config, plugins, ...validProps } = props // eslint-disable-line\n    return Object.assign(valid, validProps)\n  }, {})\n}\n\n/**\n * Parse a string for comma-separated arguments.\n *\n * @param str - String to parse arguments from.\n *\n * @returns `string[]`\n *\n * @public\n */\nexport function parseArgs(str: string): string[] {\n  const args: string[] = []\n  let arg = ''\n  let depth = 0\n  let quote = ''\n  let lastChar = ''\n  for (let p = 0; p < str.length; p++) {\n    const char = str.charAt(p)\n    if (char === quote && lastChar !== '\\\\') {\n      quote = ''\n    } else if ((char === \"'\" || char === '\"') && !quote && lastChar !== '\\\\') {\n      quote = char\n    } else if (char === '(' && !quote) {\n      depth++\n    } else if (char === ')' && !quote) {\n      depth--\n    }\n    if (char === ',' && !quote && depth === 0) {\n      args.push(arg)\n      arg = ''\n    } else if (char !== ' ' || quote) {\n      arg += char\n    }\n    lastChar = char\n  }\n  if (arg) {\n    args.push(arg)\n  }\n  return args\n}\n\n/**\n * Return a new (shallow) object with any desired props removed.\n *\n * @param obj - The starting object.\n * @param toRemove - The array of properties to remove. Accepts strings or\n * regular expressions.\n *\n * @returns `Record<string, any>`\n *\n * @public\n */\nexport function except(\n  obj: Record<string, any>,\n  toRemove: Array<string | RegExp>\n): Record<string, any> {\n  const clean: Record<string, any> = {}\n  const exps = toRemove.filter((n) => n instanceof RegExp) as RegExp[]\n  const keysToRemove = new Set(toRemove)\n  for (const key in obj) {\n    if (!keysToRemove.has(key) && !exps.some((exp) => exp.test(key))) {\n      clean[key] = obj[key]\n    }\n  }\n  return clean\n}\n\n/**\n * Extracts a set of keys from a given object. Importantly, this will extract\n * values even if they are not set on the original object — they will just have\n * an undefined value.\n *\n * @param obj - The object to get values from.\n * @param include - The array of items to get.\n *\n * @returns `Record<string, any>`\n *\n * @public\n */\nexport function only(\n  obj: Record<string, any>,\n  include: Array<string | RegExp>\n): Record<string, any> {\n  const clean: Record<string, any> = {}\n  const exps = include.filter((n) => n instanceof RegExp) as RegExp[]\n  include.forEach((key) => {\n    if (!(key instanceof RegExp)) {\n      clean[key] = obj[key]\n    }\n  })\n  Object.keys(obj).forEach((key) => {\n    if (exps.some((exp) => exp.test(key))) {\n      clean[key] = obj[key]\n    }\n  })\n  return clean\n}\n\n/**\n * This converts kebab-case to camelCase. It ONLY converts from kebab to camel.\n *\n * @param str - String to be camel cased.\n *\n * @returns `string`\n *\n * @public\n */\nexport function camel(str: string): string {\n  return str.replace(/-([a-z0-9])/gi, (_s: string, g: string) =>\n    g.toUpperCase()\n  )\n}\n\n/**\n * This converts camel-case to kebab case. It ONLY converts from camel to kebab.\n *\n * @param str - String to be kebabed.\n *\n * @returns `string`\n *\n * @public\n */\nexport function kebab(str: string): string {\n  return str\n    .replace(\n      /([a-z0-9])([A-Z])/g,\n      (_s: string, trail: string, cap: string) =>\n        trail + '-' + cap.toLowerCase()\n    )\n    .replace(' ', '-')\n    .toLowerCase()\n}\n\n/**\n * Shallowly clones the given object.\n *\n * @param obj - Object to be shallowly cloned.\n * @param explicit - The array of keys to be explicity cloned.\n *\n * @returns `T`\n *\n * @public\n */\nexport function shallowClone<T>(obj: T, explicit: string[] = explicitKeys): T {\n  if (obj !== null && typeof obj === 'object') {\n    let returnObject: any[] | Record<string, any> | undefined\n    if (Array.isArray(obj)) returnObject = [...obj]\n    else if (isPojo(obj)) returnObject = { ...obj }\n    if (returnObject) {\n      applyExplicit(obj, returnObject, explicit)\n      return returnObject as T\n    }\n  }\n  return obj\n}\n\n/**\n * Perform a recursive clone on a given object. Only intended to be used\n * for simple objects like arrays and POJOs.\n *\n * @param obj - Object to be cloned.\n * @param explicit - Array of items to be explicity cloned.\n *\n * @returns `T`\n *\n * @public\n */\nexport function clone<T extends Record<string, unknown> | unknown[] | null>(\n  obj: T,\n  explicit: string[] = explicitKeys\n): T {\n  if (\n    obj === null ||\n    obj instanceof RegExp ||\n    obj instanceof Date ||\n    obj instanceof Map ||\n    obj instanceof Set ||\n    (typeof File === 'function' && obj instanceof File)\n  )\n    return obj\n  let returnObject\n  if (Array.isArray(obj)) {\n    returnObject = obj.map((value) => {\n      if (typeof value === 'object') return clone(value as unknown[], explicit)\n      return value\n    }) as T\n  } else {\n    returnObject = Object.keys(obj).reduce((newObj, key) => {\n      newObj[key] =\n        typeof obj[key] === 'object'\n          ? clone(obj[key] as unknown[], explicit)\n          : obj[key]\n      return newObj\n    }, {} as Record<string, unknown>) as T\n  }\n  for (const key of explicit) {\n    if (key in obj) {\n      Object.defineProperty(returnObject, key, {\n        enumerable: false,\n        value: (obj as any)[key],\n      })\n    }\n  }\n  return returnObject\n}\n\n/**\n * Clones anything. If the item is scalar, no worries, it passes it back. If it\n * is an object, it performs a (fast/loose) clone operation.\n *\n * @param obj - The value to be cloned.\n *\n * @returns `T`\n *\n * @public\n */\nexport function cloneAny<T>(obj: T): T {\n  return typeof obj === 'object'\n    ? (clone(obj as Record<string, unknown>) as T)\n    : obj\n}\n\n/**\n * Get a specific value via dot notation.\n *\n * @param obj - An object to fetch data from.\n * @param addr - An \"address\" in dot notation.\n *\n * @returns `unknown`\n *\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function getAt(obj: any, addr: string): unknown {\n  if (!obj || typeof obj !== 'object') return null\n  const segments = addr.split('.')\n  let o = obj\n  for (const i in segments) {\n    const segment = segments[i]\n    if (has(o, segment)) {\n      o = o[segment]\n    }\n    if (+i === segments.length - 1) return o\n    if (!o || typeof o !== 'object') return null\n  }\n  return null\n}\n\n/**\n * Determines if the value of a prop that is either present (true) or not\n * present (undefined). For example, the prop disabled should disable\n * by just existing, but what if it is set to the string \"false\" — then it\n * should not be disabled.\n *\n * @param value - Value to check for undefined.\n *\n * @returns `true | undefined`\n *\n * @public\n */\nexport function undefine(value: unknown): true | undefined {\n  return value !== undefined && value !== 'false' && value !== false\n    ? true\n    : undefined\n}\n\n/**\n * Defines an object as an initial value.\n *\n * @param obj - Object to be added an initial value.\n *\n * @returns `T & { __init?: true }`\n *\n * @public\n */\n/* eslint-disable-next-line @typescript-eslint/ban-types */\nexport function init<T extends object>(obj: T): T & { __init?: true } {\n  return !Object.isFrozen(obj)\n    ? (Object.defineProperty(obj, '__init', {\n        enumerable: false,\n        value: true,\n      }) as T & { __init: true })\n    : obj\n}\n\n/**\n * Turn any string into a URL/DOM-safe string.\n *\n * @param str - String to be slugified to a URL-safe string.\n *\n * @returns `string`\n *\n * @public\n */\nexport function slugify(str: string): string {\n  return str\n    .normalize('NFD')\n    .replace(/[\\u0300-\\u036f]/g, '')\n    .toLowerCase()\n    .replace(/[^a-z0-9]/g, ' ')\n    .trim()\n    .replace(/\\s+/g, '-')\n}\n\n/**\n * Spreads an object or an array, otherwise returns the same value.\n *\n * @param obj - The object to be spread.\n * @param explicit - The array of items to be explicity spread.\n *\n * @returns `T`\n *\n * @public\n */\nexport function spread<T>(obj: T, explicit: string[] = explicitKeys): T {\n  if (obj && typeof obj === 'object') {\n    if (obj instanceof RegExp) return obj\n    if (obj instanceof Date) return obj\n    let spread: T\n    if (Array.isArray(obj)) {\n      spread = [...obj] as unknown as T\n    } else {\n      spread = { ...(obj as Record<PropertyKey, any>) } as T\n    }\n\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    return applyExplicit(\n      obj as Record<PropertyKey, any> | any[],\n      spread as Record<PropertyKey, any>,\n      explicit\n    ) as unknown as T\n  }\n  return obj\n}\n\n/**\n * Apply non enumerable properties to an object.\n *\n * @param original - Original object\n * @param obj - Objecto to aplly the values\n * @param explicit - Array of items to be explicity added.\n *\n * @returns `T`\n *\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction applyExplicit<T extends object | any[]>(\n  original: T,\n  obj: T,\n  explicit: string[]\n): T {\n  for (const key of explicit) {\n    if (key in original) {\n      Object.defineProperty(obj, key, {\n        enumerable: false,\n        value: original[key as keyof T],\n      })\n    }\n  }\n  return obj\n}\n\n/**\n * Uses a global mutation observer to wait for a given element to appear in the\n * DOM.\n * @param childId - The id of the child node.\n * @param callback - The callback to call when the child node is found.\n *\n * @public\n */\nexport function whenAvailable(\n  childId: string,\n  callback: (el: Element) => void,\n  root?: Document | ShadowRoot\n): void {\n  if (!isBrowser) return\n  if (!root) root = document\n  const el = root.getElementById(childId)\n  if (el) return callback(el)\n  const observer = new MutationObserver(() => {\n    const el = root?.getElementById(childId)\n    if (el) {\n      observer?.disconnect()\n      callback(el)\n    }\n  })\n  observer.observe(root, { childList: true, subtree: true })\n}\n\n/**\n * Given a function only 1 call will be made per call stack. All others will\n * be discarded.\n * @param fn - The function to be called once per tick.\n * @returns\n * @public\n */\nexport function oncePerTick<T extends CallableFunction>(fn: T): T {\n  let called = false\n  return ((...args: any[]) => {\n    if (called) return\n    called = true\n    queueMicrotask(() => (called = false))\n    return fn(...args)\n  }) as unknown as T\n}\n\n/**\n * Converts any value to a boolean value — but assumes that the default is true.\n * This is used on naked attributes like `disabled` or `required`.\n * @param value - The value to be converted to a boolean.\n * @public\n */\nexport function boolGetter(value: unknown): true | undefined {\n  if (value === 'false' || value === false) return undefined\n  return true\n}\n"]}