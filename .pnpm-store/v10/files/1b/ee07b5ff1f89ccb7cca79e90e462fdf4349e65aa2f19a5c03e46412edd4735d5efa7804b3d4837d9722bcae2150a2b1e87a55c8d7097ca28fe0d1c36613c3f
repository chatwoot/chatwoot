{"version":3,"file":"page.js","sourceRoot":"","sources":["../lib/page.js"],"names":[],"mappings":"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","sourcesContent":["\"use strict\";\n\nimport inherit from \"inherits\";\nimport { Facade } from \"./facade\";\nimport { Track } from \"./track\";\nimport isEmail from \"./is-email\";\n\n/**\n * Initialize a new `Page` facade with a `dictionary` of arguments.\n *\n * @param {Object} dictionary - The object to wrap.\n * @param {string} [dictionary.category] - The page category.\n * @param {string} [dictionary.name] - The page name.\n * @param {string} [dictionary.properties] - The page properties.\n * @param {Object} opts - Options about what kind of Facade to create.\n *\n * @augments Facade\n */\nexport function Page(dictionary, opts) {\n  Facade.call(this, dictionary, opts);\n}\n\ninherit(Page, Facade);\n\nconst p = Page.prototype;\n\n/**\n * Return the type of facade this is. This will always return `\"page\"`.\n *\n * @return {string}\n */\np.action = function () {\n  return \"page\";\n};\n\n/**\n * An alias for {@link Page#action}.\n *\n * @function\n * @return {string}\n */\np.type = p.action;\n\n/**\n * Get the page category from `category`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @return {string}\n */\np.category = Facade.field(\"category\");\n\n/**\n * Get the page name from `name`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @return {string}\n */\np.name = Facade.field(\"name\");\n\n/**\n * Get the page title from `properties.title`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @return {string}\n */\np.title = Facade.proxy(\"properties.title\");\n\n/**\n * Get the page path from `properties.path`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @return {string}\n */\np.path = Facade.proxy(\"properties.path\");\n\n/**\n * Get the page URL from `properties.url`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @return {string}\n */\np.url = Facade.proxy(\"properties.url\");\n\n/**\n * Get the HTTP referrer from `context.referrer.url`, `context.page.referrer`,\n * or `properties.referrer`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @return {string}\n */\np.referrer = function () {\n  return (\n    this.proxy(\"context.referrer.url\") ||\n    this.proxy(\"context.page.referrer\") ||\n    this.proxy(\"properties.referrer\")\n  );\n};\n\n/**\n * Get the page's properties. This is identical to how {@link Facade#traits}\n * works, except it looks at `properties.*` instead of `options.traits.*`.\n *\n * Properties are gotten from `properties`, augmented with the page's `name`\n * and `category`.\n *\n * The parameter `aliases` is meant to transform keys in `properties` into new\n * keys. Each alias like `{ \"xxx\": \"yyy\" }` will take whatever is at `xxx` in\n * the traits, and move it to `yyy`. If `xxx` is a method of this facade, it'll\n * be called as a function instead of treated as a key into the traits.\n *\n * @example\n * let obj = { properties: { foo: \"bar\" }, anonymousId: \"xxx\" }\n * let page = new Page(obj)\n *\n * page.traits() // { \"foo\": \"bar\" }\n * page.traits({ \"foo\": \"asdf\" }) // { \"asdf\": \"bar\" }\n * page.traits({ \"sessionId\": \"rofl\" }) // { \"rofl\": \"xxx\" }\n *\n * @param {Object} aliases - A mapping from keys to the new keys they should be\n * transformed to.\n * @return {Object}\n */\np.properties = function (aliases) {\n  let props = this.field(\"properties\") || {};\n  let category = this.category();\n  let name = this.name();\n  aliases = aliases || {};\n\n  if (category) props.category = category;\n  if (name) props.name = name;\n\n  for (const alias in aliases) {\n    if (Object.prototype.hasOwnProperty.call(aliases, alias)) {\n      const value = this[alias] == null\n        ? this.proxy(\"properties.\" + alias)\n        : this[alias]();\n      if (value == null) continue;\n      props[aliases[alias]] = value;\n      if (alias !== aliases[alias]) delete props[alias];\n    }\n  }\n\n  return props;\n};\n\n/**\n * Get the user's email from `context.traits.email` or `properties.email`,\n * falling back to `userId` if it's a valid email.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @return {string}\n */\np.email = function () {\n  let email =\n    this.proxy(\"context.traits.email\") || this.proxy(\"properties.email\");\n  if (email) return email;\n\n  let userId = this.userId();\n  if (isEmail(userId)) return userId;\n};\n\n/**\n * Get the page fullName. This is `$category $name` if both are present, and\n * just `name` otherwiser.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @return {string}\n */\np.fullName = function () {\n  let category = this.category();\n  let name = this.name();\n  return name && category ? category + \" \" + name : name;\n};\n\n/**\n * Get an event name from this page call. If `name` is present, this will be\n * `Viewed $name Page`; otherwise, it will be `Loaded a Page`.\n *\n * @param {string} name - The name of this page.\n * @return {string}\n */\np.event = function (name) {\n  return name ? \"Viewed \" + name + \" Page\" : \"Loaded a Page\";\n};\n\n/**\n * Convert this Page to a {@link Track} facade. The inputted `name` will be\n * converted to the Track's event name via {@link Page#event}.\n *\n * @param {string} name\n * @return {Track}\n */\np.track = function (name) {\n  let json = this.json();\n  json.event = this.event(name);\n  json.timestamp = this.timestamp();\n  json.properties = this.properties();\n  return new Track(json, this.opts);\n};\n"]}