{"version":3,"file":"index.js","sourceRoot":"","sources":["src/index.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport {ElementInternalsShim} from './lib/element-internals.js';\n\nexport {\n  ariaMixinAttributes,\n  ElementInternals,\n  HYDRATE_INTERNALS_ATTR_PREFIX,\n} from './lib/element-internals.js';\n\nconst attributes: WeakMap<\n  InstanceType<typeof HTMLElementShim>,\n  Map<string, string>\n> = new WeakMap();\nconst attributesForElement = (\n  element: InstanceType<typeof HTMLElementShim>\n) => {\n  let attrs = attributes.get(element);\n  if (attrs === undefined) {\n    attributes.set(element, (attrs = new Map()));\n  }\n  return attrs;\n};\n\n// The typings around the exports below are a little funky:\n//\n// 1. We want the `name` of the shim classes to match the real ones at runtime,\n//    hence e.g. `class Element`.\n// 2. We can't shadow the global types with a simple class declaration, because\n//    then we can't reference the global types for casting, hence e.g.\n//    `const ElementShim = class Element`.\n// 3. We want to export the classes typed as the real ones, hence e.g.\n//    `const ElementShimWithRealType = ElementShim as object as typeof Element;`.\n// 4. We want the exported names to match the real ones, hence e.g.\n//    `export {ElementShimWithRealType as Element}`.\nconst ElementShim = class Element {\n  get attributes() {\n    return Array.from(attributesForElement(this)).map(([name, value]) => ({\n      name,\n      value,\n    }));\n  }\n  private __shadowRootMode: null | ShadowRootMode = null;\n  protected __shadowRoot: null | ShadowRoot = null;\n  protected __internals: null | ElementInternals = null;\n\n  get shadowRoot() {\n    if (this.__shadowRootMode === 'closed') {\n      return null;\n    }\n    return this.__shadowRoot;\n  }\n  setAttribute(name: string, value: unknown): void {\n    // Emulate browser behavior that silently casts all values to string. E.g.\n    // `42` becomes `\"42\"` and `{}` becomes `\"[object Object]\"\"`.\n    attributesForElement(this).set(name, String(value));\n  }\n  removeAttribute(name: string) {\n    attributesForElement(this).delete(name);\n  }\n  hasAttribute(name: string) {\n    return attributesForElement(this).has(name);\n  }\n  attachShadow(init: ShadowRootInit): ShadowRoot {\n    const shadowRoot = {host: this} as object as ShadowRoot;\n    this.__shadowRootMode = init.mode;\n    if (init && init.mode === 'open') {\n      this.__shadowRoot = shadowRoot;\n    }\n    return shadowRoot;\n  }\n  attachInternals(): ElementInternals {\n    if (this.__internals !== null) {\n      throw new Error(\n        `Failed to execute 'attachInternals' on 'HTMLElement': ` +\n          `ElementInternals for the specified element was already attached.`\n      );\n    }\n    const internals = new ElementInternalsShim(this as unknown as HTMLElement);\n    this.__internals = internals;\n    return internals as ElementInternals;\n  }\n  getAttribute(name: string) {\n    const value = attributesForElement(this).get(name);\n    return value ?? null;\n  }\n};\nconst ElementShimWithRealType = ElementShim as object as typeof Element;\nexport {ElementShimWithRealType as Element};\n\nconst HTMLElementShim = class HTMLElement extends ElementShim {};\nconst HTMLElementShimWithRealType =\n  HTMLElementShim as object as typeof HTMLElement;\nexport {HTMLElementShimWithRealType as HTMLElement};\n\ninterface CustomHTMLElementConstructor {\n  new (): HTMLElement;\n  observedAttributes?: string[];\n}\n\ntype CustomElementRegistration = {\n  ctor: {new (): HTMLElement};\n  observedAttributes: string[];\n};\n\nconst CustomElementRegistryShim = class CustomElementRegistry {\n  private __definitions = new Map<string, CustomElementRegistration>();\n\n  define(name: string, ctor: CustomHTMLElementConstructor) {\n    if (this.__definitions.has(name)) {\n      if (process.env.NODE_ENV === 'development') {\n        console.warn(\n          `'CustomElementRegistry' already has \"${name}\" defined. ` +\n            `This may have been caused by live reload or hot module ` +\n            `replacement in which case it can be safely ignored.\\n` +\n            `Make sure to test your application with a production build as ` +\n            `repeat registrations will throw in production.`\n        );\n      } else {\n        throw new Error(\n          `Failed to execute 'define' on 'CustomElementRegistry': ` +\n            `the name \"${name}\" has already been used with this registry`\n        );\n      }\n    }\n    this.__definitions.set(name, {\n      ctor,\n      // Note it's important we read `observedAttributes` in case it is a getter\n      // with side-effects, as is the case in Lit, where it triggers class\n      // finalization.\n      //\n      // TODO(aomarks) To be spec compliant, we should also capture the\n      // registration-time lifecycle methods like `connectedCallback`. For them\n      // to be actually accessible to e.g. the Lit SSR element renderer, though,\n      // we'd need to introduce a new API for accessing them (since `get` only\n      // returns the constructor).\n      observedAttributes: ctor.observedAttributes ?? [],\n    });\n  }\n\n  get(name: string) {\n    const definition = this.__definitions.get(name);\n    return definition?.ctor;\n  }\n};\nconst CustomElementRegistryShimWithRealType =\n  CustomElementRegistryShim as object as typeof CustomElementRegistry;\nexport {CustomElementRegistryShimWithRealType as CustomElementRegistry};\n\nexport const customElements = new CustomElementRegistryShimWithRealType();\n"]}