{"version":3,"file":"facade.js","sourceRoot":"","sources":["../lib/facade.js"],"names":[],"mappings":"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","sourcesContent":["\"use strict\";\n\nimport address from \"./address\";\nimport { clone } from \"./clone\";\nimport isEnabled from \"./is-enabled\";\nimport newDate from \"new-date\";\nimport objCase from \"obj-case\";\nimport traverse from \"@segment/isodate-traverse\";\n\n/**\n * A *Facade* is an object meant for creating convience wrappers around\n * objects. When developing integrations, you probably want to look at its\n * subclasses, such as {@link Track} or {@link Identify}, rather than this\n * general-purpose class.\n *\n * This letructor will initialize a new `Facade` with an `obj` of arguments.\n *\n * If the inputted `obj` doesn't have a `timestamp` property, one will be added\n * with the value `new Date()`. Otherwise, the `timestamp` property will be\n * converted to a Date using the `new-date` package.\n *\n * By default, the inputted object will be defensively copied, and all ISO\n * strings present in the string will be converted into Dates.\n *\n * @param {Object} obj - The object to wrap.\n * @param {Object} opts - Options about what kind of Facade to create.\n * @param {boolean} [opts.clone=true] - Whether to make defensive clones. If enabled,\n * the inputted object will be cloned, and any objects derived from this facade\n * will be cloned before being returned.\n * @param {boolean} [opts.traverse=true] - Whether to perform ISODate-Traverse\n * on the inputted object.\n *\n * @see {@link https://github.com/segmentio/new-date|new-date}\n * @see {@link https://github.com/segmentio/isodate-traverse|isodate-traverse}\n */\nexport function Facade (obj, opts) {\n  opts = opts || {};\n  this.raw = clone(obj);\n  if (!(\"clone\" in opts)) opts.clone = true;\n  if (opts.clone) obj = clone(obj);\n  if (!(\"traverse\" in opts)) opts.traverse = true;\n  if (!(\"timestamp\" in obj)) obj.timestamp = new Date();\n  else obj.timestamp = newDate(obj.timestamp);\n  if (opts.traverse) traverse(obj);\n  this.opts = opts;\n  this.obj = obj;\n}\n\nconst f = Facade.prototype;\n\n/**\n * Get a potentially-nested field in this facade. `field` should be a\n * period-separated sequence of properties.\n *\n * If the first field passed in points to a function (e.g. the `field` passed\n * in is `a.b.c` and this facade's `obj.a` is a function), then that function\n * will be called, and then the deeper fields will be fetched (using obj-case)\n * from what that function returns. If the first field isn't a function, then\n * this function works just like obj-case.\n *\n * Because this function uses obj-case, the camel- or snake-case of the input\n * is irrelevant.\n *\n * @example\n * YourClass.prototype.height = function() {\n *   return this.proxy('getDimensions.height') ||\n *     this.proxy('props.size.side_length');\n * }\n * @param {string} field - A sequence of properties, joined by periods (`.`).\n * @return {*} - A property of the inputted object.\n * @see {@link https://github.com/segmentio/obj-case|obj-case}\n */\nf.proxy = function(field) {\n  let fields = field.split(\".\");\n  field = fields.shift();\n\n  // Call a function at the beginning to take advantage of facaded fields\n  let obj = this[field] || this.obj[field];\n  if (!obj) return obj;\n  if (typeof obj === \"function\") obj = obj.call(this) || {};\n  if (fields.length === 0) return this.opts.clone ? transform(obj) : obj;\n\n  obj = objCase(obj, fields.join(\".\"));\n  return this.opts.clone ? transform(obj) : obj;\n};\n\n/**\n * Directly access a specific `field` from the underlying object. Only\n * \"top-level\" fields will work with this function. \"Nested\" fields *will not\n * work* with this function.\n *\n * @param {string} field\n * @return {*}\n */\nf.field = function(field) {\n  let obj = this.obj[field];\n  return this.opts.clone ? transform(obj) : obj;\n};\n\n/**\n * Utility method to always proxy a particular `field`. In other words, it\n * returns a function that will always return `this.proxy(field)`.\n *\n * @example\n * MyClass.prototype.height = Facade.proxy('options.dimensions.height');\n *\n * @param {string} field\n * @return {Function}\n */\nFacade.proxy = function(field) {\n  return function() {\n    return this.proxy(field);\n  };\n};\n\n/**\n * Utility method to always access a `field`. In other words, it returns a\n * function that will always return `this.field(field)`.\n *\n * @param {string} field\n * @return {Function}\n */\nFacade.field = function(field) {\n  return function() {\n    return this.field(field);\n  };\n};\n\n/**\n * Create a helper function for fetching a \"plural\" thing.\n *\n * The generated method will take the inputted `path` and append an \"s\" to it\n * and calls `this.proxy` with this \"pluralized\" path. If that produces an\n * array, that will be returned. Otherwise, a one-element array containing\n * `this.proxy(path)` will be returned.\n *\n * @example\n * MyClass.prototype.birds = Facade.multi('animals.bird');\n *\n * @param {string} path\n * @return {Function}\n */\nFacade.multi = function(path) {\n  return function() {\n    let multi = this.proxy(path + \"s\");\n    if (Array.isArray(multi)) return multi;\n    let one = this.proxy(path);\n    if (one) one = [this.opts.clone ? clone(one) : one];\n    return one || [];\n  };\n};\n\n/**\n * Create a helper function for getting a \"singular\" thing.\n *\n * The generated method will take the inputted path and call\n * `this.proxy(path)`. If a truthy thing is produced, it will be returned.\n * Otherwise, `this.proxy(path + 's')` will be called, and if that produces an\n * array the first element of that array will be returned. Otherwise,\n * `undefined` is returned.\n *\n * @example\n * MyClass.prototype.bird = Facade.one('animals.bird');\n *\n * @param {string} path\n * @return {Function}\n */\nFacade.one = function(path) {\n  return function() {\n    let one = this.proxy(path);\n    if (one) return one;\n    let multi = this.proxy(path + \"s\");\n    if (Array.isArray(multi)) return multi[0];\n  };\n};\n\n/**\n * Gets the underlying object this facade wraps around.\n *\n * If this facade has a property `type`, it will be invoked as a function and\n * will be assigned as the property `type` of the outputted object.\n *\n * @return {Object}\n */\nf.json = function() {\n  let ret = this.opts.clone ? clone(this.obj) : this.obj;\n  if (this.type) ret.type = this.type();\n  return ret;\n};\n\n/**\n * Gets a copy of the unmodified input object this facade wraps around.\n * \n * Unlike the `json` method which does make some subtle modifications \n * to datetime values and the `type` property. This method returns a copy of \n * the unmodified input object\n * \n * @return {Object}\n */\nf.rawEvent = function() {\n  return this.raw;\n};\n\n/**\n * Get the options of a call. If an integration is passed, only the options for\n * that integration are included. If the integration is not enabled, then\n * `undefined` is returned.\n *\n * Options are taken from the `options` property of the underlying object,\n * falling back to the object's `context` or simply `{}`.\n *\n * @param {string} integration - The name of the integration to get settings\n * for. Casing does not matter.\n * @return {Object|undefined}\n */\nf.options = function(integration) {\n  let obj = this.obj.options || this.obj.context || {};\n  let options = this.opts.clone ? clone(obj) : obj;\n  if (!integration) return options;\n  if (!this.enabled(integration)) return;\n  let integrations = this.integrations();\n  let value = integrations[integration] || objCase(integrations, integration);\n  if (typeof value !== \"object\") value = objCase(this.options(), integration);\n  return typeof value === \"object\" ? value : {};\n};\n\n/**\n * An alias for {@link Facade#options}.\n */\nf.context = f.options;\n\n/**\n * Check whether an integration is enabled.\n *\n * Basically, this method checks whether this integration is explicitly\n * enabled. If it isn'texplicitly mentioned, it checks whether it has been\n * enabled at the global level. Some integrations (e.g. Salesforce), cannot\n * enabled by these global event settings.\n *\n * More concretely, the deciding factors here are:\n *\n * 1. If `this.integrations()` has the integration set to `true`, return `true`.\n * 2. If `this.integrations().providers` has the integration set to `true`, return `true`.\n * 3. If integrations are set to default-disabled via global parameters (i.e.\n * `options.providers.all`, `options.all`, or `integrations.all`), then return\n * false.\n * 4. If the integration is one of the special default-deny integrations\n * (currently, only Salesforce), then return false.\n * 5. Else, return true.\n *\n * @param {string} integration\n * @return {boolean}\n */\nf.enabled = function(integration) {\n  let allEnabled = this.proxy(\"options.providers.all\");\n  if (typeof allEnabled !== \"boolean\") allEnabled = this.proxy(\"options.all\");\n  if (typeof allEnabled !== \"boolean\")\n    allEnabled = this.proxy(\"integrations.all\");\n  if (typeof allEnabled !== \"boolean\") allEnabled = true;\n\n  let enabled = allEnabled && isEnabled(integration);\n  let options = this.integrations();\n\n  // If the integration is explicitly enabled or disabled, use that\n  // First, check options.providers for backwards compatibility\n  if (options.providers && options.providers.hasOwnProperty(integration)) {\n    enabled = options.providers[integration];\n  }\n\n  // Next, check for the integration's existence in 'options' to enable it.\n  // If the settings are a boolean, use that, otherwise it should be enabled.\n  if (options.hasOwnProperty(integration)) {\n    let settings = options[integration];\n    if (typeof settings === \"boolean\") {\n      enabled = settings;\n    } else {\n      enabled = true;\n    }\n  }\n\n  return !!enabled;\n};\n\n/**\n * Get all `integration` options.\n *\n * @ignore\n * @param {string} integration\n * @return {Object}\n */\nf.integrations = function() {\n  return (\n    this.obj.integrations || this.proxy(\"options.providers\") || this.options()\n  );\n};\n\n/**\n * Check whether the user is active.\n *\n * @return {boolean}\n */\nf.active = function() {\n  let active = this.proxy(\"options.active\");\n  if (active === null || active === undefined) active = true;\n  return active;\n};\n\n/**\n * Get `sessionId / anonymousId`.\n *\n * @return {*}\n */\nf.anonymousId = function() {\n  return this.field(\"anonymousId\") || this.field(\"sessionId\");\n};\n\n/**\n * An alias for {@link Facade#anonymousId}.\n *\n * @function\n * @return {string}\n */\nf.sessionId = f.anonymousId;\n\n/**\n * Get `groupId` from `context.groupId`.\n *\n * @function\n * @return {string}\n */\nf.groupId = Facade.proxy(\"options.groupId\");\n\n/**\n * Get the call's \"traits\". All event types can pass in traits, though {@link\n * Identify} and {@link Group} override this implementation.\n *\n * Traits are gotten from `options.traits`, augmented with a property `id` with\n * the event's `userId`.\n *\n * The parameter `aliases` is meant to transform keys in `options.traits` into\n * new keys. Each alias like `{ \"xxx\": \"yyy\" }` will take whatever is at `xxx`\n * in the traits, and move it to `yyy`. If `xxx` is a method of this facade,\n * it'll be called as a function instead of treated as a key into the traits.\n *\n * @example\n * let obj = { options: { traits: { foo: \"bar\" } }, anonymousId: \"xxx\" }\n * let facade = new Facade(obj)\n *\n * facade.traits() // { \"foo\": \"bar\" }\n * facade.traits({ \"foo\": \"asdf\" }) // { \"asdf\": \"bar\" }\n * facade.traits({ \"sessionId\": \"rofl\" }) // { \"rofl\": \"xxx\" }\n *\n * @param {Object} aliases - A mapping from keys to the new keys they should be\n * transformed to.\n * @return {Object}\n */\nf.traits = function(aliases) {\n  let ret = this.proxy(\"options.traits\") || {};\n  let id = this.userId();\n  aliases = aliases || {};\n\n  if (id) ret.id = id;\n\n  for (const alias in aliases) {\n    if (Object.prototype.hasOwnProperty.call(aliases, alias)) {\n      const value = this[alias] == null\n        ? this.proxy(\"options.traits.\" + alias)\n        : this[alias]();\n      if (value == null) continue;\n      ret[aliases[alias]] = value;\n      delete ret[alias];\n    }\n  }\n\n  return ret;\n};\n\n/**\n * The library and version of the client used to produce the message.\n *\n * If the library name cannot be determined, it is set to `\"unknown\"`. If the\n * version cannot be determined, it is set to `null`.\n *\n * @return {{name: string, version: string}}\n */\nf.library = function() {\n  let library = this.proxy(\"options.library\");\n  if (!library) return { name: \"unknown\", version: null };\n  if (typeof library === \"string\") return { name: library, version: null };\n  return library;\n};\n\n/**\n * Return the device information, falling back to an empty object.\n *\n * Interesting values of `type` are `\"ios\"` and `\"android\"`, but other values\n * are possible if the client is doing something unusual with `context.device`.\n *\n * @return {{type: string}}\n */\nf.device = function() {\n  let device = this.proxy(\"context.device\");\n  if (typeof device !== \"object\" || device === null) {\n    device = {};\n  }\n  let library = this.library().name;\n  if (device.type) return device;\n\n  if (library.indexOf(\"ios\") > -1) device.type = \"ios\";\n  if (library.indexOf(\"android\") > -1) device.type = \"android\";\n  return device;\n};\n\n/**\n * Get the User-Agent from `context.userAgent`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @function\n * @return string\n */\nf.userAgent = Facade.proxy(\"context.userAgent\");\n\n/**\n * Get the timezone from `context.timezone`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @function\n * @return string\n */\nf.timezone = Facade.proxy(\"context.timezone\");\n\n/**\n * Get the timestamp from `context.timestamp`.\n *\n * @function\n * @return string\n */\nf.timestamp = Facade.field(\"timestamp\");\n\n/**\n * Get the channel from `channel`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @function\n * @return string\n */\nf.channel = Facade.field(\"channel\");\n\n/**\n * Get the IP address from `context.ip`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @function\n * @return string\n */\nf.ip = Facade.proxy(\"context.ip\");\n\n/**\n * Get the user ID from `userId`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @function\n * @return string\n */\nf.userId = Facade.field(\"userId\");\n\n/**\n * Get the ZIP/Postal code from `traits`, `traits.address`, `properties`, or\n * `properties.address`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @name zip\n * @function\n * @memberof f\n * @return {string}\n */\n\n/**\n * Get the country from `traits`, `traits.address`, `properties`, or\n * `properties.address`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @name country\n * @function\n * @memberof f\n * @return {string}\n */\n\n/**\n * Get the street from `traits`, `traits.address`, `properties`, or\n * `properties.address`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @name street\n * @function\n * @memberof f\n * @return {string}\n */\n\n/**\n * Get the state from `traits`, `traits.address`, `properties`, or\n * `properties.address`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @name state\n * @function\n * @memberof f\n * @return {string}\n */\n\n/**\n * Get the city from `traits`, `traits.address`, `properties`, or\n * `properties.address`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @name city\n * @function\n * @memberof f\n * @return {string}\n */\n\n/**\n * Get the region from `traits`, `traits.address`, `properties`, or\n * `properties.address`.\n *\n * This *should* be a string, but may not be if the client isn't adhering to\n * the spec.\n *\n * @name region\n * @function\n * @memberof f\n * @return {string}\n */\n\naddress(f);\n\n/**\n * Return the cloned and traversed object\n *\n * @ignore\n * @param {*} obj\n * @return {*}\n */\nfunction transform (obj) {\n  return clone(obj);\n}\n"]}