{"version":3,"file":"request.js","sources":["../../../../src/tracing/request.ts"],"sourcesContent":["import {\n  SENTRY_XHR_DATA_KEY,\n  addPerformanceInstrumentationHandler,\n  addXhrInstrumentationHandler,\n} from '@sentry-internal/browser-utils';\nimport {\n  SEMANTIC_ATTRIBUTE_SENTRY_OP,\n  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,\n  SentryNonRecordingSpan,\n  getActiveSpan,\n  getClient,\n  getCurrentScope,\n  getDynamicSamplingContextFromClient,\n  getDynamicSamplingContextFromSpan,\n  getIsolationScope,\n  hasTracingEnabled,\n  instrumentFetchRequest,\n  setHttpStatus,\n  spanToJSON,\n  spanToTraceHeader,\n  startInactiveSpan,\n} from '@sentry/core';\nimport type { Client, HandlerDataXhr, SentryWrappedXMLHttpRequest, Span } from '@sentry/types';\nimport {\n  BAGGAGE_HEADER_NAME,\n  addFetchEndInstrumentationHandler,\n  addFetchInstrumentationHandler,\n  browserPerformanceTimeOrigin,\n  dynamicSamplingContextToSentryBaggageHeader,\n  generateSentryTraceHeader,\n  parseUrl,\n  stringMatchesSomePattern,\n} from '@sentry/utils';\nimport { WINDOW } from '../helpers';\n\n/** Options for Request Instrumentation */\nexport interface RequestInstrumentationOptions {\n  /**\n   * List of strings and/or Regular Expressions used to determine which outgoing requests will have `sentry-trace` and `baggage`\n   * headers attached.\n   *\n   * **Default:** If this option is not provided, tracing headers will be attached to all outgoing requests.\n   * If you are using a browser SDK, by default, tracing headers will only be attached to outgoing requests to the same origin.\n   *\n   * **Disclaimer:** Carelessly setting this option in browser environments may result into CORS errors!\n   * Only attach tracing headers to requests to the same origin, or to requests to services you can control CORS headers of.\n   * Cross-origin requests, meaning requests to a different domain, for example a request to `https://api.example.com/` while you're on `https://example.com/`, take special care.\n   * If you are attaching headers to cross-origin requests, make sure the backend handling the request returns a `\"Access-Control-Allow-Headers: sentry-trace, baggage\"` header to ensure your requests aren't blocked.\n   *\n   * If you provide a `tracePropagationTargets` array, the entries you provide will be matched against the entire URL of the outgoing request.\n   * If you are using a browser SDK, the entries will also be matched against the pathname of the outgoing requests.\n   * This is so you can have matchers for relative requests, for example, `/^\\/api/` if you want to trace requests to your `/api` routes on the same domain.\n   *\n   * If any of the two match any of the provided values, tracing headers will be attached to the outgoing request.\n   * Both, the string values, and the RegExes you provide in the array will match if they partially match the URL or pathname.\n   *\n   * Examples:\n   * - `tracePropagationTargets: [/^\\/api/]` and request to `https://same-origin.com/api/posts`:\n   *   - Tracing headers will be attached because the request is sent to the same origin and the regex matches the pathname \"/api/posts\".\n   * - `tracePropagationTargets: [/^\\/api/]` and request to `https://different-origin.com/api/posts`:\n   *   - Tracing headers will not be attached because the pathname will only be compared when the request target lives on the same origin.\n   * - `tracePropagationTargets: [/^\\/api/, 'https://external-api.com']` and request to `https://external-api.com/v1/data`:\n   *   - Tracing headers will be attached because the request URL matches the string `'https://external-api.com'`.\n   */\n  tracePropagationTargets?: Array<string | RegExp>;\n\n  /**\n   * Flag to disable patching all together for fetch requests.\n   *\n   * Default: true\n   */\n  traceFetch: boolean;\n\n  /**\n   * Flag to disable patching all together for xhr requests.\n   *\n   * Default: true\n   */\n  traceXHR: boolean;\n\n  /**\n   * If true, Sentry will capture http timings and add them to the corresponding http spans.\n   *\n   * Default: true\n   */\n  enableHTTPTimings: boolean;\n\n  /**\n   * This function will be called before creating a span for a request with the given url.\n   * Return false if you don't want a span for the given url.\n   *\n   * Default: (url: string) => true\n   */\n  shouldCreateSpanForRequest?(this: void, url: string): boolean;\n}\n\nconst responseToSpanId = new WeakMap<object, string>();\nconst spanIdToEndTimestamp = new Map<string, number>();\n\nexport const defaultRequestInstrumentationOptions: RequestInstrumentationOptions = {\n  traceFetch: true,\n  traceXHR: true,\n  enableHTTPTimings: true,\n};\n\n/** Registers span creators for xhr and fetch requests  */\nexport function instrumentOutgoingRequests(client: Client, _options?: Partial<RequestInstrumentationOptions>): void {\n  const { traceFetch, traceXHR, shouldCreateSpanForRequest, enableHTTPTimings, tracePropagationTargets } = {\n    traceFetch: defaultRequestInstrumentationOptions.traceFetch,\n    traceXHR: defaultRequestInstrumentationOptions.traceXHR,\n    ..._options,\n  };\n\n  const shouldCreateSpan =\n    typeof shouldCreateSpanForRequest === 'function' ? shouldCreateSpanForRequest : (_: string) => true;\n\n  const shouldAttachHeadersWithTargets = (url: string): boolean => shouldAttachHeaders(url, tracePropagationTargets);\n\n  const spans: Record<string, Span> = {};\n\n  if (traceFetch) {\n    // Keeping track of http requests, whose body payloads resolved later than the intial resolved request\n    // e.g. streaming using server sent events (SSE)\n    client.addEventProcessor(event => {\n      if (event.type === 'transaction' && event.spans) {\n        event.spans.forEach(span => {\n          if (span.op === 'http.client') {\n            const updatedTimestamp = spanIdToEndTimestamp.get(span.span_id);\n            if (updatedTimestamp) {\n              span.timestamp = updatedTimestamp / 1000;\n              spanIdToEndTimestamp.delete(span.span_id);\n            }\n          }\n        });\n      }\n      return event;\n    });\n\n    addFetchEndInstrumentationHandler(handlerData => {\n      if (handlerData.response) {\n        const span = responseToSpanId.get(handlerData.response);\n        if (span && handlerData.endTimestamp) {\n          spanIdToEndTimestamp.set(span, handlerData.endTimestamp);\n        }\n      }\n    });\n\n    addFetchInstrumentationHandler(handlerData => {\n      const createdSpan = instrumentFetchRequest(handlerData, shouldCreateSpan, shouldAttachHeadersWithTargets, spans);\n\n      if (handlerData.response && handlerData.fetchData.__span) {\n        responseToSpanId.set(handlerData.response, handlerData.fetchData.__span);\n      }\n\n      // We cannot use `window.location` in the generic fetch instrumentation,\n      // but we need it for reliable `server.address` attribute.\n      // so we extend this in here\n      if (createdSpan) {\n        const fullUrl = getFullURL(handlerData.fetchData.url);\n        const host = fullUrl ? parseUrl(fullUrl).host : undefined;\n        createdSpan.setAttributes({\n          'http.url': fullUrl,\n          'server.address': host,\n        });\n      }\n\n      if (enableHTTPTimings && createdSpan) {\n        addHTTPTimings(createdSpan);\n      }\n    });\n  }\n\n  if (traceXHR) {\n    addXhrInstrumentationHandler(handlerData => {\n      const createdSpan = xhrCallback(handlerData, shouldCreateSpan, shouldAttachHeadersWithTargets, spans);\n      if (enableHTTPTimings && createdSpan) {\n        addHTTPTimings(createdSpan);\n      }\n    });\n  }\n}\n\nfunction isPerformanceResourceTiming(entry: PerformanceEntry): entry is PerformanceResourceTiming {\n  return (\n    entry.entryType === 'resource' &&\n    'initiatorType' in entry &&\n    typeof (entry as PerformanceResourceTiming).nextHopProtocol === 'string' &&\n    (entry.initiatorType === 'fetch' || entry.initiatorType === 'xmlhttprequest')\n  );\n}\n\n/**\n * Creates a temporary observer to listen to the next fetch/xhr resourcing timings,\n * so that when timings hit their per-browser limit they don't need to be removed.\n *\n * @param span A span that has yet to be finished, must contain `url` on data.\n */\nfunction addHTTPTimings(span: Span): void {\n  const { url } = spanToJSON(span).data || {};\n\n  if (!url || typeof url !== 'string') {\n    return;\n  }\n\n  const cleanup = addPerformanceInstrumentationHandler('resource', ({ entries }) => {\n    entries.forEach(entry => {\n      if (isPerformanceResourceTiming(entry) && entry.name.endsWith(url)) {\n        const spanData = resourceTimingEntryToSpanData(entry);\n        spanData.forEach(data => span.setAttribute(...data));\n        // In the next tick, clean this handler up\n        // We have to wait here because otherwise this cleans itself up before it is fully done\n        setTimeout(cleanup);\n      }\n    });\n  });\n}\n\n/**\n * Converts ALPN protocol ids to name and version.\n *\n * (https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids)\n * @param nextHopProtocol PerformanceResourceTiming.nextHopProtocol\n */\nexport function extractNetworkProtocol(nextHopProtocol: string): { name: string; version: string } {\n  let name = 'unknown';\n  let version = 'unknown';\n  let _name = '';\n  for (const char of nextHopProtocol) {\n    // http/1.1 etc.\n    if (char === '/') {\n      [name, version] = nextHopProtocol.split('/') as [string, string];\n      break;\n    }\n    // h2, h3 etc.\n    if (!isNaN(Number(char))) {\n      name = _name === 'h' ? 'http' : _name;\n      version = nextHopProtocol.split(_name)[1] as string;\n      break;\n    }\n    _name += char;\n  }\n  if (_name === nextHopProtocol) {\n    // webrtc, ftp, etc.\n    name = _name;\n  }\n  return { name, version };\n}\n\nfunction getAbsoluteTime(time: number = 0): number {\n  return ((browserPerformanceTimeOrigin || performance.timeOrigin) + time) / 1000;\n}\n\nfunction resourceTimingEntryToSpanData(resourceTiming: PerformanceResourceTiming): [string, string | number][] {\n  const { name, version } = extractNetworkProtocol(resourceTiming.nextHopProtocol);\n\n  const timingSpanData: [string, string | number][] = [];\n\n  timingSpanData.push(['network.protocol.version', version], ['network.protocol.name', name]);\n\n  if (!browserPerformanceTimeOrigin) {\n    return timingSpanData;\n  }\n  return [\n    ...timingSpanData,\n    ['http.request.redirect_start', getAbsoluteTime(resourceTiming.redirectStart)],\n    ['http.request.fetch_start', getAbsoluteTime(resourceTiming.fetchStart)],\n    ['http.request.domain_lookup_start', getAbsoluteTime(resourceTiming.domainLookupStart)],\n    ['http.request.domain_lookup_end', getAbsoluteTime(resourceTiming.domainLookupEnd)],\n    ['http.request.connect_start', getAbsoluteTime(resourceTiming.connectStart)],\n    ['http.request.secure_connection_start', getAbsoluteTime(resourceTiming.secureConnectionStart)],\n    ['http.request.connection_end', getAbsoluteTime(resourceTiming.connectEnd)],\n    ['http.request.request_start', getAbsoluteTime(resourceTiming.requestStart)],\n    ['http.request.response_start', getAbsoluteTime(resourceTiming.responseStart)],\n    ['http.request.response_end', getAbsoluteTime(resourceTiming.responseEnd)],\n  ];\n}\n\n/**\n * A function that determines whether to attach tracing headers to a request.\n * We only export this function for testing purposes.\n */\nexport function shouldAttachHeaders(\n  targetUrl: string,\n  tracePropagationTargets: (string | RegExp)[] | undefined,\n): boolean {\n  // window.location.href not being defined is an edge case in the browser but we need to handle it.\n  // Potentially dangerous situations where it may not be defined: Browser Extensions, Web Workers, patching of the location obj\n  const href: string | undefined = WINDOW.location && WINDOW.location.href;\n\n  if (!href) {\n    // If there is no window.location.origin, we default to only attaching tracing headers to relative requests, i.e. ones that start with `/`\n    // BIG DISCLAIMER: Users can call URLs with a double slash (fetch(\"//example.com/api\")), this is a shorthand for \"send to the same protocol\",\n    // so we need a to exclude those requests, because they might be cross origin.\n    const isRelativeSameOriginRequest = !!targetUrl.match(/^\\/(?!\\/)/);\n    if (!tracePropagationTargets) {\n      return isRelativeSameOriginRequest;\n    } else {\n      return stringMatchesSomePattern(targetUrl, tracePropagationTargets);\n    }\n  } else {\n    let resolvedUrl;\n    let currentOrigin;\n\n    // URL parsing may fail, we default to not attaching trace headers in that case.\n    try {\n      resolvedUrl = new URL(targetUrl, href);\n      currentOrigin = new URL(href).origin;\n    } catch (e) {\n      return false;\n    }\n\n    const isSameOriginRequest = resolvedUrl.origin === currentOrigin;\n    if (!tracePropagationTargets) {\n      return isSameOriginRequest;\n    } else {\n      return (\n        stringMatchesSomePattern(resolvedUrl.toString(), tracePropagationTargets) ||\n        (isSameOriginRequest && stringMatchesSomePattern(resolvedUrl.pathname, tracePropagationTargets))\n      );\n    }\n  }\n}\n\n/**\n * Create and track xhr request spans\n *\n * @returns Span if a span was created, otherwise void.\n */\nexport function xhrCallback(\n  handlerData: HandlerDataXhr,\n  shouldCreateSpan: (url: string) => boolean,\n  shouldAttachHeaders: (url: string) => boolean,\n  spans: Record<string, Span>,\n): Span | undefined {\n  const xhr = handlerData.xhr;\n  const sentryXhrData = xhr && xhr[SENTRY_XHR_DATA_KEY];\n\n  if (!xhr || xhr.__sentry_own_request__ || !sentryXhrData) {\n    return undefined;\n  }\n\n  const shouldCreateSpanResult = hasTracingEnabled() && shouldCreateSpan(sentryXhrData.url);\n\n  // check first if the request has finished and is tracked by an existing span which should now end\n  if (handlerData.endTimestamp && shouldCreateSpanResult) {\n    const spanId = xhr.__sentry_xhr_span_id__;\n    if (!spanId) return;\n\n    const span = spans[spanId];\n    if (span && sentryXhrData.status_code !== undefined) {\n      setHttpStatus(span, sentryXhrData.status_code);\n      span.end();\n\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete spans[spanId];\n    }\n    return undefined;\n  }\n\n  const fullUrl = getFullURL(sentryXhrData.url);\n  const host = fullUrl ? parseUrl(fullUrl).host : undefined;\n\n  const hasParent = !!getActiveSpan();\n\n  const span =\n    shouldCreateSpanResult && hasParent\n      ? startInactiveSpan({\n          name: `${sentryXhrData.method} ${sentryXhrData.url}`,\n          attributes: {\n            type: 'xhr',\n            'http.method': sentryXhrData.method,\n            'http.url': fullUrl,\n            url: sentryXhrData.url,\n            'server.address': host,\n            [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.browser',\n            [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'http.client',\n          },\n        })\n      : new SentryNonRecordingSpan();\n\n  xhr.__sentry_xhr_span_id__ = span.spanContext().spanId;\n  spans[xhr.__sentry_xhr_span_id__] = span;\n\n  const client = getClient();\n\n  if (xhr.setRequestHeader && shouldAttachHeaders(sentryXhrData.url) && client) {\n    addTracingHeadersToXhrRequest(\n      xhr,\n      client,\n      // If performance is disabled (TWP) or there's no active root span (pageload/navigation/interaction),\n      // we do not want to use the span as base for the trace headers,\n      // which means that the headers will be generated from the scope and the sampling decision is deferred\n      hasTracingEnabled() && hasParent ? span : undefined,\n    );\n  }\n\n  return span;\n}\n\nfunction addTracingHeadersToXhrRequest(xhr: SentryWrappedXMLHttpRequest, client: Client, span?: Span): void {\n  const scope = getCurrentScope();\n  const isolationScope = getIsolationScope();\n  const { traceId, spanId, sampled, dsc } = {\n    ...isolationScope.getPropagationContext(),\n    ...scope.getPropagationContext(),\n  };\n\n  const sentryTraceHeader =\n    span && hasTracingEnabled() ? spanToTraceHeader(span) : generateSentryTraceHeader(traceId, spanId, sampled);\n\n  const sentryBaggageHeader = dynamicSamplingContextToSentryBaggageHeader(\n    dsc || (span ? getDynamicSamplingContextFromSpan(span) : getDynamicSamplingContextFromClient(traceId, client)),\n  );\n\n  setHeaderOnXhr(xhr, sentryTraceHeader, sentryBaggageHeader);\n}\n\nfunction setHeaderOnXhr(\n  xhr: SentryWrappedXMLHttpRequest,\n  sentryTraceHeader: string,\n  sentryBaggageHeader: string | undefined,\n): void {\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    xhr.setRequestHeader!('sentry-trace', sentryTraceHeader);\n    if (sentryBaggageHeader) {\n      // From MDN: \"If this method is called several times with the same header, the values are merged into one single request header.\"\n      // We can therefore simply set a baggage header without checking what was there before\n      // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      xhr.setRequestHeader!(BAGGAGE_HEADER_NAME, sentryBaggageHeader);\n    }\n  } catch (_) {\n    // Error: InvalidStateError: Failed to execute 'setRequestHeader' on 'XMLHttpRequest': The object's state must be OPENED.\n  }\n}\n\nfunction getFullURL(url: string): string | undefined {\n  try {\n    // By adding a base URL to new URL(), this will also work for relative urls\n    // If `url` is a full URL, the base URL is ignored anyhow\n    const parsed = new URL(url, WINDOW.location.origin);\n    return parsed.href;\n  } catch {\n    return undefined;\n  }\n}\n"],"names":["addFetchEndInstrumentationHandler","addFetchInstrumentationHandler","instrumentFetchRequest","parseUrl","addXhrInstrumentationHandler","spanToJSON","addPerformanceInstrumentationHandler","browserPerformanceTimeOrigin","WINDOW","stringMatchesSomePattern","SENTRY_XHR_DATA_KEY","hasTracingEnabled","setHttpStatus","getActiveSpan","startInactiveSpan","SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN","SEMANTIC_ATTRIBUTE_SENTRY_OP","SentryNonRecordingSpan","getClient","getCurrentScope","getIsolationScope","spanToTraceHeader","generateSentryTraceHeader","dynamicSamplingContextToSentryBaggageHeader","getDynamicSamplingContextFromSpan","getDynamicSamplingContextFromClient","BAGGAGE_HEADER_NAME"],"mappings":"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"}