{"version":3,"file":"private-async-helpers.js","sources":["../../../src/directives/private-async-helpers.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n// Note, this module is not included in package exports so that it's private to\n// our first-party directives. If it ends up being useful, we can open it up and\n// export it.\n\n/**\n * Helper to iterate an AsyncIterable in its own closure.\n * @param iterable The iterable to iterate\n * @param callback The callback to call for each value. If the callback returns\n * `false`, the loop will be broken.\n */\nexport const forAwaitOf = async <T>(\n  iterable: AsyncIterable<T>,\n  callback: (value: T) => Promise<boolean>\n) => {\n  for await (const v of iterable) {\n    if ((await callback(v)) === false) {\n      return;\n    }\n  }\n};\n\n/**\n * Holds a reference to an instance that can be disconnected and reconnected,\n * so that a closure over the ref (e.g. in a then function to a promise) does\n * not strongly hold a ref to the instance. Approximates a WeakRef but must\n * be manually connected & disconnected to the backing instance.\n */\nexport class PseudoWeakRef<T> {\n  private _ref?: T;\n  constructor(ref: T) {\n    this._ref = ref;\n  }\n  /**\n   * Disassociates the ref with the backing instance.\n   */\n  disconnect() {\n    this._ref = undefined;\n  }\n  /**\n   * Reassociates the ref with the backing instance.\n   */\n  reconnect(ref: T) {\n    this._ref = ref;\n  }\n  /**\n   * Retrieves the backing instance (will be undefined when disconnected)\n   */\n  deref() {\n    return this._ref;\n  }\n}\n\n/**\n * A helper to pause and resume waiting on a condition in an async function\n */\nexport class Pauser {\n  private _promise?: Promise<void> = undefined;\n  private _resolve?: () => void = undefined;\n  /**\n   * When paused, returns a promise to be awaited; when unpaused, returns\n   * undefined. Note that in the microtask between the pauser being resumed\n   * an an await of this promise resolving, the pauser could be paused again,\n   * hence callers should check the promise in a loop when awaiting.\n   * @returns A promise to be awaited when paused or undefined\n   */\n  get() {\n    return this._promise;\n  }\n  /**\n   * Creates a promise to be awaited\n   */\n  pause() {\n    this._promise ??= new Promise((resolve) => (this._resolve = resolve));\n  }\n  /**\n   * Resolves the promise which may be awaited\n   */\n  resume() {\n    this._resolve?.();\n    this._promise = this._resolve = undefined;\n  }\n}\n"],"names":[],"mappings":"AAAA;;;;AAIG;AAEH;AACA;AACA;AAEA;;;;;AAKG;AACU,MAAA,UAAU,GAAG,OACxB,QAA0B,EAC1B,QAAwC,KACtC;AACF,IAAA,WAAW,MAAM,CAAC,IAAI,QAAQ,EAAE;QAC9B,IAAI,CAAC,MAAM,QAAQ,CAAC,CAAC,CAAC,MAAM,KAAK,EAAE;YACjC,OAAO;AACR,SAAA;AACF,KAAA;AACH,EAAE;AAEF;;;;;AAKG;MACU,aAAa,CAAA;AAExB,IAAA,WAAA,CAAY,GAAM,EAAA;AAChB,QAAA,IAAI,CAAC,IAAI,GAAG,GAAG,CAAC;KACjB;AACD;;AAEG;IACH,UAAU,GAAA;AACR,QAAA,IAAI,CAAC,IAAI,GAAG,SAAS,CAAC;KACvB;AACD;;AAEG;AACH,IAAA,SAAS,CAAC,GAAM,EAAA;AACd,QAAA,IAAI,CAAC,IAAI,GAAG,GAAG,CAAC;KACjB;AACD;;AAEG;IACH,KAAK,GAAA;QACH,OAAO,IAAI,CAAC,IAAI,CAAC;KAClB;AACF,CAAA;AAED;;AAEG;MACU,MAAM,CAAA;AAAnB,IAAA,WAAA,GAAA;QACU,IAAQ,CAAA,QAAA,GAAmB,SAAS,CAAC;QACrC,IAAQ,CAAA,QAAA,GAAgB,SAAS,CAAC;KAwB3C;AAvBC;;;;;;AAMG;IACH,GAAG,GAAA;QACD,OAAO,IAAI,CAAC,QAAQ,CAAC;KACtB;AACD;;AAEG;IACH,KAAK,GAAA;;QACH,CAAA,EAAA,GAAA,IAAI,CAAC,QAAQ,MAAb,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,IAAA,IAAI,CAAC,QAAQ,GAAK,IAAI,OAAO,CAAC,CAAC,OAAO,MAAM,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC,CAAC,CAAC,CAAA;KACvE;AACD;;AAEG;IACH,MAAM,GAAA;;AACJ,QAAA,CAAA,EAAA,GAAA,IAAI,CAAC,QAAQ,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAA,IAAA,CAAA,IAAA,CAAI,CAAC;QAClB,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,QAAQ,GAAG,SAAS,CAAC;KAC3C;AACF;;;;"}