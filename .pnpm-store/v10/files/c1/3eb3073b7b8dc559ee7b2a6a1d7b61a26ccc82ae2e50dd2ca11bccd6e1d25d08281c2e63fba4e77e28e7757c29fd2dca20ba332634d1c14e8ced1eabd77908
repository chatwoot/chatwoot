export declare const HstButton: {
    new (...args: any[]): {
        $: import("@vue/runtime-core").ComponentInternalInstance;
        $data: {};
        $props: Partial<{}> & Omit<{
            readonly color?: "default" | "primary" | "flat";
        } & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            color: {
                type: import("@vue/runtime-core").PropType<"default" | "primary" | "flat">;
            };
        }>>, never>;
        $attrs: {
            [x: string]: unknown;
        };
        $refs: {
            [x: string]: unknown;
        };
        $slots: Readonly<{
            [name: string]: import("@vue/runtime-core").Slot<any>;
        }>;
        $root: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>;
        $parent: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>;
        $emit: (event: string, ...args: any[]) => void;
        $el: any;
        $options: import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            color: {
                type: import("@vue/runtime-core").PropType<"default" | "primary" | "flat">;
            };
        }>>, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {}, string, {}, {}, string, {}> & {
            beforeCreate?: (() => void) | (() => void)[];
            created?: (() => void) | (() => void)[];
            beforeMount?: (() => void) | (() => void)[];
            mounted?: (() => void) | (() => void)[];
            beforeUpdate?: (() => void) | (() => void)[];
            updated?: (() => void) | (() => void)[];
            activated?: (() => void) | (() => void)[];
            deactivated?: (() => void) | (() => void)[];
            beforeDestroy?: (() => void) | (() => void)[];
            beforeUnmount?: (() => void) | (() => void)[];
            destroyed?: (() => void) | (() => void)[];
            unmounted?: (() => void) | (() => void)[];
            renderTracked?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
            renderTriggered?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
            errorCaptured?: ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>, info: string) => boolean | void) | ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>, info: string) => boolean | void)[];
        };
        $forceUpdate: () => void;
        $nextTick: typeof import("@vue/runtime-core").nextTick;
        $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (args_0: R, args_1: R) => any : (...args: any) => any, options?: import("@vue/runtime-core").WatchOptions<boolean>): import("@vue/runtime-core").WatchStopHandle;
    } & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
        color: {
            type: import("@vue/runtime-core").PropType<"default" | "primary" | "flat">;
        };
    }>> & import("@vue/reactivity").ShallowUnwrapRef<{}> & {} & import("@vue/runtime-core").ComponentCustomProperties & {};
    __isFragment?: never;
    __isTeleport?: never;
    __isSuspense?: never;
} & import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
    color: {
        type: import("@vue/runtime-core").PropType<"default" | "primary" | "flat">;
    };
}>>, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {}, string, {}, {}, string, {}> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & (new () => {
    $slots: {
        default?(_: {}): any;
    };
});
export declare const HstButtonGroup: {
    new (...args: any[]): {
        $: import("@vue/runtime-core").ComponentInternalInstance;
        $data: {};
        $props: Partial<{}> & Omit<{
            readonly options: string[] | Record<string, string | number> | number[] | import("./types").HstControlOption[];
            readonly title?: string;
            readonly modelValue?: string;
            "onUpdate:modelValue"?: (value: string) => any;
        } & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            title: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            modelValue: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            options: {
                type: import("@vue/runtime-core").PropType<string[] | Record<string, string | number> | number[] | import("./types").HstControlOption[]>;
                required: true;
            };
        }>> & {
            "onUpdate:modelValue"?: (value: string) => any;
        }, never>;
        $attrs: {
            [x: string]: unknown;
        };
        $refs: {
            [x: string]: unknown;
        };
        $slots: Readonly<{
            [name: string]: import("@vue/runtime-core").Slot<any>;
        }>;
        $root: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>;
        $parent: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>;
        $emit: (event: "update:modelValue", value: string) => void;
        $el: any;
        $options: import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            title: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            modelValue: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            options: {
                type: import("@vue/runtime-core").PropType<string[] | Record<string, string | number> | number[] | import("./types").HstControlOption[]>;
                required: true;
            };
        }>> & {
            "onUpdate:modelValue"?: (value: string) => any;
        }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
            "update:modelValue": (value: string) => void;
        }, string, {}, {}, string, {}> & {
            beforeCreate?: (() => void) | (() => void)[];
            created?: (() => void) | (() => void)[];
            beforeMount?: (() => void) | (() => void)[];
            mounted?: (() => void) | (() => void)[];
            beforeUpdate?: (() => void) | (() => void)[];
            updated?: (() => void) | (() => void)[];
            activated?: (() => void) | (() => void)[];
            deactivated?: (() => void) | (() => void)[];
            beforeDestroy?: (() => void) | (() => void)[];
            beforeUnmount?: (() => void) | (() => void)[];
            destroyed?: (() => void) | (() => void)[];
            unmounted?: (() => void) | (() => void)[];
            renderTracked?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
            renderTriggered?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
            errorCaptured?: ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>, info: string) => boolean | void) | ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>, info: string) => boolean | void)[];
        };
        $forceUpdate: () => void;
        $nextTick: typeof import("@vue/runtime-core").nextTick;
        $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (args_0: R, args_1: R) => any : (...args: any) => any, options?: import("@vue/runtime-core").WatchOptions<boolean>): import("@vue/runtime-core").WatchStopHandle;
    } & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
        title: {
            type: import("@vue/runtime-core").PropType<string>;
        };
        modelValue: {
            type: import("@vue/runtime-core").PropType<string>;
        };
        options: {
            type: import("@vue/runtime-core").PropType<string[] | Record<string, string | number> | number[] | import("./types").HstControlOption[]>;
            required: true;
        };
    }>> & {
        "onUpdate:modelValue"?: (value: string) => any;
    } & import("@vue/reactivity").ShallowUnwrapRef<{}> & {} & import("@vue/runtime-core").ComponentCustomProperties & {};
    __isFragment?: never;
    __isTeleport?: never;
    __isSuspense?: never;
} & import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
    title: {
        type: import("@vue/runtime-core").PropType<string>;
    };
    modelValue: {
        type: import("@vue/runtime-core").PropType<string>;
    };
    options: {
        type: import("@vue/runtime-core").PropType<string[] | Record<string, string | number> | number[] | import("./types").HstControlOption[]>;
        required: true;
    };
}>> & {
    "onUpdate:modelValue"?: (value: string) => any;
}, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
    "update:modelValue": (value: string) => void;
}, string, {}, {}, string, {}> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & (new () => {
    $slots: {
        actions?(_: {}): any;
    };
});
export declare const HstCheckbox: {
    new (...args: any[]): {
        $: import("@vue/runtime-core").ComponentInternalInstance;
        $data: {};
        $props: Partial<{}> & Omit<{
            readonly title?: string;
            readonly modelValue?: boolean | "true" | "false";
            "onUpdate:modelValue"?: (newValue: boolean | "true" | "false") => any;
        } & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            modelValue: {
                type: import("@vue/runtime-core").PropType<boolean | "true" | "false">;
            };
            title: {
                type: import("@vue/runtime-core").PropType<string>;
            };
        }>> & {
            "onUpdate:modelValue"?: (newValue: boolean | "true" | "false") => any;
        }, never>;
        $attrs: {
            [x: string]: unknown;
        };
        $refs: {
            [x: string]: unknown;
        };
        $slots: Readonly<{
            [name: string]: import("@vue/runtime-core").Slot<any>;
        }>;
        $root: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>;
        $parent: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>;
        $emit: (event: "update:modelValue", newValue: boolean | "true" | "false") => void;
        $el: any;
        $options: import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            modelValue: {
                type: import("@vue/runtime-core").PropType<boolean | "true" | "false">;
            };
            title: {
                type: import("@vue/runtime-core").PropType<string>;
            };
        }>> & {
            "onUpdate:modelValue"?: (newValue: boolean | "true" | "false") => any;
        }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
            "update:modelValue": (newValue: boolean | "true" | "false") => void;
        }, string, {}, {}, string, {}> & {
            beforeCreate?: (() => void) | (() => void)[];
            created?: (() => void) | (() => void)[];
            beforeMount?: (() => void) | (() => void)[];
            mounted?: (() => void) | (() => void)[];
            beforeUpdate?: (() => void) | (() => void)[];
            updated?: (() => void) | (() => void)[];
            activated?: (() => void) | (() => void)[];
            deactivated?: (() => void) | (() => void)[];
            beforeDestroy?: (() => void) | (() => void)[];
            beforeUnmount?: (() => void) | (() => void)[];
            destroyed?: (() => void) | (() => void)[];
            unmounted?: (() => void) | (() => void)[];
            renderTracked?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
            renderTriggered?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
            errorCaptured?: ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>, info: string) => boolean | void) | ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>, info: string) => boolean | void)[];
        };
        $forceUpdate: () => void;
        $nextTick: typeof import("@vue/runtime-core").nextTick;
        $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (args_0: R, args_1: R) => any : (...args: any) => any, options?: import("@vue/runtime-core").WatchOptions<boolean>): import("@vue/runtime-core").WatchStopHandle;
    } & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
        modelValue: {
            type: import("@vue/runtime-core").PropType<boolean | "true" | "false">;
        };
        title: {
            type: import("@vue/runtime-core").PropType<string>;
        };
    }>> & {
        "onUpdate:modelValue"?: (newValue: boolean | "true" | "false") => any;
    } & import("@vue/reactivity").ShallowUnwrapRef<{}> & {} & import("@vue/runtime-core").ComponentCustomProperties & {};
    __isFragment?: never;
    __isTeleport?: never;
    __isSuspense?: never;
} & import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
    modelValue: {
        type: import("@vue/runtime-core").PropType<boolean | "true" | "false">;
    };
    title: {
        type: import("@vue/runtime-core").PropType<string>;
    };
}>> & {
    "onUpdate:modelValue"?: (newValue: boolean | "true" | "false") => any;
}, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
    "update:modelValue": (newValue: boolean | "true" | "false") => void;
}, string, {}, {}, string, {}> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & (new () => {
    $slots: {
        actions?(_: {}): any;
    };
});
export declare const HstCheckboxList: {
    new (...args: any[]): {
        $: import("@vue/runtime-core").ComponentInternalInstance;
        $data: {};
        $props: Partial<{}> & Omit<{
            readonly modelValue: string[];
            readonly options: string[] | import("./types").HstControlOption[];
            readonly title?: string;
            "onUpdate:modelValue"?: (value: string[]) => any;
        } & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            title: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            modelValue: {
                type: import("@vue/runtime-core").PropType<string[]>;
                required: true;
            };
            options: {
                type: import("@vue/runtime-core").PropType<string[] | import("./types").HstControlOption[]>;
                required: true;
            };
        }>> & {
            "onUpdate:modelValue"?: (value: string[]) => any;
        }, never>;
        $attrs: {
            [x: string]: unknown;
        };
        $refs: {
            [x: string]: unknown;
        };
        $slots: Readonly<{
            [name: string]: import("@vue/runtime-core").Slot<any>;
        }>;
        $root: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>;
        $parent: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>;
        $emit: (event: "update:modelValue", value: string[]) => void;
        $el: any;
        $options: import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            title: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            modelValue: {
                type: import("@vue/runtime-core").PropType<string[]>;
                required: true;
            };
            options: {
                type: import("@vue/runtime-core").PropType<string[] | import("./types").HstControlOption[]>;
                required: true;
            };
        }>> & {
            "onUpdate:modelValue"?: (value: string[]) => any;
        }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
            "update:modelValue": (value: string[]) => void;
        }, string, {}, {}, string, {}> & {
            beforeCreate?: (() => void) | (() => void)[];
            created?: (() => void) | (() => void)[];
            beforeMount?: (() => void) | (() => void)[];
            mounted?: (() => void) | (() => void)[];
            beforeUpdate?: (() => void) | (() => void)[];
            updated?: (() => void) | (() => void)[];
            activated?: (() => void) | (() => void)[];
            deactivated?: (() => void) | (() => void)[];
            beforeDestroy?: (() => void) | (() => void)[];
            beforeUnmount?: (() => void) | (() => void)[];
            destroyed?: (() => void) | (() => void)[];
            unmounted?: (() => void) | (() => void)[];
            renderTracked?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
            renderTriggered?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
            errorCaptured?: ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>, info: string) => boolean | void) | ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>, info: string) => boolean | void)[];
        };
        $forceUpdate: () => void;
        $nextTick: typeof import("@vue/runtime-core").nextTick;
        $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (args_0: R, args_1: R) => any : (...args: any) => any, options?: import("@vue/runtime-core").WatchOptions<boolean>): import("@vue/runtime-core").WatchStopHandle;
    } & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
        title: {
            type: import("@vue/runtime-core").PropType<string>;
        };
        modelValue: {
            type: import("@vue/runtime-core").PropType<string[]>;
            required: true;
        };
        options: {
            type: import("@vue/runtime-core").PropType<string[] | import("./types").HstControlOption[]>;
            required: true;
        };
    }>> & {
        "onUpdate:modelValue"?: (value: string[]) => any;
    } & import("@vue/reactivity").ShallowUnwrapRef<{}> & {} & import("@vue/runtime-core").ComponentCustomProperties & {};
    __isFragment?: never;
    __isTeleport?: never;
    __isSuspense?: never;
} & import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
    title: {
        type: import("@vue/runtime-core").PropType<string>;
    };
    modelValue: {
        type: import("@vue/runtime-core").PropType<string[]>;
        required: true;
    };
    options: {
        type: import("@vue/runtime-core").PropType<string[] | import("./types").HstControlOption[]>;
        required: true;
    };
}>> & {
    "onUpdate:modelValue"?: (value: string[]) => any;
}, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
    "update:modelValue": (value: string[]) => void;
}, string, {}, {}, string, {}> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & (new () => {
    $slots: {
        actions?(_: {}): any;
    };
});
export declare const HstText: {
    new (...args: any[]): {
        $: import("@vue/runtime-core").ComponentInternalInstance;
        $data: {};
        $props: Partial<{}> & Omit<{
            readonly title?: string;
            readonly modelValue?: string;
            "onUpdate:modelValue"?: (newValue: string) => any;
        } & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            title: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            modelValue: {
                type: import("@vue/runtime-core").PropType<string>;
            };
        }>> & {
            "onUpdate:modelValue"?: (newValue: string) => any;
        }, never>;
        $attrs: {
            [x: string]: unknown;
        };
        $refs: {
            [x: string]: unknown;
        };
        $slots: Readonly<{
            [name: string]: import("@vue/runtime-core").Slot<any>;
        }>;
        $root: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>;
        $parent: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>;
        $emit: (event: "update:modelValue", newValue: string) => void;
        $el: any;
        $options: import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            title: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            modelValue: {
                type: import("@vue/runtime-core").PropType<string>;
            };
        }>> & {
            "onUpdate:modelValue"?: (newValue: string) => any;
        }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
            "update:modelValue": (newValue: string) => void;
        }, string, {}, {}, string, {}> & {
            beforeCreate?: (() => void) | (() => void)[];
            created?: (() => void) | (() => void)[];
            beforeMount?: (() => void) | (() => void)[];
            mounted?: (() => void) | (() => void)[];
            beforeUpdate?: (() => void) | (() => void)[];
            updated?: (() => void) | (() => void)[];
            activated?: (() => void) | (() => void)[];
            deactivated?: (() => void) | (() => void)[];
            beforeDestroy?: (() => void) | (() => void)[];
            beforeUnmount?: (() => void) | (() => void)[];
            destroyed?: (() => void) | (() => void)[];
            unmounted?: (() => void) | (() => void)[];
            renderTracked?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
            renderTriggered?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
            errorCaptured?: ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>, info: string) => boolean | void) | ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>, info: string) => boolean | void)[];
        };
        $forceUpdate: () => void;
        $nextTick: typeof import("@vue/runtime-core").nextTick;
        $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (args_0: R, args_1: R) => any : (...args: any) => any, options?: import("@vue/runtime-core").WatchOptions<boolean>): import("@vue/runtime-core").WatchStopHandle;
    } & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
        title: {
            type: import("@vue/runtime-core").PropType<string>;
        };
        modelValue: {
            type: import("@vue/runtime-core").PropType<string>;
        };
    }>> & {
        "onUpdate:modelValue"?: (newValue: string) => any;
    } & import("@vue/reactivity").ShallowUnwrapRef<{}> & {} & import("@vue/runtime-core").ComponentCustomProperties & {};
    __isFragment?: never;
    __isTeleport?: never;
    __isSuspense?: never;
} & import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
    title: {
        type: import("@vue/runtime-core").PropType<string>;
    };
    modelValue: {
        type: import("@vue/runtime-core").PropType<string>;
    };
}>> & {
    "onUpdate:modelValue"?: (newValue: string) => any;
}, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
    "update:modelValue": (newValue: string) => void;
}, string, {}, {}, string, {}> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & (new () => {
    $slots: {
        actions?(_: {}): any;
    };
});
export declare const HstNumber: {
    new (...args: any[]): {
        $: import("@vue/runtime-core").ComponentInternalInstance;
        $data: {};
        $props: Partial<{}> & Omit<{
            readonly title?: string;
            readonly modelValue?: number;
            "onUpdate:modelValue"?: (newValue: number) => any;
        } & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            title: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            modelValue: {
                type: import("@vue/runtime-core").PropType<number>;
            };
        }>> & {
            "onUpdate:modelValue"?: (newValue: number) => any;
        }, never>;
        $attrs: {
            [x: string]: unknown;
        };
        $refs: {
            [x: string]: unknown;
        };
        $slots: Readonly<{
            [name: string]: import("@vue/runtime-core").Slot<any>;
        }>;
        $root: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>;
        $parent: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>;
        $emit: (event: "update:modelValue", newValue: number) => void;
        $el: any;
        $options: import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            title: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            modelValue: {
                type: import("@vue/runtime-core").PropType<number>;
            };
        }>> & {
            "onUpdate:modelValue"?: (newValue: number) => any;
        }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
            "update:modelValue": (newValue: number) => void;
        }, string, {}, {}, string, {}> & {
            beforeCreate?: (() => void) | (() => void)[];
            created?: (() => void) | (() => void)[];
            beforeMount?: (() => void) | (() => void)[];
            mounted?: (() => void) | (() => void)[];
            beforeUpdate?: (() => void) | (() => void)[];
            updated?: (() => void) | (() => void)[];
            activated?: (() => void) | (() => void)[];
            deactivated?: (() => void) | (() => void)[];
            beforeDestroy?: (() => void) | (() => void)[];
            beforeUnmount?: (() => void) | (() => void)[];
            destroyed?: (() => void) | (() => void)[];
            unmounted?: (() => void) | (() => void)[];
            renderTracked?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
            renderTriggered?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
            errorCaptured?: ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>, info: string) => boolean | void) | ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>, info: string) => boolean | void)[];
        };
        $forceUpdate: () => void;
        $nextTick: typeof import("@vue/runtime-core").nextTick;
        $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (args_0: R, args_1: R) => any : (...args: any) => any, options?: import("@vue/runtime-core").WatchOptions<boolean>): import("@vue/runtime-core").WatchStopHandle;
    } & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
        title: {
            type: import("@vue/runtime-core").PropType<string>;
        };
        modelValue: {
            type: import("@vue/runtime-core").PropType<number>;
        };
    }>> & {
        "onUpdate:modelValue"?: (newValue: number) => any;
    } & import("@vue/reactivity").ShallowUnwrapRef<{}> & {} & import("@vue/runtime-core").ComponentCustomProperties & {};
    __isFragment?: never;
    __isTeleport?: never;
    __isSuspense?: never;
} & import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
    title: {
        type: import("@vue/runtime-core").PropType<string>;
    };
    modelValue: {
        type: import("@vue/runtime-core").PropType<number>;
    };
}>> & {
    "onUpdate:modelValue"?: (newValue: number) => any;
}, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
    "update:modelValue": (newValue: number) => void;
}, string, {}, {}, string, {}> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & (new () => {
    $slots: {
        actions?(_: {}): any;
    };
});
export declare const HstSlider: import("@vue/runtime-core").DefineComponent<{
    title: {
        type: import("@vue/runtime-core").PropType<string>;
    };
    modelValue: {
        type: import("@vue/runtime-core").PropType<number>;
    };
    min: {
        type: import("@vue/runtime-core").PropType<number>;
        required: true;
    };
    max: {
        type: import("@vue/runtime-core").PropType<number>;
        required: true;
    };
}, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
    "update:modelValue": (newValue: number) => void;
}, string, import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps, Readonly<import("@vue/runtime-core").ExtractPropTypes<{
    title: {
        type: import("@vue/runtime-core").PropType<string>;
    };
    modelValue: {
        type: import("@vue/runtime-core").PropType<number>;
    };
    min: {
        type: import("@vue/runtime-core").PropType<number>;
        required: true;
    };
    max: {
        type: import("@vue/runtime-core").PropType<number>;
        required: true;
    };
}>> & {
    "onUpdate:modelValue"?: (newValue: number) => any;
}, {}, {}>;
export declare const HstTextarea: {
    new (...args: any[]): {
        $: import("@vue/runtime-core").ComponentInternalInstance;
        $data: {};
        $props: Partial<{}> & Omit<{
            readonly title?: string;
            readonly modelValue?: string;
            "onUpdate:modelValue"?: (newValue: string) => any;
        } & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            title: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            modelValue: {
                type: import("@vue/runtime-core").PropType<string>;
            };
        }>> & {
            "onUpdate:modelValue"?: (newValue: string) => any;
        }, never>;
        $attrs: {
            [x: string]: unknown;
        };
        $refs: {
            [x: string]: unknown;
        };
        $slots: Readonly<{
            [name: string]: import("@vue/runtime-core").Slot<any>;
        }>;
        $root: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>;
        $parent: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>;
        $emit: (event: "update:modelValue", newValue: string) => void;
        $el: any;
        $options: import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            title: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            modelValue: {
                type: import("@vue/runtime-core").PropType<string>;
            };
        }>> & {
            "onUpdate:modelValue"?: (newValue: string) => any;
        }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
            "update:modelValue": (newValue: string) => void;
        }, string, {}, {}, string, {}> & {
            beforeCreate?: (() => void) | (() => void)[];
            created?: (() => void) | (() => void)[];
            beforeMount?: (() => void) | (() => void)[];
            mounted?: (() => void) | (() => void)[];
            beforeUpdate?: (() => void) | (() => void)[];
            updated?: (() => void) | (() => void)[];
            activated?: (() => void) | (() => void)[];
            deactivated?: (() => void) | (() => void)[];
            beforeDestroy?: (() => void) | (() => void)[];
            beforeUnmount?: (() => void) | (() => void)[];
            destroyed?: (() => void) | (() => void)[];
            unmounted?: (() => void) | (() => void)[];
            renderTracked?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
            renderTriggered?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
            errorCaptured?: ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>, info: string) => boolean | void) | ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>, info: string) => boolean | void)[];
        };
        $forceUpdate: () => void;
        $nextTick: typeof import("@vue/runtime-core").nextTick;
        $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (args_0: R, args_1: R) => any : (...args: any) => any, options?: import("@vue/runtime-core").WatchOptions<boolean>): import("@vue/runtime-core").WatchStopHandle;
    } & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
        title: {
            type: import("@vue/runtime-core").PropType<string>;
        };
        modelValue: {
            type: import("@vue/runtime-core").PropType<string>;
        };
    }>> & {
        "onUpdate:modelValue"?: (newValue: string) => any;
    } & import("@vue/reactivity").ShallowUnwrapRef<{}> & {} & import("@vue/runtime-core").ComponentCustomProperties & {};
    __isFragment?: never;
    __isTeleport?: never;
    __isSuspense?: never;
} & import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
    title: {
        type: import("@vue/runtime-core").PropType<string>;
    };
    modelValue: {
        type: import("@vue/runtime-core").PropType<string>;
    };
}>> & {
    "onUpdate:modelValue"?: (newValue: string) => any;
}, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
    "update:modelValue": (newValue: string) => void;
}, string, {}, {}, string, {}> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & (new () => {
    $slots: {
        actions?(_: {}): any;
    };
});
export declare const HstSelect: {
    new (...args: any[]): {
        $: import("@vue/runtime-core").ComponentInternalInstance;
        $data: {};
        $props: Partial<{}> & Omit<{
            readonly options: unknown;
            readonly title?: string;
            readonly modelValue?: any;
            "onUpdate:modelValue"?: (value: any) => any;
        } & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            title: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            modelValue: {
                type: import("@vue/runtime-core").PropType<any>;
            };
            options: {
                type: import("@vue/runtime-core").PropType<Record<string, any> | string[] | import("./types").HstControlOption[]>;
                required: true;
            };
        }>> & {
            "onUpdate:modelValue"?: (value: any) => any;
        }, never>;
        $attrs: {
            [x: string]: unknown;
        };
        $refs: {
            [x: string]: unknown;
        };
        $slots: Readonly<{
            [name: string]: import("@vue/runtime-core").Slot<any>;
        }>;
        $root: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>;
        $parent: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>;
        $emit: (event: "update:modelValue", value: any) => void;
        $el: any;
        $options: import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            title: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            modelValue: {
                type: import("@vue/runtime-core").PropType<any>;
            };
            options: {
                type: import("@vue/runtime-core").PropType<Record<string, any> | string[] | import("./types").HstControlOption[]>;
                required: true;
            };
        }>> & {
            "onUpdate:modelValue"?: (value: any) => any;
        }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
            "update:modelValue": (value: any) => void;
        }, string, {}, {}, string, {}> & {
            beforeCreate?: (() => void) | (() => void)[];
            created?: (() => void) | (() => void)[];
            beforeMount?: (() => void) | (() => void)[];
            mounted?: (() => void) | (() => void)[];
            beforeUpdate?: (() => void) | (() => void)[];
            updated?: (() => void) | (() => void)[];
            activated?: (() => void) | (() => void)[];
            deactivated?: (() => void) | (() => void)[];
            beforeDestroy?: (() => void) | (() => void)[];
            beforeUnmount?: (() => void) | (() => void)[];
            destroyed?: (() => void) | (() => void)[];
            unmounted?: (() => void) | (() => void)[];
            renderTracked?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
            renderTriggered?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
            errorCaptured?: ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>, info: string) => boolean | void) | ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>, info: string) => boolean | void)[];
        };
        $forceUpdate: () => void;
        $nextTick: typeof import("@vue/runtime-core").nextTick;
        $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (args_0: R, args_1: R) => any : (...args: any) => any, options?: import("@vue/runtime-core").WatchOptions<boolean>): import("@vue/runtime-core").WatchStopHandle;
    } & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
        title: {
            type: import("@vue/runtime-core").PropType<string>;
        };
        modelValue: {
            type: import("@vue/runtime-core").PropType<any>;
        };
        options: {
            type: import("@vue/runtime-core").PropType<Record<string, any> | string[] | import("./types").HstControlOption[]>;
            required: true;
        };
    }>> & {
        "onUpdate:modelValue"?: (value: any) => any;
    } & import("@vue/reactivity").ShallowUnwrapRef<{}> & {} & import("@vue/runtime-core").ComponentCustomProperties & {};
    __isFragment?: never;
    __isTeleport?: never;
    __isSuspense?: never;
} & import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
    title: {
        type: import("@vue/runtime-core").PropType<string>;
    };
    modelValue: {
        type: import("@vue/runtime-core").PropType<any>;
    };
    options: {
        type: import("@vue/runtime-core").PropType<Record<string, any> | string[] | import("./types").HstControlOption[]>;
        required: true;
    };
}>> & {
    "onUpdate:modelValue"?: (value: any) => any;
}, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
    "update:modelValue": (value: any) => void;
}, string, {}, {}, string, {}> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & (new () => {
    $slots: {
        actions?(_: {}): any;
    };
});
export declare const HstColorShades: {
    new (...args: any[]): {
        $: import("@vue/runtime-core").ComponentInternalInstance;
        $data: {};
        $props: Partial<{}> & Omit<{
            readonly shades: unknown;
            readonly search?: string;
            readonly getName?: (key: string, color: string) => string;
        } & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            shades: {
                type: import("@vue/runtime-core").PropType<Record<string, any>>;
                required: true;
            };
            getName: {
                type: import("@vue/runtime-core").PropType<(key: string, color: string) => string>;
            };
            search: {
                type: import("@vue/runtime-core").PropType<string>;
            };
        }>>, never>;
        $attrs: {
            [x: string]: unknown;
        };
        $refs: {
            [x: string]: unknown;
        };
        $slots: Readonly<{
            [name: string]: import("@vue/runtime-core").Slot<any>;
        }>;
        $root: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>;
        $parent: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>;
        $emit: (event: string, ...args: any[]) => void;
        $el: any;
        $options: import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            shades: {
                type: import("@vue/runtime-core").PropType<Record<string, any>>;
                required: true;
            };
            getName: {
                type: import("@vue/runtime-core").PropType<(key: string, color: string) => string>;
            };
            search: {
                type: import("@vue/runtime-core").PropType<string>;
            };
        }>>, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {}, string, {}, {}, string, {}> & {
            beforeCreate?: (() => void) | (() => void)[];
            created?: (() => void) | (() => void)[];
            beforeMount?: (() => void) | (() => void)[];
            mounted?: (() => void) | (() => void)[];
            beforeUpdate?: (() => void) | (() => void)[];
            updated?: (() => void) | (() => void)[];
            activated?: (() => void) | (() => void)[];
            deactivated?: (() => void) | (() => void)[];
            beforeDestroy?: (() => void) | (() => void)[];
            beforeUnmount?: (() => void) | (() => void)[];
            destroyed?: (() => void) | (() => void)[];
            unmounted?: (() => void) | (() => void)[];
            renderTracked?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
            renderTriggered?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
            errorCaptured?: ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>, info: string) => boolean | void) | ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>, info: string) => boolean | void)[];
        };
        $forceUpdate: () => void;
        $nextTick: typeof import("@vue/runtime-core").nextTick;
        $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (args_0: R, args_1: R) => any : (...args: any) => any, options?: import("@vue/runtime-core").WatchOptions<boolean>): import("@vue/runtime-core").WatchStopHandle;
    } & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
        shades: {
            type: import("@vue/runtime-core").PropType<Record<string, any>>;
            required: true;
        };
        getName: {
            type: import("@vue/runtime-core").PropType<(key: string, color: string) => string>;
        };
        search: {
            type: import("@vue/runtime-core").PropType<string>;
        };
    }>> & import("@vue/reactivity").ShallowUnwrapRef<{}> & {} & import("@vue/runtime-core").ComponentCustomProperties & {};
    __isFragment?: never;
    __isTeleport?: never;
    __isSuspense?: never;
} & import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
    shades: {
        type: import("@vue/runtime-core").PropType<Record<string, any>>;
        required: true;
    };
    getName: {
        type: import("@vue/runtime-core").PropType<(key: string, color: string) => string>;
    };
    search: {
        type: import("@vue/runtime-core").PropType<string>;
    };
}>>, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {}, string, {}, {}, string, {}> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & (new () => {
    $slots: {
        default?(_: {
            color: string;
        }): any;
    };
});
export declare const HstTokenList: {
    new (...args: any[]): {
        $: import("@vue/runtime-core").ComponentInternalInstance;
        $data: {};
        $props: Partial<{}> & Omit<{
            readonly tokens: Record<string, string | number | any[] | Record<string, any>>;
            readonly getName?: (key: string, value: string | number | any[] | Record<string, any>) => string;
        } & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            tokens: {
                type: import("@vue/runtime-core").PropType<Record<string, string | number | any[] | Record<string, any>>>;
                required: true;
            };
            getName: {
                type: import("@vue/runtime-core").PropType<(key: string, value: string | number | any[] | Record<string, any>) => string>;
            };
        }>>, never>;
        $attrs: {
            [x: string]: unknown;
        };
        $refs: {
            [x: string]: unknown;
        };
        $slots: Readonly<{
            [name: string]: import("@vue/runtime-core").Slot<any>;
        }>;
        $root: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>;
        $parent: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>;
        $emit: (event: string, ...args: any[]) => void;
        $el: any;
        $options: import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            tokens: {
                type: import("@vue/runtime-core").PropType<Record<string, string | number | any[] | Record<string, any>>>;
                required: true;
            };
            getName: {
                type: import("@vue/runtime-core").PropType<(key: string, value: string | number | any[] | Record<string, any>) => string>;
            };
        }>>, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {}, string, {}, {}, string, {}> & {
            beforeCreate?: (() => void) | (() => void)[];
            created?: (() => void) | (() => void)[];
            beforeMount?: (() => void) | (() => void)[];
            mounted?: (() => void) | (() => void)[];
            beforeUpdate?: (() => void) | (() => void)[];
            updated?: (() => void) | (() => void)[];
            activated?: (() => void) | (() => void)[];
            deactivated?: (() => void) | (() => void)[];
            beforeDestroy?: (() => void) | (() => void)[];
            beforeUnmount?: (() => void) | (() => void)[];
            destroyed?: (() => void) | (() => void)[];
            unmounted?: (() => void) | (() => void)[];
            renderTracked?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
            renderTriggered?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
            errorCaptured?: ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>, info: string) => boolean | void) | ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>, info: string) => boolean | void)[];
        };
        $forceUpdate: () => void;
        $nextTick: typeof import("@vue/runtime-core").nextTick;
        $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (args_0: R, args_1: R) => any : (...args: any) => any, options?: import("@vue/runtime-core").WatchOptions<boolean>): import("@vue/runtime-core").WatchStopHandle;
    } & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
        tokens: {
            type: import("@vue/runtime-core").PropType<Record<string, string | number | any[] | Record<string, any>>>;
            required: true;
        };
        getName: {
            type: import("@vue/runtime-core").PropType<(key: string, value: string | number | any[] | Record<string, any>) => string>;
        };
    }>> & import("@vue/reactivity").ShallowUnwrapRef<{}> & {} & import("@vue/runtime-core").ComponentCustomProperties & {};
    __isFragment?: never;
    __isTeleport?: never;
    __isSuspense?: never;
} & import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
    tokens: {
        type: import("@vue/runtime-core").PropType<Record<string, string | number | any[] | Record<string, any>>>;
        required: true;
    };
    getName: {
        type: import("@vue/runtime-core").PropType<(key: string, value: string | number | any[] | Record<string, any>) => string>;
    };
}>>, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {}, string, {}, {}, string, {}> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & (new () => {
    $slots: {
        default?(_: {
            token: {
                key: string;
                name: string;
                value: string | any[] | Record<string, any>;
            };
        }): any;
    };
});
export declare const HstTokenGrid: {
    new (...args: any[]): {
        $: import("@vue/runtime-core").ComponentInternalInstance;
        $data: {};
        $props: Partial<{
            getName: (key: string, value: string | number | any[] | Record<string, any>) => string;
            colSize: number;
        }> & Omit<{
            readonly tokens: Record<string, string | number | any[] | Record<string, any>>;
            readonly colSize: number;
            readonly getName?: (key: string, value: string | number | any[] | Record<string, any>) => string;
        } & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            getName: {
                type: import("@vue/runtime-core").PropType<(key: string, value: string | number | any[] | Record<string, any>) => string>;
                default: any;
            };
            tokens: {
                type: import("@vue/runtime-core").PropType<Record<string, string | number | any[] | Record<string, any>>>;
                required: true;
            };
            colSize: {
                type: import("@vue/runtime-core").PropType<number>;
                default: number;
            };
        }>>, "getName" | "colSize">;
        $attrs: {
            [x: string]: unknown;
        };
        $refs: {
            [x: string]: unknown;
        };
        $slots: Readonly<{
            [name: string]: import("@vue/runtime-core").Slot<any>;
        }>;
        $root: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>;
        $parent: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>;
        $emit: (event: string, ...args: any[]) => void;
        $el: any;
        $options: import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            getName: {
                type: import("@vue/runtime-core").PropType<(key: string, value: string | number | any[] | Record<string, any>) => string>;
                default: any;
            };
            tokens: {
                type: import("@vue/runtime-core").PropType<Record<string, string | number | any[] | Record<string, any>>>;
                required: true;
            };
            colSize: {
                type: import("@vue/runtime-core").PropType<number>;
                default: number;
            };
        }>>, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {}, string, {
            getName: (key: string, value: string | number | any[] | Record<string, any>) => string;
            colSize: number;
        }, {}, string, {}> & {
            beforeCreate?: (() => void) | (() => void)[];
            created?: (() => void) | (() => void)[];
            beforeMount?: (() => void) | (() => void)[];
            mounted?: (() => void) | (() => void)[];
            beforeUpdate?: (() => void) | (() => void)[];
            updated?: (() => void) | (() => void)[];
            activated?: (() => void) | (() => void)[];
            deactivated?: (() => void) | (() => void)[];
            beforeDestroy?: (() => void) | (() => void)[];
            beforeUnmount?: (() => void) | (() => void)[];
            destroyed?: (() => void) | (() => void)[];
            unmounted?: (() => void) | (() => void)[];
            renderTracked?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
            renderTriggered?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
            errorCaptured?: ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>, info: string) => boolean | void) | ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>, info: string) => boolean | void)[];
        };
        $forceUpdate: () => void;
        $nextTick: typeof import("@vue/runtime-core").nextTick;
        $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (args_0: R, args_1: R) => any : (...args: any) => any, options?: import("@vue/runtime-core").WatchOptions<boolean>): import("@vue/runtime-core").WatchStopHandle;
    } & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
        getName: {
            type: import("@vue/runtime-core").PropType<(key: string, value: string | number | any[] | Record<string, any>) => string>;
            default: any;
        };
        tokens: {
            type: import("@vue/runtime-core").PropType<Record<string, string | number | any[] | Record<string, any>>>;
            required: true;
        };
        colSize: {
            type: import("@vue/runtime-core").PropType<number>;
            default: number;
        };
    }>> & import("@vue/reactivity").ShallowUnwrapRef<{}> & {} & import("@vue/runtime-core").ComponentCustomProperties & {};
    __isFragment?: never;
    __isTeleport?: never;
    __isSuspense?: never;
} & import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
    getName: {
        type: import("@vue/runtime-core").PropType<(key: string, value: string | number | any[] | Record<string, any>) => string>;
        default: any;
    };
    tokens: {
        type: import("@vue/runtime-core").PropType<Record<string, string | number | any[] | Record<string, any>>>;
        required: true;
    };
    colSize: {
        type: import("@vue/runtime-core").PropType<number>;
        default: number;
    };
}>>, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {}, string, {
    getName: (key: string, value: string | number | any[] | Record<string, any>) => string;
    colSize: number;
}, {}, string, {}> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & (new () => {
    $slots: {
        default?(_: {
            token: {
                key: string;
                name: string;
                value: string | any[] | Record<string, any>;
            };
        }): any;
    };
});
export declare const HstCopyIcon: import("@vue/runtime-core").DefineComponent<{
    content: {
        type: import("@vue/runtime-core").PropType<string | (() => import("@histoire/shared").Awaitable<string>)>;
        required: true;
    };
}, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {}, string, import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps, Readonly<import("@vue/runtime-core").ExtractPropTypes<{
    content: {
        type: import("@vue/runtime-core").PropType<string | (() => import("@histoire/shared").Awaitable<string>)>;
        required: true;
    };
}>>, {}, {}>;
export declare const HstRadio: {
    new (...args: any[]): {
        $: import("@vue/runtime-core").ComponentInternalInstance;
        $data: {};
        $props: Partial<{}> & Omit<{
            readonly options: import("./types").HstControlOption[];
            readonly title?: string;
            readonly modelValue?: string;
            "onUpdate:modelValue"?: (value: string) => any;
        } & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            title: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            modelValue: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            options: {
                type: import("@vue/runtime-core").PropType<import("./types").HstControlOption[]>;
                required: true;
            };
        }>> & {
            "onUpdate:modelValue"?: (value: string) => any;
        }, never>;
        $attrs: {
            [x: string]: unknown;
        };
        $refs: {
            [x: string]: unknown;
        };
        $slots: Readonly<{
            [name: string]: import("@vue/runtime-core").Slot<any>;
        }>;
        $root: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>;
        $parent: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>;
        $emit: (event: "update:modelValue", value: string) => void;
        $el: any;
        $options: import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            title: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            modelValue: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            options: {
                type: import("@vue/runtime-core").PropType<import("./types").HstControlOption[]>;
                required: true;
            };
        }>> & {
            "onUpdate:modelValue"?: (value: string) => any;
        }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
            "update:modelValue": (value: string) => void;
        }, string, {}, {}, string, {}> & {
            beforeCreate?: (() => void) | (() => void)[];
            created?: (() => void) | (() => void)[];
            beforeMount?: (() => void) | (() => void)[];
            mounted?: (() => void) | (() => void)[];
            beforeUpdate?: (() => void) | (() => void)[];
            updated?: (() => void) | (() => void)[];
            activated?: (() => void) | (() => void)[];
            deactivated?: (() => void) | (() => void)[];
            beforeDestroy?: (() => void) | (() => void)[];
            beforeUnmount?: (() => void) | (() => void)[];
            destroyed?: (() => void) | (() => void)[];
            unmounted?: (() => void) | (() => void)[];
            renderTracked?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
            renderTriggered?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
            errorCaptured?: ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>, info: string) => boolean | void) | ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>, info: string) => boolean | void)[];
        };
        $forceUpdate: () => void;
        $nextTick: typeof import("@vue/runtime-core").nextTick;
        $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (args_0: R, args_1: R) => any : (...args: any) => any, options?: import("@vue/runtime-core").WatchOptions<boolean>): import("@vue/runtime-core").WatchStopHandle;
    } & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
        title: {
            type: import("@vue/runtime-core").PropType<string>;
        };
        modelValue: {
            type: import("@vue/runtime-core").PropType<string>;
        };
        options: {
            type: import("@vue/runtime-core").PropType<import("./types").HstControlOption[]>;
            required: true;
        };
    }>> & {
        "onUpdate:modelValue"?: (value: string) => any;
    } & import("@vue/reactivity").ShallowUnwrapRef<{}> & {} & import("@vue/runtime-core").ComponentCustomProperties & {};
    __isFragment?: never;
    __isTeleport?: never;
    __isSuspense?: never;
} & import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
    title: {
        type: import("@vue/runtime-core").PropType<string>;
    };
    modelValue: {
        type: import("@vue/runtime-core").PropType<string>;
    };
    options: {
        type: import("@vue/runtime-core").PropType<import("./types").HstControlOption[]>;
        required: true;
    };
}>> & {
    "onUpdate:modelValue"?: (value: string) => any;
}, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
    "update:modelValue": (value: string) => void;
}, string, {}, {}, string, {}> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & (new () => {
    $slots: {
        actions?(_: {}): any;
    };
});
export declare const HstJson: {
    new (...args: any[]): {
        $: import("@vue/runtime-core").ComponentInternalInstance;
        $data: {};
        $props: Partial<{}> & Omit<{
            readonly modelValue: unknown;
            readonly title?: string;
            "onUpdate:modelValue"?: (newValue: unknown) => any;
        } & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            title: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            modelValue: {
                type: import("@vue/runtime-core").PropType<unknown>;
                required: true;
            };
        }>> & {
            "onUpdate:modelValue"?: (newValue: unknown) => any;
        }, never>;
        $attrs: {
            [x: string]: unknown;
        };
        $refs: {
            [x: string]: unknown;
        };
        $slots: Readonly<{
            [name: string]: import("@vue/runtime-core").Slot<any>;
        }>;
        $root: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>;
        $parent: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>;
        $emit: (event: "update:modelValue", newValue: unknown) => void;
        $el: any;
        $options: import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            title: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            modelValue: {
                type: import("@vue/runtime-core").PropType<unknown>;
                required: true;
            };
        }>> & {
            "onUpdate:modelValue"?: (newValue: unknown) => any;
        }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
            "update:modelValue": (newValue: unknown) => void;
        }, string, {}, {}, string, {}> & {
            beforeCreate?: (() => void) | (() => void)[];
            created?: (() => void) | (() => void)[];
            beforeMount?: (() => void) | (() => void)[];
            mounted?: (() => void) | (() => void)[];
            beforeUpdate?: (() => void) | (() => void)[];
            updated?: (() => void) | (() => void)[];
            activated?: (() => void) | (() => void)[];
            deactivated?: (() => void) | (() => void)[];
            beforeDestroy?: (() => void) | (() => void)[];
            beforeUnmount?: (() => void) | (() => void)[];
            destroyed?: (() => void) | (() => void)[];
            unmounted?: (() => void) | (() => void)[];
            renderTracked?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
            renderTriggered?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
            errorCaptured?: ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>, info: string) => boolean | void) | ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>, info: string) => boolean | void)[];
        };
        $forceUpdate: () => void;
        $nextTick: typeof import("@vue/runtime-core").nextTick;
        $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (args_0: R, args_1: R) => any : (...args: any) => any, options?: import("@vue/runtime-core").WatchOptions<boolean>): import("@vue/runtime-core").WatchStopHandle;
    } & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
        title: {
            type: import("@vue/runtime-core").PropType<string>;
        };
        modelValue: {
            type: import("@vue/runtime-core").PropType<unknown>;
            required: true;
        };
    }>> & {
        "onUpdate:modelValue"?: (newValue: unknown) => any;
    } & import("@vue/reactivity").ShallowUnwrapRef<{}> & {} & import("@vue/runtime-core").ComponentCustomProperties & {};
    __isFragment?: never;
    __isTeleport?: never;
    __isSuspense?: never;
} & import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
    title: {
        type: import("@vue/runtime-core").PropType<string>;
    };
    modelValue: {
        type: import("@vue/runtime-core").PropType<unknown>;
        required: true;
    };
}>> & {
    "onUpdate:modelValue"?: (newValue: unknown) => any;
}, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
    "update:modelValue": (newValue: unknown) => void;
}, string, {}, {}, string, {}> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & (new () => {
    $slots: {
        actions?(_: {}): any;
    };
});
export declare const HstColorSelect: {
    new (...args: any[]): {
        $: import("@vue/runtime-core").ComponentInternalInstance;
        $data: {};
        $props: Partial<{}> & Omit<{
            readonly title?: string;
            readonly modelValue?: string;
            "onUpdate:modelValue"?: (newValue: string) => any;
        } & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            title: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            modelValue: {
                type: import("@vue/runtime-core").PropType<string>;
            };
        }>> & {
            "onUpdate:modelValue"?: (newValue: string) => any;
        }, never>;
        $attrs: {
            [x: string]: unknown;
        };
        $refs: {
            [x: string]: unknown;
        };
        $slots: Readonly<{
            [name: string]: import("@vue/runtime-core").Slot<any>;
        }>;
        $root: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>;
        $parent: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>;
        $emit: (event: "update:modelValue", newValue: string) => void;
        $el: any;
        $options: import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            title: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            modelValue: {
                type: import("@vue/runtime-core").PropType<string>;
            };
        }>> & {
            "onUpdate:modelValue"?: (newValue: string) => any;
        }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
            "update:modelValue": (newValue: string) => void;
        }, string, {}, {}, string, {}> & {
            beforeCreate?: (() => void) | (() => void)[];
            created?: (() => void) | (() => void)[];
            beforeMount?: (() => void) | (() => void)[];
            mounted?: (() => void) | (() => void)[];
            beforeUpdate?: (() => void) | (() => void)[];
            updated?: (() => void) | (() => void)[];
            activated?: (() => void) | (() => void)[];
            deactivated?: (() => void) | (() => void)[];
            beforeDestroy?: (() => void) | (() => void)[];
            beforeUnmount?: (() => void) | (() => void)[];
            destroyed?: (() => void) | (() => void)[];
            unmounted?: (() => void) | (() => void)[];
            renderTracked?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
            renderTriggered?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
            errorCaptured?: ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>, info: string) => boolean | void) | ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>, info: string) => boolean | void)[];
        };
        $forceUpdate: () => void;
        $nextTick: typeof import("@vue/runtime-core").nextTick;
        $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (args_0: R, args_1: R) => any : (...args: any) => any, options?: import("@vue/runtime-core").WatchOptions<boolean>): import("@vue/runtime-core").WatchStopHandle;
    } & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
        title: {
            type: import("@vue/runtime-core").PropType<string>;
        };
        modelValue: {
            type: import("@vue/runtime-core").PropType<string>;
        };
    }>> & {
        "onUpdate:modelValue"?: (newValue: string) => any;
    } & import("@vue/reactivity").ShallowUnwrapRef<{}> & {} & import("@vue/runtime-core").ComponentCustomProperties & {};
    __isFragment?: never;
    __isTeleport?: never;
    __isSuspense?: never;
} & import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
    title: {
        type: import("@vue/runtime-core").PropType<string>;
    };
    modelValue: {
        type: import("@vue/runtime-core").PropType<string>;
    };
}>> & {
    "onUpdate:modelValue"?: (newValue: string) => any;
}, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
    "update:modelValue": (newValue: string) => void;
}, string, {}, {}, string, {}> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & (new () => {
    $slots: {
        actions?(_: {}): any;
    };
});
export declare const components: {
    HstButton: {
        new (...args: any[]): {
            $: import("@vue/runtime-core").ComponentInternalInstance;
            $data: {};
            $props: Partial<{}> & Omit<{
                readonly color?: "default" | "primary" | "flat";
            } & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
                color: {
                    type: import("@vue/runtime-core").PropType<"default" | "primary" | "flat">;
                };
            }>>, never>;
            $attrs: {
                [x: string]: unknown;
            };
            $refs: {
                [x: string]: unknown;
            };
            $slots: Readonly<{
                [name: string]: import("@vue/runtime-core").Slot<any>;
            }>;
            $root: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>;
            $parent: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>;
            $emit: (event: string, ...args: any[]) => void;
            $el: any;
            $options: import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
                color: {
                    type: import("@vue/runtime-core").PropType<"default" | "primary" | "flat">;
                };
            }>>, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {}, string, {}, {}, string, {}> & {
                beforeCreate?: (() => void) | (() => void)[];
                created?: (() => void) | (() => void)[];
                beforeMount?: (() => void) | (() => void)[];
                mounted?: (() => void) | (() => void)[];
                beforeUpdate?: (() => void) | (() => void)[];
                updated?: (() => void) | (() => void)[];
                activated?: (() => void) | (() => void)[];
                deactivated?: (() => void) | (() => void)[];
                beforeDestroy?: (() => void) | (() => void)[];
                beforeUnmount?: (() => void) | (() => void)[];
                destroyed?: (() => void) | (() => void)[];
                unmounted?: (() => void) | (() => void)[];
                renderTracked?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
                renderTriggered?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
                errorCaptured?: ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>, info: string) => boolean | void) | ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>, info: string) => boolean | void)[];
            };
            $forceUpdate: () => void;
            $nextTick: typeof import("@vue/runtime-core").nextTick;
            $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (args_0: R, args_1: R) => any : (...args: any) => any, options?: import("@vue/runtime-core").WatchOptions<boolean>): import("@vue/runtime-core").WatchStopHandle;
        } & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            color: {
                type: import("@vue/runtime-core").PropType<"default" | "primary" | "flat">;
            };
        }>> & import("@vue/reactivity").ShallowUnwrapRef<{}> & {} & import("@vue/runtime-core").ComponentCustomProperties & {};
        __isFragment?: never;
        __isTeleport?: never;
        __isSuspense?: never;
    } & import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
        color: {
            type: import("@vue/runtime-core").PropType<"default" | "primary" | "flat">;
        };
    }>>, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {}, string, {}, {}, string, {}> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & (new () => {
        $slots: {
            default?(_: {}): any;
        };
    });
    HstButtonGroup: {
        new (...args: any[]): {
            $: import("@vue/runtime-core").ComponentInternalInstance;
            $data: {};
            $props: Partial<{}> & Omit<{
                readonly options: string[] | Record<string, string | number> | number[] | import("./types").HstControlOption[];
                readonly title?: string;
                readonly modelValue?: string;
                "onUpdate:modelValue"?: (value: string) => any;
            } & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
                title: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
                modelValue: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
                options: {
                    type: import("@vue/runtime-core").PropType<string[] | Record<string, string | number> | number[] | import("./types").HstControlOption[]>;
                    required: true;
                };
            }>> & {
                "onUpdate:modelValue"?: (value: string) => any;
            }, never>;
            $attrs: {
                [x: string]: unknown;
            };
            $refs: {
                [x: string]: unknown;
            };
            $slots: Readonly<{
                [name: string]: import("@vue/runtime-core").Slot<any>;
            }>;
            $root: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>;
            $parent: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>;
            $emit: (event: "update:modelValue", value: string) => void;
            $el: any;
            $options: import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
                title: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
                modelValue: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
                options: {
                    type: import("@vue/runtime-core").PropType<string[] | Record<string, string | number> | number[] | import("./types").HstControlOption[]>;
                    required: true;
                };
            }>> & {
                "onUpdate:modelValue"?: (value: string) => any;
            }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
                "update:modelValue": (value: string) => void;
            }, string, {}, {}, string, {}> & {
                beforeCreate?: (() => void) | (() => void)[];
                created?: (() => void) | (() => void)[];
                beforeMount?: (() => void) | (() => void)[];
                mounted?: (() => void) | (() => void)[];
                beforeUpdate?: (() => void) | (() => void)[];
                updated?: (() => void) | (() => void)[];
                activated?: (() => void) | (() => void)[];
                deactivated?: (() => void) | (() => void)[];
                beforeDestroy?: (() => void) | (() => void)[];
                beforeUnmount?: (() => void) | (() => void)[];
                destroyed?: (() => void) | (() => void)[];
                unmounted?: (() => void) | (() => void)[];
                renderTracked?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
                renderTriggered?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
                errorCaptured?: ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>, info: string) => boolean | void) | ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>, info: string) => boolean | void)[];
            };
            $forceUpdate: () => void;
            $nextTick: typeof import("@vue/runtime-core").nextTick;
            $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (args_0: R, args_1: R) => any : (...args: any) => any, options?: import("@vue/runtime-core").WatchOptions<boolean>): import("@vue/runtime-core").WatchStopHandle;
        } & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            title: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            modelValue: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            options: {
                type: import("@vue/runtime-core").PropType<string[] | Record<string, string | number> | number[] | import("./types").HstControlOption[]>;
                required: true;
            };
        }>> & {
            "onUpdate:modelValue"?: (value: string) => any;
        } & import("@vue/reactivity").ShallowUnwrapRef<{}> & {} & import("@vue/runtime-core").ComponentCustomProperties & {};
        __isFragment?: never;
        __isTeleport?: never;
        __isSuspense?: never;
    } & import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
        title: {
            type: import("@vue/runtime-core").PropType<string>;
        };
        modelValue: {
            type: import("@vue/runtime-core").PropType<string>;
        };
        options: {
            type: import("@vue/runtime-core").PropType<string[] | Record<string, string | number> | number[] | import("./types").HstControlOption[]>;
            required: true;
        };
    }>> & {
        "onUpdate:modelValue"?: (value: string) => any;
    }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
        "update:modelValue": (value: string) => void;
    }, string, {}, {}, string, {}> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & (new () => {
        $slots: {
            actions?(_: {}): any;
        };
    });
    HstCheckbox: {
        new (...args: any[]): {
            $: import("@vue/runtime-core").ComponentInternalInstance;
            $data: {};
            $props: Partial<{}> & Omit<{
                readonly title?: string;
                readonly modelValue?: boolean | "true" | "false";
                "onUpdate:modelValue"?: (newValue: boolean | "true" | "false") => any;
            } & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
                modelValue: {
                    type: import("@vue/runtime-core").PropType<boolean | "true" | "false">;
                };
                title: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
            }>> & {
                "onUpdate:modelValue"?: (newValue: boolean | "true" | "false") => any;
            }, never>;
            $attrs: {
                [x: string]: unknown;
            };
            $refs: {
                [x: string]: unknown;
            };
            $slots: Readonly<{
                [name: string]: import("@vue/runtime-core").Slot<any>;
            }>;
            $root: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>;
            $parent: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>;
            $emit: (event: "update:modelValue", newValue: boolean | "true" | "false") => void;
            $el: any;
            $options: import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
                modelValue: {
                    type: import("@vue/runtime-core").PropType<boolean | "true" | "false">;
                };
                title: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
            }>> & {
                "onUpdate:modelValue"?: (newValue: boolean | "true" | "false") => any;
            }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
                "update:modelValue": (newValue: boolean | "true" | "false") => void;
            }, string, {}, {}, string, {}> & {
                beforeCreate?: (() => void) | (() => void)[];
                created?: (() => void) | (() => void)[];
                beforeMount?: (() => void) | (() => void)[];
                mounted?: (() => void) | (() => void)[];
                beforeUpdate?: (() => void) | (() => void)[];
                updated?: (() => void) | (() => void)[];
                activated?: (() => void) | (() => void)[];
                deactivated?: (() => void) | (() => void)[];
                beforeDestroy?: (() => void) | (() => void)[];
                beforeUnmount?: (() => void) | (() => void)[];
                destroyed?: (() => void) | (() => void)[];
                unmounted?: (() => void) | (() => void)[];
                renderTracked?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
                renderTriggered?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
                errorCaptured?: ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>, info: string) => boolean | void) | ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>, info: string) => boolean | void)[];
            };
            $forceUpdate: () => void;
            $nextTick: typeof import("@vue/runtime-core").nextTick;
            $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (args_0: R, args_1: R) => any : (...args: any) => any, options?: import("@vue/runtime-core").WatchOptions<boolean>): import("@vue/runtime-core").WatchStopHandle;
        } & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            modelValue: {
                type: import("@vue/runtime-core").PropType<boolean | "true" | "false">;
            };
            title: {
                type: import("@vue/runtime-core").PropType<string>;
            };
        }>> & {
            "onUpdate:modelValue"?: (newValue: boolean | "true" | "false") => any;
        } & import("@vue/reactivity").ShallowUnwrapRef<{}> & {} & import("@vue/runtime-core").ComponentCustomProperties & {};
        __isFragment?: never;
        __isTeleport?: never;
        __isSuspense?: never;
    } & import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
        modelValue: {
            type: import("@vue/runtime-core").PropType<boolean | "true" | "false">;
        };
        title: {
            type: import("@vue/runtime-core").PropType<string>;
        };
    }>> & {
        "onUpdate:modelValue"?: (newValue: boolean | "true" | "false") => any;
    }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
        "update:modelValue": (newValue: boolean | "true" | "false") => void;
    }, string, {}, {}, string, {}> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & (new () => {
        $slots: {
            actions?(_: {}): any;
        };
    });
    HstCheckboxList: {
        new (...args: any[]): {
            $: import("@vue/runtime-core").ComponentInternalInstance;
            $data: {};
            $props: Partial<{}> & Omit<{
                readonly modelValue: string[];
                readonly options: string[] | import("./types").HstControlOption[];
                readonly title?: string;
                "onUpdate:modelValue"?: (value: string[]) => any;
            } & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
                title: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
                modelValue: {
                    type: import("@vue/runtime-core").PropType<string[]>;
                    required: true;
                };
                options: {
                    type: import("@vue/runtime-core").PropType<string[] | import("./types").HstControlOption[]>;
                    required: true;
                };
            }>> & {
                "onUpdate:modelValue"?: (value: string[]) => any;
            }, never>;
            $attrs: {
                [x: string]: unknown;
            };
            $refs: {
                [x: string]: unknown;
            };
            $slots: Readonly<{
                [name: string]: import("@vue/runtime-core").Slot<any>;
            }>;
            $root: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>;
            $parent: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>;
            $emit: (event: "update:modelValue", value: string[]) => void;
            $el: any;
            $options: import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
                title: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
                modelValue: {
                    type: import("@vue/runtime-core").PropType<string[]>;
                    required: true;
                };
                options: {
                    type: import("@vue/runtime-core").PropType<string[] | import("./types").HstControlOption[]>;
                    required: true;
                };
            }>> & {
                "onUpdate:modelValue"?: (value: string[]) => any;
            }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
                "update:modelValue": (value: string[]) => void;
            }, string, {}, {}, string, {}> & {
                beforeCreate?: (() => void) | (() => void)[];
                created?: (() => void) | (() => void)[];
                beforeMount?: (() => void) | (() => void)[];
                mounted?: (() => void) | (() => void)[];
                beforeUpdate?: (() => void) | (() => void)[];
                updated?: (() => void) | (() => void)[];
                activated?: (() => void) | (() => void)[];
                deactivated?: (() => void) | (() => void)[];
                beforeDestroy?: (() => void) | (() => void)[];
                beforeUnmount?: (() => void) | (() => void)[];
                destroyed?: (() => void) | (() => void)[];
                unmounted?: (() => void) | (() => void)[];
                renderTracked?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
                renderTriggered?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
                errorCaptured?: ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>, info: string) => boolean | void) | ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>, info: string) => boolean | void)[];
            };
            $forceUpdate: () => void;
            $nextTick: typeof import("@vue/runtime-core").nextTick;
            $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (args_0: R, args_1: R) => any : (...args: any) => any, options?: import("@vue/runtime-core").WatchOptions<boolean>): import("@vue/runtime-core").WatchStopHandle;
        } & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            title: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            modelValue: {
                type: import("@vue/runtime-core").PropType<string[]>;
                required: true;
            };
            options: {
                type: import("@vue/runtime-core").PropType<string[] | import("./types").HstControlOption[]>;
                required: true;
            };
        }>> & {
            "onUpdate:modelValue"?: (value: string[]) => any;
        } & import("@vue/reactivity").ShallowUnwrapRef<{}> & {} & import("@vue/runtime-core").ComponentCustomProperties & {};
        __isFragment?: never;
        __isTeleport?: never;
        __isSuspense?: never;
    } & import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
        title: {
            type: import("@vue/runtime-core").PropType<string>;
        };
        modelValue: {
            type: import("@vue/runtime-core").PropType<string[]>;
            required: true;
        };
        options: {
            type: import("@vue/runtime-core").PropType<string[] | import("./types").HstControlOption[]>;
            required: true;
        };
    }>> & {
        "onUpdate:modelValue"?: (value: string[]) => any;
    }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
        "update:modelValue": (value: string[]) => void;
    }, string, {}, {}, string, {}> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & (new () => {
        $slots: {
            actions?(_: {}): any;
        };
    });
    HstText: {
        new (...args: any[]): {
            $: import("@vue/runtime-core").ComponentInternalInstance;
            $data: {};
            $props: Partial<{}> & Omit<{
                readonly title?: string;
                readonly modelValue?: string;
                "onUpdate:modelValue"?: (newValue: string) => any;
            } & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
                title: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
                modelValue: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
            }>> & {
                "onUpdate:modelValue"?: (newValue: string) => any;
            }, never>;
            $attrs: {
                [x: string]: unknown;
            };
            $refs: {
                [x: string]: unknown;
            };
            $slots: Readonly<{
                [name: string]: import("@vue/runtime-core").Slot<any>;
            }>;
            $root: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>;
            $parent: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>;
            $emit: (event: "update:modelValue", newValue: string) => void;
            $el: any;
            $options: import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
                title: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
                modelValue: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
            }>> & {
                "onUpdate:modelValue"?: (newValue: string) => any;
            }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
                "update:modelValue": (newValue: string) => void;
            }, string, {}, {}, string, {}> & {
                beforeCreate?: (() => void) | (() => void)[];
                created?: (() => void) | (() => void)[];
                beforeMount?: (() => void) | (() => void)[];
                mounted?: (() => void) | (() => void)[];
                beforeUpdate?: (() => void) | (() => void)[];
                updated?: (() => void) | (() => void)[];
                activated?: (() => void) | (() => void)[];
                deactivated?: (() => void) | (() => void)[];
                beforeDestroy?: (() => void) | (() => void)[];
                beforeUnmount?: (() => void) | (() => void)[];
                destroyed?: (() => void) | (() => void)[];
                unmounted?: (() => void) | (() => void)[];
                renderTracked?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
                renderTriggered?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
                errorCaptured?: ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>, info: string) => boolean | void) | ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>, info: string) => boolean | void)[];
            };
            $forceUpdate: () => void;
            $nextTick: typeof import("@vue/runtime-core").nextTick;
            $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (args_0: R, args_1: R) => any : (...args: any) => any, options?: import("@vue/runtime-core").WatchOptions<boolean>): import("@vue/runtime-core").WatchStopHandle;
        } & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            title: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            modelValue: {
                type: import("@vue/runtime-core").PropType<string>;
            };
        }>> & {
            "onUpdate:modelValue"?: (newValue: string) => any;
        } & import("@vue/reactivity").ShallowUnwrapRef<{}> & {} & import("@vue/runtime-core").ComponentCustomProperties & {};
        __isFragment?: never;
        __isTeleport?: never;
        __isSuspense?: never;
    } & import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
        title: {
            type: import("@vue/runtime-core").PropType<string>;
        };
        modelValue: {
            type: import("@vue/runtime-core").PropType<string>;
        };
    }>> & {
        "onUpdate:modelValue"?: (newValue: string) => any;
    }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
        "update:modelValue": (newValue: string) => void;
    }, string, {}, {}, string, {}> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & (new () => {
        $slots: {
            actions?(_: {}): any;
        };
    });
    HstNumber: {
        new (...args: any[]): {
            $: import("@vue/runtime-core").ComponentInternalInstance;
            $data: {};
            $props: Partial<{}> & Omit<{
                readonly title?: string;
                readonly modelValue?: number;
                "onUpdate:modelValue"?: (newValue: number) => any;
            } & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
                title: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
                modelValue: {
                    type: import("@vue/runtime-core").PropType<number>;
                };
            }>> & {
                "onUpdate:modelValue"?: (newValue: number) => any;
            }, never>;
            $attrs: {
                [x: string]: unknown;
            };
            $refs: {
                [x: string]: unknown;
            };
            $slots: Readonly<{
                [name: string]: import("@vue/runtime-core").Slot<any>;
            }>;
            $root: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>;
            $parent: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>;
            $emit: (event: "update:modelValue", newValue: number) => void;
            $el: any;
            $options: import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
                title: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
                modelValue: {
                    type: import("@vue/runtime-core").PropType<number>;
                };
            }>> & {
                "onUpdate:modelValue"?: (newValue: number) => any;
            }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
                "update:modelValue": (newValue: number) => void;
            }, string, {}, {}, string, {}> & {
                beforeCreate?: (() => void) | (() => void)[];
                created?: (() => void) | (() => void)[];
                beforeMount?: (() => void) | (() => void)[];
                mounted?: (() => void) | (() => void)[];
                beforeUpdate?: (() => void) | (() => void)[];
                updated?: (() => void) | (() => void)[];
                activated?: (() => void) | (() => void)[];
                deactivated?: (() => void) | (() => void)[];
                beforeDestroy?: (() => void) | (() => void)[];
                beforeUnmount?: (() => void) | (() => void)[];
                destroyed?: (() => void) | (() => void)[];
                unmounted?: (() => void) | (() => void)[];
                renderTracked?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
                renderTriggered?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
                errorCaptured?: ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>, info: string) => boolean | void) | ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>, info: string) => boolean | void)[];
            };
            $forceUpdate: () => void;
            $nextTick: typeof import("@vue/runtime-core").nextTick;
            $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (args_0: R, args_1: R) => any : (...args: any) => any, options?: import("@vue/runtime-core").WatchOptions<boolean>): import("@vue/runtime-core").WatchStopHandle;
        } & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            title: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            modelValue: {
                type: import("@vue/runtime-core").PropType<number>;
            };
        }>> & {
            "onUpdate:modelValue"?: (newValue: number) => any;
        } & import("@vue/reactivity").ShallowUnwrapRef<{}> & {} & import("@vue/runtime-core").ComponentCustomProperties & {};
        __isFragment?: never;
        __isTeleport?: never;
        __isSuspense?: never;
    } & import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
        title: {
            type: import("@vue/runtime-core").PropType<string>;
        };
        modelValue: {
            type: import("@vue/runtime-core").PropType<number>;
        };
    }>> & {
        "onUpdate:modelValue"?: (newValue: number) => any;
    }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
        "update:modelValue": (newValue: number) => void;
    }, string, {}, {}, string, {}> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & (new () => {
        $slots: {
            actions?(_: {}): any;
        };
    });
    HstSlider: import("@vue/runtime-core").DefineComponent<{
        title: {
            type: import("@vue/runtime-core").PropType<string>;
        };
        modelValue: {
            type: import("@vue/runtime-core").PropType<number>;
        };
        min: {
            type: import("@vue/runtime-core").PropType<number>;
            required: true;
        };
        max: {
            type: import("@vue/runtime-core").PropType<number>;
            required: true;
        };
    }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
        "update:modelValue": (newValue: number) => void;
    }, string, import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps, Readonly<import("@vue/runtime-core").ExtractPropTypes<{
        title: {
            type: import("@vue/runtime-core").PropType<string>;
        };
        modelValue: {
            type: import("@vue/runtime-core").PropType<number>;
        };
        min: {
            type: import("@vue/runtime-core").PropType<number>;
            required: true;
        };
        max: {
            type: import("@vue/runtime-core").PropType<number>;
            required: true;
        };
    }>> & {
        "onUpdate:modelValue"?: (newValue: number) => any;
    }, {}, {}>;
    HstTextarea: {
        new (...args: any[]): {
            $: import("@vue/runtime-core").ComponentInternalInstance;
            $data: {};
            $props: Partial<{}> & Omit<{
                readonly title?: string;
                readonly modelValue?: string;
                "onUpdate:modelValue"?: (newValue: string) => any;
            } & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
                title: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
                modelValue: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
            }>> & {
                "onUpdate:modelValue"?: (newValue: string) => any;
            }, never>;
            $attrs: {
                [x: string]: unknown;
            };
            $refs: {
                [x: string]: unknown;
            };
            $slots: Readonly<{
                [name: string]: import("@vue/runtime-core").Slot<any>;
            }>;
            $root: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>;
            $parent: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>;
            $emit: (event: "update:modelValue", newValue: string) => void;
            $el: any;
            $options: import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
                title: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
                modelValue: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
            }>> & {
                "onUpdate:modelValue"?: (newValue: string) => any;
            }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
                "update:modelValue": (newValue: string) => void;
            }, string, {}, {}, string, {}> & {
                beforeCreate?: (() => void) | (() => void)[];
                created?: (() => void) | (() => void)[];
                beforeMount?: (() => void) | (() => void)[];
                mounted?: (() => void) | (() => void)[];
                beforeUpdate?: (() => void) | (() => void)[];
                updated?: (() => void) | (() => void)[];
                activated?: (() => void) | (() => void)[];
                deactivated?: (() => void) | (() => void)[];
                beforeDestroy?: (() => void) | (() => void)[];
                beforeUnmount?: (() => void) | (() => void)[];
                destroyed?: (() => void) | (() => void)[];
                unmounted?: (() => void) | (() => void)[];
                renderTracked?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
                renderTriggered?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
                errorCaptured?: ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>, info: string) => boolean | void) | ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>, info: string) => boolean | void)[];
            };
            $forceUpdate: () => void;
            $nextTick: typeof import("@vue/runtime-core").nextTick;
            $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (args_0: R, args_1: R) => any : (...args: any) => any, options?: import("@vue/runtime-core").WatchOptions<boolean>): import("@vue/runtime-core").WatchStopHandle;
        } & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            title: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            modelValue: {
                type: import("@vue/runtime-core").PropType<string>;
            };
        }>> & {
            "onUpdate:modelValue"?: (newValue: string) => any;
        } & import("@vue/reactivity").ShallowUnwrapRef<{}> & {} & import("@vue/runtime-core").ComponentCustomProperties & {};
        __isFragment?: never;
        __isTeleport?: never;
        __isSuspense?: never;
    } & import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
        title: {
            type: import("@vue/runtime-core").PropType<string>;
        };
        modelValue: {
            type: import("@vue/runtime-core").PropType<string>;
        };
    }>> & {
        "onUpdate:modelValue"?: (newValue: string) => any;
    }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
        "update:modelValue": (newValue: string) => void;
    }, string, {}, {}, string, {}> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & (new () => {
        $slots: {
            actions?(_: {}): any;
        };
    });
    HstSelect: {
        new (...args: any[]): {
            $: import("@vue/runtime-core").ComponentInternalInstance;
            $data: {};
            $props: Partial<{}> & Omit<{
                readonly options: unknown;
                readonly title?: string;
                readonly modelValue?: any;
                "onUpdate:modelValue"?: (value: any) => any;
            } & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
                title: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
                modelValue: {
                    type: import("@vue/runtime-core").PropType<any>;
                };
                options: {
                    type: import("@vue/runtime-core").PropType<Record<string, any> | string[] | import("./types").HstControlOption[]>;
                    required: true;
                };
            }>> & {
                "onUpdate:modelValue"?: (value: any) => any;
            }, never>;
            $attrs: {
                [x: string]: unknown;
            };
            $refs: {
                [x: string]: unknown;
            };
            $slots: Readonly<{
                [name: string]: import("@vue/runtime-core").Slot<any>;
            }>;
            $root: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>;
            $parent: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>;
            $emit: (event: "update:modelValue", value: any) => void;
            $el: any;
            $options: import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
                title: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
                modelValue: {
                    type: import("@vue/runtime-core").PropType<any>;
                };
                options: {
                    type: import("@vue/runtime-core").PropType<Record<string, any> | string[] | import("./types").HstControlOption[]>;
                    required: true;
                };
            }>> & {
                "onUpdate:modelValue"?: (value: any) => any;
            }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
                "update:modelValue": (value: any) => void;
            }, string, {}, {}, string, {}> & {
                beforeCreate?: (() => void) | (() => void)[];
                created?: (() => void) | (() => void)[];
                beforeMount?: (() => void) | (() => void)[];
                mounted?: (() => void) | (() => void)[];
                beforeUpdate?: (() => void) | (() => void)[];
                updated?: (() => void) | (() => void)[];
                activated?: (() => void) | (() => void)[];
                deactivated?: (() => void) | (() => void)[];
                beforeDestroy?: (() => void) | (() => void)[];
                beforeUnmount?: (() => void) | (() => void)[];
                destroyed?: (() => void) | (() => void)[];
                unmounted?: (() => void) | (() => void)[];
                renderTracked?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
                renderTriggered?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
                errorCaptured?: ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>, info: string) => boolean | void) | ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>, info: string) => boolean | void)[];
            };
            $forceUpdate: () => void;
            $nextTick: typeof import("@vue/runtime-core").nextTick;
            $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (args_0: R, args_1: R) => any : (...args: any) => any, options?: import("@vue/runtime-core").WatchOptions<boolean>): import("@vue/runtime-core").WatchStopHandle;
        } & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            title: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            modelValue: {
                type: import("@vue/runtime-core").PropType<any>;
            };
            options: {
                type: import("@vue/runtime-core").PropType<Record<string, any> | string[] | import("./types").HstControlOption[]>;
                required: true;
            };
        }>> & {
            "onUpdate:modelValue"?: (value: any) => any;
        } & import("@vue/reactivity").ShallowUnwrapRef<{}> & {} & import("@vue/runtime-core").ComponentCustomProperties & {};
        __isFragment?: never;
        __isTeleport?: never;
        __isSuspense?: never;
    } & import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
        title: {
            type: import("@vue/runtime-core").PropType<string>;
        };
        modelValue: {
            type: import("@vue/runtime-core").PropType<any>;
        };
        options: {
            type: import("@vue/runtime-core").PropType<Record<string, any> | string[] | import("./types").HstControlOption[]>;
            required: true;
        };
    }>> & {
        "onUpdate:modelValue"?: (value: any) => any;
    }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
        "update:modelValue": (value: any) => void;
    }, string, {}, {}, string, {}> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & (new () => {
        $slots: {
            actions?(_: {}): any;
        };
    });
    HstRadio: {
        new (...args: any[]): {
            $: import("@vue/runtime-core").ComponentInternalInstance;
            $data: {};
            $props: Partial<{}> & Omit<{
                readonly options: import("./types").HstControlOption[];
                readonly title?: string;
                readonly modelValue?: string;
                "onUpdate:modelValue"?: (value: string) => any;
            } & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
                title: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
                modelValue: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
                options: {
                    type: import("@vue/runtime-core").PropType<import("./types").HstControlOption[]>;
                    required: true;
                };
            }>> & {
                "onUpdate:modelValue"?: (value: string) => any;
            }, never>;
            $attrs: {
                [x: string]: unknown;
            };
            $refs: {
                [x: string]: unknown;
            };
            $slots: Readonly<{
                [name: string]: import("@vue/runtime-core").Slot<any>;
            }>;
            $root: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>;
            $parent: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>;
            $emit: (event: "update:modelValue", value: string) => void;
            $el: any;
            $options: import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
                title: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
                modelValue: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
                options: {
                    type: import("@vue/runtime-core").PropType<import("./types").HstControlOption[]>;
                    required: true;
                };
            }>> & {
                "onUpdate:modelValue"?: (value: string) => any;
            }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
                "update:modelValue": (value: string) => void;
            }, string, {}, {}, string, {}> & {
                beforeCreate?: (() => void) | (() => void)[];
                created?: (() => void) | (() => void)[];
                beforeMount?: (() => void) | (() => void)[];
                mounted?: (() => void) | (() => void)[];
                beforeUpdate?: (() => void) | (() => void)[];
                updated?: (() => void) | (() => void)[];
                activated?: (() => void) | (() => void)[];
                deactivated?: (() => void) | (() => void)[];
                beforeDestroy?: (() => void) | (() => void)[];
                beforeUnmount?: (() => void) | (() => void)[];
                destroyed?: (() => void) | (() => void)[];
                unmounted?: (() => void) | (() => void)[];
                renderTracked?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
                renderTriggered?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
                errorCaptured?: ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>, info: string) => boolean | void) | ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>, info: string) => boolean | void)[];
            };
            $forceUpdate: () => void;
            $nextTick: typeof import("@vue/runtime-core").nextTick;
            $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (args_0: R, args_1: R) => any : (...args: any) => any, options?: import("@vue/runtime-core").WatchOptions<boolean>): import("@vue/runtime-core").WatchStopHandle;
        } & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            title: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            modelValue: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            options: {
                type: import("@vue/runtime-core").PropType<import("./types").HstControlOption[]>;
                required: true;
            };
        }>> & {
            "onUpdate:modelValue"?: (value: string) => any;
        } & import("@vue/reactivity").ShallowUnwrapRef<{}> & {} & import("@vue/runtime-core").ComponentCustomProperties & {};
        __isFragment?: never;
        __isTeleport?: never;
        __isSuspense?: never;
    } & import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
        title: {
            type: import("@vue/runtime-core").PropType<string>;
        };
        modelValue: {
            type: import("@vue/runtime-core").PropType<string>;
        };
        options: {
            type: import("@vue/runtime-core").PropType<import("./types").HstControlOption[]>;
            required: true;
        };
    }>> & {
        "onUpdate:modelValue"?: (value: string) => any;
    }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
        "update:modelValue": (value: string) => void;
    }, string, {}, {}, string, {}> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & (new () => {
        $slots: {
            actions?(_: {}): any;
        };
    });
    HstJson: {
        new (...args: any[]): {
            $: import("@vue/runtime-core").ComponentInternalInstance;
            $data: {};
            $props: Partial<{}> & Omit<{
                readonly modelValue: unknown;
                readonly title?: string;
                "onUpdate:modelValue"?: (newValue: unknown) => any;
            } & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
                title: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
                modelValue: {
                    type: import("@vue/runtime-core").PropType<unknown>;
                    required: true;
                };
            }>> & {
                "onUpdate:modelValue"?: (newValue: unknown) => any;
            }, never>;
            $attrs: {
                [x: string]: unknown;
            };
            $refs: {
                [x: string]: unknown;
            };
            $slots: Readonly<{
                [name: string]: import("@vue/runtime-core").Slot<any>;
            }>;
            $root: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>;
            $parent: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>;
            $emit: (event: "update:modelValue", newValue: unknown) => void;
            $el: any;
            $options: import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
                title: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
                modelValue: {
                    type: import("@vue/runtime-core").PropType<unknown>;
                    required: true;
                };
            }>> & {
                "onUpdate:modelValue"?: (newValue: unknown) => any;
            }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
                "update:modelValue": (newValue: unknown) => void;
            }, string, {}, {}, string, {}> & {
                beforeCreate?: (() => void) | (() => void)[];
                created?: (() => void) | (() => void)[];
                beforeMount?: (() => void) | (() => void)[];
                mounted?: (() => void) | (() => void)[];
                beforeUpdate?: (() => void) | (() => void)[];
                updated?: (() => void) | (() => void)[];
                activated?: (() => void) | (() => void)[];
                deactivated?: (() => void) | (() => void)[];
                beforeDestroy?: (() => void) | (() => void)[];
                beforeUnmount?: (() => void) | (() => void)[];
                destroyed?: (() => void) | (() => void)[];
                unmounted?: (() => void) | (() => void)[];
                renderTracked?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
                renderTriggered?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
                errorCaptured?: ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>, info: string) => boolean | void) | ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>, info: string) => boolean | void)[];
            };
            $forceUpdate: () => void;
            $nextTick: typeof import("@vue/runtime-core").nextTick;
            $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (args_0: R, args_1: R) => any : (...args: any) => any, options?: import("@vue/runtime-core").WatchOptions<boolean>): import("@vue/runtime-core").WatchStopHandle;
        } & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            title: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            modelValue: {
                type: import("@vue/runtime-core").PropType<unknown>;
                required: true;
            };
        }>> & {
            "onUpdate:modelValue"?: (newValue: unknown) => any;
        } & import("@vue/reactivity").ShallowUnwrapRef<{}> & {} & import("@vue/runtime-core").ComponentCustomProperties & {};
        __isFragment?: never;
        __isTeleport?: never;
        __isSuspense?: never;
    } & import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
        title: {
            type: import("@vue/runtime-core").PropType<string>;
        };
        modelValue: {
            type: import("@vue/runtime-core").PropType<unknown>;
            required: true;
        };
    }>> & {
        "onUpdate:modelValue"?: (newValue: unknown) => any;
    }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
        "update:modelValue": (newValue: unknown) => void;
    }, string, {}, {}, string, {}> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & (new () => {
        $slots: {
            actions?(_: {}): any;
        };
    });
    HstColorShades: {
        new (...args: any[]): {
            $: import("@vue/runtime-core").ComponentInternalInstance;
            $data: {};
            $props: Partial<{}> & Omit<{
                readonly shades: unknown;
                readonly search?: string;
                readonly getName?: (key: string, color: string) => string;
            } & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
                shades: {
                    type: import("@vue/runtime-core").PropType<Record<string, any>>;
                    required: true;
                };
                getName: {
                    type: import("@vue/runtime-core").PropType<(key: string, color: string) => string>;
                };
                search: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
            }>>, never>;
            $attrs: {
                [x: string]: unknown;
            };
            $refs: {
                [x: string]: unknown;
            };
            $slots: Readonly<{
                [name: string]: import("@vue/runtime-core").Slot<any>;
            }>;
            $root: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>;
            $parent: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>;
            $emit: (event: string, ...args: any[]) => void;
            $el: any;
            $options: import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
                shades: {
                    type: import("@vue/runtime-core").PropType<Record<string, any>>;
                    required: true;
                };
                getName: {
                    type: import("@vue/runtime-core").PropType<(key: string, color: string) => string>;
                };
                search: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
            }>>, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {}, string, {}, {}, string, {}> & {
                beforeCreate?: (() => void) | (() => void)[];
                created?: (() => void) | (() => void)[];
                beforeMount?: (() => void) | (() => void)[];
                mounted?: (() => void) | (() => void)[];
                beforeUpdate?: (() => void) | (() => void)[];
                updated?: (() => void) | (() => void)[];
                activated?: (() => void) | (() => void)[];
                deactivated?: (() => void) | (() => void)[];
                beforeDestroy?: (() => void) | (() => void)[];
                beforeUnmount?: (() => void) | (() => void)[];
                destroyed?: (() => void) | (() => void)[];
                unmounted?: (() => void) | (() => void)[];
                renderTracked?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
                renderTriggered?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
                errorCaptured?: ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>, info: string) => boolean | void) | ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>, info: string) => boolean | void)[];
            };
            $forceUpdate: () => void;
            $nextTick: typeof import("@vue/runtime-core").nextTick;
            $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (args_0: R, args_1: R) => any : (...args: any) => any, options?: import("@vue/runtime-core").WatchOptions<boolean>): import("@vue/runtime-core").WatchStopHandle;
        } & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            shades: {
                type: import("@vue/runtime-core").PropType<Record<string, any>>;
                required: true;
            };
            getName: {
                type: import("@vue/runtime-core").PropType<(key: string, color: string) => string>;
            };
            search: {
                type: import("@vue/runtime-core").PropType<string>;
            };
        }>> & import("@vue/reactivity").ShallowUnwrapRef<{}> & {} & import("@vue/runtime-core").ComponentCustomProperties & {};
        __isFragment?: never;
        __isTeleport?: never;
        __isSuspense?: never;
    } & import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
        shades: {
            type: import("@vue/runtime-core").PropType<Record<string, any>>;
            required: true;
        };
        getName: {
            type: import("@vue/runtime-core").PropType<(key: string, color: string) => string>;
        };
        search: {
            type: import("@vue/runtime-core").PropType<string>;
        };
    }>>, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {}, string, {}, {}, string, {}> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & (new () => {
        $slots: {
            default?(_: {
                color: string;
            }): any;
        };
    });
    HstTokenList: {
        new (...args: any[]): {
            $: import("@vue/runtime-core").ComponentInternalInstance;
            $data: {};
            $props: Partial<{}> & Omit<{
                readonly tokens: Record<string, string | number | any[] | Record<string, any>>;
                readonly getName?: (key: string, value: string | number | any[] | Record<string, any>) => string;
            } & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
                tokens: {
                    type: import("@vue/runtime-core").PropType<Record<string, string | number | any[] | Record<string, any>>>;
                    required: true;
                };
                getName: {
                    type: import("@vue/runtime-core").PropType<(key: string, value: string | number | any[] | Record<string, any>) => string>;
                };
            }>>, never>;
            $attrs: {
                [x: string]: unknown;
            };
            $refs: {
                [x: string]: unknown;
            };
            $slots: Readonly<{
                [name: string]: import("@vue/runtime-core").Slot<any>;
            }>;
            $root: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>;
            $parent: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>;
            $emit: (event: string, ...args: any[]) => void;
            $el: any;
            $options: import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
                tokens: {
                    type: import("@vue/runtime-core").PropType<Record<string, string | number | any[] | Record<string, any>>>;
                    required: true;
                };
                getName: {
                    type: import("@vue/runtime-core").PropType<(key: string, value: string | number | any[] | Record<string, any>) => string>;
                };
            }>>, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {}, string, {}, {}, string, {}> & {
                beforeCreate?: (() => void) | (() => void)[];
                created?: (() => void) | (() => void)[];
                beforeMount?: (() => void) | (() => void)[];
                mounted?: (() => void) | (() => void)[];
                beforeUpdate?: (() => void) | (() => void)[];
                updated?: (() => void) | (() => void)[];
                activated?: (() => void) | (() => void)[];
                deactivated?: (() => void) | (() => void)[];
                beforeDestroy?: (() => void) | (() => void)[];
                beforeUnmount?: (() => void) | (() => void)[];
                destroyed?: (() => void) | (() => void)[];
                unmounted?: (() => void) | (() => void)[];
                renderTracked?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
                renderTriggered?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
                errorCaptured?: ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>, info: string) => boolean | void) | ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>, info: string) => boolean | void)[];
            };
            $forceUpdate: () => void;
            $nextTick: typeof import("@vue/runtime-core").nextTick;
            $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (args_0: R, args_1: R) => any : (...args: any) => any, options?: import("@vue/runtime-core").WatchOptions<boolean>): import("@vue/runtime-core").WatchStopHandle;
        } & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            tokens: {
                type: import("@vue/runtime-core").PropType<Record<string, string | number | any[] | Record<string, any>>>;
                required: true;
            };
            getName: {
                type: import("@vue/runtime-core").PropType<(key: string, value: string | number | any[] | Record<string, any>) => string>;
            };
        }>> & import("@vue/reactivity").ShallowUnwrapRef<{}> & {} & import("@vue/runtime-core").ComponentCustomProperties & {};
        __isFragment?: never;
        __isTeleport?: never;
        __isSuspense?: never;
    } & import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
        tokens: {
            type: import("@vue/runtime-core").PropType<Record<string, string | number | any[] | Record<string, any>>>;
            required: true;
        };
        getName: {
            type: import("@vue/runtime-core").PropType<(key: string, value: string | number | any[] | Record<string, any>) => string>;
        };
    }>>, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {}, string, {}, {}, string, {}> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & (new () => {
        $slots: {
            default?(_: {
                token: {
                    key: string;
                    name: string;
                    value: string | any[] | Record<string, any>;
                };
            }): any;
        };
    });
    HstTokenGrid: {
        new (...args: any[]): {
            $: import("@vue/runtime-core").ComponentInternalInstance;
            $data: {};
            $props: Partial<{
                getName: (key: string, value: string | number | any[] | Record<string, any>) => string;
                colSize: number;
            }> & Omit<{
                readonly tokens: Record<string, string | number | any[] | Record<string, any>>;
                readonly colSize: number;
                readonly getName?: (key: string, value: string | number | any[] | Record<string, any>) => string;
            } & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
                getName: {
                    type: import("@vue/runtime-core").PropType<(key: string, value: string | number | any[] | Record<string, any>) => string>;
                    default: any;
                };
                tokens: {
                    type: import("@vue/runtime-core").PropType<Record<string, string | number | any[] | Record<string, any>>>;
                    required: true;
                };
                colSize: {
                    type: import("@vue/runtime-core").PropType<number>;
                    default: number;
                };
            }>>, "getName" | "colSize">;
            $attrs: {
                [x: string]: unknown;
            };
            $refs: {
                [x: string]: unknown;
            };
            $slots: Readonly<{
                [name: string]: import("@vue/runtime-core").Slot<any>;
            }>;
            $root: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>;
            $parent: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>;
            $emit: (event: string, ...args: any[]) => void;
            $el: any;
            $options: import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
                getName: {
                    type: import("@vue/runtime-core").PropType<(key: string, value: string | number | any[] | Record<string, any>) => string>;
                    default: any;
                };
                tokens: {
                    type: import("@vue/runtime-core").PropType<Record<string, string | number | any[] | Record<string, any>>>;
                    required: true;
                };
                colSize: {
                    type: import("@vue/runtime-core").PropType<number>;
                    default: number;
                };
            }>>, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {}, string, {
                getName: (key: string, value: string | number | any[] | Record<string, any>) => string;
                colSize: number;
            }, {}, string, {}> & {
                beforeCreate?: (() => void) | (() => void)[];
                created?: (() => void) | (() => void)[];
                beforeMount?: (() => void) | (() => void)[];
                mounted?: (() => void) | (() => void)[];
                beforeUpdate?: (() => void) | (() => void)[];
                updated?: (() => void) | (() => void)[];
                activated?: (() => void) | (() => void)[];
                deactivated?: (() => void) | (() => void)[];
                beforeDestroy?: (() => void) | (() => void)[];
                beforeUnmount?: (() => void) | (() => void)[];
                destroyed?: (() => void) | (() => void)[];
                unmounted?: (() => void) | (() => void)[];
                renderTracked?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
                renderTriggered?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
                errorCaptured?: ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>, info: string) => boolean | void) | ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>, info: string) => boolean | void)[];
            };
            $forceUpdate: () => void;
            $nextTick: typeof import("@vue/runtime-core").nextTick;
            $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (args_0: R, args_1: R) => any : (...args: any) => any, options?: import("@vue/runtime-core").WatchOptions<boolean>): import("@vue/runtime-core").WatchStopHandle;
        } & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            getName: {
                type: import("@vue/runtime-core").PropType<(key: string, value: string | number | any[] | Record<string, any>) => string>;
                default: any;
            };
            tokens: {
                type: import("@vue/runtime-core").PropType<Record<string, string | number | any[] | Record<string, any>>>;
                required: true;
            };
            colSize: {
                type: import("@vue/runtime-core").PropType<number>;
                default: number;
            };
        }>> & import("@vue/reactivity").ShallowUnwrapRef<{}> & {} & import("@vue/runtime-core").ComponentCustomProperties & {};
        __isFragment?: never;
        __isTeleport?: never;
        __isSuspense?: never;
    } & import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
        getName: {
            type: import("@vue/runtime-core").PropType<(key: string, value: string | number | any[] | Record<string, any>) => string>;
            default: any;
        };
        tokens: {
            type: import("@vue/runtime-core").PropType<Record<string, string | number | any[] | Record<string, any>>>;
            required: true;
        };
        colSize: {
            type: import("@vue/runtime-core").PropType<number>;
            default: number;
        };
    }>>, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {}, string, {
        getName: (key: string, value: string | number | any[] | Record<string, any>) => string;
        colSize: number;
    }, {}, string, {}> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & (new () => {
        $slots: {
            default?(_: {
                token: {
                    key: string;
                    name: string;
                    value: string | any[] | Record<string, any>;
                };
            }): any;
        };
    });
    HstCopyIcon: import("@vue/runtime-core").DefineComponent<{
        content: {
            type: import("@vue/runtime-core").PropType<string | (() => import("@histoire/shared").Awaitable<string>)>;
            required: true;
        };
    }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {}, string, import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps, Readonly<import("@vue/runtime-core").ExtractPropTypes<{
        content: {
            type: import("@vue/runtime-core").PropType<string | (() => import("@histoire/shared").Awaitable<string>)>;
            required: true;
        };
    }>>, {}, {}>;
    HstColorSelect: {
        new (...args: any[]): {
            $: import("@vue/runtime-core").ComponentInternalInstance;
            $data: {};
            $props: Partial<{}> & Omit<{
                readonly title?: string;
                readonly modelValue?: string;
                "onUpdate:modelValue"?: (newValue: string) => any;
            } & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
                title: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
                modelValue: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
            }>> & {
                "onUpdate:modelValue"?: (newValue: string) => any;
            }, never>;
            $attrs: {
                [x: string]: unknown;
            };
            $refs: {
                [x: string]: unknown;
            };
            $slots: Readonly<{
                [name: string]: import("@vue/runtime-core").Slot<any>;
            }>;
            $root: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>;
            $parent: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>;
            $emit: (event: "update:modelValue", newValue: string) => void;
            $el: any;
            $options: import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
                title: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
                modelValue: {
                    type: import("@vue/runtime-core").PropType<string>;
                };
            }>> & {
                "onUpdate:modelValue"?: (newValue: string) => any;
            }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
                "update:modelValue": (newValue: string) => void;
            }, string, {}, {}, string, {}> & {
                beforeCreate?: (() => void) | (() => void)[];
                created?: (() => void) | (() => void)[];
                beforeMount?: (() => void) | (() => void)[];
                mounted?: (() => void) | (() => void)[];
                beforeUpdate?: (() => void) | (() => void)[];
                updated?: (() => void) | (() => void)[];
                activated?: (() => void) | (() => void)[];
                deactivated?: (() => void) | (() => void)[];
                beforeDestroy?: (() => void) | (() => void)[];
                beforeUnmount?: (() => void) | (() => void)[];
                destroyed?: (() => void) | (() => void)[];
                unmounted?: (() => void) | (() => void)[];
                renderTracked?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
                renderTriggered?: ((e: import("@vue/reactivity").DebuggerEvent) => void) | ((e: import("@vue/reactivity").DebuggerEvent) => void)[];
                errorCaptured?: ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>, info: string) => boolean | void) | ((err: unknown, instance: import("@vue/runtime-core").ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("@vue/runtime-core").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}, {}, string, {}>, {}, {}>, info: string) => boolean | void)[];
            };
            $forceUpdate: () => void;
            $nextTick: typeof import("@vue/runtime-core").nextTick;
            $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (args_0: R, args_1: R) => any : (...args: any) => any, options?: import("@vue/runtime-core").WatchOptions<boolean>): import("@vue/runtime-core").WatchStopHandle;
        } & Readonly<import("@vue/runtime-core").ExtractPropTypes<{
            title: {
                type: import("@vue/runtime-core").PropType<string>;
            };
            modelValue: {
                type: import("@vue/runtime-core").PropType<string>;
            };
        }>> & {
            "onUpdate:modelValue"?: (newValue: string) => any;
        } & import("@vue/reactivity").ShallowUnwrapRef<{}> & {} & import("@vue/runtime-core").ComponentCustomProperties & {};
        __isFragment?: never;
        __isTeleport?: never;
        __isSuspense?: never;
    } & import("@vue/runtime-core").ComponentOptionsBase<Readonly<import("@vue/runtime-core").ExtractPropTypes<{
        title: {
            type: import("@vue/runtime-core").PropType<string>;
        };
        modelValue: {
            type: import("@vue/runtime-core").PropType<string>;
        };
    }>> & {
        "onUpdate:modelValue"?: (newValue: string) => any;
    }, {}, unknown, {}, {}, import("@vue/runtime-core").ComponentOptionsMixin, import("@vue/runtime-core").ComponentOptionsMixin, {
        "update:modelValue": (newValue: string) => void;
    }, string, {}, {}, string, {}> & import("@vue/runtime-core").VNodeProps & import("@vue/runtime-core").AllowedComponentProps & import("@vue/runtime-core").ComponentCustomProps & (new () => {
        $slots: {
            actions?(_: {}): any;
        };
    });
};
export * from './types';
