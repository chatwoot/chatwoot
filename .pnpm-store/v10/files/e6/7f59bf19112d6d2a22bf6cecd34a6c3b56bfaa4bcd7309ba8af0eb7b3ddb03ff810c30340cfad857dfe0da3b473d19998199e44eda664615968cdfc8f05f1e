{"version":3,"sources":["../src/algorithms/jaroWinkler.ts","../src/utils.ts","../src/pico.ts"],"sourcesContent":["/**\n * Calculates the Jaro-Winkler similarity between two strings.\n * @param {string} str1 - The first string to compare.\n * @param {string} str2 - The second string to compare.\n * @returns {number} A value between 0 and 1 indicating the similarity between the two strings, where 1 means the strings are identical and 0 means the strings are completely different.\n */\nexport default function jaroWinkler(str1: string, str2: string): number {\n  // Swap strings if str1 is shorter than string 2\n  if (str1.length < str2.length) {\n    [str1, str2] = [str2, str1];\n  }\n\n  const len1 = str1.length;\n  const len2 = str2.length;\n\n  if (len1 === 0) return 0.0;\n  if (len2 === 0) return 0.0;\n\n  const delta = Math.floor(len1 / 2) - 1;\n\n  // Flags for transpositions\n  const flag = Array(len2).fill(false);\n  const ch1Match = Array(len1).fill(\"\");\n\n  // Count number of matching characters\n  let matches = 0;\n  // Check if characters on both string matches\n  for (let i = 0; i < len1; i++) {\n    const ch1: string = str1[i];\n    for (let j = 0; j < len2; j++) {\n      const ch2: string = str2[j];\n      if (j <= i + delta && j + delta >= 1 && ch1 === ch2 && !flag[j]) {\n        flag[j] = true;\n        ch1Match[matches++] = ch1;\n        break;\n      }\n    }\n  }\n\n  if (!matches) {\n    return 0;\n  }\n\n  // Count number of transpositions (shared characters placed in different positions)\n  let transpositions = 0.0;\n  for (let i = 0, j = 0; j < len2; j++) {\n    if (flag[j]) {\n      if (str2[j] !== ch1Match[i]) {\n        transpositions++;\n      }\n      i++;\n    }\n  }\n\n  const mCount: number = matches;\n\n  // Jaro Similarity Formula simj = ( (m / length of s1) + (m / length of s2) + (m - t) / m ) / 3\n  const jaro: number =\n    (mCount / len1 + mCount / len2 + (mCount - transpositions / 2.0) / mCount) /\n    3.0;\n\n  // Length of common prefix between string up to 4 characters\n  let commonPrefix = 0.0;\n  const prefixLength = Math.min(4, len2);\n\n  for (let i = 0; i < prefixLength; i++) {\n    if (str1[i] === str2[i]) {\n      commonPrefix++;\n    }\n  }\n\n  return jaro + commonPrefix * 0.1 * (1.0 - jaro);\n}\n","/**\n * Calculates the weighted average of a set of values.\n * @param {number[]} values - The values to be averaged.\n * @param {number[]} [weights] - The weights to be applied to the values.\n * @returns {number} The weighted average of the values.\n * @throws {Error} If the number of values is not equal to the number of weights.\n */\nexport function weightedAverage(values: number[], weights?: number[]): number {\n  let sum = 0;\n  let totalWeight = 0;\n\n  if (weights && values.length !== weights.length) {\n    throw new Error(\n      \"The number of values must be equal to the number of weights\",\n    );\n  }\n\n  for (let i = 0; i < values.length; i++) {\n    const weight = weights ? weights[i] : 1;\n    sum += values[i] * weight;\n    totalWeight += weight;\n  }\n\n  return sum / totalWeight;\n}\n\n/**\n * Clamps a number between a minimum and maximum value.\n * @param {number} value - The number to clamp.\n * @returns {number} The clamped value, which is between the minimum and maximum values.\n */\nexport function clamp(value: number): number {\n  return Math.max(0, Math.min(1, value));\n}\n\n/**\n * Splits a string into words, removes duplicates and empty words.\n * @param {string } value - The string to split and trim.\n * @returns {string[]} Returns an array of words, with duplicates and empty strings removed.\n */\nexport function splitAndTrim(value: string): string[] {\n  return value\n    .split(/\\s+/) // split by one or more whitespace characters\n    .filter((word, index, words) => word && words.indexOf(word) === index); // remove empty strings and duplicates\n}\n","import jaroWinkler from \"./algorithms/jaroWinkler\";\nimport { clamp, weightedAverage, splitAndTrim } from \"./utils\";\n\ninterface SearchResult<T> {\n  object: T;\n  similarity: number;\n}\n\ntype KeyWithWeight = { name: string; weight: number };\ntype Keys = Array<KeyWithWeight | string>;\n\nconst BOOST_FACTOR = {\n  CONTAINS_MATCH: 1.2,\n  FIRST_SIMILARITY: 1.1,\n  // this value is less than contains match,\n  // so that if a word starts with the search term, but also contains it,\n  // it will be boosted less than if it only contains it\n  STARTS_WITH: 1.05,\n};\n\n/**\n * Searches for objects in an array based on a search term and a set of keys.\n * @param {T[]} objectsArray - The array of objects to search.\n * @param {string} searchTerm - The search term to match against the objects.\n * @param {Keys} keys - The keys to search in each object.\n * @param {PicoSearchConfig} [config] - Configuration options for the search.\n * @returns {T[]} An array of objects that match the search criteria, ordered by their similarity from the search term.\n */\nexport function picoSearch<T>(\n  objectsArray: T[],\n  searchTerm: string,\n  keys: Keys,\n  config: { threshold: number },\n): T[] {\n  if (!searchTerm || typeof searchTerm !== \"string\") {\n    return objectsArray;\n  }\n\n  const results: SearchResult<T>[] = [];\n  const threshold = config?.threshold ?? 0.8;\n  const trimmedSearchTerm = searchTerm.trim().toLowerCase();\n  const splitSearchTerm = splitAndTrim(trimmedSearchTerm);\n\n  objectsArray.forEach((obj) => {\n    const similarityScores: number[] = [];\n    const weightsInOrder: number[] = [];\n\n    keys.forEach((key) => {\n      let keyToCheck: string;\n      let weight = 1;\n\n      if (typeof key === \"string\") {\n        keyToCheck = key;\n      } else {\n        keyToCheck = key.name;\n        weight = key.weight;\n      }\n\n      weightsInOrder.push(weight);\n      const valueToSearch = (obj as any)[keyToCheck]?.trim().toLowerCase(); // skipcq: JS-0323\n\n      if (valueToSearch) {\n        const similarity = splitWordsAndRank(valueToSearch, splitSearchTerm);\n        similarityScores.push(similarity);\n      } else {\n        similarityScores.push(0);\n      }\n    });\n\n    const similarityForObject = weightedAverage(\n      similarityScores,\n      weightsInOrder,\n    );\n\n    if (similarityForObject >= threshold) {\n      results.push({ object: obj, similarity: similarityForObject });\n    }\n  });\n\n  results.sort((a, b) => b.similarity - a.similarity);\n\n  return results.map((result) => result.object);\n}\n\n/**\n * Splits a string into words, removes duplicates and empty words, and calculates the similarity score for each word.\n * Returns the maximum similarity score, with a boost if the highest matching word shows up first.\n * @param {string} valueToSearch - The string to split into words and rank.\n * @param {string} searchTerm - The search term to match against the words.\n * @returns {number} The maximum similarity score, with a boost if the highest matching word shows up first.\n */\nfunction splitWordsAndRank(valueToSearch: string, splitSearchTerm: string[]) {\n  const splitSearchCandidate = splitAndTrim(valueToSearch);\n\n  const splitScores = splitSearchTerm.map((searchWord) => {\n    const similarityValues = splitSearchCandidate.map((word) =>\n      getScoreForWord(word, searchWord),\n    );\n\n    const maxSimilarity = Math.max(...similarityValues);\n\n    // boost score if the highest matching word shows up first\n    return maxSimilarity === similarityValues[0]\n      ? maxSimilarity * BOOST_FACTOR.FIRST_SIMILARITY\n      : clamp(maxSimilarity);\n  });\n\n  return weightedAverage(splitScores);\n}\n\n/**\n * Calculates the similarity score between a word and a search term using the Jaro-Winkler algorithm.\n * If the word includes the search term, the score is boosted by a factor.\n * @param {string} word - The word to compare to the search term.\n * @param {string} searchTerm - The search term to compare to the word.\n * @returns {number} The similarity score between the word and the search term, possibly boosted.\n */\nfunction getScoreForWord(word: string, searchTerm: string): number {\n  const jwScore = jaroWinkler(word, searchTerm);\n\n  return word.includes(searchTerm)\n    ? jwScore * BOOST_FACTOR.CONTAINS_MATCH\n    : jwScore;\n}\n"],"mappings":"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","names":["jaroWinkler","str1","str2","len1","len2","delta","flag","ch1Match","matches","i","ch1","j","ch2","transpositions","mCount","jaro","commonPrefix","prefixLength","weightedAverage","values","weights","sum","totalWeight","i","weight","clamp","value","splitAndTrim","word","index","words","BOOST_FACTOR","picoSearch","objectsArray","searchTerm","keys","config","results","threshold","trimmedSearchTerm","splitSearchTerm","splitAndTrim","obj","similarityScores","weightsInOrder","key","keyToCheck","weight","valueToSearch","similarity","splitWordsAndRank","similarityForObject","weightedAverage","a","b","result","splitSearchCandidate","splitScores","searchWord","similarityValues","word","getScoreForWord","maxSimilarity","clamp","jwScore","jaroWinkler"]}