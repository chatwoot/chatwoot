{"version":3,"sources":["../src/plugin.ts","../src/props.ts","../src/features/options.ts","../src/createSection.ts","../src/compose.ts","../src/sections/actions.ts","../src/sections/box.ts","../src/sections/boxHelp.ts","../src/sections/boxInner.ts","../src/sections/boxLabel.ts","../src/sections/boxOption.ts","../src/sections/boxOptions.ts","../src/sections/boxWrapper.ts","../src/sections/buttonInput.ts","../src/sections/buttonLabel.ts","../src/sections/decorator.ts","../src/sections/fieldset.ts","../src/sections/fileInput.ts","../src/sections/fileItem.ts","../src/sections/fileList.ts","../src/sections/fileName.ts","../src/sections/fileRemove.ts","../src/sections/formInput.ts","../src/sections/fragment.ts","../src/sections/help.ts","../src/sections/icon.ts","../src/sections/inner.ts","../src/sections/label.ts","../src/sections/legend.ts","../src/sections/message.ts","../src/sections/messages.ts","../src/sections/noFiles.ts","../src/sections/optGroup.ts","../src/sections/option.ts","../src/sections/optionSlot.ts","../src/sections/outer.ts","../src/sections/prefix.ts","../src/sections/selectInput.ts","../src/sections/submitInput.ts","../src/sections/suffix.ts","../src/sections/textInput.ts","../src/sections/textareaInput.ts","../src/sections/wrapper.ts","../src/features/renamesRadios.ts","../src/features/checkboxes.ts","../src/features/normalizeBoxes.ts","../src/features/icon.ts","../src/features/disables.ts","../src/features/localize.ts","../src/features/files.ts","../src/features/forms.ts","../src/features/ignores.ts","../src/features/initialValue.ts","../src/features/casts.ts","../src/features/radios.ts","../src/features/selects.ts","../src/inputs/button.ts","../src/inputs/checkbox.ts","../src/inputs/file.ts","../src/inputs/form.ts","../src/inputs/group.ts","../src/inputs/hidden.ts","../src/inputs/list.ts","../src/inputs/meta.ts","../src/inputs/radio.ts","../src/inputs/select.ts","../src/inputs/textarea.ts","../src/inputs/text.ts","../src/index.ts"],"names":["option","options","extend","fragment","isComponent","isDOM","warn","has","defaultIcon","files","file","createMessage","toggleChecked","isChecked","undefine","eq","optionValue","selectInput","form","select"],"mappings":";AAAA,SAAS,OAAO,QAAQ,WAAW;AAY5B,SAAS,uBACX,WACY;AAIf,QAAM,UAAU,UAAU;AAAA,IACxB,CAAC,QAAQ,QAAQ,OAAO,QAAQ,GAAG;AAAA,IACnC,CAAC;AAAA,EACH;AAEA,QAAM,SAAS,MAAM;AAAA,EAAC;AAKtB,SAAO,UAAU,SAAU,MAAmB;AAC5C,UAAM,OAAO,MAAM,KAAK,MAAM,IAAI;AAClC,QAAI,IAAI,SAAS,IAAI,GAAG;AACtB,WAAK,OAAO,QAAQ,IAAI,CAAC;AAAA,IAC3B;AAAA,EACF;AACA,SAAO;AACT;;;ACksBO,IAAM,eAAe;AAAA,EAC1B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA;AAAA,EAEA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;AAQO,SAAS,cACdA,SAImC;AACnC,SACEA,WACA,OAAOA,YAAW,YAClB,WAAWA,WACX,MAAM,QAAQA,QAAO,OAAO;AAEhC;;;AC5wBA,SAAS,IAAI,cAAc;AAYpB,SAAS,iBACdC,UACA,IAAI,EAAE,OAAO,EAAE,GAGgB;AAC/B,MAAI,MAAM,QAAQA,QAAO,GAAG;AAC1B,WAAOA,SAAQ;AAAA,MACb,CAACD,YAAyD;AACxD,YAAI,OAAOA,YAAW,YAAY,OAAOA,YAAW,UAAU;AAC5D,iBAAO;AAAA,YACL,OAAO,OAAOA,OAAM;AAAA,YACpB,OAAO,OAAOA,OAAM;AAAA,UACtB;AAAA,QACF;AACA,YAAI,OAAOA,WAAU,UAAU;AAC7B,cAAI,WAAWA,SAAQ;AACrB,YAAAA,QAAO,UAAU,iBAAiBA,QAAO,WAAW,CAAC,GAAG,CAAC;AACzD,mBAAOA;AAAA,UACT,WAAW,WAAWA,WAAU,OAAOA,QAAO,UAAU,UAAU;AAChE,mBAAO,OAAOA,SAAQ;AAAA,cACpB,OAAO,UAAU,EAAE,OAAO;AAAA,cAC1B,YAAYA,QAAO;AAAA,YACrB,CAAC;AAAA,UACH;AAAA,QACF;AACA,eAAOA;AAAA,MACT;AAAA,IACF;AAAA,EACF;AACA,SAAO,OAAO,KAAKC,QAAO,EAAE,IAAI,CAAC,UAAkB;AACjD,WAAO;AAAA,MACL,OAAOA,SAAQ,KAAK;AAAA,MACpB;AAAA,IACF;AAAA,EACF,CAAC;AACH;AAYO,SAAS,YACdA,UACA,OACA,sBAAsB,OACb;AACT,MAAI,MAAM,QAAQA,QAAO,GAAG;AAC1B,eAAWD,WAAUC,UAAS;AAC5B,UAAI,OAAOD,YAAW,YAAYA;AAAQ;AAC1C,UAAI,cAAcA,OAAM,GAAG;AACzB,cAAM,QAAQ,YAAYA,QAAO,SAAS,OAAO,IAAI;AACrD,YAAI,UAAU,QAAW;AACvB,iBAAO;AAAA,QACT;AAAA,MACF,WAAW,SAASA,QAAO,OAAO;AAChC,eAAO,gBAAgBA,UAASA,QAAO,aAAaA,QAAO;AAAA,MAC7D;AAAA,IACF;AAAA,EACF;AACA,SAAO,sBAAsB,SAAY;AAC3C;AAYO,SAAS,aAAa,QAAiB,QAA0B;AACtE,MACG,WAAW,QAAQ,WAAW,UAC9B,WAAW,UAAa,WAAW;AAEpC,WAAO;AACT,MAAI,UAAU;AAAQ,WAAO;AAC7B,MAAI,OAAO,MAAM,KAAK,OAAO,MAAM;AAAG,WAAO,GAAG,QAAQ,MAAM;AAC9D,SAAO;AACT;AAUe,SAAR,QAAyB,MAAyB;AACvD,OAAK,KAAK,KAAK,CAAC,MAAW,SAAc;AAzH3C;AA0HI,QAAI,KAAK,SAAS,WAAW;AAC3B,UAAI,OAAO,KAAK,UAAU,YAAY;AACpC,aAAK,MAAM,gBAAgB,KAAK;AAChC,aAAK,QAAQ,CAAC;AAAA,MAChB,OAAO;AACL,mBAAK,OAAM,sBAAX,GAAW,oBAAsB,EAAE,OAAO,EAAE;AAC5C,aAAK,QAAQ,iBAAiB,KAAK,OAAO,KAAK,MAAM,iBAAiB;AAAA,MACxE;AAAA,IACF;AACA,WAAO,KAAK,IAAI;AAAA,EAClB,CAAC;AACH;;;ACrIA,SAAS,UAAAE,eAAc;AACvB;AAAA,EAGE;AAAA,EACA;AAAA,OAMK;AAAA;AAwEA,SAAS,cACd,SACA,IACAC,YAAW,OAGX;AACA,SAAO,IACF,aAGA;AACH,UAAM,aAAa,CAAC,eAAsC;AACxD,YAAM,OAAO,CAAC,MAAM,OAAO,OAAO,WAAW,EAAE,KAAK,GAAG,IAAI,GAAG;AAC9D,UAAI,MAAM,IAAI,KAAK,YAAY,IAAI,GAAG;AACpC,YAAI,CAAC,KAAK,MAAM;AACd,eAAK,OAAO,EAAE,QAAQ;AAAA,QACxB,OAAO;AACL,eAAK,KAAK,UAAU;AAAA,QACtB;AACA,YAAI,SAAS,UAAU,CAAC,KAAK,UAAU;AACrC,eAAK,WAAW;AAAA,YACd,GAAG,SAAS;AAAA,cAAI,CAAC,UACf,OAAO,UAAU,aAAa,MAAM,UAAU,IAAI;AAAA,YACpD;AAAA,UACF;AAAA,QACF;AACA,YAAI,MAAM,IAAI,GAAG;AACf,eAAK,QAAQ;AAAA,YACX,OAAO,YAAY,OAAO;AAAA,YAC1B,GAAI,KAAK,SAAS,CAAC;AAAA,UACrB;AAAA,QACF;AAAA,MACF;AACA,aAAO;AAAA,QACL,IAAI,UAAU,OAAO;AAAA,QACrB,MAAM,UAAU,OAAO;AAAA,QACvB,MACE,WAAW,aACP,6BAAa,MAAM,WAAW,OAAO,CAAC,IACtC;AAAA,MACR;AAAA,IACF;AACA,eAAW,KAAK;AAChB,WAAOA,YAAW,2BAAW,UAAU,IAAI;AAAA,EAC7C;AACF;AAAA;AAYO,SAAS,WACd,aAC6B;AAC7B,SAAO,CAAC,eAAsC;AAC5C,WAAO,CAAC,YAAY,UAAU,CAAC;AAAA,EACjC;AACF;AAYO,SAAS,eACd,QAIuB;AACvB,SAAO,CAAC,EACN,UACA,OAAO,WAAW,aACjB,SAAS,UAAU,UAAU,UAAU,cAAc;AAE1D;AAAA;AAcO,SAAS,aACd,QACA,YAA+C,CAAC,GAC7B;AACnB,MAAI,OAAO,WAAW,UAAU;AAC9B,WAAO,eAAe,SAAS,KAAK,OAAO,cAAc,WACrD,YACA;AAAA,EACN,WAAW,MAAM,QAAQ,MAAM,GAAG;AAChC,WAAO,eAAe,SAAS,IAAI,YAAY;AAAA,EACjD;AACA,SAAOD,QAAO,QAAQ,SAAS;AACjC;;;ACpMA,SAAS,UAAAA,SAAQ,UAAU,aAAa;AACxC;AAAA,EAOE,eAAAE;AAAA,EACA,SAAAC;AAAA,EACA;AAAA,EACA,QAAAC;AAAA,OAGK;;;ACPA,IAAM,UAAU,cAAc,WAAW,OAAO;AAAA,EACrD,KAAK;AAAA,EACL,IAAI;AACN,EAAE;;;ACHK,IAAM,MAAM,cAAc,SAAS,OAAO;AAAA,EAC/C,KAAK;AAAA,EACL,MAAM;AAAA,EACN,OAAO;AAAA,IACL,MAAM;AAAA,IACN,MAAM;AAAA,IACN,UAAU;AAAA,IACV,SAAS;AAAA,IACT,SAAS;AAAA,IACT,QAAQ;AAAA,IACR,OAAO;AAAA,IACP,IAAI;AAAA,IACJ,oBAAoB;AAAA,MAClB,IAAI;AAAA,MACJ,MAAM;AAAA,QACJ,IAAI;AAAA,QACJ,MAAM;AAAA,QACN,MAAM;AAAA,MACR;AAAA,MACA,MAAM;AAAA,QACJ,IAAI;AAAA,QACJ,MAAM;AAAA,QACN,MAAM;AAAA,MACR;AAAA,IACF;AAAA,EACF;AACF,EAAE;;;AC1BK,IAAM,UAAU,cAAc,cAAc,OAAO;AAAA,EACxD,KAAK;AAAA,EACL,IAAI;AAAA,EACJ,OAAO;AAAA,IACL,IAAI;AAAA,EACN;AACF,EAAE;;;ACNK,IAAM,WAAW,cAAc,SAAS,MAAM;;;ACA9C,IAAM,WAAW,cAAc,SAAS,MAAM;;;ACA9C,IAAM,YAAY,cAAc,UAAU,OAAO;AAAA,EACtD,KAAK;AAAA,EACL,KAAK,CAAC,UAAU,UAAU;AAAA,EAC1B,OAAO;AAAA,IACL,iBAAiB;AAAA,EACnB;AACF,EAAE;;;ACNK,IAAM,aAAa,cAAc,WAAW,IAAI;;;ACAhD,IAAM,aAAa,cAAc,WAAW,OAAO;AAAA,EACxD,KAAK;AAAA,EACL,OAAO;AAAA,IACL,iBAAiB;AAAA,MACf,IAAI;AAAA,MACJ,MAAM;AAAA,MACN,MAAM;AAAA,IACR;AAAA,IACA,gBAAgB;AAAA,MACd,IAAI;AAAA,MACJ,MAAM;AAAA,MACN,MAAM;AAAA,IACR;AAAA,EACF;AACF,EAAE;;;ACdK,IAAM,cAAc,cAAc,SAAS,OAAO;AAAA,EACvD,KAAK;AAAA,EACL,MAAM;AAAA,EACN,OAAO;AAAA,IACL,MAAM;AAAA,IACN,UAAU;AAAA,IACV,MAAM;AAAA,IACN,IAAI;AAAA,EACN;AACF,EAAE;;;ACTK,IAAM,cAAc,cAAc,WAAW,IAAI;;;ACAjD,IAAM,YAAY,cAAc,aAAa,OAAO;AAAA,EACzD,KAAK;AAAA,EACL,OAAO;AAAA,IACL,eAAe;AAAA,EACjB;AACF,EAAE;;;ACLK,IAAM,WAAW,cAAc,YAAY,OAAO;AAAA,EACvD,KAAK;AAAA,EACL,OAAO;AAAA,IACL,IAAI;AAAA,IACJ,oBAAoB;AAAA,MAClB,IAAI;AAAA,MACJ,MAAM;AAAA,MACN,MAAM;AAAA,IACR;AAAA,EACF;AACF,EAAE;;;ACVK,IAAM,YAAY,cAAc,SAAS,OAAO;AAAA,EACrD,KAAK;AAAA,EACL,MAAM;AAAA,EACN,OAAO;AAAA,IACL,MAAM;AAAA,IACN,UAAU;AAAA,IACV,MAAM;AAAA,IACN,UAAU;AAAA,IACV,QAAQ;AAAA,IACR,IAAI;AAAA,IACJ,oBAAoB;AAAA,IACpB,iBAAiB;AAAA,EACnB;AACF,EAAE;;;ACbK,IAAM,WAAW,cAAc,YAAY,OAAO;AAAA,EACvD,KAAK;AAAA,EACL,KAAK,CAAC,QAAQ,QAAQ;AACxB,EAAE;;;ACHK,IAAM,WAAW,cAAc,YAAY,OAAO;AAAA,EACvD,KAAK;AAAA,EACL,IAAI;AAAA,EACJ,OAAO;AAAA,IACL,qBAAqB;AAAA,EACvB;AACF,EAAE;;;ACNK,IAAM,WAAW,cAAc,YAAY,OAAO;AAAA,EACvD,KAAK;AAAA,EACL,OAAO;AAAA,IACL,OAAO;AAAA,EACT;AACF,EAAE;;;ACLK,IAAM,aAAa,cAAc,cAAc,OAAO;AAAA,EAC3D,KAAK;AAAA,EACL,OAAO;AAAA,IACL,MAAM;AAAA,IACN,SAAS;AAAA,EACX;AACF,EAAE;;;ACNK,IAAM,YAAY,cAAc,QAAQ,OAAO;AAAA,EACpD,KAAK;AAAA,EACL,MAAM;AAAA,EACN,MAAM;AAAA,IACJ,aAAa;AAAA,EACf;AAAA,EACA,OAAO;AAAA,IACL,IAAI;AAAA,IACJ,MAAM;AAAA,IACN,UAAU;AAAA,IACV,gBAAgB;AAAA,EAClB;AACF,EAAE;;;ACZK,IAAM,WAAW,cAAc,WAAW,MAAM,IAAI;;;ACApD,IAAM,OAAO,cAAc,QAAQ,OAAO;AAAA,EAC/C,KAAK;AAAA,EACL,IAAI;AAAA,EACJ,OAAO;AAAA,IACL,IAAI;AAAA,EACN;AACF,EAAE;;;ACNK,IAAM,OAAO,CAClB,YACA,OACmC;AACnC,SAAO,cAAc,GAAG,UAAU,QAAQ,MAAM;AAC9C,UAAM,cAAc,OAAO,WACxB,OAAO,CAAC,EACR,YAAY,CAAC,GAAG,WAAW,MAAM,CAAC,CAAC;AACtC,WAAO;AAAA,MACL,IAAI,IAAI,UAAU,YAAY,WAAW;AAAA,MACzC,KAAK,GAAG,KAAK,KAAK,MAAM;AAAA,MACxB,OAAO;AAAA,QACL,OAAO,YAAY,UAAU;AAAA,QAC7B,WAAW,IAAI,WAAW;AAAA,QAC1B,SAAS,uBAAuB,UAAU;AAAA,QAC1C,MAAM,iBAAiB,UAAU;AAAA,QACjC,UAAU,iBAAiB,UAAU;AAAA,QACrC,KAAK;AAAA,UACH,IAAI,GAAG,OAAO,OAAO;AAAA,UACrB,MAAM;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAAA,EACF,CAAC,EAAE;AACL;;;ACxBO,IAAM,QAAQ,cAAc,SAAS,KAAK;;;ACA1C,IAAM,QAAQ,cAAc,SAAS,OAAO;AAAA,EACjD,KAAK;AAAA,EACL,IAAI;AAAA,EACJ,OAAO;AAAA,IACL,KAAK;AAAA,EACP;AACF,EAAE;;;ACNK,IAAM,SAAS,cAAc,UAAU,OAAO;AAAA,EACnD,KAAK;AAAA,EACL,IAAI;AACN,EAAE;;;ACHK,IAAM,UAAU,cAAc,WAAW,OAAO;AAAA,EACrD,KAAK;AAAA,EACL,KAAK,CAAC,WAAW,WAAW;AAAA,EAC5B,OAAO;AAAA,IACL,KAAK;AAAA,IACL,IAAI;AAAA,IACJ,qBAAqB;AAAA,EACvB;AACF,EAAE;;;ACRK,IAAM,WAAW,cAAc,YAAY,OAAO;AAAA,EACvD,KAAK;AAAA,EACL,IAAI;AACN,EAAE;;;ACHK,IAAM,UAAU,cAAc,WAAW,OAAO;AAAA,EACrD,KAAK;AAAA,EACL,IAAI;AACN,EAAE;;;ACHK,IAAM,WAAW,cAAc,YAAY,OAAO;AAAA,EACvD,KAAK;AAAA,EACL,MAAM;AAAA,EACN,OAAO;AAAA,IACL,OAAO;AAAA,EACT;AACF,EAAE;;;ACNK,IAAM,SAAS,cAAc,UAAU,OAAO;AAAA,EACnD,KAAK;AAAA,EACL,MAAM;AAAA,EACN,OAAO;AAAA,IACL,OAAO;AAAA,IACP,OAAO;AAAA,IACP,UAAU;AAAA,EACZ;AACF,EAAE;;;ACRK,IAAM,aAAa,cAAc,WAAW,OAAO;AAAA,EACxD,KAAK;AAAA,EACL,IAAI;AAAA,EACJ,KAAK,CAAC,UAAU,6BAA6B;AAC/C,EAAE;;;ACJK,IAAM,QAAQ,cAAc,SAAS,OAAO;AAAA,EACjD,KAAK;AAAA,EACL,MAAM;AAAA,IACJ,aAAa;AAAA,EACf;AAAA,EACA,OAAO;AAAA,IACL,KAAK;AAAA,IACL,eAAe;AAAA,IACf,aAAa;AAAA,IACb,iBACE;AAAA,IACF,qBAAqB;AAAA,IACrB,iBAAiB;AAAA,IACjB,cAAc;AAAA,IACd,iBAAiB;AAAA,IACjB,gBAAgB;AAAA,IAChB,eAAe;AAAA,IACf,kBAAkB;AAAA,IAClB,oBAAoB;AAAA,IACpB,oBAAoB;AAAA,IACpB,0BAA0B;AAAA,IAC1B,0BAA0B;AAAA,EAC5B;AACF,EAAE;;;ACvBK,IAAM,SAAS,cAAc,UAAU,IAAI;;;ACA3C,IAAM,cAAc,cAAc,SAAS,OAAO;AAAA,EACvD,KAAK;AAAA,EACL,MAAM;AAAA,EACN,OAAO;AAAA,IACL,IAAI;AAAA,IACJ,oBAAoB;AAAA,IACpB,UAAU;AAAA,IACV,OAAO;AAAA,IACP,MAAM;AAAA,IACN,UAAU;AAAA,IACV,SAAS;AAAA,IACT,QAAQ;AAAA,IACR,oBAAoB;AAAA,IACpB,iBAAiB;AAAA,EACnB;AACF,EAAE;;;ACfK,IAAM,cAAc,cAAc,UAAU,OAAO;AAAA,EACxD,MAAM;AAAA,EACN,MAAM;AAAA,EACN,OAAO;AAAA,IACL,MAAM;AAAA,IACN,OAAO;AAAA,EACT;AACF,EAAE;;;ACPK,IAAM,SAAS,cAAc,UAAU,IAAI;;;ACA3C,IAAM,YAAY,cAAc,SAAS,OAAO;AAAA,EACrD,KAAK;AAAA,EACL,MAAM;AAAA,EACN,OAAO;AAAA,IACL,MAAM;AAAA,IACN,UAAU;AAAA,IACV,MAAM;AAAA,IACN,SAAS;AAAA,IACT,QAAQ;AAAA,IACR,OAAO;AAAA,IACP,IAAI;AAAA,IACJ,oBAAoB;AAAA,IACpB,iBAAiB;AAAA,EACnB;AACF,EAAE;;;ACdK,IAAM,gBAAgB,cAAc,SAAS,OAAO;AAAA,EACzD,KAAK;AAAA,EACL,MAAM;AAAA,EACN,OAAO;AAAA,IACL,UAAU;AAAA,IACV,MAAM;AAAA,IACN,SAAS;AAAA,IACT,QAAQ;AAAA,IACR,OAAO;AAAA,IACP,IAAI;AAAA,IACJ,oBAAoB;AAAA,IACpB,iBAAiB;AAAA,EACnB;AAAA,EACA,UAAU;AACZ,EAAE;;;ACdK,IAAM,UAAU,cAAc,WAAW,KAAK;;;ACFrD,IAAI,gBAAgB;AAEb,SAAS,aAAa;AAC3B,kBAAgB;AAClB;AASe,SAAR,cAA+B,MAAmB;AACvD,MAAI,KAAK,SAAS,WAAW,KAAK,SAAS,QAAQ;AACjD,SAAK,QAAQ,IAAI,mBAAmB;AAAA,EACtC;AACF;AAEA,SAAS,oBAAoB,MAAmB;AAC9C,MAAI,KAAK,MAAM,SAAS,SAAS;AAC/B,SAAK,SAAS,CAAC,SAAS,CAAC;AACzB,SAAK,MAAM,UAAU,GAAG,KAAK,IAAI,IAAI,eAAe;AAAA,EACtD;AACF;;;AC5BA,SAAS,OAAAC,YAAW;;;ACApB,SAAS,UAAAL,SAAQ,eAAe;AAWjB,SAAR,eACL,MAC0D;AAC1D,SAAO,SAAU,MAAM,MAAM;AAC3B,QAAI,KAAK,SAAS,aAAa,MAAM,QAAQ,KAAK,KAAK,GAAG;AACxD,WAAK,QAAQ,KAAK,MAAM,IAAI,CAACF,YAAW;AACtC,YAAI,CAACA,QAAO,OAAO,IAAI;AACrB,iBAAOE,QAAOF,SAAQ;AAAA,YACpB,OAAO;AAAA,cACL,IAAI,GAAG,KAAK,MAAM,EAAE,WAAW,QAAQ,OAAOA,QAAO,KAAK,CAAC,CAAC;AAAA,YAC9D;AAAA,UACF,CAAC;AAAA,QACH;AACA,eAAOA;AAAA,MACT,CAAC;AACD,UAAI,KAAK,MAAM,SAAS,cAAc,CAAC,MAAM,QAAQ,KAAK,KAAK,GAAG;AAChE,YAAI,KAAK,WAAW;AAClB,eAAK,MAAM,CAAC,GAAG,KAAK;AAAA,QACtB,OAAO;AACL,eAAK,GAAG,WAAW,MAAM;AACvB,gBAAI,CAAC,MAAM,QAAQ,KAAK,KAAK,GAAG;AAC9B,mBAAK,MAAM,CAAC,GAAG,KAAK;AAAA,YACtB;AAAA,UACF,CAAC;AAAA,QACH;AAAA,MACF;AAAA,IACF;AACA,WAAO,KAAK,IAAI;AAAA,EAClB;AACF;;;AD5BA,SAAS,cAAc,MAAmB,GAAU;AAClD,QAAM,KAAK,EAAE;AACb,MAAI,cAAc,kBAAkB;AAClC,UAAM,QAAQ,MAAM,QAAQ,KAAK,MAAM,OAAO,IAC1C,YAAY,KAAK,MAAM,SAAS,GAAG,KAAK,IACxC,GAAG;AACP,QAAI,MAAM,QAAQ,KAAK,MAAM,OAAO,KAAK,KAAK,MAAM,QAAQ,QAAQ;AAClE,UAAI,CAAC,MAAM,QAAQ,KAAK,MAAM,GAAG;AAE/B,aAAK,MAAM,CAAC,KAAK,CAAC;AAAA,MACpB,WACE,CAAC,KAAK,OAAO,KAAK,CAAC,kBAAkB,aAAa,OAAO,aAAa,CAAC,GACvE;AAEA,aAAK,MAAM,CAAC,GAAG,KAAK,QAAQ,KAAK,CAAC;AAAA,MACpC,OAAO;AAEL,aAAK;AAAA,UACH,KAAK,OAAO;AAAA,YACV,CAAC,kBAAkB,CAAC,aAAa,OAAO,aAAa;AAAA,UACvD;AAAA,QACF;AAAA,MACF;AAAA,IACF,OAAO;AACL,UAAI,GAAG,SAAS;AACd,aAAK,MAAM,KAAK,MAAM,OAAO;AAAA,MAC/B,OAAO;AACL,aAAK,MAAM,KAAK,MAAM,QAAQ;AAAA,MAChC;AAAA,IACF;AAAA,EACF;AACF;AAYA,SAAS,UAAU,MAAmB,OAAY;AAEhD,OAAK,SAAS;AACd,OAAK,SAAS;AACd,MAAI,MAAM,QAAQ,KAAK,MAAM,GAAG;AAC9B,WAAO,KAAK,OAAO;AAAA,MAAK,CAAC,kBACvB,aAAa,YAAY,KAAK,MAAM,SAAS,KAAK,GAAG,aAAa;AAAA,IACpE;AAAA,EACF;AACA,SAAO;AACT;AASe,SAAR,WAA4B,MAAyB;AAC1D,OAAK,GAAG,WAAW,MAAM;AACvB,QAAI,KAAK,SAAS,UAAU;AAC1B,WAAK,QAAQ,SAAS,gBAAgB,cAAc,KAAK,MAAM,IAAI;AAAA,IACrE;AACA,QAAI,KAAK,SAAS,KAAK;AACrB,WAAK,QAAQ,IAAI,YAAY,UAAU,KAAK,MAAM,IAAI;AAAA,IACxD;AAEA,QAAI,CAACO,KAAI,KAAK,OAAO,SAAS;AAAG,WAAK,MAAM,UAAU;AACtD,QAAI,CAACA,KAAI,KAAK,OAAO,UAAU;AAAG,WAAK,MAAM,WAAW;AAAA,EAC1D,CAAC;AAED,OAAK,KAAK,KAAK,eAAe,IAAI,CAAC;AACrC;;;AE7Ee,SAAR,YAA6B,YAAoBC,cAAqB;AAC3E,SAAO,CAAC,SAA4B;AAClC,QAAI,KAAK,MAAM,GAAG,UAAU,MAAM,MAAM,QAAW;AACjD,WAAK,MAAM,GAAG,UAAU,MAAM,IAAIA,aAAY,WAAW,MAAM,IAC3DA,eACA,WAAWA,YAAW;AAAA,IAC5B;AAAA,EACF;AACF;;;ACnBA,SAAS,gBAAgB;AASV,SAAR,SAA0B,MAAyB;AACxD,OAAK,GAAG,WAAW,MAAM;AAGvB,QAAI,cAAc,KAAK,OAAO;AAC5B,WAAK,MAAM,WAAW,SAAS,KAAK,MAAM,QAAQ;AAClD,WAAK,OAAO,WAAW,SAAS,KAAK,MAAM,QAAQ;AAAA,IACrD;AAAA,EACF,CAAC;AACD,OAAK,KAAK,KAAK,CAAC,EAAE,MAAM,MAAM,GAAG,SAAS;AACxC,YAAQ,SAAS,aAAa,SAAS,KAAK,IAAI;AAChD,WAAO,KAAK,EAAE,MAAM,MAAM,CAAC;AAAA,EAC7B,CAAC;AACD,OAAK,GAAG,iBAAiB,CAAC,EAAE,SAAS,MAAM,MAAM;AAC/C,SAAK,OAAO,WAAW,SAAS,KAAK;AAAA,EACvC,CAAC;AACH;;;AC1BA,SAAsB,qBAAqB;AAa5B,SAAR,SACL,KACA,OAC6B;AAC7B,SAAO,CAAC,SAA4B;AAClC,SAAK,MAAM;AAAA,MACO,8BAAc;AAAA,QAC5B;AAAA,QACA,MAAM;AAAA,QACN,OAAO,SAAS;AAAA,QAChB,MAAM;AAAA,UACJ,UAAU;AAAA,UACV,UAAU,CAAC,IAAI;AAAA,QACjB;AAAA,MACF,CAAC;AAAA,IACH;AAAA,EACF;AACF;;;ACpBA,IAAM,YAAY,OAAO,WAAW;AASpC,SAAS,YAAY,GAAU;AAC7B,MACE,EAAE,kBAAkB,eACpB,EAAE,OAAO,aAAa,iBAAiB,GACvC;AACA,MAAE,OAAO,gBAAgB,iBAAiB;AAAA,EAC5C;AACF;AASA,SAAS,iBAAiB,MAAc,GAAU;AAChD,MAAI,EAAE,EAAE,kBAAkB,mBAAmB;AAC3C,MAAE,eAAe;AAAA,EACnB,WAAW,SAAS,YAAY;AAC9B,MAAE,OAAO,aAAa,mBAAmB,MAAM;AAAA,EACjD;AACA,MAAI,SAAS,QAAQ;AACnB,gBAAY,CAAC;AAAA,EACf;AACF;AASe,SAAR,MAAuB,MAAyB;AAErD,WAAS,WAAW,aAAa,EAAE,IAAI;AACvC,WAAS,aAAa,YAAY,EAAE,IAAI;AACxC,WAAS,QAAQ,EAAE,IAAI;AACvB,OAAK,SAAS,CAAC,mBAAmB,CAAC;AAEnC,MAAI,WAAW;AACb,QAAI,CAAC,OAAO,oBAAoB;AAC9B,aAAO;AAAA,QACL;AAAA,QACA,iBAAiB,KAAK,MAAM,UAAU;AAAA,MACxC;AACA,aAAO,iBAAiB,QAAQ,iBAAiB,KAAK,MAAM,MAAM,CAAC;AACnE,aAAO,iBAAiB,aAAa,WAAW;AAChD,aAAO,qBAAqB;AAAA,IAC9B;AAAA,EACF;AACA,OAAK,KAAK,MAAM,CAAC,OAAO,SAAS,KAAK,MAAM,QAAQ,KAAK,IAAI,QAAQ,CAAC,CAAC,CAAC;AACxE,OAAK,GAAG,SAAS,CAAC,EAAE,SAAS,MAAM,MAAM;AACvC,SAAK,MAAM,oBACT,MAAM,QAAQ,KAAK,KAAK,MAAM,SAAS,IAAI,OAAO;AAAA,EACtD,CAAC;AAED,OAAK,GAAG,SAAS,MAAM;AACrB,QAAI,KAAK,MAAM,MAAM,WAAW;AAC9B,YAAM,KAAK,SAAS,eAAe,KAAK,MAAM,EAAE;AAChD,UAAI;AAAI,QAAC,GAAwB,QAAQ;AAAA,IAC3C;AAAA,EACF,CAAC;AAED,OAAK,GAAG,WAAW,MAAM;AACvB,QAAI,CAAC,MAAM,QAAQ,KAAK,KAAK;AAAG,WAAK,MAAM,CAAC,GAAG,KAAK;AAEpD,QAAI,CAAC,KAAK;AAAS;AAEnB,SAAK,QAAQ,SAAS,aAAa,CAAC,MAAa;AAC/C,QAAE,eAAe;AACjB,WAAK,MAAM,CAAC,CAAC;AACb,UAAI,KAAK,MAAM,MAAM,WAAW;AAC9B,cAAM,KAAK,SAAS,eAAe,KAAK,MAAM,EAAE;AAChD,YAAI;AAAI,UAAC,GAAwB,QAAQ;AACzC,YAAI,MAAM;AAAA,MACZ;AAAA,IACF;AAEA,SAAK,QAAQ,SAAS,QAAQ,CAAC,MAAa;AAC1C,YAAMC,SAA0B,CAAC;AACjC,UAAI,EAAE,kBAAkB,oBAAoB,EAAE,OAAO,OAAO;AAC1D,iBAAS,IAAI,GAAG,IAAI,EAAE,OAAO,MAAM,QAAQ,KAAK;AAC9C,cAAIC;AACJ,cAAKA,QAAO,EAAE,OAAO,MAAM,KAAK,CAAC,GAAI;AACnC,YAAAD,OAAM,KAAK,EAAE,MAAMC,MAAK,MAAM,MAAAA,MAAK,CAAC;AAAA,UACtC;AAAA,QACF;AACA,aAAK,MAAMD,MAAK;AAAA,MAClB;AACA,UAAI,KAAK;AAAS,aAAK,QAAQ,QAAQA;AAGvC,UAAI,OAAO,KAAK,MAAM,OAAO,aAAa,YAAY;AACpD,aAAK,MAAM,OAAO,SAAS,CAAC;AAAA,MAC9B;AAAA,IACF;AAAA,EACF,CAAC;AACH;;;ACtHA,SAAS,iBAAAE,sBAAkC;AAC3C,SAAS,OAAAJ,MAAK,aAAa;AAE3B,IAAM,UAA0B,gBAAAI,eAAc;AAAA,EAC5C,KAAK;AAAA,EACL,OAAO;AAAA,EACP,SAAS;AACX,CAAC;AASD,eAAe,aAAa,MAAmB,aAAoB;AACjE,QAAM,cAAc,KAAK,OAAO;AAChC,OAAK,MAAM,eAAe;AAC1B,cAAY,eAAe;AAC3B,QAAM,KAAK;AAEX,MAAI,KAAK,OAAO,MAAM,YAAY,GAAG;AAEnC,SAAK,MAAM,IAAI,OAAO;AACtB,UAAM,KAAK,OAAO,QAAQ,YAAY;AACtC,SAAK,MAAM,OAAO,SAAS;AAE3B,QAAI,KAAK,MAAM,iBAAiB;AAAa;AAAA,EAC/C;AAEA,QAAM,eAAe,CAAC,MACpB,EAAE,MAAM;AAAA,IACU,gBAAAA,eAAc;AAAA,MAC5B,KAAK;AAAA,MACL,OAAO;AAAA,MACP,SAAS;AAAA,IACX,CAAC;AAAA,EACH;AACF,OAAK,KAAK,YAAY;AACtB,eAAa,IAAI;AAEjB,OAAK,KAAK,YAAY;AACtB,MAAI,OAAO,KAAK,MAAM,gBAAgB,YAAY;AAChD,SAAK,MAAM,YAAY,aAAa,IAAI;AAAA,EAC1C;AAEA,MAAI,KAAK,OAAO,MAAM,UAAU,GAAG;AACjC,QAAI,OAAO,KAAK,MAAM,oBAAoB,YAAY;AACpD,WAAK,MAAM,gBAAgB,IAAI;AAAA,IACjC;AAEA,QAAI,KAAK,MAAM,sBAAsB,OAAO;AAC1C,2BAAqB,IAAI;AAAA,IAC3B;AAAA,EACF,OAAO;AAEL,QAAI,OAAO,KAAK,MAAM,aAAa,YAAY;AAE7C,YAAM,SAAS,KAAK,MAAM;AAAA,QACxB,KAAK,KAAK,OAAO,SAAS,MAAM,KAAK,KAA4B,CAAC;AAAA,QAClE;AAAA,MACF;AACA,UAAI,kBAAkB,SAAS;AAC7B,cAAM,cACJ,KAAK,MAAM,aAAa,UACxB,KAAK,MAAM,mBAAmB;AAChC,YAAI;AAAa,eAAK,MAAM,WAAW;AACvC,aAAK,MAAM,IAAI,OAAO;AACtB,cAAM;AACN,YAAI;AAAa,eAAK,MAAM,WAAW;AACvC,aAAK,MAAM,OAAO,SAAS;AAAA,MAC7B;AAAA,IACF,OAAO;AACL,UAAI,YAAY,kBAAkB,iBAAiB;AACjD,oBAAY,OAAO,OAAO;AAAA,MAC5B;AAAA,IACF;AAAA,EACF;AACF;AAMA,SAAS,qBAAqB,MAAmB;AAC/C,OAAK,MAAM;AAAA,IACO,gBAAAA,eAAc;AAAA,MAC5B,UAAU;AAAA,MACV,KAAK;AAAA,MACL,MAAM;AAAA,QACJ,UAAU,KAAK,MAAM,sBAAsB;AAAA,QAC3C,UAAU,CAAC,EAAE,KAAK,CAAC;AAAA,QACnB,eAAe;AAAA,MACjB;AAAA,MACA,MAAM;AAAA,MACN,OAAO,KAAK,MAAM,qBAAqB;AAAA,IACzC,CAAC;AAAA,EACH;AACF;AASe,SAAR,KAAsB,MAAyB;AA5GtD;AA6GE,OAAK,MAAM,SAAS;AACpB,OAAK,OAAO,MAAM,cAAc,CAAC,MAAM,EAAE,QAAQ,YAAY;AAE7D,aAAK,OAAM,gBAAX,GAAW,cAAgB;AAAA,IACzB,UAAU,KAAK,MAAM;AAAA,EACvB;AAEA,OAAK,GAAG,iBAAiB,CAAC,EAAE,SAAS,SAAS,MAAM;AAClD,SAAK,MAAM,cAAc,EAAE,GAAG,KAAK,MAAM,aAAa,SAAS;AAAA,EACjE,CAAC;AAED,OAAK,GAAG,WAAW,MAAM;AACvB,QAAI,KAAK,SAAS,UAAU;AAC1B,WAAK,QAAQ,SAAS,SAAS,aAAa,KAAK,MAAM,IAAI;AAAA,IAC7D;AACA,QAAI,CAACJ,KAAI,KAAK,OAAO,SAAS,GAAG;AAC/B,WAAK,MAAM,UAAU;AAAA,IACvB;AAAA,EACF,CAAC;AACD,OAAK,GAAG,0BAA0B,MAAM;AACtC,QAAI,KAAK,MAAM;AAAY,2BAAqB,IAAI;AAAA,EACtD,CAAC;AACD,OAAK,GAAG,oBAAoB,MAAM,KAAK,MAAM,OAAO,YAAY,CAAC;AACnE;;;AC3He,SAAR,OAAwB,MAAyB;AACtD,MAAI,KAAK,MAAM,WAAW,QAAW;AACnC,SAAK,MAAM,SAAS;AACpB,SAAK,SAAS;AAAA,EAChB;AACF;;;ACLe,SAAR,aAA8B,MAAyB;AAC5D,OAAK,GAAG,WAAW,MAAM;AACvB,QAAI,KAAK,SAAS;AAChB,WAAK,QAAQ,eAAe,KAAK,SAAS;AAAA,IAC5C;AAAA,EACF,CAAC;AACH;;;ACNe,SAAR,MAAuB,MAAyB;AACrD,MAAI,OAAO,KAAK,MAAM,WAAW;AAAa;AAC9C,QAAM,SAAS,CAAC,UAAU,SAAS,QAAQ,EAAE,SAAS,KAAK,MAAM,IAAI;AACrE,OAAK,KAAK,MAAM,CAAC,OAAO,SAAS;AAC/B,QAAI,UAAU;AAAI,aAAO,KAAK,MAAS;AACvC,UAAM,eACJ,KAAK,MAAM,WAAW,YAAY,SAAS,KAAK,IAAI,WAAW,KAAK;AACtE,QAAI,CAAC,OAAO,SAAS,YAAY;AAC/B,aAAO,SAAS,KAAK,MAAS,IAAI,KAAK,KAAK;AAC9C,WAAO,KAAK,YAAY;AAAA,EAC1B,CAAC;AACH;;;ACpBA,SAAsB,YAAY;AAYlC,SAASK,eAAc,MAAmB,OAAc;AACtD,MAAI,MAAM,kBAAkB,kBAAkB;AAC5C,SAAK,MAAM,YAAY,KAAK,MAAM,SAAS,MAAM,OAAO,KAAK,CAAC;AAAA,EAChE;AACF;AAYA,SAASC,WAAU,MAAmB,OAAe;AAEnD,OAAK,SAAS;AACd,OAAK,SAAS;AACd,SAAO,aAAa,YAAY,KAAK,MAAM,SAAS,KAAK,GAAG,KAAK,MAAM;AACzE;AASe,SAAR,OAAwB,MAAyB;AACtD,OAAK,GAAG,WAAW,MAAM;AACvB,QAAI,CAAC,MAAM,QAAQ,KAAK,MAAM,OAAO,GAAG;AACtC,WAAK,KAAK;AAAA,QACR;AAAA,QACA,WAAW;AAAA,MACb,CAAC;AAAA,IACH;AACA,QAAI,KAAK,SAAS,UAAU;AAC1B,WAAK,QAAQ,SAAS,gBAAgBD,eAAc,KAAK,MAAM,IAAI;AAAA,IACrE;AACA,QAAI,KAAK,SAAS,KAAK;AACrB,WAAK,QAAQ,IAAI,YAAYC,WAAU,KAAK,MAAM,IAAI;AAAA,IACxD;AAAA,EACF,CAAC;AACD,OAAK,KAAK,KAAK,eAAe,IAAI,CAAC;AACrC;;;ACpDA,SAAS,YAAAC,WAAU,MAAAC,WAAU;AAW7B,SAAS,WACP,MACAf,SACA;AACA,MAAI,cAAcA,OAAM;AAAG,WAAO;AAElC,OAAK,WAAW,KAAK,QAAQ;AAC7B,QAAMgB,eAAc,gBAAgBhB,UAASA,QAAO,aAAaA,QAAO;AACxE,SAAO,MAAM,QAAQ,KAAK,MAAM,IAC5B,KAAK,OAAO,KAAK,CAAC,YAAY,aAAa,SAASgB,YAAW,CAAC,KAC/D,KAAK,WAAW,UACd,KAAK,WAAW,QAAQ,CAAC,cAAc,KAAK,MAAM,SAAS,IAAI,MAClEhB,QAAO,SACPA,QAAO,MAAM,qBAAqB,IAClC,OACA,aAAagB,cAAa,KAAK,MAAM;AAC3C;AAKA,SAAS,cACPf,UACA,OACS;AACT,SAAOA,SAAQ,KAAK,CAACD,YAAW;AAC9B,QAAI,cAAcA,OAAM,GAAG;AACzB,aAAO,cAAcA,QAAO,SAAS,KAAK;AAAA,IAC5C,OAAO;AACL,cACG,gBAAgBA,UAASA,QAAO,aAAaA,QAAO,WAAW;AAAA,IAEpE;AAAA,EACF,CAAC;AACH;AAOA,eAAe,YAAY,MAAmB,GAAU;AACtD,MAAI,OAAO,KAAK,MAAM,OAAO,aAAa,YAAY;AACpD,UAAM,IAAI,QAAQ,CAAC,MAAM,WAAW,GAAG,CAAC,CAAC;AACzC,UAAM,KAAK;AACX,SAAK,MAAM,MAAM,SAAS,CAAC;AAAA,EAC7B;AACF;AAMA,SAAyBiB,aAAY,MAAmB,GAAU;AAChE,QAAM,SAAS,EAAE;AACjB,QAAM,QAAQ,OAAO,aAAa,UAAU,IACxC,MAAM,KAAK,OAAO,eAAe,EAAE;AAAA,IAAI,CAAC,MACtC,YAAY,KAAK,MAAM,SAAS,EAAE,KAAK;AAAA,EACzC,IACA,YAAY,KAAK,MAAM,SAAS,OAAO,KAAK;AAChD,OAAK,MAAM,KAAK;AAClB;AAQA,SAAS,iBAAiBhB,UAA6B,aAAqB;AAC1E,MACE,CAACA,SAAQ;AAAA,IACP,CAACD,YAAWA,QAAO,SAASA,QAAO,MAAM,qBAAqB;AAAA,EAChE,GACA;AACA,WAAO;AAAA,MACL;AAAA,QACE,OAAO;AAAA,QACP,OAAO;AAAA,QACP,OAAO;AAAA,UACL,QAAQ;AAAA,UACR,UAAU;AAAA,UACV,uBAAuB;AAAA,QACzB;AAAA,MACF;AAAA,MACA,GAAGC;AAAA,IACL;AAAA,EACF;AACA,SAAOA;AACT;AAMA,SAAS,WAAWA,UAAgD;AAClE,QAAMD,UAASC,SAAQ,SAAS,IAAIA,SAAQ,CAAC,IAAI;AACjD,MAAI,CAACD;AAAQ,WAAO;AACpB,MAAI,cAAcA,OAAM;AAAG,WAAO,WAAWA,QAAO,OAAO;AAC3D,SAAO,gBAAgBA,UAASA,QAAO,aAAaA,QAAO;AAC7D;AAOe,SAAR,OAAwB,MAAyB;AAEtD,OAAK,GAAG,WAAW,MAAM;AACvB,UAAM,aAAac,UAAS,KAAK,MAAM,OAAO,QAAQ;AAEtD,QACE,CAAC,cACD,KAAK,MAAM,eACX,MAAM,QAAQ,KAAK,MAAM,OAAO,GAChC;AACA,WAAK,KAAK,KAAK,CAAC,EAAE,MAAM,MAAM,GAAG,SAAS;AACxC,YAAI,SAAS,WAAW;AACtB,kBAAQ,iBAAiB,OAAO,KAAK,MAAM,WAAW;AAAA,QACxD;AACA,eAAO,KAAK,EAAE,MAAM,MAAM,CAAC;AAAA,MAC7B,CAAC;AACD,WAAK,MAAM,UAAU;AAAA,QACnB,KAAK,MAAM;AAAA,QACX,KAAK,MAAM;AAAA,MACb;AAAA,IACF;AACA,QAAI,YAAY;AACd,UAAI,KAAK,UAAU,QAAW;AAC5B,aAAK,MAAM,CAAC,GAAG,KAAK;AAAA,MACtB;AAAA,IACF,WAAW,KAAK,WAAW,CAAC,KAAK,QAAQ,SAAS;AAGhD,WAAK,MAAM,QAAQ,OAAO,OAAO,CAAC,GAAG,KAAK,MAAM,OAAO;AAAA,QACrD,OAAO,KAAK;AAAA,MACd,CAAC;AACD,WAAK,GAAG,SAAS,CAAC,EAAE,QAAQ,MAAM;AAChC,aAAK,MAAM,QAAQ,OAAO,OAAO,CAAC,GAAG,KAAK,MAAM,OAAO;AAAA,UACrD,OAAO;AAAA,QACT,CAAC;AAAA,MACH,CAAC;AAAA,IACH;AACA,QAAI,KAAK,SAAS,UAAU;AAC1B,WAAK,QAAQ,SAAS,cAAcG,aAAY,KAAK,MAAM,IAAI;AAC/D,WAAK,QAAQ,SAAS,WAAW,YAAY,KAAK,MAAM,IAAI;AAAA,IAC9D;AACA,QAAI,KAAK,SAAS,KAAK;AACrB,WAAK,QAAQ,IAAI,aAAa,WAAW,KAAK,MAAM,IAAI;AACxD,WAAK,QAAQ,IAAI,kBAAkB,CAAC,OAAgB,gBAAgB;AAClE,YAAI,CAAC,MAAM,QAAQ,KAAK,MAAM,OAAO;AAAG,iBAAO;AAC/C,cAAM,mBAAmB,KAAK,MAAM,QAAQ;AAAA,UAC1C,CAACjB,YAA+B;AAC9B,gBAAIA,QAAO,SAAS,yBAAyBA,QAAO;AAClD,qBAAO;AACT,kBAAMgB,eACJ,gBAAgBhB,UAASA,QAAO,aAAaA,QAAO;AACtD,mBAAOe,IAAG,OAAOC,YAAW;AAAA,UAC9B;AAAA,QACF;AACA,eAAO,eAAe,CAAC,mBAAmB,OAAO;AAAA,MACnD;AAAA,IACF;AAAA,EACF,CAAC;AAED,OAAK,KAAK,MAAM,CAAC,OAAO,SAAS;AAC/B,QACE,CAAC,KAAK,MAAM,eACZ,UAAU,UACV,MAAM,QAAQ,KAAK,OAAO,OAAO,KACjC,KAAK,MAAM,QAAQ,UACnB,CAACF,UAAS,KAAK,OAAO,OAAO,QAAQ,GACrC;AACA,cAAQ,WAAW,KAAK,MAAM,OAAO;AAAA,IACvC;AACA,WAAO,KAAK,KAAK;AAAA,EACnB,CAAC;AACH;;;;AnD1GO,SAAS,gBAAgB,MAI9B;AACA,MACE,cAAc,IAAI,KAClB,KAAK,MACL,KAAK,GAAG,WAAW,SAAS,KAC5B,OAAO,KAAK,SAAS,YACrB,KAAK,KAAK,WAAW,SAAS,KAC9B,UAAU,MACV;AACA,WAAO;AAAA,EACT;AACA,SAAO;AACT;AAAA;AAaO,SAAS,YACd,QACA,QAMI;AACJ,SACE;AAAA,IACE;AAAA,IACA,CAAC,SAAS,kBAAkB,WAAW;AACrC,UAAI,QAAQ,MAAM,YAAY,QAAQ;AACpC,eAAO,CAAC,QAAQ,gBAAgB;AAAA,MAClC;AACA;AAAA,IACF;AAAA,IACA;AAAA,EACF,KAAK,CAAC,OAAO,KAAK;AAEtB;AAeO,SAAS,YACd,QACA,UAKA,uBAAuB,OACvB,cACU;AACV,MAAI,MAAM,QAAQ,MAAM,GAAG;AACzB,eAAW,QAAQ,QAAQ;AACzB,YAAM,iBAAiB;AAAA,QACrB;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AACA,UAAI,kBAAkB,sBAAsB;AAC1C,eAAO;AAAA,MACT;AAAA,IACF;AACA;AAAA,EACF;AACA,MAAI,UAAU,MAAM,GAAG;AACrB,UAAM,iBAAiB,SAAS,OAAO,MAAM,QAAQ,YAAY;AACjE,QAAI,kBAAkB,sBAAsB;AAC1C,aAAO;AAAA,IACT;AACA,WAAO,YAAY,OAAO,MAAM,UAAU,sBAAsB,MAAM;AAAA,EACxE,YAAYV,aAAY,MAAM,KAAKC,OAAM,MAAM,MAAM,OAAO,UAAU;AACpE,WAAO;AAAA,MACL,OAAO;AAAA,MACP;AAAA,MACA;AAAA,IACF;AAAA,EACF,WAAW,cAAc,MAAM,GAAG;AAChC,QAAI,iBAA2B;AAE/B,QAAI,OAAO,QAAQ,OAAO,OAAO,SAAS,UAAU;AAClD,uBAAiB;AAAA,QACf,OAAO;AAAA,QACP;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,kBAAkB,OAAO,QAAQ,OAAO,OAAO,SAAS,UAAU;AACrE,uBAAiB;AAAA,QACf,OAAO;AAAA,QACP;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAEA,QAAI,kBAAkB,sBAAsB;AAC1C,aAAO;AAAA,IACT;AAAA,EACF;AACF;AAQA,SAAS,UACP,SACiC;AACjC,MACE,cAAc,OAAO,KACrB,OAAO,QAAQ,SAAS,YACxB,QAAQ,QACR,OAAO,QAAQ,SAAS,YACxB,CAAC,MAAM,QAAQ,QAAQ,IAAI,KAC3B,CAAC,cAAc,QAAQ,IAAI,KAC3B,QAAQ,KAAK,MAAM,SACnB;AACA,WAAO;AAAA,EACT;AACA,SAAO;AACT;AAAA;AAWO,SAAS,UACd,cACA,iBAAwC,CAAC,GACT;AAChC,QAAM,SAAyB;AAAA,IACb;AAAA,MACE,sBAAM,QAAQ;AAAA,MACd,sBAAsB,qBAAK,QAAQ,GAAmB,uBAAO,GAAG,aAAa,GAAmB,uBAAO,GAAmB,qBAAK,QAAQ,CAAC;AAAA,IAC1J;AAAA,IACgB,qBAAK,OAAO;AAAA,IACZ,yBAAyB,wBAAQ,gBAAgB,CAAC;AAAA,EACpE;AACA,SAAO,CAAC,qBAA4C,CAAC,MACnD,OAAOH,QAAO,gBAAgB,kBAAkB,CAA0B;AAC9E;AAAA;AAiBO,SAAS,OACd,OACA,SACgC;AAChC,QAAM,aAAa,CAAC,eAAsC;AACxD,UAAM,OAAO,QAAQ,UAAU;AAC/B,UAAM,aAAa,OAAO,UAAU,aAAa,MAAM,IAAI;AAC3D,QAAI,CAAC,SAAS,UAAU;AAAG,aAAO;AAClC,QAAI,gCAAgB,IAAI,KAAKG,OAAM,KAAK,IAAI,GAAG;AAC7C,WAAK,KAAK,QAAQ,EAAE,GAAG,KAAK,KAAK,OAAO,GAAG,WAAW;AAAA,IACxD,WAAWA,OAAM,IAAI,GAAG;AACtB,WAAK,QAAQ,EAAE,GAAG,KAAK,OAAO,GAAG,WAAW;AAAA,IAC9C;AACA,WAAO;AAAA,EACT;AACA,aAAW,KAAK,QAAQ;AACxB,SAAO;AACT;AAAA;AAcO,SAAS,IACd,WACA,MACA,WACgC;AAChC,QAAM,aAAa,CAAC,eAAsC;AACxD,UAAM,OAAO,KAAK,UAAU;AAC5B,QACE,aACC,eAAe,IAAI,KAAK,QAAQ,QACjC,gCAAgB,IAAI,GACpB;AACA,YAAM,kBAA0C;AAAA,QAC9C,IAAI;AAAA,QACJ,MAAM;AAAA,MACR;AACA,UAAI,WAAW;AACb,wBAAgB,OAAO,UAAU,UAAU;AAAA,MAC7C;AACA,aAAO;AAAA,IACT,WAAW,gCAAgB,IAAI,GAAG;AAChC,aAAO,OAAO,KAAK,MAAM,EAAE,IAAI,UAAU,CAAC;AAAA,IAC5C,WAAW,eAAe,IAAI,GAAG;AAC/B,aAAO,OAAO,MAAM,EAAE,IAAI,UAAU,CAAC;AAAA,IACvC;AACA,WAAO;AAAA,EACT;AACA,aAAW,KAAK,MAAM;AACtB,SAAO;AACT;AAAA;AAcO,SAAS,KACd,SACA,QACA,SACA;AACA,SAAO,CAAC,eAAyD;AAC/D,UAAM,OAAO,QAAQ,UAAU;AAC/B,QAAI,gCAAgB,IAAI,GAAG;AACzB,aAAO,OAAO,KAAK,MAAM,EAAE,KAAK,CAAC,SAAS,MAAM,EAAE,CAAC;AAAA,IACrD,WAAW,eAAe,IAAI,GAAG;AAC/B,aAAO,OAAO,MAAM,EAAE,KAAK,CAAC,SAAS,MAAM,EAAE,CAAC;AAAA,IAChD;AACA,WAAO;AAAA,EACT;AACF;AAAA;AAaO,SAAS,QACd,SACA,YACgC;AAChC,QAAM,aAAa,CAAC,eAAsC;AACxD,UAAM,OAAO,QAAQ,CAAC,CAAC;AACvB,QAAI,gCAAgB,IAAI,GAAG;AACzB,UAAI,MAAM,QAAQ,KAAK,IAAI;AAAG,eAAO;AACrC,WAAK,OAAO;AAAA,QACV,aAAa,KAAK,MAAM,UAAU;AAAA,QAClC,QAAQ,KAAK,WAAW,QAAQ,EAAE,IAAI,CAAC;AAAA,MACzC;AACA,aAAO;AAAA,IACT;AACA,WAAO;AAAA,MACL,aAAa,MAAM,UAAU;AAAA,MAC7B,QAAQ,KAAK,WAAW,QAAQ,EAAE,IAAI,CAAC;AAAA,IACzC;AAAA,EACF;AACA,aAAW,KAAK,QAAQ;AACxB,SAAO;AACT;AAAA;AAYO,SAAS,MACd,SAC6B;AAC7B,EAAAC,MAAK,KAAK,OAAO;AACjB,SAAO,WAAW,OAAO;AAC3B;AAEO,SAAS,cAAc;AAC5B,aAAW;AACb;;;AoDnZO,IAAM,SAAgC;AAAA;AAAA;AAAA;AAAA,EAI3C,QAAwB;AAAA,IACN,yBAAyB,wBAAQ,gBAAgB,CAAC;AAAA,IAClD;AAAA,MACE;AAAA,QACE,qBAAK,QAAQ;AAAA,QACb,uBAAO;AAAA,QACP,4BAAY,4BAA4B;AAAA,QACxC,uBAAO;AAAA,QACP,qBAAK,QAAQ;AAAA,MAC/B;AAAA,IACF;AAAA,IACgB,qBAAK,OAAO;AAAA,EAC9B;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA,EAKN,QAAQ;AAAA;AAAA;AAAA;AAAA,EAIR,OAAO,CAAC;AAAA;AAAA;AAAA;AAAA,EAIR,UAAU,CAAC,SAAS,QAAQ,GAAG,MAAO;AAAA;AAAA;AAAA;AAAA;AAAA,EAKtC,eAAe;AACjB;;;AC7BO,IAAM,WAAkC;AAAA;AAAA;AAAA;AAAA,EAI7C,QAAwB;AAAA,IACtB;AAAA,MACE;AAAA;AAAA;AAAA;AAAA,MAIgB;AAAA,QACE,yBAAyB,uBAAO,GAAmB,oBAAI,GAAmB,0BAA0B,qBAAK,WAAW,CAAC,GAAmB,uBAAO,CAAC;AAAA,QAChK,QAAwB,yBAAS,QAAQ,GAAG;AAAA,UAC1C,IAAI;AAAA,QACN,CAAC;AAAA,MACH;AAAA;AAAA;AAAA;AAAA,MAIgB;AAAA,QACE,uBAAO,QAAQ;AAAA,QACf,qBAAK,OAAO;AAAA,QACZ;AAAA,UACE;AAAA,YACE;AAAA,cACE;AAAA,gBACE,uBAAO;AAAA,gBACvB,QAAwB,oBAAI,GAAG;AAAA,kBAC7B,MAAM;AAAA,kBACN,OAAO;AAAA,oBACL,IAAI;AAAA,oBACJ,OAAO;AAAA,oBACP,SAAS;AAAA,kBACX;AAAA,gBACF,CAAC;AAAA,gBACe,0BAA0B,qBAAK,WAAW,CAAC;AAAA,gBAC3C,uBAAO;AAAA,cACzB;AAAA,cACA,QAAwB,yBAAS,eAAe,GAAG;AAAA,gBACjD,IAAI;AAAA,cACN,CAAC;AAAA,YACH;AAAA,YACgB,wBAAQ,cAAc;AAAA,UACxC;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA;AAAA,IAEA,IAAI,kCAAkD,qBAAK,OAAO,CAAC;AAAA,IACnD,yBAAyB,wBAAQ,gBAAgB,CAAC;AAAA,EACpE;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA,EAKN,QAAQ;AAAA;AAAA;AAAA;AAAA,EAIR,OAAO,CAAC,WAAW,WAAW,YAAY,eAAe;AAAA;AAAA;AAAA;AAAA,EAIzD,UAAU;AAAA,IACR;AAAA,IACA;AAAA,IACA,YAAY,aAAa,mBAAmB;AAAA,EAC9C;AAAA;AAAA;AAAA;AAAA,EAIA,eAAe;AACjB;;;AC/EO,IAAM,OAA8B;AAAA;AAAA;AAAA;AAAA,EAIzC,QAAwB;AAAA,IACN;AAAA,MACE,sBAAM,QAAQ;AAAA,MACd;AAAA,QACE,qBAAK,UAAU,OAAO;AAAA,QACtB,uBAAO;AAAA,QACP,0BAAU;AAAA,QACV;AAAA,UACE;AAAA,YACE,qBAAK,UAAU;AAAA,YACf,yBAAS,YAAY;AAAA,YACrC;AAAA,cACE;AAAA,cACgB;AAAA,gBACE,qBAAK,YAAY;AAAA,gBACjC;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,QACA,IAAI,qBAAqC,2BAAW,qBAAqB,CAAC;AAAA,QAC1D,wBAAwB,qBAAK,SAAS,GAAG,mBAAmB;AAAA,QAC5D,uBAAO;AAAA,QACP,qBAAK,QAAQ;AAAA,MAC/B;AAAA,IACF;AAAA,IACgB,qBAAK,OAAO;AAAA,IACZ,yBAAyB,wBAAQ,gBAAgB,CAAC;AAAA,EACpE;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA,EAKN,QAAQ;AAAA;AAAA;AAAA;AAAA,EAIR,OAAO,CAAC;AAAA;AAAA;AAAA;AAAA,EAIR,UAAU;AAAA,IACR;AAAA,IACA,YAAY,YAAY,UAAU;AAAA,IAClC,YAAY,cAAc,YAAY;AAAA,IACtC,YAAY,WAAW,SAAS;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA,EAIA,eAAe;AACjB;;;ACvEO,IAAMY,QAA8B;AAAA;AAAA;AAAA;AAAA,EAIzC,QAAwB;AAAA,IACtB;AAAA,IACgB,yBAAyB,wBAAQ,gBAAgB,CAAC;AAAA,IAClD,wBAAwB,4BAAY,CAAC;AAAA,EACvD;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM;AAAA;AAAA;AAAA;AAAA,EAIN,OAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAIA,UAAU,CAAC,MAAO,QAAgB;AAAA;AAAA;AAAA;AAAA,EAIlC,eAAe;AACjB;;;ACxCO,IAAM,QAA+B;AAAA;AAAA;AAAA;AAAA,EAI1C,QAAwB,yBAAS,gBAAgB;AAAA;AAAA;AAAA;AAAA,EAIjD,MAAM;AAAA;AAAA;AAAA;AAAA,EAIN,OAAO,CAAC;AAAA;AAAA;AAAA;AAAA,EAIR,UAAU,CAAC,UAAkB,aAAa;AAC5C;;;ACjBO,IAAM,SAAgC;AAAA;AAAA;AAAA;AAAA,EAI3C,QAAwB,0BAAU;AAAA;AAAA;AAAA;AAAA,EAIlC,MAAM;AAAA;AAAA;AAAA;AAAA,EAIN,OAAO,CAAC;AAAA;AAAA;AAAA;AAAA,EAIR,UAAU,CAAC,KAAK;AAClB;;;ACjBO,IAAM,OAA8B;AAAA;AAAA;AAAA;AAAA,EAIzC,QAAwB,yBAAS,gBAAgB;AAAA;AAAA;AAAA;AAAA,EAIjD,MAAM;AAAA;AAAA;AAAA;AAAA,EAIN,OAAO,CAAC,QAAQ,SAAS;AAAA;AAAA;AAAA;AAAA,EAIzB,UAAU,CAAC,UAAkB,aAAa;AAC5C;;;ACjBO,IAAM,OAA8B;AAAA;AAAA;AAAA;AAAA,EAIzC,QAAwB,yBAAS;AAAA;AAAA;AAAA;AAAA,EAIjC,MAAM;AAAA;AAAA;AAAA;AAAA,EAIN,OAAO,CAAC;AAAA;AAAA;AAAA;AAAA,EAIR,UAAU,CAAC;AACb;;;ACMO,IAAM,QAA+B;AAAA;AAAA;AAAA;AAAA,EAI1C,QAAwB;AAAA,IACtB;AAAA,MACE;AAAA;AAAA;AAAA;AAAA,MAIgB;AAAA,QACE,yBAAyB,uBAAO,GAAmB,oBAAI,GAAmB,0BAA0B,qBAAK,WAAW,CAAC,GAAmB,uBAAO,CAAC;AAAA,QAChK,QAAwB,yBAAS,QAAQ,GAAG;AAAA,UAC1C,IAAI;AAAA,QACN,CAAC;AAAA,MACH;AAAA;AAAA;AAAA;AAAA,MAIgB;AAAA,QACE,uBAAO,QAAQ;AAAA,QACf,qBAAK,OAAO;AAAA,QACZ;AAAA,UACE;AAAA,YACE;AAAA,cACE;AAAA,gBACE,uBAAO;AAAA,gBACvB,QAAwB,oBAAI,GAAG;AAAA,kBAC7B,MAAM;AAAA,kBACN,OAAO;AAAA,oBACL,IAAI;AAAA,oBACJ,OAAO;AAAA,oBACP,SAAS;AAAA,kBACX;AAAA,gBACF,CAAC;AAAA,gBACe,0BAA0B,qBAAK,WAAW,CAAC;AAAA,gBAC3C,uBAAO;AAAA,cACzB;AAAA,cACA,QAAwB,yBAAS,eAAe,GAAG;AAAA,gBACjD,IAAI;AAAA,cACN,CAAC;AAAA,YACH;AAAA,YACgB,wBAAQ,cAAc;AAAA,UACxC;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA;AAAA,IAEA,IAAI,kCAAkD,qBAAK,OAAO,CAAC;AAAA,IACnD,yBAAyB,wBAAQ,gBAAgB,CAAC;AAAA,EACpE;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA,EAKN,QAAQ;AAAA;AAAA;AAAA;AAAA,EAIR,OAAO,CAAC,WAAW,WAAW,YAAY,eAAe;AAAA;AAAA;AAAA;AAAA,EAIzD,UAAU,CAAC,SAAS,QAAQ,YAAY,aAAa,gBAAgB,CAAC;AAAA;AAAA;AAAA;AAAA,EAItE,eAAe;AACjB;;;AC5EO,IAAMC,UAAgC;AAAA;AAAA;AAAA;AAAA,EAI3C,QAAwB;AAAA,IACN;AAAA,MACE,sBAAM,QAAQ;AAAA,MACd;AAAA,QACE,qBAAK,QAAQ;AAAA,QACb,uBAAO;AAAA,QACP;AAAA,UACd;AAAA,YACE;AAAA,YACA,MAAM;AAAA,YACU;AAAA,cACd;AAAA,gBACE;AAAA,gBACgB,yBAAyB,2BAA2B,uBAAO,eAAe,CAAC,CAAC;AAAA,gBAC5E,uBAAO,eAAe;AAAA,cACxC;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,QACA,IAAI,iCAAiC,MAAM,IAAoB,qBAAK,QAAQ,CAAC;AAAA,QAC7D,uBAAO;AAAA,QACP,qBAAK,QAAQ;AAAA,MAC/B;AAAA,IACF;AAAA,IACgB,qBAAK,OAAO;AAAA,IACZ,yBAAyB,wBAAQ,gBAAgB,CAAC;AAAA,EACpE;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM;AAAA;AAAA;AAAA;AAAA,EAIN,OAAO,CAAC,WAAW,eAAe,eAAe;AAAA;AAAA;AAAA;AAAA,EAIjD,UAAU,CAAC,SAAS,QAAS,YAAY,UAAU,QAAQ,CAAC;AAAA;AAAA;AAAA;AAAA,EAI5D,eAAe;AACjB;;;ACrDO,IAAM,WAAkC;AAAA;AAAA;AAAA;AAAA,EAI7C,QAAwB;AAAA,IACN;AAAA,MACE,sBAAM,QAAQ;AAAA,MACd;AAAA,QACE,qBAAK,UAAU,OAAO;AAAA,QACtB,uBAAO;AAAA,QACP,8BAAc;AAAA,QACd,uBAAO;AAAA,QACP,qBAAK,QAAQ;AAAA,MAC/B;AAAA,IACF;AAAA,IACgB,qBAAK,OAAO;AAAA,IACZ,yBAAyB,wBAAQ,gBAAgB,CAAC;AAAA,EACpE;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM;AAAA;AAAA;AAAA;AAAA,EAIN,OAAO,CAAC;AAAA;AAAA;AAAA;AAAA,EAIR,UAAU,CAAC,YAAY;AAAA;AAAA;AAAA;AAAA,EAIvB,eAAe;AACjB;;;AClCO,IAAM,OAA8B;AAAA;AAAA;AAAA;AAAA,EAIzC,QAAwB;AAAA,IACN;AAAA,MACE,sBAAM,QAAQ;AAAA,MACd;AAAA,QACE,qBAAK,UAAU,OAAO;AAAA,QACtB,uBAAO;AAAA,QACP,0BAAU;AAAA,QACV,uBAAO;AAAA,QACP,qBAAK,QAAQ;AAAA,MAC/B;AAAA,IACF;AAAA,IACgB,qBAAK,OAAO;AAAA,IACZ,yBAAyB,wBAAQ,gBAAgB,CAAC;AAAA,EACpE;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA,EAKN,QAAQ;AAAA;AAAA;AAAA;AAAA,EAIR,OAAO,CAAC;AAAA;AAAA;AAAA;AAAA,EAIR,UAAU,CAAC,KAAK;AAAA;AAAA;AAAA;AAAA,EAIhB,eAAe;AACjB;;;ACyDO,IAAM,SAAS;AAAA,EACpB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,MAAAD;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,QAAAC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF","sourcesContent":["import { camel, extend, has } from '@formkit/utils'\nimport { FormKitLibrary, FormKitPlugin, FormKitNode } from '@formkit/core'\n\n/**\n * Creates a plugin based on a list of {@link @formkit/core#FormKitLibrary | FormKitLibrary}.\n *\n * @param libraries - One or many {@link @formkit/core#FormKitLibrary | FormKitLibrary}.\n *\n * @returns {@link @formkit/core#FormKitPlugin | FormKitPlugin}\n *\n * @public\n */\nexport function createLibraryPlugin(\n  ...libraries: FormKitLibrary[]\n): FormKitPlugin {\n  /**\n   * Merge all provided library items.\n   */\n  const library = libraries.reduce(\n    (merged, lib) => extend(merged, lib) as FormKitLibrary,\n    {} as FormKitLibrary\n  )\n  /* eslint-disable-next-line @typescript-eslint/no-empty-function */\n  const plugin = () => {}\n  /**\n   * Enables the hook that exposes all library inputs.\n   * @param node - The primary plugin\n   */\n  plugin.library = function (node: FormKitNode) {\n    const type = camel(node.props.type)\n    if (has(library, type)) {\n      node.define(library[type])\n    }\n  }\n  return plugin\n}\n","import {\n  FormKitPlugin,\n  FormKitGroupValue,\n  FormKitTypeDefinition,\n  FormKitSectionsSchema,\n  FormKitNode,\n  FormKitClasses,\n  FormKitFrameworkContext,\n  FormKitMessage,\n} from '@formkit/core'\nimport { FormKitFile } from './index'\n\n/**\n * These are props that are used as conditionals in one or more inputs, and as\n * such they need to be defined on all input types. These should all be defined\n * explicitly as \"undefined\" here, and then defined as their specific type\n * in the FormKitInputProps interface only on the inputs that use them.\n * @public\n */\nexport interface FormKitConditionalProps {\n  onValue: undefined\n  offValue: undefined\n  options: undefined\n  number: undefined\n}\n\n/**\n * An attempt to capture all non-undefined values. This is used to define\n * various conditionals where undefined is not a concrete type, but all other\n * values need to take one logical branch.\n *\n * @public\n */\nexport type AllReals =\n  | number\n  | string\n  | boolean\n  | CallableFunction\n  | Array<any>\n  | null\n  | Record<any, any>\n/**\n * This is the base interface for providing prop definitions to the FormKit\n * component. It is used to define the props that are available to the each\n * component in the FormKit library by using a discriminated union type. The\n * structure of this interface is:\n *\n * ```ts\n * interface FormKitInputProps {\n *  typeString: { type: 'string'; value?: string } // <-- All unique props\n * }\n * ```\n *\n * All inputs will also inherit all props from FormKitBaseInputProps.\n *\n * Note: It is important that all inputs provide a type and a value prop.\n * @public\n */\nexport interface FormKitInputProps<Props extends FormKitInputs<Props>> {\n  button: { type: 'button'; value?: undefined }\n  checkbox: {\n    type: 'checkbox'\n    options?: FormKitOptionsProp\n    onValue?: any\n    offValue?: any\n    value?: Props['options'] extends Record<infer T, string>\n      ? T[]\n      : Props['options'] extends FormKitOptionsItem[]\n      ? Array<Props['options'][number]['value']>\n      : Props['options'] extends Array<infer T>\n      ? T[]\n      :\n          | (Props['onValue'] extends AllReals ? Props['onValue'] : true)\n          | (Props['offValue'] extends AllReals ? Props['offValue'] : false)\n  }\n  color: { type: 'color'; value?: string }\n  date: { type: 'date'; value?: string }\n  'datetime-local': { type: 'datetime-local'; value?: string }\n  email: {\n    type: 'email'\n    value?: string\n  }\n  file: { type: 'file'; value?: FormKitFile[] }\n  form: {\n    type: 'form'\n    value?: FormKitGroupValue\n    actions?: boolean | string\n    submitAttrs?: Record<string, any>\n    submitBehavior?: 'disabled' | 'live'\n    incompleteMessage?: false | string\n  }\n  group: { type: 'group'; value?: FormKitGroupValue }\n  hidden: {\n    type: 'hidden'\n    value?: Props['number'] extends AllReals ? number : string\n    number?: 'integer' | 'float' | 'true' | true\n  }\n  list: {\n    type: 'list'\n    value?: unknown[]\n    dynamic?: boolean | 'true' | 'false'\n    sync?: boolean | 'true' | 'false'\n  }\n  meta: { type: 'meta'; value?: any }\n  month: { type: 'month'; value?: string }\n  number: {\n    type: 'number'\n    value?: Props['number'] extends AllReals ? number : string\n    number?: 'integer' | 'float' | 'true' | true\n  }\n  password: { type: 'password'; value?: string }\n  radio: {\n    type: 'radio'\n    options: FormKitOptionsProp\n    value?: FormKitOptionsValue<Props['options']>\n  }\n  range: {\n    type: 'range'\n    value?: Props['number'] extends AllReals ? number : string\n    number?: 'integer' | 'float' | 'true' | true\n  }\n  search: {\n    type: 'search'\n    value?: Props['number'] extends AllReals ? number | string : string\n    number?: 'integer' | 'float' | 'true' | true\n  }\n  select: {\n    type: 'select'\n    options?: FormKitOptionsPropWithGroups\n    value?: FormKitOptionsValue<Props['options']>\n  }\n  submit: { type: 'submit'; value?: string }\n  tel: {\n    type: 'tel'\n    value?: Props['number'] extends AllReals ? number | string : string\n    number?: 'integer' | 'float' | 'true' | true\n  }\n  text: {\n    type: 'text'\n    value?: Props['number'] extends AllReals ? number | string : string\n    number?: 'integer' | 'float' | 'true' | true\n  }\n  textarea: { type: 'textarea'; value?: string }\n  time: { type: 'time'; value?: string }\n  url: { type: 'url'; value?: string }\n  week: { type: 'week'; value?: string }\n  // This fallthrough is for inputs that do not have their type set. These\n  // are effectively \"text\" inputs.\n  _: {\n    type?:\n      | (Props['type'] extends FormKitTypeDefinition<any>\n          ? Props['type']\n          : never & {})\n      | (Props['type'] extends keyof FormKitInputProps<Props>\n          ? Props['type']\n          : never)\n    value?: Props['type'] extends FormKitTypeDefinition<infer T>\n      ? T\n      : Props['type'] extends AllReals\n      ? never\n      : string\n  }\n}\n\n/**\n * A merger of input props, base props, and conditional props. This is then\n * used as the structure for the FormKitInputs type.\n * @public\n */\nexport type MergedProps<Props extends FormKitInputs<Props>> = {\n  [K in keyof FormKitInputProps<Props>]: Omit<\n    Partial<FormKitBaseProps>,\n    keyof FormKitInputProps<Props>[K]\n  > &\n    Omit<\n      Partial<FormKitRuntimeProps<Props>>,\n      keyof FormKitInputProps<Props>[K]\n    > &\n    Omit<Partial<FormKitConditionalProps>, keyof FormKitInputProps<Props>[K]> &\n    Partial<\n      K extends keyof FormKitInputEventsAsProps<Props>\n        ? Omit<\n            FormKitEventsAsProps,\n            keyof FormKitInputEventsAsProps<Props>[K]\n          > &\n            FormKitInputEventsAsProps<Props>[K]\n        : FormKitEventsAsProps\n    > &\n    FormKitInputProps<Props>[K]\n}\n\n/**\n * Merge all events into a single type. This is then used as the structure for\n *\n * @public\n */\nexport type MergedEvents<Props extends FormKitInputs<Props>> =\n  InputType<Props> extends keyof FormKitInputEvents<Props>\n    ? FormKitBaseEvents<Props> & FormKitInputEvents<Props>[InputType<Props>]\n    : FormKitBaseEvents<Props>\n\n/**\n * Selects the \"type\" from the props if it exists, otherwise it defaults to\n * \"text\".\n *\n * @public\n */\nexport type InputType<Props extends FormKitInputs<Props>> =\n  Props['type'] extends FormKitTypeDefinition<any>\n    ? Props['type']\n    : Props['type'] extends string\n    ? Props['type']\n    : 'text'\n\n/**\n * All FormKit events should be included for a given set of props.\n *\n * @public\n */\nexport type FormKitEvents<Props extends FormKitInputs<Props>> =\n  MergedEvents<Props>\n\n/**\n * All FormKit inputs should be included for this type.\n * @public\n */\nexport type FormKitInputs<Props extends FormKitInputs<Props>> =\n  MergedProps<Props>[keyof MergedProps<Props>]\n\n/**\n * Unique events emitted by each FormKit input. The shape of this interface is:\n *\n * ```ts\n * interface FormKitInputEvents<Props extends Inputs> {\n *   typeString: { customEvent: (value: PropType<Props, 'value'>) => any } // <-- All unique events\n * }\n * ```\n *\n * All inputs will also inherit all events from FormKitBaseInputEvents.\n * @public\n */\nexport interface FormKitInputEvents<Props extends FormKitInputs<Props>> {\n  form: {\n    (event: 'submit-raw', e: Event, node: FormKitNode): any\n    (event: 'submit-invalid', node: FormKitNode): any\n    (event: 'submit', data: any, node: FormKitNode): any\n  }\n}\n\n/**\n * Extracts the type from a given prop.\n * @public\n */\nexport type PropType<\n  Props extends FormKitInputs<Props>,\n  T extends keyof FormKitInputs<Props>\n> = Props['type'] extends FormKitTypeDefinition<infer T>\n  ? T extends 'value'\n    ? Props['type']\n    : T\n  : Extract<\n      FormKitInputs<Props>,\n      {\n        type: Props['type'] extends keyof FormKitInputProps<Props>\n          ? Props['type']\n          : 'text'\n      }\n    >[T]\n\n/**\n * The proper shape of data to be passed to options prop.\n * @public\n */\nexport type FormKitOptionsValue<Options> = Options extends FormKitOptionsProp\n  ? Options extends Record<infer T, string>\n    ? T\n    : Options extends FormKitOptionsItem[]\n    ? Options[number]['value']\n    : Options extends Array<infer T>\n    ? T\n    : unknown\n  : unknown\n\n/**\n * General input events available to all FormKit inputs.\n * @public\n */\nexport interface FormKitBaseEvents<Props extends FormKitInputs<Props>> {\n  (event: 'input', value: PropType<Props, 'value'>, node: FormKitNode): any\n  (event: 'inputRaw', value: PropType<Props, 'value'>, node: FormKitNode): any\n  (event: 'input-raw', value: PropType<Props, 'value'>, node: FormKitNode): any\n  (event: 'update:modelValue', value: PropType<Props, 'value'>): any\n  (event: 'update:model-value', value: PropType<Props, 'value'>): any\n  (event: 'node', node: FormKitNode): any\n}\n\n/**\n * In a perfect world this interface would not be required at all. However, Vue\n * expects the interfaces to be defined as method overloads. Unfortunately since\n * our events interface uses generics UnionToIntersection is not able to be used\n * meaning that we lose event data if we store the events as a standard\n * interface with property keys. The only way we have found to reliably get\n * Volar (as of June 2023) to properly recognize all defined events is to use\n * a the \"standard\" method overload approach (see FormKitBaseEvents).\n *\n * (Basically we cannot use the events in this interface to automatically\n * produce the FormKitBaseEvents without Volar loosing event data)\n *\n * This means we have no way to get the event names out of the interface so we\n * cannot properly use them in our props. This matters for things like TSX\n * support where the event names need to be available as `onEventName` props.\n *\n * This interface is used to manually patch that gap in the type system. These\n * types should match up 1-1 with the events defined in FormKitBaseEvents as\n * well as FormKitInputEvents.\n *\n * @public\n */\nexport interface FormKitEventsAsProps {\n  onInput: (value: unknown, node: FormKitNode) => any\n  onInputRaw: (value: unknown, node: FormKitNode) => any\n  'onUpdate:modelValue': (value: unknown, node: FormKitNode) => any\n  onNode: (node: FormKitNode) => any\n}\n\n/**\n * See the comment tome on {@link FormKitEventsAsProps} for why this type is\n * necessary.\n *\n * @public\n */\nexport interface FormKitInputEventsAsProps<Props extends FormKitInputs<Props>> {\n  form: {\n    onSubmitRaw: (e: Event, node: FormKitNode) => any\n    onSubmitInvalid: (node: FormKitNode) => any\n    onSubmit: (data: any, node: FormKitNode) => any\n  }\n}\n\n/**\n * The shape of the context object that is passed to each slot.\n * @public\n */\nexport interface FormKitSlotData<\n  Props extends FormKitInputs<Props>,\n  E extends Record<string, any> = {}\n> {\n  (context: FormKitFrameworkContext<PropType<Props, 'value'>> & E): any\n}\n\n/**\n * Nearly all inputs in FormKit have a \"base\" set of slots. This is the\n * \"sandwich\" around the input itself, like the wrappers, help text, error\n * messages etc. Several other input’s slots extend this base interface.\n * @public\n */\nexport interface FormKitBaseSlots<Props extends FormKitInputs<Props>> {\n  help: FormKitSlotData<Props>\n  inner: FormKitSlotData<Props>\n  input: FormKitSlotData<Props>\n  label: FormKitSlotData<Props>\n  message: FormKitSlotData<Props, { message: FormKitMessage }>\n  messages: FormKitSlotData<Props>\n  outer: FormKitSlotData<Props>\n  prefix: FormKitSlotData<Props>\n  prefixIcon: FormKitSlotData<Props>\n  suffix: FormKitSlotData<Props>\n  suffixIcon: FormKitSlotData<Props>\n  wrapper: FormKitSlotData<Props>\n}\n\n/**\n * The slots available to the FormKitText input, these extend the base slots.\n * @public\n */\nexport interface FormKitTextSlots<Props extends FormKitInputs<Props>>\n  extends FormKitBaseSlots<Props> {}\n\n/**\n * The data available to slots that have an option in scope.\n * @public\n */\nexport interface OptionSlotData<Props extends FormKitInputs<Props>> {\n  option: FormKitOptionsItem<PropType<Props, 'value'>>\n}\n\n/**\n * The slots available to the select input, these extend the base slots.\n * @public\n */\nexport interface FormKitSelectSlots<Props extends FormKitInputs<Props>>\n  extends FormKitBaseSlots<Props> {\n  default: FormKitSlotData<Props>\n  option: FormKitSlotData<Props, OptionSlotData<Props>>\n  selectIcon: FormKitSlotData<Props>\n}\n\n/**\n * The slots available to the checkbox inputs even when options are not provided, these extend the base slots.\n * @public\n */\nexport interface FormKitCheckboxSlots<Props extends FormKitInputs<Props>>\n  extends FormKitBaseSlots<Props> {\n  decorator: FormKitSlotData<Props, OptionSlotData<Props>>\n  decoratorIcon: FormKitSlotData<Props, OptionSlotData<Props>>\n}\n\n/**\n * The slots available to the radio and checkbox inputs when options are\n * provided.\n * @public\n */\nexport interface FormKitBoxSlots<Props extends FormKitInputs<Props>> {\n  fieldset: FormKitSlotData<Props>\n  legend: FormKitSlotData<Props>\n  help: FormKitSlotData<Props>\n  options: FormKitSlotData<Props>\n  option: FormKitSlotData<Props, OptionSlotData<Props>>\n  wrapper: FormKitSlotData<Props, OptionSlotData<Props>>\n  inner: FormKitSlotData<Props, OptionSlotData<Props>>\n  input: FormKitSlotData<Props, OptionSlotData<Props>>\n  label: FormKitSlotData<Props, OptionSlotData<Props>>\n  prefix: FormKitSlotData<Props, OptionSlotData<Props>>\n  suffix: FormKitSlotData<Props, OptionSlotData<Props>>\n  decorator: FormKitSlotData<Props, OptionSlotData<Props>>\n  decoratorIcon: FormKitSlotData<Props, OptionSlotData<Props>>\n  optionHelp: FormKitSlotData<Props, OptionSlotData<Props>>\n  box: FormKitSlotData<Props, OptionSlotData<Props>>\n  icon: FormKitSlotData<Props, OptionSlotData<Props>>\n  message: FormKitSlotData<Props, { message: FormKitMessage }>\n  messages: FormKitSlotData<Props>\n}\n\n/**\n * The slots available to the file input, these extend the base slots.\n * @public\n */\nexport interface FormKitFileSlots<Props extends FormKitInputs<Props>>\n  extends FormKitBaseSlots<Props> {\n  fileList: FormKitSlotData<Props>\n  fileItem: FormKitSlotData<Props>\n  fileItemIcon: FormKitSlotData<Props, { file: FormKitFile }>\n  fileName: FormKitSlotData<Props, { file: FormKitFile }>\n  fileRemove: FormKitSlotData<Props, { file: FormKitFile }>\n  fileRemoveIcon: FormKitSlotData<Props, { file: FormKitFile }>\n  noFiles: FormKitSlotData<Props>\n}\n\n/**\n * The slots available to the button input, these extend the base slots.\n *\n * @public\n */\nexport type FormKitButtonSlots<Props extends FormKitInputs<Props>> = Omit<\n  FormKitBaseSlots<Props>,\n  'inner'\n> & {\n  default: FormKitSlotData<Props>\n}\n\n/**\n * Slots provided by each FormKit input. The shape of this interface is:\n *\n * ```ts\n * interface FormKitInputSlots<Props extends Inputs> {\n *   typeString: { default: (value: PropType<Props, 'value'>) => any } // <-- All unique slots\n * }\n * ```\n *\n * There is no automatic inheritance of slots — each slot must be explicitly\n * defined for each input.\n * @public\n */\nexport interface FormKitInputSlots<Props extends FormKitInputs<Props>> {\n  text: FormKitTextSlots<Props>\n  color: FormKitTextSlots<Props>\n  date: FormKitTextSlots<Props>\n  'datetime-local': FormKitTextSlots<Props>\n  email: FormKitTextSlots<Props>\n  month: FormKitTextSlots<Props>\n  number: FormKitTextSlots<Props>\n  password: FormKitTextSlots<Props>\n  search: FormKitTextSlots<Props>\n  tel: FormKitTextSlots<Props>\n  time: FormKitTextSlots<Props>\n  url: FormKitTextSlots<Props>\n  week: FormKitTextSlots<Props>\n  range: FormKitTextSlots<Props>\n  // Technically textarea has a unique schema, but the slots are the same:\n  textarea: FormKitTextSlots<Props>\n  select: FormKitSelectSlots<Props>\n  radio: Props['options'] extends AllReals\n    ? FormKitBoxSlots<Props>\n    : FormKitBaseSlots<Props>\n  list: { default: FormKitSlotData<Props> }\n  hidden: { input: FormKitSlotData<Props> }\n  meta: { wrapper: FormKitSlotData<Props> }\n  group: { default: FormKitSlotData<Props> }\n  form: {\n    form: FormKitSlotData<Props>\n    default: FormKitSlotData<Props>\n    message: FormKitSlotData<Props, { message: FormKitMessage }>\n    messages: FormKitSlotData<Props>\n    actions: FormKitSlotData<Props>\n    submit: FormKitSlotData<Props>\n  }\n  file: FormKitFileSlots<Props>\n  checkbox: Props['options'] extends AllReals\n    ? FormKitBoxSlots<Props>\n    : FormKitCheckboxSlots<Props>\n  submit: FormKitButtonSlots<Props>\n  button: FormKitButtonSlots<Props>\n}\n\n/**\n * Options should always be formatted as an array of objects with label and value\n * properties.\n *\n * @public\n */\nexport interface FormKitOptionsItem<V = unknown> {\n  label: string\n  value: V\n  attrs?: {\n    disabled?: boolean\n  } & Record<string, any>\n  __original?: any\n  [index: string]: any\n}\n\n/**\n * Option groups should always be formatted as an array of objects with group and nested options\n *\n * @public\n */\nexport interface FormKitOptionsGroupItemProp {\n  group: string\n  options: FormKitOptionsProp\n  attrs?: Record<string, any>\n}\n\n/**\n * Option groups should always be formatted as an array of objects with group and nested options\n *\n * @public\n */\nexport interface FormKitOptionsGroupItem {\n  group: string\n  options: FormKitOptionsList\n  attrs?: Record<string, any>\n}\n\n/**\n * An array of option items.\n *\n * @public\n */\nexport type FormKitOptionsList = FormKitOptionsItem[]\n\n/**\n * An array of option items with a group.\n *\n * @public\n */\nexport type FormKitOptionsListWithGroups = Array<\n  FormKitOptionsItem | FormKitOptionsGroupItem\n>\n\n/**\n * An array of option items with a group support — where the `option` of the\n * groups can be any valid FormKitOptionsProp type.\n *\n * @public\n */\nexport type FormKitOptionsListWithGroupsProp = Array<\n  FormKitOptionsItem | FormKitOptionsGroupItemProp\n>\n\n/**\n * Allows for prop extensions to be defined by using an interface whose keys\n * are ignored, but values are applied to a union type. This allows for any\n * third party code to extend the options prop by using module augmentation\n * to add new values to the union type.\n *\n * @public\n */\nexport interface FormKitOptionsPropExtensions {\n  arrayOfStrings: string[]\n  arrayOfNumbers: number[]\n  optionsList: FormKitOptionsList\n  valueLabelPojo: Record<string | number, string>\n}\n\n/**\n * The types of options that can be passed to the options prop.\n *\n * @public\n */\nexport type FormKitOptionsProp =\n  FormKitOptionsPropExtensions[keyof FormKitOptionsPropExtensions]\n\n/**\n * The types of options that can be passed to the options prop.\n *\n * @public\n */\nexport type FormKitOptionsPropWithGroups =\n  | FormKitOptionsProp\n  | FormKitOptionsListWithGroupsProp\n\n/**\n * Typings for all the built in runtime props.\n *\n * Warning: As of writing these are only specific to Vue’s runtime prop\n * requirements and should not be used as any kind of external API as they are\n * subject to change.\n *\n * @public\n */\nexport interface FormKitRuntimeProps<\n  Props extends FormKitInputs<Props>,\n  V = unknown\n> {\n  /**\n   * An object of configuration data for the input and its children.\n   */\n  config: Record<string, any>\n  /**\n   * An object of classes to be applied to the input.\n   */\n  classes: Record<string, string | Record<string, boolean> | FormKitClasses>\n  /**\n   * Amount of time to debounce input before committing.\n   */\n  delay: number\n  /**\n   * An array of errors for the input.\n   */\n  errors: string[]\n  /**\n   * A object of values\n   */\n  inputErrors: Record<string, string[]>\n  /**\n   * An explicit index to mount a child of a list at.\n   */\n  index: number\n  /**\n   * A globally unique identifier for the input — this passes through to the\n   * id attribute.\n   */\n  id: string\n  /**\n   * The dynamic value of the input.\n   */\n  modelValue: PropType<Props, 'value'>\n  /**\n   * The name of the input.\n   */\n  name: string\n  /**\n   * An explicit parent node for the input.\n   */\n  parent: FormKitNode\n  /**\n   * An array of plugins to apply to the input.\n   */\n  plugins: FormKitPlugin[]\n  /**\n   * An object of sections to merge with the input’s internal schema.\n   */\n  sectionsSchema: FormKitSectionsSchema\n  /**\n   * A boolean indicating whether the input should be synced with the model.\n   */\n  sync: boolean | undefined\n  /**\n   * The type of the input.\n   */\n  type: string | FormKitTypeDefinition<V>\n  /**\n   * A validation string or array of validation rules.\n   */\n  validation: string | Array<[rule: string, ...args: any]>\n  /**\n   * An object of validation messages to use for the input.\n   */\n  validationMessages: Record<\n    string,\n    string | ((ctx: { node: FormKitNode; name: string; args: any[] }) => string)\n  >\n  /**\n   * An object of additional validation rules to use for the input.\n   */\n  validationRules: Record<\n    string,\n    (node: FormKitNode, ...args: any[]) => boolean | Promise<boolean>\n  >\n  /**\n   * Use this to override the default validation label in validation messages.\n   */\n  validationLabel: string | ((node: FormKitNode) => string)\n}\n\n/**\n * Base props that should be applied to all FormKit inputs. These are not actual\n * runtime props and are pulled from the context.attrs object. Many of these are\n * just html attributes that are passed through to the input element.\n *\n * @public\n */\nexport interface FormKitBaseProps {\n  /**\n   * HTML Attribute, read more here: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#accept\n   */\n  accept: string\n  action: string\n  actions: 'true' | 'false' | boolean\n  dirtyBehavior: 'touched' | 'compare'\n  disabled: 'true' | 'false' | boolean\n  enctype: string\n  help: string\n  ignore: 'true' | 'false' | boolean\n  label: string\n  library: Record<string, any>\n  max: string | number\n  method: string\n  min: string | number\n  multiple: 'true' | 'false' | boolean\n  preserve: 'true' | 'false' | boolean\n  preserveErrors: 'true' | 'false' | boolean\n  placeholder: string\n  step: string | number\n  validationVisibility: 'live' | 'blur' | 'dirty' | 'submit'\n}\n\n/**\n * All the explicit FormKit props that need to be passed to FormKit’s Vue\n * component instance.\n * @public\n */\nexport const runtimeProps = [\n  'classes',\n  'config',\n  'delay',\n  'errors',\n  'id',\n  'index',\n  'inputErrors',\n  'library',\n  'modelValue',\n  'onUpdate:modelValue',\n  'name',\n  'number',\n  'parent',\n  'plugins',\n  'sectionsSchema',\n  'type',\n  'validation',\n  'validationLabel',\n  'validationMessages',\n  'validationRules',\n  // Runtime event props:\n  'onInput',\n  'onInputRaw',\n  'onUpdate:modelValue',\n  'onNode',\n  'onSubmit',\n  'onSubmitInvalid',\n  'onSubmitRaw',\n]\n\n/**\n * A helper to determine if an option is a group or an option.\n * @param option - An option\n *\n * @public\n */\nexport function isGroupOption(\n  option:\n    | FormKitOptionsItem\n    | FormKitOptionsGroupItem\n    | FormKitOptionsGroupItemProp\n): option is FormKitOptionsGroupItem {\n  return (\n    option &&\n    typeof option === 'object' &&\n    'group' in option &&\n    Array.isArray(option.options)\n  )\n}\n","import { FormKitNode } from '@formkit/core'\nimport {\n  FormKitOptionsPropWithGroups,\n  FormKitOptionsListWithGroups,\n  FormKitOptionsItem,\n  FormKitOptionsGroupItem,\n  FormKitOptionsList,\n  FormKitOptionsProp,\n  isGroupOption,\n} from '../props'\nimport { eq, isPojo } from '@formkit/utils'\n\n/**\n * A function to normalize an array of objects, array of strings, or object of\n * key-values to use an array of objects with value and label properties.\n *\n * @param options - An un-normalized {@link FormKitOptionsProp | FormKitOptionsProp}.\n *\n * @returns A list of {@link FormKitOptionsList | FormKitOptionsList}.\n *\n * @public\n */\nexport function normalizeOptions<T extends FormKitOptionsPropWithGroups>(\n  options: T,\n  i = { count: 1 }\n): T extends FormKitOptionsProp\n  ? FormKitOptionsList\n  : FormKitOptionsListWithGroups {\n  if (Array.isArray(options)) {\n    return options.map(\n      (option): FormKitOptionsItem | FormKitOptionsGroupItem => {\n        if (typeof option === 'string' || typeof option === 'number') {\n          return {\n            label: String(option),\n            value: String(option),\n          }\n        }\n        if (typeof option == 'object') {\n          if ('group' in option) {\n            option.options = normalizeOptions(option.options || [], i)\n            return option as FormKitOptionsGroupItem\n          } else if ('value' in option && typeof option.value !== 'string') {\n            Object.assign(option, {\n              value: `__mask_${i.count++}`,\n              __original: option.value,\n            })\n          }\n        }\n        return option as FormKitOptionsItem\n      }\n    ) as any\n  }\n  return Object.keys(options).map((value: string) => {\n    return {\n      label: options[value],\n      value,\n    }\n  })\n}\n\n/**\n * Given an {@link FormKitOptionsList | FormKitOptionsListWithGroups}, find the real value in the options.\n *\n * @param options - The {@link FormKitOptionsList | FormKitOptionsListWithGroups} to check for a given value\n * @param value - The value to return\n *\n * @returns `unknown`\n *\n * @public\n */\nexport function optionValue(\n  options: FormKitOptionsListWithGroups,\n  value: string,\n  undefinedIfNotFound = false\n): unknown {\n  if (Array.isArray(options)) {\n    for (const option of options) {\n      if (typeof option !== 'object' && option) continue\n      if (isGroupOption(option)) {\n        const found = optionValue(option.options, value, true)\n        if (found !== undefined) {\n          return found\n        }\n      } else if (value == option.value) {\n        return '__original' in option ? option.__original : option.value\n      }\n    }\n  }\n  return undefinedIfNotFound ? undefined : value\n}\n\n/**\n * Determines if the value should be selected.\n *\n * @param valueA - Any type of value\n * @param valueB - Any type of value\n *\n * @returns `boolean`\n *\n * @public\n */\nexport function shouldSelect(valueA: unknown, valueB: unknown): boolean {\n  if (\n    (valueA === null && valueB === undefined) ||\n    (valueA === undefined && valueB === null)\n  )\n    return false\n  if (valueA == valueB) return true\n  if (isPojo(valueA) && isPojo(valueB)) return eq(valueA, valueB)\n  return false\n}\n\n/**\n * A feature that converts the options prop to usable values, to be used by a\n * feature or a plugin.\n *\n * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.\n *\n * @public\n */\nexport default function options(node: FormKitNode): void {\n  node.hook.prop((prop: any, next: any) => {\n    if (prop.prop === 'options') {\n      if (typeof prop.value === 'function') {\n        node.props.optionsLoader = prop.value\n        prop.value = []\n      } else {\n        node.props._normalizeCounter ??= { count: 1 }\n        prop.value = normalizeOptions(prop.value, node.props._normalizeCounter)\n      }\n    }\n    return next(prop)\n  })\n}\n","import { extend } from '@formkit/utils'\nimport {\n  FormKitSchemaNode,\n  FormKitExtendableSchemaRoot,\n  isDOM,\n  isComponent,\n  FormKitSchemaDOMNode,\n  FormKitSchemaComponent,\n  FormKitSchemaFormKit,\n  FormKitSectionsSchema,\n  FormKitSchemaCondition,\n} from '@formkit/core'\n\n/**\n * A function that is called with an extensions argument and returns a valid\n * schema node.\n *\n * @public\n */\nexport interface FormKitSchemaExtendableSection {\n  (extensions: FormKitSectionsSchema): FormKitSchemaNode\n  _s?: string\n}\n\n/**\n * A function that when called, returns a function that can in turn be called\n * with an extension parameter.\n *\n * @public\n */\nexport interface FormKitSection<T = FormKitSchemaExtendableSection> {\n  (\n    ...children: Array<\n      FormKitSchemaExtendableSection | string | FormKitSchemaCondition\n    >\n  ): T\n}\n\n/**\n * Creates a new reusable section.\n *\n * @param section - A single section of schema\n * @param el - The element or a function that returns a schema node.\n * @param root - When true, returns a FormKitExtendableSchemaRoot. When false,\n * returns a FormKitSchemaExtendableSection.\n *\n * @returns Returns a {@link @formkit/core#FormKitExtendableSchemaRoot\n * | FormKitExtendableSchemaRoot} or a {@link\n * @formkit/core#FormKitSchemaExtendableSection | FormKitSchemaExtendableSection}.\n *\n * @public\n */\nexport function createSection(\n  section: string,\n  el: string | null | (() => FormKitSchemaNode),\n  fragment: true\n): FormKitSection<FormKitExtendableSchemaRoot>\n\n/**\n * @param section - A single section of schema\n * @param el - The element or a function that returns a schema node.\n *\n * @public\n */\nexport function createSection(\n  section: string,\n  el: string | null | (() => FormKitSchemaNode)\n): FormKitSection<FormKitSchemaExtendableSection>\n\n/**\n * @param section - A single section of schema\n * @param el - The element or a function that returns a schema node.\n * @param root - When false, returns a FormKitSchemaExtendableSection.\n *\n * @public\n */\nexport function createSection(\n  section: string,\n  el: string | (() => FormKitSchemaNode),\n  fragment: false\n): FormKitSection<FormKitSchemaExtendableSection>\n\n/*@__NO_SIDE_EFFECTS__*/\nexport function createSection(\n  section: string,\n  el: string | null | (() => FormKitSchemaNode),\n  fragment = false\n): FormKitSection<\n  FormKitExtendableSchemaRoot | FormKitSchemaExtendableSection\n> {\n  return (\n    ...children: Array<\n      FormKitSchemaExtendableSection | string | FormKitSchemaCondition\n    >\n  ) => {\n    const extendable = (extensions: FormKitSectionsSchema) => {\n      const node = !el || typeof el === 'string' ? { $el: el } : el()\n      if (isDOM(node) || isComponent(node)) {\n        if (!node.meta) {\n          node.meta = { section }\n        } else {\n          node.meta.section = section\n        }\n        if (children.length && !node.children) {\n          node.children = [\n            ...children.map((child) =>\n              typeof child === 'function' ? child(extensions) : child\n            ),\n          ]\n        }\n        if (isDOM(node)) {\n          node.attrs = {\n            class: `$classes.${section}`,\n            ...(node.attrs || {}),\n          }\n        }\n      }\n      return {\n        if: `$slots.${section}`,\n        then: `$slots.${section}`,\n        else:\n          section in extensions\n            ? extendSchema(node, extensions[section])\n            : node,\n      }\n    }\n    extendable._s = section\n    return fragment ? createRoot(extendable) : extendable\n  }\n}\n\n/**\n * Returns an extendable schema root node.\n *\n * @param rootSection - Creates the root node.\n *\n * @returns {@link @formkit/core#FormKitExtendableSchemaRoot | FormKitExtendableSchemaRoot}\n *\n * @internal\n */\n/*@__NO_SIDE_EFFECTS__*/\nexport function createRoot(\n  rootSection: FormKitSchemaExtendableSection\n): FormKitExtendableSchemaRoot {\n  return (extensions: FormKitSectionsSchema) => {\n    return [rootSection(extensions)]\n  }\n}\n\n/**\n * Type guard for schema objects.\n *\n * @param schema - returns `true` if the node is a schema node but not a string\n * or conditional.\n *\n * @returns `boolean`\n *\n * @public\n */\nexport function isSchemaObject(\n  schema: Partial<FormKitSchemaNode> | null\n): schema is\n  | FormKitSchemaDOMNode\n  | FormKitSchemaComponent\n  | FormKitSchemaFormKit {\n  return !!(\n    schema &&\n    typeof schema === 'object' &&\n    ('$el' in schema || '$cmp' in schema || '$formkit' in schema)\n  )\n}\n\n/**\n * Extends a single schema node with an extension. The extension can be any\n * partial node including strings.\n *\n * @param schema - The base schema node.\n * @param extension - The values to extend on the base schema node.\n *\n * @returns {@link @formkit/core#FormKitSchemaNode | FormKitSchemaNode}\n *\n * @public\n */\n/*@__NO_SIDE_EFFECTS__*/\nexport function extendSchema(\n  schema: FormKitSchemaNode,\n  extension: Partial<FormKitSchemaNode> | null = {}\n): FormKitSchemaNode {\n  if (typeof schema === 'string') {\n    return isSchemaObject(extension) || typeof extension === 'string'\n      ? extension\n      : schema\n  } else if (Array.isArray(schema)) {\n    return isSchemaObject(extension) ? extension : schema\n  }\n  return extend(schema, extension) as FormKitSchemaNode\n}\n","import { extend, isObject, token } from '@formkit/utils'\nimport {\n  FormKitExtendableSchemaRoot,\n  FormKitSchemaAttributes,\n  FormKitSchemaNode,\n  FormKitSchemaCondition,\n  FormKitSchemaDefinition,\n  FormKitSchemaComponent,\n  isComponent,\n  isDOM,\n  isConditional,\n  warn,\n  FormKitSchemaDOMNode,\n  FormKitSectionsSchema,\n} from '@formkit/core'\nimport {\n  isSchemaObject,\n  extendSchema,\n  FormKitSection,\n  FormKitSchemaExtendableSection,\n  createRoot,\n} from './createSection'\nimport {\n  outer,\n  wrapper,\n  prefix,\n  suffix,\n  label,\n  inner,\n  messages,\n  message,\n  help,\n  icon,\n} from './sections'\nimport { resetRadio } from './features/renamesRadios'\n\n/**\n * Either a schema node, or a function that returns a schema node.\n *\n * @public\n */\nexport type FormKitInputSchema =\n  | ((children?: FormKitSchemaDefinition) => FormKitSchemaNode)\n  | FormKitSchemaNode\n\n/**\n * A type narrowed type that represents a formkit schema \"section\". These are\n * always in the shape:\n * ```js\n * {\n *   if: string,\n *   then: '$slots.sectionName',\n *   else: {\n *    meta: {\n *      section: 'sectionName'\n *    },\n *    $el: 'div' // or $cmp...\n *   }\n * }\n * ```\n *\n * @public\n */\nexport type FormKitSchemaSection = FormKitSchemaCondition & {\n  else:\n    | FormKitSchemaDOMNode\n    | (FormKitSchemaComponent & { meta: { section: string } })\n}\n\n/**\n * Checks if the current schema node is a slot condition.\n *\n * @example\n *\n * ```js\n * {\n *  if: '$slot.name',\n *  then: '$slot.name',\n *  else: []\n * } // this schema node would return true.\n * ```\n *\n * @param node - A {@link @formkit/core#FormKitSchemaNode | FormKitSchemaNode}.\n *\n * @returns `boolean`\n *\n * @public\n */\n/*@__NO_SIDE_EFFECTS__*/\nexport function isSlotCondition(node: FormKitSchemaNode): node is {\n  if: string\n  then: string\n  else: FormKitSchemaNode | FormKitSchemaNode[]\n} {\n  if (\n    isConditional(node) &&\n    node.if &&\n    node.if.startsWith('$slots.') &&\n    typeof node.then === 'string' &&\n    node.then.startsWith('$slots.') &&\n    'else' in node\n  ) {\n    return true\n  }\n  return false\n}\n\n/**\n * Finds a section by name in a schema.\n *\n * @param schema - A {@link @formkit/core#FormKitSchemaDefinition | FormKitSchemaDefinition} array.\n * @param target - The name of the section to find.\n *\n * @returns a tuple of the schema and the section or a tuple of `false` and `false` if not found.\n *\n * @public\n */\n/*@__NO_SIDE_EFFECTS__*/\nexport function findSection(\n  schema: FormKitSchemaDefinition,\n  target: string\n):\n  | [false, false]\n  | [\n      FormKitSchemaNode[] | FormKitSchemaCondition | false | undefined,\n      FormKitSchemaCondition\n    ] {\n  return (\n    eachSection(\n      schema,\n      (section, sectionCondition, parent) => {\n        if (section.meta?.section === target) {\n          return [parent, sectionCondition]\n        }\n        return\n      },\n      true\n    ) ?? [false, false]\n  )\n}\n\n/**\n * Runs a callback over every section in a schema. if stopOnCallbackReturn is true\n * and the callback returns a value, the iteration will stop and return that value.\n *\n * @param schema - A {@link @formkit/core#FormKitSchemaNode | FormKitSchemaNode} array.\n * @param callback - A callback to run on every section.\n * @param stopOnCallbackReturn - If true, the loop will stop if the callback returns a value.\n * @param schemaParent - The parent of the current schema node.\n *\n * @returns\n *\n * @public\n */\nexport function eachSection<T>(\n  schema: FormKitSchemaDefinition,\n  callback: (\n    section: FormKitSchemaComponent | FormKitSchemaDOMNode,\n    sectionConditional: FormKitSchemaCondition,\n    sectionParent: FormKitSchemaNode[] | FormKitSchemaCondition | undefined\n  ) => T,\n  stopOnCallbackReturn = false,\n  schemaParent?: FormKitSchemaNode[] | FormKitSchemaCondition\n): T | void {\n  if (Array.isArray(schema)) {\n    for (const node of schema) {\n      const callbackReturn = eachSection(\n        node,\n        callback,\n        stopOnCallbackReturn,\n        schema\n      )\n      if (callbackReturn && stopOnCallbackReturn) {\n        return callbackReturn\n      }\n    }\n    return\n  }\n  if (isSection(schema)) {\n    const callbackReturn = callback(schema.else, schema, schemaParent)\n    if (callbackReturn && stopOnCallbackReturn) {\n      return callbackReturn\n    }\n    return eachSection(schema.else, callback, stopOnCallbackReturn, schema)\n  } else if ((isComponent(schema) || isDOM(schema)) && schema.children) {\n    return eachSection(\n      schema.children as FormKitSchemaNode,\n      callback,\n      stopOnCallbackReturn\n    )\n  } else if (isConditional(schema)) {\n    let callbackReturn: T | void = undefined\n\n    if (schema.then && typeof schema.then !== 'string') {\n      callbackReturn = eachSection(\n        schema.then,\n        callback,\n        stopOnCallbackReturn,\n        schema\n      )\n    }\n\n    if (!callbackReturn && schema.else && typeof schema.else !== 'string') {\n      callbackReturn = eachSection(\n        schema.else,\n        callback,\n        stopOnCallbackReturn,\n        schema\n      )\n    }\n\n    if (callbackReturn && stopOnCallbackReturn) {\n      return callbackReturn\n    }\n  }\n}\n\n/**\n * Check if a schema node is conditional, has an else clause, and that else\n * clause contains a section in the meta.\n * @param section - A schema node to check.\n * @public\n */\nfunction isSection(\n  section: FormKitSchemaNode\n): section is FormKitSchemaSection {\n  if (\n    isConditional(section) &&\n    typeof section.then === 'string' &&\n    section.else &&\n    typeof section.else !== 'string' &&\n    !Array.isArray(section.else) &&\n    !isConditional(section.else) &&\n    section.else.meta?.section\n  ) {\n    return true\n  }\n  return false\n}\n/**\n * Creates an input schema with all of the wrapping base schema.\n *\n * @param inputSection - Content to store in the input section key location.\n *\n * @returns {@link @formkit/core#FormKitExtendableSchemaRoot | FormKitExtendableSchemaRoot}\n *\n * @public\n */\n/*@__NO_SIDE_EFFECTS__*/\nexport function useSchema(\n  inputSection: FormKitSection,\n  sectionsSchema: FormKitSectionsSchema = {}\n): FormKitSchemaExtendableSection {\n  const schema = /* #__PURE__ */ outer(\n    /* #__PURE__ */ wrapper(\n      /* #__PURE__ */ label('$label'),\n      /* #__PURE__ */ inner(/* #__PURE__ */ icon('prefix'), /* #__PURE__ */ prefix(), inputSection(), /* #__PURE__ */ suffix(), /* #__PURE__ */ icon('suffix'))\n    ),\n    /* #__PURE__ */ help('$help'),\n    /* #__PURE__ */ messages(/* #__PURE__ */ message('$message.value'))\n  )\n  return (propSectionsSchema: FormKitSectionsSchema = {}) =>\n    schema(extend(sectionsSchema, propSectionsSchema) as FormKitSectionsSchema)\n}\n\n// ========================================================\n\n/**\n * Applies attributes to a given schema section by applying a higher order\n * function that merges a given set of attributes into the node.\n *\n * @param attrs - Attributes to apply to a {@link FormKitSchemaExtendableSection\n * | FormKitSchemaExtendableSection}.\n * @param section - A section to apply attributes to.\n *\n * @returns {@link FormKitSchemaExtendableSection | FormKitSchemaExtendableSection}\n *\n * @public\n */\n/*@__NO_SIDE_EFFECTS__*/\nexport function $attrs(\n  attrs: FormKitSchemaAttributes | (() => FormKitSchemaAttributes),\n  section: FormKitSchemaExtendableSection\n): FormKitSchemaExtendableSection {\n  const extendable = (extensions: FormKitSectionsSchema) => {\n    const node = section(extensions)\n    const attributes = typeof attrs === 'function' ? attrs() : attrs\n    if (!isObject(attributes)) return node\n    if (isSlotCondition(node) && isDOM(node.else)) {\n      node.else.attrs = { ...node.else.attrs, ...attributes }\n    } else if (isDOM(node)) {\n      node.attrs = { ...node.attrs, ...attributes }\n    }\n    return node\n  }\n  extendable._s = section._s\n  return extendable\n}\n\n/**\n * Applies a condition to a given schema section.\n *\n * @param condition - A schema condition to apply to a section.\n * @param then - The section that applies if the condition is true.\n * @param otherwise - (else) The section that applies if the condition is false.\n *\n * @returns {@link FormKitSchemaExtendableSection | FormKitSchemaExtendableSection}\n *\n * @public\n */\n/*@__NO_SIDE_EFFECTS__*/\nexport function $if(\n  condition: string,\n  then: FormKitSchemaExtendableSection,\n  otherwise?: FormKitSchemaExtendableSection\n): FormKitSchemaExtendableSection {\n  const extendable = (extensions: FormKitSectionsSchema) => {\n    const node = then(extensions)\n    if (\n      otherwise ||\n      (isSchemaObject(node) && 'if' in node) ||\n      isSlotCondition(node)\n    ) {\n      const conditionalNode: FormKitSchemaCondition = {\n        if: condition,\n        then: node,\n      }\n      if (otherwise) {\n        conditionalNode.else = otherwise(extensions)\n      }\n      return conditionalNode\n    } else if (isSlotCondition(node)) {\n      Object.assign(node.else, { if: condition })\n    } else if (isSchemaObject(node)) {\n      Object.assign(node, { if: condition })\n    }\n    return node\n  }\n  extendable._s = token()\n  return extendable\n}\n\n/**\n * Applies a condition to a given schema section.\n *\n * @param varName - The name of the variable that holds the current instance.\n * @param inName - The variable we are iterating over.\n * @param section - A section to repeat.\n *\n * @returns {@link FormKitSchemaExtendableSection | FormKitSchemaExtendableSection}\n *\n * @public\n */\n/*@__NO_SIDE_EFFECTS__*/\nexport function $for(\n  varName: string,\n  inName: string,\n  section: FormKitSchemaExtendableSection\n) {\n  return (extensions: FormKitSectionsSchema): FormKitSchemaNode => {\n    const node = section(extensions)\n    if (isSlotCondition(node)) {\n      Object.assign(node.else, { for: [varName, inName] })\n    } else if (isSchemaObject(node)) {\n      Object.assign(node, { for: [varName, inName] })\n    }\n    return node\n  }\n}\n\n/**\n * Extends a schema node with a given set of extensions.\n *\n * @param section - A section to apply an extension to.\n * @param extendWith - A partial schema snippet to apply to the section.\n *\n * @returns {@link FormKitSchemaExtendableSection | FormKitSchemaExtendableSection}\n *\n * @public\n */\n/*@__NO_SIDE_EFFECTS__*/\nexport function $extend(\n  section: FormKitSchemaExtendableSection,\n  extendWith: Partial<FormKitSchemaNode>\n): FormKitSchemaExtendableSection {\n  const extendable = (extensions: FormKitSectionsSchema) => {\n    const node = section({})\n    if (isSlotCondition(node)) {\n      if (Array.isArray(node.else)) return node\n      node.else = extendSchema(\n        extendSchema(node.else, extendWith),\n        section._s ? extensions[section._s] : {}\n      )\n      return node\n    }\n    return extendSchema(\n      extendSchema(node, extendWith),\n      section._s ? extensions[section._s] : {}\n    )\n  }\n  extendable._s = section._s\n  return extendable\n}\n\n/**\n * Creates a root schema section.\n *\n * @param section - A section to make a root from.\n *\n * @returns {@link FormKitSchemaExtendableSection | FormKitSchemaExtendableSection}\n *\n * @public\n */\n/*@__NO_SIDE_EFFECTS__*/\nexport function $root(\n  section: FormKitSchemaExtendableSection\n): FormKitExtendableSchemaRoot {\n  warn(800, '$root')\n  return createRoot(section)\n}\n\nexport function resetCounts() {\n  resetRadio()\n}\n\nexport * from './features'\nexport * from './sections'\n","import { createSection } from '../createSection'\n\n/**\n * Actions section that shows the action buttons\n *\n * @public\n */\nexport const actions = createSection('actions', () => ({\n  $el: 'div',\n  if: '$actions',\n}))\n","import { createSection } from '../createSection'\n\n/**\n * Box section used for grouping options\n *\n * @public\n */\nexport const box = createSection('input', () => ({\n  $el: 'input',\n  bind: '$attrs',\n  attrs: {\n    type: '$type',\n    name: '$node.props.altName || $node.name',\n    disabled: '$option.attrs.disabled || $disabled',\n    onInput: '$handlers.toggleChecked',\n    checked: '$fns.eq($_value, $onValue)',\n    onBlur: '$handlers.blur',\n    value: '$: true',\n    id: '$id',\n    'aria-describedby': {\n      if: '$options.length',\n      then: {\n        if: '$option.help',\n        then: '$: \"help-\" + $option.attrs.id',\n        else: undefined,\n      },\n      else: {\n        if: '$help',\n        then: '$: \"help-\" + $id',\n        else: undefined,\n      },\n    },\n  },\n}))\n","import { createSection } from '../createSection'\n\n/**\n * Option help section\n *\n * @public\n */\nexport const boxHelp = createSection('optionHelp', () => ({\n  $el: 'div',\n  if: '$option.help',\n  attrs: {\n    id: '$: \"help-\" + $option.attrs.id',\n  },\n}))\n","import { createSection } from '../createSection'\n\n/**\n * Box Inner section\n *\n * @public\n */\nexport const boxInner = createSection('inner', 'span')\n","import { createSection } from '../createSection'\n\n/**\n * Label section for options\n *\n * @public\n */\nexport const boxLabel = createSection('label', 'span')\n","import { createSection } from '../createSection'\n\n/**\n * Option section used to show an option\n *\n * @public\n */\nexport const boxOption = createSection('option', () => ({\n  $el: 'li',\n  for: ['option', '$options'],\n  attrs: {\n    'data-disabled': '$option.attrs.disabled || $disabled || undefined',\n  },\n}))\n","import { createSection } from '../createSection'\n\n/**\n * Options section used to wrap all option sections in a list\n *\n * @public\n */\nexport const boxOptions = createSection('options', 'ul')\n","import { createSection } from '../createSection'\n\n/**\n * Wrapper section for options\n *\n * @public\n */\nexport const boxWrapper = createSection('wrapper', () => ({\n  $el: 'label',\n  attrs: {\n    'data-disabled': {\n      if: '$options.length',\n      then: undefined,\n      else: '$disabled || undefined',\n    },\n    'data-checked': {\n      if: '$options == undefined',\n      then: '$fns.eq($_value, $onValue) || undefined',\n      else: '$fns.isChecked($option.value) || undefined',\n    },\n  },\n}))\n","import { createSection } from '../createSection'\n\n/**\n * Input section for a button\n *\n * @public\n */\nexport const buttonInput = createSection('input', () => ({\n  $el: 'button',\n  bind: '$attrs',\n  attrs: {\n    type: '$type',\n    disabled: '$disabled',\n    name: '$node.name',\n    id: '$id',\n  },\n}))\n","import { createSection } from '../createSection'\n\n/**\n * Default section for a button\n *\n * @public\n */\nexport const buttonLabel = createSection('default', null)\n","import { createSection } from '../createSection'\n\n/**\n * Decorator section\n *\n * @public\n */\nexport const decorator = createSection('decorator', () => ({\n  $el: 'span',\n  attrs: {\n    'aria-hidden': 'true',\n  },\n}))\n","import { createSection } from '../createSection'\n\n/**\n * Fieldset section, used to describe help\n *\n * @public\n */\nexport const fieldset = createSection('fieldset', () => ({\n  $el: 'fieldset',\n  attrs: {\n    id: '$id',\n    'aria-describedby': {\n      if: '$help',\n      then: '$: \"help-\" + $id',\n      else: undefined,\n    },\n  },\n}))\n","import { createSection } from '../createSection'\n\n/**\n * Input section for a file input\n *\n * @public\n */\nexport const fileInput = createSection('input', () => ({\n  $el: 'input',\n  bind: '$attrs',\n  attrs: {\n    type: 'file',\n    disabled: '$disabled',\n    name: '$node.name',\n    onChange: '$handlers.files',\n    onBlur: '$handlers.blur',\n    id: '$id',\n    'aria-describedby': '$describedBy',\n    'aria-required': '$state.required || undefined',\n  },\n}))\n","import { createSection } from '../createSection'\n\n/**\n * File item section for showing a file name\n *\n * @public\n */\nexport const fileItem = createSection('fileItem', () => ({\n  $el: 'li',\n  for: ['file', '$value'],\n}))\n","import { createSection } from '../createSection'\n\n/**\n * File list section to show all file names\n *\n * @public\n */\nexport const fileList = createSection('fileList', () => ({\n  $el: 'ul',\n  if: '$value.length',\n  attrs: {\n    'data-has-multiple': '$_hasMultipleFiles',\n  },\n}))\n","import { createSection } from '../createSection'\n\n/**\n * File name section to show the file name\n *\n * @public\n */\nexport const fileName = createSection('fileName', () => ({\n  $el: 'span',\n  attrs: {\n    class: '$classes.fileName',\n  },\n}))\n","import { createSection } from '../createSection'\n\n/**\n * File remove section to show a remove button for files\n *\n * @public\n */\nexport const fileRemove = createSection('fileRemove', () => ({\n  $el: 'button',\n  attrs: {\n    type: 'button',\n    onClick: '$handlers.resetFiles',\n  },\n}))\n","import { createSection } from '../createSection'\n\n/**\n * Form section\n *\n * @public\n */\nexport const formInput = createSection('form', () => ({\n  $el: 'form',\n  bind: '$attrs',\n  meta: {\n    autoAnimate: true,\n  },\n  attrs: {\n    id: '$id',\n    name: '$node.name',\n    onSubmit: '$handlers.submit',\n    'data-loading': '$state.loading || undefined',\n  },\n}))\n","import { createSection } from '../createSection'\n\n/**\n * A simple fragment section\n *\n * @public\n */\nexport const fragment = createSection('wrapper', null, true)\n","import { createSection } from '../createSection'\n\n/**\n * Help section that shows help text\n *\n * @public\n */\nexport const help = createSection('help', () => ({\n  $el: 'div',\n  if: '$help',\n  attrs: {\n    id: '$: \"help-\" + $id',\n  },\n}))\n","import { createSection, FormKitSchemaExtendableSection } from '../createSection'\n\n/**\n * Icon section used by all icons\n *\n * @public\n */\nexport const icon = (\n  sectionKey: string,\n  el?: string\n): FormKitSchemaExtendableSection => {\n  return createSection(`${sectionKey}Icon`, () => {\n    const rawIconProp = `_raw${sectionKey\n      .charAt(0)\n      .toUpperCase()}${sectionKey.slice(1)}Icon`\n    return {\n      if: `$${sectionKey}Icon && $${rawIconProp}`,\n      $el: `${el ? el : 'span'}`,\n      attrs: {\n        class: `$classes.${sectionKey}Icon + \" \" + $classes.icon`,\n        innerHTML: `$${rawIconProp}`,\n        onClick: `$handlers.iconClick(${sectionKey})`,\n        role: `$fns.iconRole(${sectionKey})`,\n        tabindex: `$fns.iconRole(${sectionKey}) === \"button\" && \"0\" || undefined`,\n        for: {\n          if: `${el === 'label'}`,\n          then: '$id',\n        },\n      },\n    }\n  })()\n}\n","import { createSection } from '../createSection'\n\n/**\n * Inner section\n *\n * @public\n */\nexport const inner = createSection('inner', 'div')\n","import { createSection } from '../createSection'\n\n/**\n * Label section with label element\n *\n * @public\n */\nexport const label = createSection('label', () => ({\n  $el: 'label',\n  if: '$label',\n  attrs: {\n    for: '$id',\n  },\n}))\n","import { createSection } from '../createSection'\n\n/**\n * Legend section, used instead of label when its grouping fields.\n *\n * @public\n */\nexport const legend = createSection('legend', () => ({\n  $el: 'legend',\n  if: '$label',\n}))\n","import { createSection } from '../createSection'\n\n/**\n * Message section, shows a group of messages.\n *\n * @public\n */\nexport const message = createSection('message', () => ({\n  $el: 'li',\n  for: ['message', '$messages'],\n  attrs: {\n    key: '$message.key',\n    id: `$id + '-' + $message.key`,\n    'data-message-type': '$message.type',\n  },\n}))\n","import { createSection } from '../createSection'\n\n/**\n * Messages section where all messages will be displayed.\n *\n * @public\n */\nexport const messages = createSection('messages', () => ({\n  $el: 'ul',\n  if: '$defaultMessagePlacement && $fns.length($messages)',\n}))\n","import { createSection } from '../createSection'\n\n/**\n * No file section that shows when there is no files\n *\n * @public\n */\nexport const noFiles = createSection('noFiles', () => ({\n  $el: 'span',\n  if: '$value == null || $value.length == 0',\n}))\n","import { createSection } from '../createSection'\n\n/**\n * Option section used to show options\n *\n * @public\n */\nexport const optGroup = createSection('optGroup', () => ({\n  $el: 'optgroup',\n  bind: '$option.attrs',\n  attrs: {\n    label: '$option.group',\n  },\n}))\n","import { createSection } from '../createSection'\n\n/**\n * Option section used to show options\n *\n * @public\n */\nexport const option = createSection('option', () => ({\n  $el: 'option',\n  bind: '$option.attrs',\n  attrs: {\n    class: '$classes.option',\n    value: '$option.value',\n    selected: '$fns.isSelected($option)',\n  },\n}))\n","import { createSection } from '../createSection'\n\n/**\n * Options slot section that displays options when used with slots\n *\n * @public\n */\nexport const optionSlot = createSection('options', () => ({\n  $el: null,\n  if: '$options.length',\n  for: ['option', '$option.options || $options'],\n}))\n","import { createSection } from '../createSection'\n\n/**\n * Outer section where most data attributes are assigned.\n *\n * @public\n */\nexport const outer = createSection('outer', () => ({\n  $el: 'div',\n  meta: {\n    autoAnimate: true,\n  },\n  attrs: {\n    key: '$id',\n    'data-family': '$family || undefined',\n    'data-type': '$type',\n    'data-multiple':\n      '$attrs.multiple || ($type != \"select\" && $options != undefined) || undefined',\n    'data-has-multiple': '$_hasMultipleFiles',\n    'data-disabled': '$: ($disabled !== \"false\" && $disabled) || undefined',\n    'data-empty': '$state.empty || undefined',\n    'data-complete': '$state.complete || undefined',\n    'data-invalid': '$state.invalid || undefined',\n    'data-errors': '$state.errors || undefined',\n    'data-submitted': '$state.submitted || undefined',\n    'data-prefix-icon': '$_rawPrefixIcon !== undefined || undefined',\n    'data-suffix-icon': '$_rawSuffixIcon !== undefined || undefined',\n    'data-prefix-icon-click': '$onPrefixIconClick !== undefined || undefined',\n    'data-suffix-icon-click': '$onSuffixIconClick !== undefined || undefined',\n  },\n}))\n","import { createSection } from '../createSection'\n\n/**\n * Prefix section\n *\n * @public\n */\nexport const prefix = createSection('prefix', null)\n","import { createSection } from '../createSection'\n\n/**\n * Input section used by selects\n *\n * @public\n */\nexport const selectInput = createSection('input', () => ({\n  $el: 'select',\n  bind: '$attrs',\n  attrs: {\n    id: '$id',\n    'data-placeholder': '$fns.showPlaceholder($_value, $placeholder)',\n    disabled: '$disabled',\n    class: '$classes.input',\n    name: '$node.name',\n    onChange: '$handlers.onChange',\n    onInput: '$handlers.selectInput',\n    onBlur: '$handlers.blur',\n    'aria-describedby': '$describedBy',\n    'aria-required': '$state.required || undefined',\n  },\n}))\n","import { createSection } from '../createSection'\n\n/**\n * Submit section that displays a submit button from a form\n *\n * @public\n */\nexport const submitInput = createSection('submit', () => ({\n  $cmp: 'FormKit',\n  bind: '$submitAttrs',\n  props: {\n    type: 'submit',\n    label: '$submitLabel',\n  },\n}))\n","import { createSection } from '../createSection'\n\n/**\n * Suffix section\n *\n * @public\n */\nexport const suffix = createSection('suffix', null)\n","import { createSection } from '../createSection'\n\n/**\n * Input section\n *\n * @public\n */\nexport const textInput = createSection('input', () => ({\n  $el: 'input',\n  bind: '$attrs',\n  attrs: {\n    type: '$type',\n    disabled: '$disabled',\n    name: '$node.name',\n    onInput: '$handlers.DOMInput',\n    onBlur: '$handlers.blur',\n    value: '$_value',\n    id: '$id',\n    'aria-describedby': '$describedBy',\n    'aria-required': '$state.required || undefined',\n  },\n}))\n","import { createSection } from '../createSection'\n\n/**\n * Input section used by textarea inputs\n *\n * @public\n */\nexport const textareaInput = createSection('input', () => ({\n  $el: 'textarea',\n  bind: '$attrs',\n  attrs: {\n    disabled: '$disabled',\n    name: '$node.name',\n    onInput: '$handlers.DOMInput',\n    onBlur: '$handlers.blur',\n    value: '$_value',\n    id: '$id',\n    'aria-describedby': '$describedBy',\n    'aria-required': '$state.required || undefined',\n  },\n  children: '$initialValue',\n}))\n","import { createSection } from '../createSection'\n\n/**\n * Wrapper input section\n *\n * @public\n */\nexport const wrapper = createSection('wrapper', 'div')\n","import type { FormKitNode } from '@formkit/core'\n\n/**\n * A simple counter to keep track of how many radios have been placed.\n */\nlet radioInstance = 0\n\nexport function resetRadio() {\n  radioInstance = 0\n}\n\n/**\n * Automatically rename any radio inputs.\n * @param node - A formkit node.\n * @returns\n *\n * @public\n */\nexport default function renamesRadios(node: FormKitNode) {\n  if (node.type === 'group' || node.type === 'list') {\n    node.plugins.add(renamesRadiosPlugin)\n  }\n}\n\nfunction renamesRadiosPlugin(node: FormKitNode) {\n  if (node.props.type === 'radio') {\n    node.addProps(['altName'])\n    node.props.altName = `${node.name}_${radioInstance++}`\n  }\n}\n","import { FormKitNode } from '@formkit/core'\nimport { has } from '@formkit/utils'\nimport normalizeBoxes from './normalizeBoxes'\nimport { shouldSelect, optionValue } from './options'\n\n/**\n * Event handler when an input is toggled.\n *\n * @param node - The {@link @formkit/node#FormKitNode | FormKitNode} being toggled.\n * @param e - The input event related to the toggling.\n *\n * @public\n */\nfunction toggleChecked(node: FormKitNode, e: Event) {\n  const el = e.target\n  if (el instanceof HTMLInputElement) {\n    const value = Array.isArray(node.props.options)\n      ? optionValue(node.props.options, el.value)\n      : el.value\n    if (Array.isArray(node.props.options) && node.props.options.length) {\n      if (!Array.isArray(node._value)) {\n        // There is no array value set\n        node.input([value])\n      } else if (\n        !node._value.some((existingValue) => shouldSelect(value, existingValue))\n      ) {\n        // The value is not in the current set\n        node.input([...node._value, value])\n      } else {\n        // Filter out equivalent values\n        node.input(\n          node._value.filter(\n            (existingValue) => !shouldSelect(value, existingValue)\n          )\n        )\n      }\n    } else {\n      if (el.checked) {\n        node.input(node.props.onValue)\n      } else {\n        node.input(node.props.offValue)\n      }\n    }\n  }\n}\n\n/**\n * Checks if a given option is present in the node value.\n *\n * @param node - The The {@link @formkit/node#FormKitNode | FormKitNode} being checked.\n * @param value - The value of any option.\n *\n * @returns `boolean`\n *\n * @public\n */\nfunction isChecked(node: FormKitNode, value: any) {\n  // We need to force vue’s reactivity to respond when the value is run:\n  node.context?.value\n  node.context?._value\n  if (Array.isArray(node._value)) {\n    return node._value.some((existingValue) =>\n      shouldSelect(optionValue(node.props.options, value), existingValue)\n    )\n  }\n  return false\n}\n\n/**\n * A feature that adds checkbox selection support.\n *\n * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.\n *\n * @public\n */\nexport default function checkboxes(node: FormKitNode): void {\n  node.on('created', () => {\n    if (node.context?.handlers) {\n      node.context.handlers.toggleChecked = toggleChecked.bind(null, node)\n    }\n    if (node.context?.fns) {\n      node.context.fns.isChecked = isChecked.bind(null, node)\n    }\n    // Configure our default onValue and offValue\n    if (!has(node.props, 'onValue')) node.props.onValue = true\n    if (!has(node.props, 'offValue')) node.props.offValue = false\n  })\n\n  node.hook.prop(normalizeBoxes(node))\n}\n","import { FormKitMiddleware, FormKitNode } from '@formkit/core'\nimport { extend, slugify } from '@formkit/utils'\n\n/**\n * A feature that normalizes box types (checkboxes, radios).\n *\n * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.\n *\n * @returns A {@link @formkit/node#FormKitMiddleware | FormKitMiddleware}.\n *\n * @public\n */\nexport default function normalizeBoxes(\n  node: FormKitNode\n): FormKitMiddleware<{ prop: string | symbol; value: any }> {\n  return function (prop, next) {\n    if (prop.prop === 'options' && Array.isArray(prop.value)) {\n      prop.value = prop.value.map((option) => {\n        if (!option.attrs?.id) {\n          return extend(option, {\n            attrs: {\n              id: `${node.props.id}-option-${slugify(String(option.value))}`,\n            },\n          })\n        }\n        return option\n      })\n      if (node.props.type === 'checkbox' && !Array.isArray(node.value)) {\n        if (node.isCreated) {\n          node.input([], false)\n        } else {\n          node.on('created', () => {\n            if (!Array.isArray(node.value)) {\n              node.input([], false)\n            }\n          })\n        }\n      }\n    }\n    return next(prop)\n  }\n}\n","import { FormKitNode } from '@formkit/core'\n\n/**\n * Adds icon props definition.\n *\n * @param sectionKey - the location the icon should be loaded.\n * @param defaultIcon - the icon that should be loaded if a match is found in the user's CSS.\n *\n * @returns A {@link @formkit/core#FormKitPlugin | FormKitPlugin}.\n *\n * @public\n */\nexport default function defaultIcon(sectionKey: string, defaultIcon: string) {\n  return (node: FormKitNode): void => {\n    if (node.props[`${sectionKey}Icon`] === undefined) {\n      node.props[`${sectionKey}Icon`] = defaultIcon.startsWith('<svg')\n        ? defaultIcon\n        : `default:${defaultIcon}`\n    }\n  }\n}\n","import { FormKitNode } from '@formkit/core'\nimport { undefine } from '@formkit/utils'\n\n/**\n * A feature that allows disabling children of this node.\n *\n * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.\n *\n * @public\n */\nexport default function disables(node: FormKitNode): void {\n  node.on('created', () => {\n    // If the disabled prop belongs to this *actual* node (not inherited), then\n    // perform an `undefine` on it, if not then we'll let the prop be inherited.\n    if ('disabled' in node.props) {\n      node.props.disabled = undefine(node.props.disabled)\n      node.config.disabled = undefine(node.props.disabled)\n    }\n  })\n  node.hook.prop(({ prop, value }, next) => {\n    value = prop === 'disabled' ? undefine(value) : value\n    return next({ prop, value })\n  })\n  node.on('prop:disabled', ({ payload: value }) => {\n    node.config.disabled = undefine(value)\n  })\n}\n","import { FormKitNode, createMessage } from '@formkit/core'\n\n/**\n * Creates a new feature that generates a localization message of type ui\n * for use on a given component.\n *\n * @param key - The key of the message.\n * @param value - The value of the message.\n *\n * @returns A {@link @formkit/core#FormKitPlugin | FormKitPlugin}.\n *\n * @public\n */\nexport default function localize(\n  key: string,\n  value?: string\n): (node: FormKitNode) => void {\n  return (node: FormKitNode): void => {\n    node.store.set(\n      /* #__PURE__ */ createMessage({\n        key,\n        type: 'ui',\n        value: value || key,\n        meta: {\n          localize: true,\n          i18nArgs: [node],\n        },\n      })\n    )\n  }\n}\n","import { FormKitNode } from '@formkit/core'\nimport localize from './localize'\nimport { FormKitFileValue } from '../index'\n\ndeclare global {\n  interface Window {\n    _FormKit_File_Drop: boolean\n  }\n}\n\nconst isBrowser = typeof window !== 'undefined'\n\n/**\n * Remove the data-file-hover attribute from the target.\n *\n * @param e - Event\n *\n * @internal\n */\nfunction removeHover(e: Event) {\n  if (\n    e.target instanceof HTMLElement &&\n    e.target.hasAttribute('data-file-hover')\n  ) {\n    e.target.removeAttribute('data-file-hover')\n  }\n}\n\n/**\n * Prevent stray drag/drop events from navigating the window.\n *\n * @param e - Event\n *\n * @internal\n */\nfunction preventStrayDrop(type: string, e: Event) {\n  if (!(e.target instanceof HTMLInputElement)) {\n    e.preventDefault()\n  } else if (type === 'dragover') {\n    e.target.setAttribute('data-file-hover', 'true')\n  }\n  if (type === 'drop') {\n    removeHover(e)\n  }\n}\n\n/**\n * A feature to add file handling support to an input.\n *\n * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.\n *\n * @public\n */\nexport default function files(node: FormKitNode): void {\n  // Localize our content:\n  localize('noFiles', 'Select file')(node)\n  localize('removeAll', 'Remove all')(node)\n  localize('remove')(node)\n  node.addProps(['_hasMultipleFiles'])\n\n  if (isBrowser) {\n    if (!window._FormKit_File_Drop) {\n      window.addEventListener(\n        'dragover',\n        preventStrayDrop.bind(null, 'dragover')\n      )\n      window.addEventListener('drop', preventStrayDrop.bind(null, 'drop'))\n      window.addEventListener('dragleave', removeHover)\n      window._FormKit_File_Drop = true\n    }\n  }\n  node.hook.input((value, next) => next(Array.isArray(value) ? value : []))\n  node.on('input', ({ payload: value }) => {\n    node.props._hasMultipleFiles =\n      Array.isArray(value) && value.length > 1 ? true : undefined\n  })\n\n  node.on('reset', () => {\n    if (node.props.id && isBrowser) {\n      const el = document.getElementById(node.props.id)\n      if (el) (el as HTMLInputElement).value = ''\n    }\n  })\n\n  node.on('created', () => {\n    if (!Array.isArray(node.value)) node.input([], false)\n\n    if (!node.context) return\n\n    node.context.handlers.resetFiles = (e: Event) => {\n      e.preventDefault()\n      node.input([])\n      if (node.props.id && isBrowser) {\n        const el = document.getElementById(node.props.id)\n        if (el) (el as HTMLInputElement).value = ''\n        el?.focus()\n      }\n    }\n\n    node.context.handlers.files = (e: Event) => {\n      const files: FormKitFileValue = []\n      if (e.target instanceof HTMLInputElement && e.target.files) {\n        for (let i = 0; i < e.target.files.length; i++) {\n          let file\n          if ((file = e.target.files.item(i))) {\n            files.push({ name: file.name, file })\n          }\n        }\n        node.input(files)\n      }\n      if (node.context) node.context.files = files\n      // Call the original listener if there is one.\n\n      if (typeof node.props.attrs?.onChange === 'function') {\n        node.props.attrs?.onChange(e)\n      }\n    }\n  })\n}\n","import { createMessage, FormKitNode } from '@formkit/core'\nimport { has, clone } from '@formkit/utils'\n\nconst loading = /* #__PURE__ */ createMessage({\n  key: 'loading',\n  value: true,\n  visible: false,\n})\n\n/**\n * Handle the submit event.\n *\n * @param e - The event\n *\n * @internal\n */\nasync function handleSubmit(node: FormKitNode, submitEvent: Event) {\n  const submitNonce = Math.random()\n  node.props._submitNonce = submitNonce\n  submitEvent.preventDefault()\n  await node.settled\n\n  if (node.ledger.value('validating')) {\n    // There are validation rules still pending.\n    node.store.set(loading)\n    await node.ledger.settled('validating')\n    node.store.remove('loading')\n    // If this was not the same submit event, bail out.\n    if (node.props._submitNonce !== submitNonce) return\n  }\n  // Set the submitted state on all children\n  const setSubmitted = (n: FormKitNode) =>\n    n.store.set(\n      /* #__PURE__ */ createMessage({\n        key: 'submitted',\n        value: true,\n        visible: false,\n      })\n    )\n  node.walk(setSubmitted)\n  setSubmitted(node)\n\n  node.emit('submit-raw')\n  if (typeof node.props.onSubmitRaw === 'function') {\n    node.props.onSubmitRaw(submitEvent, node)\n  }\n\n  if (node.ledger.value('blocking')) {\n    if (typeof node.props.onSubmitInvalid === 'function') {\n      node.props.onSubmitInvalid(node)\n    }\n    // There is still a blocking message in the store.\n    if (node.props.incompleteMessage !== false) {\n      setIncompleteMessage(node)\n    }\n  } else {\n    // No blocking messages\n    if (typeof node.props.onSubmit === 'function') {\n      // call onSubmit\n      const retVal = node.props.onSubmit(\n        node.hook.submit.dispatch(clone(node.value as Record<string, any>)),\n        node\n      )\n      if (retVal instanceof Promise) {\n        const autoDisable =\n          node.props.disabled === undefined &&\n          node.props.submitBehavior !== 'live'\n        if (autoDisable) node.props.disabled = true\n        node.store.set(loading)\n        await retVal\n        if (autoDisable) node.props.disabled = false\n        node.store.remove('loading')\n      }\n    } else {\n      if (submitEvent.target instanceof HTMLFormElement) {\n        submitEvent.target.submit()\n      }\n    }\n  }\n}\n\n/**\n * Set the incomplete message on a specific node.\n * @param node - The node to set the incomplete message on.\n */\nfunction setIncompleteMessage(node: FormKitNode) {\n  node.store.set(\n    /* #__PURE__ */ createMessage({\n      blocking: false,\n      key: `incomplete`,\n      meta: {\n        localize: node.props.incompleteMessage === undefined,\n        i18nArgs: [{ node }],\n        showAsMessage: true,\n      },\n      type: 'ui',\n      value: node.props.incompleteMessage || 'Form incomplete.',\n    })\n  )\n}\n\n/**\n * A feature to add a submit handler and actions section.\n *\n * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.\n *\n * @public\n */\nexport default function form(node: FormKitNode): void {\n  node.props.isForm = true\n  node.ledger.count('validating', (m) => m.key === 'validating')\n\n  node.props.submitAttrs ??= {\n    disabled: node.props.disabled,\n  }\n\n  node.on('prop:disabled', ({ payload: disabled }) => {\n    node.props.submitAttrs = { ...node.props.submitAttrs, disabled }\n  })\n\n  node.on('created', () => {\n    if (node.context?.handlers) {\n      node.context.handlers.submit = handleSubmit.bind(null, node)\n    }\n    if (!has(node.props, 'actions')) {\n      node.props.actions = true\n    }\n  })\n  node.on('prop:incompleteMessage', () => {\n    if (node.store.incomplete) setIncompleteMessage(node)\n  })\n  node.on('settled:blocking', () => node.store.remove('incomplete'))\n}\n","import { FormKitNode } from '@formkit/core'\n\n/**\n * A feature that applies `ignore=\"true\"` by default.\n *\n * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.\n *\n * @public\n */\nexport default function ignore(node: FormKitNode): void {\n  if (node.props.ignore === undefined) {\n    node.props.ignore = true\n    node.parent = null\n  }\n}\n","import { FormKitNode } from '@formkit/core'\n\n/**\n * A feature that ensures the input has an `initialValue` prop.\n *\n * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.\n *\n * @public\n */\nexport default function initialValue(node: FormKitNode): void {\n  node.on('created', () => {\n    if (node.context) {\n      node.context.initialValue = node.value || ''\n    }\n  })\n}\n","import { FormKitNode } from '@formkit/core'\n\n/**\n * A feature that allows casting to numbers.\n *\n * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.\n *\n * @public\n */\nexport default function casts(node: FormKitNode): void {\n  if (typeof node.props.number === 'undefined') return\n  const strict = ['number', 'range', 'hidden'].includes(node.props.type)\n  node.hook.input((value, next) => {\n    if (value === '') return next(undefined)\n    const numericValue =\n      node.props.number === 'integer' ? parseInt(value) : parseFloat(value)\n    if (!Number.isFinite(numericValue))\n      return strict ? next(undefined) : next(value)\n    return next(numericValue)\n  })\n}\n","import { FormKitNode, warn } from '@formkit/core'\nimport normalizeBoxes from './normalizeBoxes'\nimport { optionValue, shouldSelect } from './options'\n\n/**\n * Sets the value of a radio button when checked.\n *\n * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.\n * @param event - Event\n *\n * @public\n */\nfunction toggleChecked(node: FormKitNode, event: Event) {\n  if (event.target instanceof HTMLInputElement) {\n    node.input(optionValue(node.props.options, event.target.value))\n  }\n}\n\n/**\n * Checks if the value being checked is the current value.\n *\n * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.\n * @param value - The value to check\n *\n * @returns `boolean`\n *\n * @public\n */\nfunction isChecked(node: FormKitNode, value: string) {\n  // We need to force vue’s reactivity to respond when the value is run:\n  node.context?.value\n  node.context?._value\n  return shouldSelect(optionValue(node.props.options, value), node._value)\n}\n\n/**\n * A feature to check if the value being checked is the current value.\n *\n * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.\n *\n * @public\n */\nexport default function radios(node: FormKitNode): void {\n  node.on('created', () => {\n    if (!Array.isArray(node.props.options)) {\n      warn(350, {\n        node,\n        inputType: 'radio',\n      })\n    }\n    if (node.context?.handlers) {\n      node.context.handlers.toggleChecked = toggleChecked.bind(null, node)\n    }\n    if (node.context?.fns) {\n      node.context.fns.isChecked = isChecked.bind(null, node)\n    }\n  })\n  node.hook.prop(normalizeBoxes(node))\n}\n","import {\n  FormKitOptionsItem,\n  FormKitOptionsGroupItem,\n  FormKitOptionsListWithGroups,\n} from './../props'\nimport { FormKitNode } from '@formkit/core'\nimport { undefine, eq } from '@formkit/utils'\nimport { shouldSelect, optionValue } from './options'\nimport { FormKitOptionsList, isGroupOption } from '../props'\n\n/**\n * Checks if a the given option should have the selected attribute.\n * @param node - The node being evaluated.\n * @param option - The option value to check\n * @returns\n * @public\n */\nfunction isSelected(\n  node: FormKitNode,\n  option: FormKitOptionsItem | FormKitOptionsGroupItem\n) {\n  if (isGroupOption(option)) return false\n  // Here we trick reactivity (if at play) to watch this function.\n  node.context && node.context.value\n  const optionValue = '__original' in option ? option.__original : option.value\n  return Array.isArray(node._value)\n    ? node._value.some((optionA) => shouldSelect(optionA, optionValue))\n    : (node._value === undefined ||\n        (node._value === null && !containsValue(node.props.options, null))) &&\n      option.attrs &&\n      option.attrs['data-is-placeholder']\n    ? true\n    : shouldSelect(optionValue, node._value)\n}\n\n/**\n * Checks to see if a given value is anywhere in the options list.\n */\nfunction containsValue(\n  options: FormKitOptionsListWithGroups,\n  value: unknown\n): boolean {\n  return options.some((option) => {\n    if (isGroupOption(option)) {\n      return containsValue(option.options, value)\n    } else {\n      return (\n        ('__original' in option ? option.__original : option.value) === value\n      )\n    }\n  })\n}\n\n/**\n * Defers the change event till after the next cycle.\n * @param node - The node being evaluated.\n * @param e - The change event.\n */\nasync function deferChange(node: FormKitNode, e: Event) {\n  if (typeof node.props.attrs?.onChange === 'function') {\n    await new Promise((r) => setTimeout(r, 0))\n    await node.settled\n    node.props.attrs.onChange(e)\n  }\n}\n\n/**\n * Select the correct values.\n * @param e - The input event emitted by the select.\n */\nfunction /* #__PURE__ */ selectInput(node: FormKitNode, e: Event) {\n  const target = e.target as HTMLSelectElement\n  const value = target.hasAttribute('multiple')\n    ? Array.from(target.selectedOptions).map((o) =>\n        optionValue(node.props.options, o.value)\n      )\n    : optionValue(node.props.options, target.value)\n  node.input(value)\n}\n\n/**\n * Appends a placeholder to the options list.\n * @param options - An options list\n * @param placeholder - A placeholder string to append\n * @returns\n */\nfunction applyPlaceholder(options: FormKitOptionsList, placeholder: string) {\n  if (\n    !options.some(\n      (option) => option.attrs && option.attrs['data-is-placeholder']\n    )\n  ) {\n    return [\n      {\n        label: placeholder,\n        value: '',\n        attrs: {\n          hidden: true,\n          disabled: true,\n          'data-is-placeholder': 'true',\n        },\n      },\n      ...options,\n    ]\n  }\n  return options\n}\n\n/**\n * Given an options list, find the first true value.\n * @param options - An options list (with groups)\n */\nfunction firstValue(options: FormKitOptionsListWithGroups): unknown {\n  const option = options.length > 0 ? options[0] : undefined\n  if (!option) return undefined\n  if (isGroupOption(option)) return firstValue(option.options)\n  return '__original' in option ? option.__original : option.value\n}\n\n/**\n * Converts the options prop to usable values.\n * @param node - A formkit node.\n * @public\n */\nexport default function select(node: FormKitNode): void {\n  // Set the initial value of a multi-input\n  node.on('created', () => {\n    const isMultiple = undefine(node.props.attrs?.multiple)\n\n    if (\n      !isMultiple &&\n      node.props.placeholder &&\n      Array.isArray(node.props.options)\n    ) {\n      node.hook.prop(({ prop, value }, next) => {\n        if (prop === 'options') {\n          value = applyPlaceholder(value, node.props.placeholder)\n        }\n        return next({ prop, value })\n      })\n      node.props.options = applyPlaceholder(\n        node.props.options,\n        node.props.placeholder\n      )\n    }\n    if (isMultiple) {\n      if (node.value === undefined) {\n        node.input([], false)\n      }\n    } else if (node.context && !node.context.options) {\n      // If this input is (probably) using the default slot, we need to add a\n      // \"value\" attribute to get bound\n      node.props.attrs = Object.assign({}, node.props.attrs, {\n        value: node._value,\n      })\n      node.on('input', ({ payload }) => {\n        node.props.attrs = Object.assign({}, node.props.attrs, {\n          value: payload,\n        })\n      })\n    }\n    if (node.context?.handlers) {\n      node.context.handlers.selectInput = selectInput.bind(null, node)\n      node.context.handlers.onChange = deferChange.bind(null, node)\n    }\n    if (node.context?.fns) {\n      node.context.fns.isSelected = isSelected.bind(null, node)\n      node.context.fns.showPlaceholder = (value: unknown, placeholder) => {\n        if (!Array.isArray(node.props.options)) return false\n        const hasMatchingValue = node.props.options.some(\n          (option: FormKitOptionsItem) => {\n            if (option.attrs && 'data-is-placeholder' in option.attrs)\n              return false\n            const optionValue =\n              '__original' in option ? option.__original : option.value\n            return eq(value, optionValue)\n          }\n        )\n        return placeholder && !hasMatchingValue ? true : undefined\n      }\n    }\n  })\n\n  node.hook.input((value, next) => {\n    if (\n      !node.props.placeholder &&\n      value === undefined &&\n      Array.isArray(node.props?.options) &&\n      node.props.options.length &&\n      !undefine(node.props?.attrs?.multiple)\n    ) {\n      value = firstValue(node.props.options)\n    }\n    return next(value)\n  })\n}\n","import { FormKitTypeDefinition } from '@formkit/core'\nimport {\n  outer,\n  wrapper,\n  help,\n  messages,\n  message,\n  icon,\n  prefix,\n  suffix,\n  buttonInput,\n  buttonLabel,\n  localize,\n  ignores,\n} from '../compose'\n\n/**\n * Input definition for a button.\n * @public\n */\nexport const button: FormKitTypeDefinition = {\n  /**\n   * The actual schema of the input, or a function that returns the schema.\n   */\n  schema: /* #__PURE__ */ outer(\n    /* #__PURE__ */ messages(/* #__PURE__ */ message('$message.value')),\n    /* #__PURE__ */ wrapper(\n      /* #__PURE__ */ buttonInput(\n        /* #__PURE__ */ icon('prefix'),\n        /* #__PURE__ */ prefix(),\n        /* #__PURE__ */ buttonLabel('$label || $ui.submit.value'),\n        /* #__PURE__ */ suffix(),\n        /* #__PURE__ */ icon('suffix')\n      )\n    ),\n    /* #__PURE__ */ help('$help')\n  ),\n  /**\n   * The type of node, can be a list, group, or input.\n   */\n  type: 'input',\n  /**\n   * The family of inputs this one belongs too. For example \"text\" and \"email\"\n   * are both part of the \"text\" family. This is primary used for styling.\n   */\n  family: 'button',\n  /**\n   * An array of extra props to accept for this input.\n   */\n  props: [],\n  /**\n   * Additional features that should be added to your input\n   */\n  features: [localize('submit'), ignores],\n  /**\n   * A key to use for memoizing the schema. This is used to prevent the schema\n   * from needing to be stringified when performing a memo lookup.\n   */\n  schemaMemoKey: 'h6st4epl3j8',\n}\n","import { FormKitTypeDefinition } from '@formkit/core'\nimport {\n  outer,\n  boxInner,\n  help,\n  boxHelp,\n  messages,\n  message,\n  prefix,\n  suffix,\n  fieldset,\n  decorator,\n  box,\n  icon,\n  legend,\n  boxOption,\n  boxOptions,\n  boxWrapper,\n  boxLabel,\n  options,\n  checkboxes,\n  $if,\n  $extend,\n  defaultIcon,\n} from '../compose'\n\n/**\n * Input definition for a checkbox(ess).\n * @public\n */\nexport const checkbox: FormKitTypeDefinition = {\n  /**\n   * The actual schema of the input, or a function that returns the schema.\n   */\n  schema: /* #__PURE__ */ outer(\n    $if(\n      '$options == undefined',\n      /**\n       * Single checkbox structure.\n       */\n      /* #__PURE__ */ boxWrapper(\n        /* #__PURE__ */ boxInner(/* #__PURE__ */ prefix(), /* #__PURE__ */ box(), /* #__PURE__ */ decorator(/* #__PURE__ */ icon('decorator')), /* #__PURE__ */ suffix()),\n        $extend(/* #__PURE__ */ boxLabel('$label'), {\n          if: '$label',\n        })\n      ),\n      /**\n       * Multi checkbox structure.\n       */\n      /* #__PURE__ */ fieldset(\n        /* #__PURE__ */ legend('$label'),\n        /* #__PURE__ */ help('$help'),\n        /* #__PURE__ */ boxOptions(\n          /* #__PURE__ */ boxOption(\n            /* #__PURE__ */ boxWrapper(\n              /* #__PURE__ */ boxInner(\n                /* #__PURE__ */ prefix(),\n                $extend(/* #__PURE__ */ box(), {\n                  bind: '$option.attrs',\n                  attrs: {\n                    id: '$option.attrs.id',\n                    value: '$option.value',\n                    checked: '$fns.isChecked($option.value)',\n                  },\n                }),\n                /* #__PURE__ */ decorator(/* #__PURE__ */ icon('decorator')),\n                /* #__PURE__ */ suffix()\n              ),\n              $extend(/* #__PURE__ */ boxLabel('$option.label'), {\n                if: '$option.label',\n              })\n            ),\n            /* #__PURE__ */ boxHelp('$option.help')\n          )\n        )\n      )\n    ),\n    // Help text only goes under the input when it is a single.\n    $if('$options == undefined && $help', /* #__PURE__ */ help('$help')),\n    /* #__PURE__ */ messages(/* #__PURE__ */ message('$message.value'))\n  ),\n  /**\n   * The type of node, can be a list, group, or input.\n   */\n  type: 'input',\n  /**\n   * The family of inputs this one belongs too. For example \"text\" and \"email\"\n   * are both part of the \"text\" family. This is primary used for styling.\n   */\n  family: 'box',\n  /**\n   * An array of extra props to accept for this input.\n   */\n  props: ['options', 'onValue', 'offValue', 'optionsLoader'],\n  /**\n   * Additional features that should be added to your input\n   */\n  features: [\n    options,\n    checkboxes,\n    defaultIcon('decorator', 'checkboxDecorator'),\n  ],\n  /**\n   * The key used to memoize the schema.\n   */\n  schemaMemoKey: 'qje02tb3gu8',\n}\n","import { FormKitTypeDefinition } from '@formkit/core'\nimport {\n  outer,\n  inner,\n  wrapper,\n  label,\n  help,\n  messages,\n  message,\n  prefix,\n  suffix,\n  icon,\n  fileInput,\n  fileItem,\n  fileList,\n  fileName,\n  fileRemove,\n  noFiles,\n  files,\n  $if,\n  defaultIcon,\n} from '../compose'\n\n/**\n * Input definition for a file input.\n * @public\n */\nexport const file: FormKitTypeDefinition = {\n  /**\n   * The actual schema of the input, or a function that returns the schema.\n   */\n  schema: /* #__PURE__ */ outer(\n    /* #__PURE__ */ wrapper(\n      /* #__PURE__ */ label('$label'),\n      /* #__PURE__ */ inner(\n        /* #__PURE__ */ icon('prefix', 'label'),\n        /* #__PURE__ */ prefix(),\n        /* #__PURE__ */ fileInput(),\n        /* #__PURE__ */ fileList(\n          /* #__PURE__ */ fileItem(\n            /* #__PURE__ */ icon('fileItem'),\n            /* #__PURE__ */ fileName('$file.name'),\n            $if(\n              '$value.length === 1',\n              /* #__PURE__ */ fileRemove(\n                /* #__PURE__ */ icon('fileRemove'),\n                '$ui.remove.value + \" \" + $file.name'\n              )\n            )\n          )\n        ),\n        $if('$value.length > 1', /* #__PURE__ */ fileRemove('$ui.removeAll.value')),\n        /* #__PURE__ */ noFiles(/* #__PURE__ */ icon('noFiles'), '$ui.noFiles.value'),\n        /* #__PURE__ */ suffix(),\n        /* #__PURE__ */ icon('suffix')\n      )\n    ),\n    /* #__PURE__ */ help('$help'),\n    /* #__PURE__ */ messages(/* #__PURE__ */ message('$message.value'))\n  ),\n  /**\n   * The type of node, can be a list, group, or input.\n   */\n  type: 'input',\n  /**\n   * The family of inputs this one belongs too. For example \"text\" and \"email\"\n   * are both part of the \"text\" family. This is primary used for styling.\n   */\n  family: 'text',\n  /**\n   * An array of extra props to accept for this input.\n   */\n  props: [],\n  /**\n   * Additional features that should be added to your input\n   */\n  features: [\n    files,\n    defaultIcon('fileItem', 'fileItem'),\n    defaultIcon('fileRemove', 'fileRemove'),\n    defaultIcon('noFiles', 'noFiles'),\n  ],\n  /**\n   * The key used to memoize the schema.\n   */\n  schemaMemoKey: '9kqc4852fv8',\n}\n","import { FormKitTypeDefinition } from '@formkit/core'\nimport {\n  formInput,\n  messages,\n  message,\n  actions,\n  submitInput,\n  forms,\n  disablesChildren,\n} from '../compose'\n\n/**\n * Input definition for a form.\n * @public\n */\nexport const form: FormKitTypeDefinition = {\n  /**\n   * The actual schema of the input, or a function that returns the schema.\n   */\n  schema: /* #__PURE__ */ formInput(\n    '$slots.default',\n    /* #__PURE__ */ messages(/* #__PURE__ */ message('$message.value')),\n    /* #__PURE__ */ actions(/* #__PURE__ */ submitInput())\n  ),\n  /**\n   * The type of node, can be a list, group, or input.\n   */\n  type: 'group',\n  /**\n   * An array of extra props to accept for this input.\n   */\n  props: [\n    'actions',\n    'submit',\n    'submitLabel',\n    'submitAttrs',\n    'submitBehavior',\n    'incompleteMessage',\n  ],\n  /**\n   * Additional features that should be added to your input\n   */\n  features: [forms, disablesChildren],\n  /**\n   * The key used to memoize the schema.\n   */\n  schemaMemoKey: '5bg016redjo',\n}\n","import { FormKitTypeDefinition } from '@formkit/core'\nimport { fragment, disablesChildren, renamesRadios } from '../compose'\n\n/**\n * Input definition for a group.\n * @public\n */\nexport const group: FormKitTypeDefinition = {\n  /**\n   * The actual schema of the input, or a function that returns the schema.\n   */\n  schema: /* #__PURE__ */ fragment('$slots.default'),\n  /**\n   * The type of node, can be a list, group, or input.\n   */\n  type: 'group',\n  /**\n   * An array of extra props to accept for this input.\n   */\n  props: [],\n  /**\n   * Additional features that should be added to your input\n   */\n  features: [disablesChildren, renamesRadios],\n}\n","import { FormKitTypeDefinition } from '@formkit/core'\nimport { textInput, casts } from '../compose'\n\n/**\n * Input definition for a hidden input.\n * @public\n */\nexport const hidden: FormKitTypeDefinition = {\n  /**\n   * The actual schema of the input, or a function that returns the schema.\n   */\n  schema: /* #__PURE__ */ textInput(),\n  /**\n   * The type of node, can be a list, group, or input.\n   */\n  type: 'input',\n  /**\n   * An array of extra props to accept for this input.\n   */\n  props: [],\n  /**\n   * Additional features that should be added to your input\n   */\n  features: [casts],\n}\n","import { FormKitTypeDefinition } from '@formkit/core'\nimport { fragment, disablesChildren, renamesRadios } from '../compose'\n\n/**\n * Input definition for a list.\n * @public\n */\nexport const list: FormKitTypeDefinition = {\n  /**\n   * The actual schema of the input, or a function that returns the schema.\n   */\n  schema: /* #__PURE__ */ fragment('$slots.default'),\n  /**\n   * The type of node, can be a list, group, or input.\n   */\n  type: 'list',\n  /**\n   * An array of extra props to accept for this input.\n   */\n  props: ['sync', 'dynamic'],\n  /**\n   * Additional features that should be added to your input\n   */\n  features: [disablesChildren, renamesRadios],\n}\n","import { FormKitTypeDefinition } from '@formkit/core'\nimport { fragment } from '../compose'\n\n/**\n * Input definition for a meta input.\n * @public\n */\nexport const meta: FormKitTypeDefinition = {\n  /**\n   * The actual schema of the input, or a function that returns the schema.\n   */\n  schema: /* #__PURE__ */ fragment(),\n  /**\n   * The type of node, can be a list, group, or input.\n   */\n  type: 'input',\n  /**\n   * An array of extra props to accept for this input.\n   */\n  props: [],\n  /**\n   * Additional features that should be added to your input\n   */\n  features: [],\n}\n","import { FormKitTypeDefinition } from '@formkit/core'\nimport {\n  outer,\n  boxInner,\n  help,\n  boxHelp,\n  messages,\n  message,\n  prefix,\n  suffix,\n  fieldset,\n  decorator,\n  box,\n  icon,\n  legend,\n  boxOption,\n  boxOptions,\n  boxWrapper,\n  boxLabel,\n  options,\n  radios,\n  $if,\n  $extend,\n  defaultIcon,\n} from '../compose'\n\n/**\n * Input definition for a radio.\n * @public\n */\nexport const radio: FormKitTypeDefinition = {\n  /**\n   * The actual schema of the input, or a function that returns the schema.\n   */\n  schema: /* #__PURE__ */ outer(\n    $if(\n      '$options == undefined',\n      /**\n       * Single radio structure.\n       */\n      /* #__PURE__ */ boxWrapper(\n        /* #__PURE__ */ boxInner(/* #__PURE__ */ prefix(), /* #__PURE__ */ box(), /* #__PURE__ */ decorator(/* #__PURE__ */ icon('decorator')), /* #__PURE__ */ suffix()),\n        $extend(/* #__PURE__ */ boxLabel('$label'), {\n          if: '$label',\n        })\n      ),\n      /**\n       * Multi radio structure.\n       */\n      /* #__PURE__ */ fieldset(\n        /* #__PURE__ */ legend('$label'),\n        /* #__PURE__ */ help('$help'),\n        /* #__PURE__ */ boxOptions(\n          /* #__PURE__ */ boxOption(\n            /* #__PURE__ */ boxWrapper(\n              /* #__PURE__ */ boxInner(\n                /* #__PURE__ */ prefix(),\n                $extend(/* #__PURE__ */ box(), {\n                  bind: '$option.attrs',\n                  attrs: {\n                    id: '$option.attrs.id',\n                    value: '$option.value',\n                    checked: '$fns.isChecked($option.value)',\n                  },\n                }),\n                /* #__PURE__ */ decorator(/* #__PURE__ */ icon('decorator')),\n                /* #__PURE__ */ suffix()\n              ),\n              $extend(/* #__PURE__ */ boxLabel('$option.label'), {\n                if: '$option.label',\n              })\n            ),\n            /* #__PURE__ */ boxHelp('$option.help')\n          )\n        )\n      )\n    ),\n    // Help text only goes under the input when it is a single.\n    $if('$options == undefined && $help', /* #__PURE__ */ help('$help')),\n    /* #__PURE__ */ messages(/* #__PURE__ */ message('$message.value'))\n  ),\n  /**\n   * The type of node, can be a list, group, or input.\n   */\n  type: 'input',\n  /**\n   * The family of inputs this one belongs too. For example \"text\" and \"email\"\n   * are both part of the \"text\" family. This is primary used for styling.\n   */\n  family: 'box',\n  /**\n   * An array of extra props to accept for this input.\n   */\n  props: ['options', 'onValue', 'offValue', 'optionsLoader'],\n  /**\n   * Additional features that should be added to your input\n   */\n  features: [options, radios, defaultIcon('decorator', 'radioDecorator')],\n  /**\n   * The key used to memoize the schema.\n   */\n  schemaMemoKey: 'qje02tb3gu8',\n}\n","import { FormKitTypeDefinition } from '@formkit/core'\nimport {\n  outer,\n  inner,\n  wrapper,\n  label,\n  help,\n  messages,\n  message,\n  prefix,\n  suffix,\n  icon,\n  selectInput,\n  option,\n  optionSlot,\n  optGroup,\n  $if,\n  options,\n  selects,\n  defaultIcon,\n} from '../compose'\n\n/**\n * Input definition for a select.\n * @public\n */\nexport const select: FormKitTypeDefinition = {\n  /**\n   * The actual schema of the input, or a function that returns the schema.\n   */\n  schema: /* #__PURE__ */ outer(\n    /* #__PURE__ */ wrapper(\n      /* #__PURE__ */ label('$label'),\n      /* #__PURE__ */ inner(\n        /* #__PURE__ */ icon('prefix'),\n        /* #__PURE__ */ prefix(),\n        /* #__PURE__ */ selectInput(\n          $if(\n            '$slots.default',\n            () => '$slots.default',\n            /* #__PURE__ */ optionSlot(\n              $if(\n                '$option.group',\n                /* #__PURE__ */ optGroup(/* #__PURE__ */ optionSlot(/* #__PURE__ */ option('$option.label'))),\n                /* #__PURE__ */ option('$option.label')\n              )\n            )\n          )\n        ),\n        $if('$attrs.multiple !== undefined', () => '', /* #__PURE__ */ icon('select')),\n        /* #__PURE__ */ suffix(),\n        /* #__PURE__ */ icon('suffix')\n      )\n    ),\n    /* #__PURE__ */ help('$help'),\n    /* #__PURE__ */ messages(/* #__PURE__ */ message('$message.value'))\n  ),\n  /**\n   * The type of node, can be a list, group, or input.\n   */\n  type: 'input',\n  /**\n   * An array of extra props to accept for this input.\n   */\n  props: ['options', 'placeholder', 'optionsLoader'],\n  /**\n   * Additional features that should be added to your input\n   */\n  features: [options, selects, defaultIcon('select', 'select')],\n  /**\n   * The key used to memoize the schema.\n   */\n  schemaMemoKey: 'cb119h43krg',\n}\n","import { FormKitTypeDefinition } from '@formkit/core'\nimport {\n  outer,\n  inner,\n  wrapper,\n  label,\n  help,\n  messages,\n  message,\n  prefix,\n  suffix,\n  icon,\n  textareaInput,\n  initialValue,\n} from '../compose'\n\n/**\n * Input definition for a textarea.\n * @public\n */\nexport const textarea: FormKitTypeDefinition = {\n  /**\n   * The actual schema of the input, or a function that returns the schema.\n   */\n  schema: /* #__PURE__ */ outer(\n    /* #__PURE__ */ wrapper(\n      /* #__PURE__ */ label('$label'),\n      /* #__PURE__ */ inner(\n        /* #__PURE__ */ icon('prefix', 'label'),\n        /* #__PURE__ */ prefix(),\n        /* #__PURE__ */ textareaInput(),\n        /* #__PURE__ */ suffix(),\n        /* #__PURE__ */ icon('suffix')\n      )\n    ),\n    /* #__PURE__ */ help('$help'),\n    /* #__PURE__ */ messages(/* #__PURE__ */ message('$message.value'))\n  ),\n  /**\n   * The type of node, can be a list, group, or input.\n   */\n  type: 'input',\n  /**\n   * An array of extra props to accept for this input.\n   */\n  props: [],\n  /**\n   * Additional features that should be added to your input\n   */\n  features: [initialValue],\n  /**\n   * The key used to memoize the schema.\n   */\n  schemaMemoKey: 'b1n0td79m9g',\n}\n","import { FormKitTypeDefinition } from '@formkit/core'\nimport {\n  outer,\n  inner,\n  wrapper,\n  label,\n  help,\n  messages,\n  message,\n  icon,\n  prefix,\n  suffix,\n  textInput,\n  casts,\n} from '../compose'\n\n/**\n * Input definition for a text.\n * @public\n */\nexport const text: FormKitTypeDefinition = {\n  /**\n   * The actual schema of the input, or a function that returns the schema.\n   */\n  schema: /* #__PURE__ */ outer(\n    /* #__PURE__ */ wrapper(\n      /* #__PURE__ */ label('$label'),\n      /* #__PURE__ */ inner(\n        /* #__PURE__ */ icon('prefix', 'label'),\n        /* #__PURE__ */ prefix(),\n        /* #__PURE__ */ textInput(),\n        /* #__PURE__ */ suffix(),\n        /* #__PURE__ */ icon('suffix')\n      )\n    ),\n    /* #__PURE__ */ help('$help'),\n    /* #__PURE__ */ messages(/* #__PURE__ */ message('$message.value'))\n  ),\n  /**\n   * The type of node, can be a list, group, or input.\n   */\n  type: 'input',\n  /**\n   * The family of inputs this one belongs too. For example \"text\" and \"email\"\n   * are both part of the \"text\" family. This is primary used for styling.\n   */\n  family: 'text',\n  /**\n   * An array of extra props to accept for this input.\n   */\n  props: [],\n  /**\n   * Additional features that should be added to your input\n   */\n  features: [casts],\n  /**\n   * The key used to memoize the schema.\n   */\n  schemaMemoKey: 'c3cc4kflsg',\n}\n","/**\n * The official FormKit Inputs plugin. This package contains the source code for\n * all native HTML input types. Read the\n * {@link https://formkit.com/essentials/inputs | inputs documentation} for\n * usage instructions.\n *\n * @packageDocumentation\n */\n\n/**\n * Export the plugin.\n */\nexport { createLibraryPlugin } from './plugin'\n\n/**\n * Helper function for normalizing options.\n */\nexport { normalizeOptions } from './features/options'\n\n/**\n * createSection() and related utilities.\n */\nexport {\n  FormKitSchemaExtendableSection,\n  FormKitSection,\n  createSection,\n  isSchemaObject,\n  extendSchema,\n} from './createSection'\n\n/**\n * Composable logic.\n */\nexport * from './compose'\n\n/**\n * Prop types.\n */\nexport * from './props'\n\n/**\n * A single file object in FormKit’s synthetic \"FileList\".\n *\n * @public\n */\nexport interface FormKitFile {\n  name: string\n  file?: File\n}\n\n/**\n * A synthetic array-based \"FileList\".\n *\n * @public\n */\nexport type FormKitFileValue = FormKitFile[]\n\n/**\n * Export again as group.\n */\nimport { button } from './inputs/button'\nimport { button as submit } from './inputs/button'\nimport { checkbox } from './inputs/checkbox'\nimport { file } from './inputs/file'\nimport { form } from './inputs/form'\nimport { group } from './inputs/group'\nimport { hidden } from './inputs/hidden'\nimport { list } from './inputs/list'\nimport { meta } from './inputs/meta'\nimport { radio } from './inputs/radio'\nimport { select } from './inputs/select'\nimport { textarea } from './inputs/textarea'\nimport { text } from './inputs/text'\nimport { text as color } from './inputs/text'\nimport { text as date } from './inputs/text'\nimport { text as datetimeLocal } from './inputs/text'\nimport { text as email } from './inputs/text'\nimport { text as month } from './inputs/text'\nimport { text as number } from './inputs/text'\nimport { text as password } from './inputs/text'\nimport { text as search } from './inputs/text'\nimport { text as tel } from './inputs/text'\nimport { text as time } from './inputs/text'\nimport { text as url } from './inputs/text'\nimport { text as week } from './inputs/text'\nimport { text as range } from './inputs/text'\n\nexport {\n  button,\n  submit,\n  checkbox,\n  file,\n  form,\n  group,\n  hidden,\n  list,\n  meta,\n  radio,\n  select,\n  textarea,\n  text,\n  color,\n  date,\n  datetimeLocal,\n  email,\n  month,\n  number,\n  password,\n  search,\n  tel,\n  time,\n  url,\n  week,\n  range,\n}\n\nexport const inputs = {\n  button,\n  submit,\n  checkbox,\n  file,\n  form,\n  group,\n  hidden,\n  list,\n  meta,\n  radio,\n  select,\n  textarea,\n  text,\n  color,\n  date,\n  datetimeLocal,\n  email,\n  month,\n  number,\n  password,\n  search,\n  tel,\n  time,\n  url,\n  week,\n  range,\n}\n"]}