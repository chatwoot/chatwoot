{"_quickTake.js":{"title":"Quick Take","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; isLangCode &#x7D; from \"is-language-code\";\n\nassert.deepEqual(isLangCode(\"de-419-DE\"), &#x7B;\n  res: false,\n  message: 'Two region subtags, \"419\" and \"de\".',\n&#x7D;);\n\nassert.deepEqual(isLangCode(\"sr-Latn\"), &#x7B;\n  res: true,\n  message: null,\n&#x7D;);"},"various.js":{"title":"Various examples","content":"import &#x7B; strict as assert &#x7D; from \"assert\";\nimport &#x7B; isLangCode &#x7D; from \"is-language-code\";\n\nassert.equal(isLangCode(\"de\").res, true);\n// => true because it's a German language code\n\nassert.equal(isLangCode(\"fr\").res, true);\n// => true because it's a French language code\n\nassert.equal(isLangCode(\"ja\").res, true);\n// => true because it's a Japanese language code\n\nassert.equal(isLangCode(\"zzz\").res, false);\n// => false - unrecognised. npm package \"ietf-language-tag-regex\" would fail this\n\nassert.equal(isLangCode(\"1\").res, false);\n// => false - not recognised language code\n\nassert.equal(isLangCode(\"x-klingon\").res, true);\n// => true - private use\n\nassert.equal(isLangCode(\"x-whatever\").res, true);\n// => true - private use\n\nassert.equal(isLangCode(\"zh-Hant\").res, true);\n// => true - Chinese written using the Traditional Chinese script\n\nassert.equal(isLangCode(\"zh-cmn-Hans-CN\").res, true);\n// => true - Chinese, Mandarin, Simplified script, as used in China\n\nassert.equal(isLangCode(\"zh-Hans-CN\").res, true);\n// => true - Chinese written using the Simplified script as used in mainland China\n\nassert.equal(isLangCode(\"sr-Latn-RS\").res, true);\n// => true - Serbian written using the Latin script as used in Serbia\n\nassert.equal(isLangCode(\"sl-rozaj\").res, true);\n// => true - Resian dialect of Slovenian\n\nassert.equal(isLangCode(\"sl-nedis\").res, true);\n// => true - Nadiza dialect of Slovenian\n\nassert.equal(isLangCode(\"de-CH-1901\").res, true);\n// => true - German as used in Switzerland using the 1901 variant [orthography]\n\nassert.equal(isLangCode(\"sl-IT-nedis\").res, true);\n// => true - Slovenian as used in Italy, Nadiza dialect\n\nassert.equal(isLangCode(\"hy-Latn-IT-arevela\").res, true);\n// => true - Eastern Armenian written in Latin script, as used in Italy\n\nassert.equal(isLangCode(\"en-US\").res, true);\n// => true - English as used in the United States\n\nassert.equal(isLangCode(\"de-CH-x-phonebk\").res, true);\n// => true - private use subtag (x-)\n\nassert.equal(isLangCode(\"az-Arab-x-AZE-derbend\").res, true);\n// => true - private use subtag\n\nassert.equal(isLangCode(\"x-whatever\").res, true);\n// => true - private use subtag using singleton x-\n\nassert.equal(isLangCode(\"qaa-Qaaa-QM-x-southern\").res, true);\n// => true\n\nassert.equal(isLangCode(\"de-Qaaa\").res, true);\n// => true - private use script subtag (Qaaa)\n\nassert.equal(isLangCode(\"sr-Latn-QM\").res, true);\n// => true - Serbian, Latin script, private region QM\n\nassert.equal(isLangCode(\"en-US-u-islamcal\").res, true);\n// => true - tag with extension\n\nassert.equal(isLangCode(\"zh-CN-a-myext-x-private\").res, true);\n// => true - tag with extension\n\nassert.equal(isLangCode(\"en-a-myext-b-another\").res, true);\n// => true - tag with extension\n\nassert.equal(isLangCode(\"de-419-DE\").res, false);\n// => false - two region tags\n\nassert.equal(isLangCode(\"a-DE\").res, false);\n// => false - use of a single-character subtag in primary position\n\nassert.equal(isLangCode(\"ar-a-aaa-b-bbb-a-ccc\").res, false);\n// => false - two extensions with same single-letter prefix"}}