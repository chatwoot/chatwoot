{"version":3,"sources":["../src/dispatcher.ts","../src/node.ts","../src/events.ts","../src/errors.ts","../src/store.ts","../src/ledger.ts","../src/registry.ts","../src/config.ts","../src/submitForm.ts","../src/reset.ts","../src/schema.ts","../src/compiler.ts","../src/classes.ts","../src/setErrors.ts","../src/index.ts"],"names":["use","has","init","cloneAny","isObject","merge","receipts","node","bubble","error","token","errors","emit","resetValue","getNode","calm","hydrate","defaults","props","createConfig","setIndex","trap","char","depth","setErrors","clearErrors"],"mappings":"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","sourcesContent":["/**\n * All FormKitMiddleware conform to the pattern of accepting a payload and a\n * `next()` function. They can either pass the payload to the next middleware\n * explicitly (as an argument of next), or implicitly (no argument for next).\n *\n * @public\n */\nexport type FormKitMiddleware<T = unknown> = (\n  payload: T,\n  next: (payload: T) => T\n) => T\n\n/**\n * The FormKitDispatcher interface is responsible creating/running \"hooks\".\n *\n * @public\n */\nexport interface FormKitDispatcher<T> {\n  (dispatchable: FormKitMiddleware<T>): number\n  unshift: (dispatchable: FormKitMiddleware<T>) => number\n  remove: (dispatchable: FormKitMiddleware<T>) => void\n  dispatch: (payload: T) => T\n}\n/**\n * Creates a new dispatcher that allows the addition/removal of middleware\n * functions, and the ability to dispatch a payload to all middleware.\n *\n * @returns FormKitDispatcher\n *\n * @internal\n */\nexport default function createDispatcher<T>(): FormKitDispatcher<T> {\n  const middleware: FormKitMiddleware<T>[] = []\n  let currentIndex = 0\n  const use = (dispatchable: FormKitMiddleware<T>) =>\n    middleware.push(dispatchable)\n  const dispatch = (payload: T): T => {\n    const current = middleware[currentIndex]\n    if (typeof current === 'function') {\n      return current(payload, (explicitPayload: T) => {\n        currentIndex++\n        return dispatch(explicitPayload)\n      })\n    }\n    currentIndex = 0\n    return payload\n  }\n  use.dispatch = dispatch\n  use.unshift = (dispatchable: FormKitMiddleware<T>) =>\n    middleware.unshift(dispatchable)\n  use.remove = (dispatchable: FormKitMiddleware<T>) => {\n    const index = middleware.indexOf(dispatchable)\n    if (index > -1) middleware.splice(index, 1)\n  }\n  return use\n}\n","import createDispatcher, { FormKitDispatcher } from './dispatcher'\nimport {\n  dedupe,\n  eq,\n  has,\n  camel,\n  kebab,\n  undefine,\n  init,\n  cloneAny,\n  clone,\n  isObject,\n  boolGetter,\n  extend as merge,\n  isRecord,\n} from '@formkit/utils'\nimport {\n  createEmitter,\n  FormKitEvent,\n  FormKitEventEmitter,\n  emit,\n  bubble,\n  on,\n  off,\n  FormKitEventListener,\n} from './events'\nimport { error } from './errors'\nimport {\n  createStore,\n  FormKitMessageProps,\n  FormKitMessage,\n  FormKitStore,\n} from './store'\nimport { createLedger, FormKitLedger } from './ledger'\nimport { deregister, register } from './registry'\nimport {\n  FormKitExtendableSchemaRoot,\n  FormKitSchemaNode,\n  FormKitSchemaCondition,\n} from './schema'\nimport { FormKitClasses } from './classes'\nimport { FormKitRootConfig, configChange } from './config'\nimport { submitForm } from './submitForm'\nimport { createMessages, ErrorMessages } from './store'\nimport { reset } from './reset'\n\n/**\n * Definition of a library item — when registering a new library item, these\n * are the required and available properties.\n *\n * @public\n */\nexport type FormKitTypeDefinition<V = unknown> = {\n  /**\n   * The FormKit core node type. Can only be input | list | group.\n   */\n  type: FormKitNodeType\n  /**\n   * Groups the input into a given family of inputs, generally for styling\n   * purposes only. For example the \"text\" family would apply to all text-like\n   * inputs.\n   */\n  family?: string\n  /**\n   * An optional name for the input’s type (e.g. \"select\" for a select input).\n   * If used, this value takes precedence over the \"type\" prop string.\n   */\n  forceTypeProp?: string\n  /**\n   * Custom props that should be added to the input.\n   */\n  props?: FormKitPseudoProps\n  /**\n   * The schema used to create the input. Either this or the component is\n   * required.\n   */\n  schema?:\n    | FormKitExtendableSchemaRoot\n    | FormKitSchemaNode[]\n    | FormKitSchemaCondition\n  /**\n   * A component to use to render the input. Either this or the schema is\n   * required.\n   */\n  component?: unknown\n  /**\n   * A library of components to provide to the internal input schema.\n   */\n  library?: Record<string, unknown>\n  /**\n   * An array of additional feature functions to load when booting the input.\n   */\n  features?: Array<(node: FormKitNode<V>) => void>\n  /**\n   * An optional string to use as a comparison key for memoizing the schema.\n   */\n  schemaMemoKey?: string\n}\n\n/**\n * A library of inputs, keyed by the name of the type.\n *\n * @public\n */\nexport interface FormKitLibrary {\n  [index: string]: FormKitTypeDefinition\n}\n\n/**\n * The base interface definition for a FormKitPlugin. It's just a function that\n * accepts a node argument.\n *\n * @public\n */\nexport interface FormKitPlugin {\n  (node: FormKitNode): false | any | void\n  library?: (node: FormKitNode) => void\n}\n\n/**\n * Text fragments are small pieces of text used for things like interface\n * validation messages, or errors that may be exposed for modification or\n * even translation.\n *\n * @public\n */\nexport type FormKitTextFragment = Partial<FormKitMessageProps> & {\n  key: string\n  value: string\n  type: string\n}\n\n/**\n * The available hooks for middleware.\n *\n * @public\n */\nexport interface FormKitHooks {\n  classes: FormKitDispatcher<{\n    property: string\n    classes: Record<string, boolean>\n  }>\n  commit: FormKitDispatcher<any>\n  error: FormKitDispatcher<string>\n  setErrors: FormKitDispatcher<{\n    localErrors: ErrorMessages\n    childErrors?: ErrorMessages\n  }>\n  init: FormKitDispatcher<FormKitNode>\n  input: FormKitDispatcher<any>\n  submit: FormKitDispatcher<Record<string, any>>\n  message: FormKitDispatcher<FormKitMessage>\n  prop: FormKitDispatcher<{\n    prop: string | symbol\n    value: any\n  }>\n  text: FormKitDispatcher<FormKitTextFragment>\n  schema: FormKitDispatcher<FormKitSchemaNode[] | FormKitSchemaCondition>\n}\n\n/**\n * The definition of a FormKitTrap. These are somewhat like methods on each\n * FormKitNode. They are always symmetrical (get/set) — although it's acceptable\n * for either to throw an Exception.\n *\n * @public\n */\nexport interface FormKitTrap {\n  get: TrapGetter\n  set: TrapSetter\n}\n\n/**\n * Describes the path to a particular node from the top of the tree.\n *\n * @public\n */\nexport type FormKitAddress = Array<string | number>\n\n/**\n * These are the types of nodes that can be created. These are different from\n * the type of inputs available and rather describe their purpose in the tree.\n *\n * @public\n */\nexport type FormKitNodeType = 'input' | 'list' | 'group'\n\n/**\n * FormKit inputs of type 'group' must have keyed values by default.\n *\n * @public\n */\nexport interface FormKitGroupValue {\n  [index: string]: unknown\n  __init?: boolean\n}\n\n/**\n * FormKit inputs of type 'list' must have array values by default.\n *\n * @public\n */\nexport type FormKitListContextValue<T = any> = Array<T>\n\n/**\n * Arbitrary data that has properties. Could be a POJO, could be an array.\n *\n * @public\n */\nexport interface KeyedValue {\n  [index: number]: any\n  [index: string]: any\n}\n\n/**\n * Define the most basic shape of a context object for type guards trying to\n * reason about a context's value.\n *\n * @public\n */\nexport interface FormKitContextShape {\n  type: FormKitNodeType\n  value: unknown\n  _value: unknown\n}\n\n/**\n * The simplest definition for a context of type \"list\".\n *\n * @public\n */\nexport interface FormKitListContext {\n  type: 'list'\n  value: FormKitListContextValue\n  _value: FormKitListContextValue\n}\n\n/**\n * Signature for any of the node's getter traps. Keep in mind that because these\n * are traps and not class methods, their response types are declared explicitly\n * in the FormKitNode interface.\n *\n * @public\n */\nexport type TrapGetter =\n  | ((node: FormKitNode, context: FormKitContext, ...args: any[]) => unknown)\n  | false\n\n/**\n * The signature for a node's trap setter — these are more rare than getter\n * traps, but can be useful for blocking access to certain context properties\n * or modifying the behavior of an assignment (ex. see setParent).\n *\n * @public\n */\nexport type TrapSetter =\n  | ((\n      node: FormKitNode,\n      context: FormKitContext,\n      property: string | number | symbol,\n      value: any\n    ) => boolean | never)\n  | false\n\n/**\n * The map signature for a node's traps Map.\n *\n * @public\n */\nexport type FormKitTraps = Map<string | symbol, FormKitTrap>\n\n/**\n * General \"app\" like configuration options, these are automatically inherited\n * by all children — they are not reactive.\n *\n * @public\n */\nexport interface FormKitConfig {\n  /**\n   * The delimiter character to use for a node’s tree address. By default this\n   * is a dot `.`, but if you use dots in your input names you may want to\n   * change this to something else.\n   */\n  delimiter: string\n  /**\n   * Classes to apply on the various sections. These classes are applied after\n   * rootClasses has already run.\n   */\n  classes?: Record<string, FormKitClasses | string | Record<string, boolean>>\n  /**\n   * The rootClasses function is called to allocate the base layer of classes\n   * for each section. These classes can be further extended or modified by the\n   * classes config, classes prop, and section-class props.\n   */\n  rootClasses:\n    | ((sectionKey: string, node: FormKitNode) => Record<string, boolean>)\n    | false\n  /**\n   * A root config object. This object is usually the globally defined options.\n   */\n  rootConfig?: FormKitRootConfig\n\n  /**\n   * The merge strategy is a map of names to merge strategies. The merge\n   * strategy is used to determine how a node’s value should be merged if there\n   * are 2 nodes with the same name.\n   */\n  mergeStrategy?: Record<string | symbol, 'synced'>\n\n  [index: string]: any\n}\n\n/**\n * The user-land per-instance \"props\", which are generally akin to the props\n * passed into components on the front end.\n *\n * @public\n */\nexport type FormKitProps<V = unknown> = {\n  /**\n   * An instance of the current document’s root. When inside the context of a\n   * custom element, this will be the ShadowRoot. In most other instances this\n   * will be the Document. During SSR and other server-side contexts this will\n   * be undefined.\n   */\n  __root?: Document | ShadowRoot\n  /**\n   * An object or array of \"props\" that should be applied to the input. When\n   * using Vue, these are pulled from the attrs and placed into the node.props\n   * according to the definition provided here.\n   */\n  readonly __propDefs: FormKitPseudoProps\n  /**\n   * The total amount of time in milliseconds to debounce the input before the\n   * committing the value to the form tree.\n   */\n  delay: number\n  /**\n   * The unique id of the input. These should *always* be globally unique.\n   */\n  id: string\n  /**\n   * A function that defines how the validationLabel should be provided. By\n   * default this is the validation-label, label, then name in decreasing\n   * specificity.\n   */\n  validationLabelStrategy?: (node?: FormKitNode) => string\n  /**\n   * An object of validation rules.\n   */\n  validationRules?: Record<\n    string,\n    (node: FormKitNode, ...args: any[]) => boolean | Promise<boolean>\n  >\n  /**\n   * An object of validation messages.\n   */\n  validationMessages?: Record<\n    string,\n    ((ctx: { name: string; args: any[]; node: FormKitNode }) => string) | string\n  >\n  /**\n   * The definition of the node’s input type (if it has one).\n   */\n  definition?: FormKitTypeDefinition<V>\n  /**\n   * The framework’s context object. This is how FormKit’s core interacts with\n   * the front end framework (Vue/React/etc). This object is created by the\n   * component and is responsible for providing all the data to the framework\n   * for rendering and interaction.\n   */\n  context?: FormKitFrameworkContext\n\n  /**\n   * The merge strategy that is applied to this specific node. It can only be\n   * inherited by a parent by using the mergeStrategy config option.\n   */\n  readonly mergeStrategy?: 'synced'\n\n  [index: string]: any\n} & FormKitConfig\n\n/**\n * The interface of a FormKit node's context object. A FormKit node is a\n * proxy of this object.\n *\n * @public\n */\nexport interface FormKitContext {\n  /**\n   * A node’s internal disturbance counter.\n   */\n  _d: number\n  /**\n   * A node’s internal event emitter.\n   */\n  _e: FormKitEventEmitter\n  /**\n   * A unique identifier for a node.\n   */\n  uid: symbol\n  /**\n   * A node’s internal disturbance counter promise.\n   */\n  _resolve: ((value: unknown) => void) | false\n  /**\n   * A node’s internal input timeout.\n   */\n  _tmo: number | false\n  /**\n   * A node’s internal pre-commit value.\n   */\n  _value: unknown\n  /**\n   * An array of child nodes (groups and lists)\n   */\n  children: Array<FormKitNode | FormKitPlaceholderNode>\n  /**\n   * Configuration state for a given tree.\n   */\n  config: FormKitConfig\n  /**\n   * The context object of the current front end framework being used.\n   */\n  context?: FormKitFrameworkContext\n  /**\n   * Set of hooks\n   */\n  hook: FormKitHooks\n  /**\n   * Begins as false, set to true when the node is finished being created.\n   */\n  isCreated: boolean\n  /**\n   * Boolean determines if the node is in a settled state or not.\n   */\n  isSettled: boolean\n  /**\n   * A counting ledger for arbitrary message counters.\n   */\n  ledger: FormKitLedger\n  /**\n   * The name of the input — should be treated as readonly.\n   */\n  name: string | symbol\n  /**\n   * The parent of a node.\n   */\n  parent: FormKitNode | null\n  /**\n   * A Set of plugins registered on this node that can be inherited by children.\n   */\n  plugins: Set<FormKitPlugin>\n  /**\n   * An proxied object of props. These are typically provided by the adapter\n   * of choice.\n   */\n  props: Partial<FormKitProps>\n  /**\n   * A promise that resolves when an input is in a settled state.\n   */\n  settled: Promise<unknown>\n  /**\n   * The internal node store.\n   */\n  store: FormKitStore\n  /**\n   * The traps available to a node.\n   */\n  traps: FormKitTraps\n  /**\n   * The type of node, should only be 'input', 'list', or 'group'.\n   */\n  type: FormKitNodeType\n  /**\n   * Only used on list nodes, this flag determines whether or not the list\n   * should sync its values with the underlying node children.\n   */\n  sync: boolean\n  /**\n   * The actual value of the node.\n   */\n  value: unknown\n}\n\n/**\n * Context object to be created by and used by each respective UI framework. No\n * values are created or output by FormKitCore, but this interface\n * should be followed by each respective plugin.\n *\n * @public\n */\nexport interface FormKitFrameworkContext<T = any> {\n  [index: string]: unknown\n  /**\n   * The current \"live\" value of the input. Not debounced.\n   */\n  _value: T\n  /**\n   * The root document or shadow root the input is inside. This can be set by\n   * using a higher-order `<FormKitRoot>` component.\n   */\n  __root?: Document | ShadowRoot\n  /**\n   * An object of attributes that (generally) should be applied to the root\n   * <input> element.\n   */\n  attrs: Record<string, any>\n  /**\n   * Classes to apply on the various sections.\n   */\n  classes: Record<string, string>\n  /**\n   * Event handlers.\n   */\n  handlers: {\n    blur: (e?: FocusEvent) => void\n    touch: () => void\n    DOMInput: (e: Event) => void\n  } & Record<string, (...args: any[]) => void>\n  /**\n   * Utility functions, generally for use in the input’s schema.\n   */\n  fns: Record<string, (...args: any[]) => any>\n  /**\n   * The help text of the input.\n   */\n  help?: string\n  /**\n   * The unique id of the input. Should also be applied as the id attribute.\n   * This is generally required for accessibility reasons.\n   */\n  id: string\n  /**\n   * An array of symbols that represent the a child’s nodes. These are not the\n   * child’s nodes but are just symbols representing them. They are used to\n   * iterate over the children for rendering purposes.\n   */\n  items: symbol[]\n  /**\n   * The label of the input.\n   */\n  label?: string\n  /**\n   * A list of messages to be displayed on the input. Often these are validation\n   * messages and error messages, but other `visible` core node messages do also\n   * apply here. This object is only populated when the validation should be\n   * actually displayed.\n   */\n  messages: Record<string, FormKitMessage>\n  /**\n   * The core node of this input.\n   */\n  node: FormKitNode\n  /**\n   * If this input type accepts options (like select lists and checkboxes) then\n   * this will be populated with a properly structured list of options.\n   */\n  options?: Array<Record<string, any> & { label: string; value: any }>\n  /**\n   * Whether or not to render messages in the standard location.\n   */\n  defaultMessagePlacement: boolean\n  /**\n   * A record of slots that have been passed into the top level component\n   * responsible for creating the node.\n   */\n  slots: Record<string, CallableFunction>\n  /**\n   * A collection of state trackers/details about the input.\n   */\n  state: FormKitFrameworkContextState\n  /**\n   * The type of input \"text\" or \"select\" (retrieved from node.props.type). This\n   * is not the core node type (input, group, or list).\n   */\n  type: string\n  /**\n   * Translated ui messages that are not validation related. These are generally\n   * used for interface messages like \"loading\" or \"saving\".\n   */\n  ui: Record<string, FormKitMessage>\n  /**\n   * The current committed value of the input. This is the value that should be\n   * used for most use cases.\n   */\n  value: T\n}\n\n/**\n * The state inside a node’s framework context. Usually used to track things\n * like blurred and validity states.\n *\n * @public\n */\nexport interface FormKitFrameworkContextState {\n  /**\n   * If the input has been blurred.\n   */\n  blurred: boolean\n  /**\n   * True when these conditions are met:\n   *\n   * Either:\n   * - The input has validation rules\n   * - The validation rules are all passing\n   * - There are no errors on the input\n   * Or:\n   * - The input has no validation rules\n   * - The input has no errors\n   * - The input is dirty and has a value\n   *\n   * This is not intended to be used on forms/groups/lists but instead on\n   * individual inputs. Imagine placing a green checkbox next to each input\n   * when the user filled it out correctly — thats what these are for.\n   */\n  complete: boolean\n  /**\n   * If the input has had a value typed into it or a change made to it.\n   */\n  dirty: boolean\n  /**\n   * If the input has explicit errors placed on it, or in the case of a group,\n   * list, or form, this is true if any children have errors on them.\n   */\n  errors: boolean\n  /**\n   * Determines if the input should be considered \"invalid\" — note that this\n   * is not the opposite of the valid state. A valid input is one where the\n   * input is not loading, not pending validation, not unsettled, and\n   * passes all validation rules. An invalid input is one whose validation\n   * rules are not explicitly not passing, and those rules are visible to the user.\n   */\n  invalid: boolean\n  /**\n   * Whether or not the input includes the \"required\" validation rule. This rule\n   * is uniquely called out for accessibility reasons and should be used to\n   * power the `aria-required` attribute.\n   */\n  required: boolean\n  /**\n   * True when the input has validation rules. Has nothing to do with the\n   * state of those validation rules.\n   */\n  rules: boolean\n  /**\n   * True when the input has completed its internal debounce cycle and the\n   * value was committed to the form.\n   */\n  settled: boolean\n  /**\n   * If the form has been submitted.\n   */\n  submitted: boolean\n  /**\n   * If the input (or group/form/list) is passing all validation rules. In\n   * the case of groups, forms, and lists this includes the validation state\n   * of all its children.\n   */\n  valid: boolean\n  /**\n   * If the validation-visibility has been satisfied and any validation\n   * messages should be displayed.\n   */\n  validationVisible: boolean\n  /**\n   * Allow users to add their own arbitrary states.\n   */\n  [index: string]: boolean\n}\n\n/**\n * Options that can be used to instantiate a new node via `createNode()`.\n *\n * @public\n */\nexport type FormKitOptions = Partial<\n  Omit<FormKitContext, 'children' | 'plugins' | 'config' | 'hook'> & {\n    /**\n     * Config settings for the node, these are automatically exposed as props\n     * but are also checked in during hierarchical for prop checking.\n     */\n    config: Partial<FormKitConfig>\n    /**\n     * Props directly set on this node, these are not inherited.\n     */\n    props: Partial<FormKitProps>\n    /**\n     * The children of the node.\n     */\n    children: FormKitNode[] | Set<FormKitNode>\n    /**\n     * The explicit index of this node when used in a list. If specified, this\n     * node will be created at this index atomically.\n     */\n    index?: number\n    /**\n     * Should only be specified on list nodes — when true this indicates if the\n     * list node should automatically sync its child nodes with the value of\n     * the list node. In other words, if the list node’s value is an array of\n     * strings, and one string is popped off, the corresponding node should be\n     * removed the list and destroyed.\n     */\n    sync: boolean\n    /**\n     * Any plugins that should be registered on this node explicitly. These will\n     * automatically be inherited by any children.\n     */\n    plugins: FormKitPlugin[]\n    /**\n     * For internal use only.\n     */\n    alias: string\n    /**\n     * For internal use only.\n     */\n    schemaAlias: string\n  }\n>\n\n/**\n * The callback type for node.each().\n *\n * @public\n */\nexport interface FormKitChildCallback {\n  (child: FormKitNode): any\n}\n\n/**\n * A descriptor of a child value, generally passed up a node tree.\n *\n * @public\n */\nexport interface FormKitChildValue {\n  name: string | number | symbol\n  value: any\n  from?: number | symbol\n}\n\n/**\n * An empty interface for adding FormKit node extensions.\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface FormKitNodeExtensions {}\n\n/**\n * FormKit's Node object produced by createNode(). Every `<FormKit />` input has\n * 1 FormKitNode (\"core node\") associated with it. All inputs, forms, and groups\n * are instances of nodes. Read more about core nodes in the\n * {@link https://formkit.com/essentials/architecture#node | architecture\n * documentation.}\n *\n * @param add -\n * Add a child to a node. The node must be a group or list.\n *\n * #### Signature\n *\n * ```typescript\n * add: (node: FormKitNode, index?: number) => FormKitNode\n * ```\n *\n * #### Parameters\n *\n * - node — A {@link FormKitNode | FormKitNode}.\n * - index *optional* — A index to where it will added to.\n *\n * #### Returns\n *\n * The added {@link FormKitNode | FormKitNode}.\n *\n * @param address -\n * The address of the current node from the root of the tree.\n *\n * #### Signature\n *\n * ```typescript\n * address: FormKitAddress\n * ```\n *\n * #### Returns\n *\n * A {@link FormKitAddress | FormKitAddress}.\n *\n * @param addProps -\n * Adds props to the given node by removing them from node.props.attrs and\n * moving them to the top-level node.props object.\n *\n * #### Signature\n *\n * ```typescript\n * addProps: (props: string[]) => FormKitNode\n * ```\n *\n * #### Parameters\n *\n * - `props` — An array of strings to be added as keys for props.\n *\n * #### Returns\n *\n * The {@link FormKitNode | FormKitNode}.\n *\n * @param at -\n * Gets a node at another address. Addresses are dot-syntax paths (or arrays) of node names.\n * For example: `form.users.0.first_name`. There are a few \"special\" traversal tokens as well:\n *\n * - `$root` — Selects the root node.\n * - `$parent` — Selects the parent node.\n * - `$self` — Selects the current node.\n *\n * #### Signature\n *\n * ```typescript\n * at: (address: FormKitAddress | '$root' | '$parent' | '$self' | (string & {})) => FormKitNode | undefined\n * ```\n *\n * #### Parameters\n *\n * - `address` — An valid string or {@link FormKitAddress | FormKitAddress}.\n *\n * #### Returns\n *\n * The found {@link FormKitNode | FormKitNode} or `undefined`.\n *\n * @param children -\n * An array of child nodes (groups and lists).\n *\n * #### Signature\n *\n * ```typescript\n * children: Array<FormKitNode>\n * ```\n *\n * #### Returns\n *\n * An array of {@link FormKitNode | FormKitNode}.\n *\n * @param clearErrors -\n * Clears the errors of the node, and optionally all the children.\n *\n * #### Signature\n *\n * ```typescript\n * clearErrors: (clearChildren?: boolean, sourceKey?: string) => FormKitNode\n * ```\n *\n * #### Parameters\n *\n * - `clearChildren` *optional* — If it should clear the children.\n * - `sourceKey` *optional* — A source key to use for reset.\n *\n * #### Returns\n *\n * The {@link FormKitNode | FormKitNode}.\n *\n * @param config -\n * An object of {@link FormKitConfig | FormKitConfig} that is shared tree-wide\n * with various configuration options that should be applied to the entire tree.\n *\n * #### Signature\n *\n * ```typescript\n * config: FormKitConfig\n * ```\n *\n * #### Returns\n *\n * A {@link FormKitConfig | FormKitConfig}.\n *\n * @param define -\n * Defines the current input's library type definition including node type,\n * schema, and props.\n *\n * #### Signature\n *\n * ```typescript\n * define: (definition: FormKitTypeDefinition) => void\n * ```\n *\n * #### Parameters\n *\n * - `definition` — A {@link FormKitTypeDefinition | FormKitTypeDefinition}.\n *\n * @param destroy -\n * Removes the node from the global registry, its parent, and emits the\n * 'destroying' event.\n *\n * #### Signature\n *\n * ```typescript\n * destroy: () => void\n * ```\n *\n * @param each -\n * Perform given callback on each of the given node's children.\n *\n * #### Signature\n *\n * ```typescript\n * each: (callback: FormKitChildCallback) => void\n * ```\n *\n * #### Parameters\n *\n * - `callback` — A {@link FormKitChildCallback | FormKitChildCallback} to be called for each child.\n *\n * @param emit -\n * Emit an event from the node so it can be listened by {@link FormKitNode | on}.\n *\n * #### Signature\n *\n * ```typescript\n * emit: (event: string, payload?: any, bubble?: boolean, meta: Record<string, unknown>) => FormKitNode\n * ```\n *\n * #### Parameters\n *\n * - `event` — The event name to be emitted.\n * - `payload` *optional* — A value to be passed together with the event.\n * - `bubble` *optional* — If the event should bubble to the parent.\n *\n * #### Returns\n *\n * The {@link FormKitNode | FormKitNode}.\n *\n * @param extend -\n * Extend a {@link FormKitNode | FormKitNode} by adding arbitrary properties\n * that are accessible via `node.{property}()`.\n *\n * #### Signature\n *\n * ```typescript\n * extend: (property: string, trap: FormKitTrap) => FormKitNode\n * ```\n *\n * #### Parameters\n *\n * - `property` — The property to add the core node (`node.{property}`).\n * - `trap` — An object with a get and set property.\n *\n * #### Returns\n *\n * The {@link FormKitNode | FormKitNode}.\n *\n * @param find -\n * Within a given tree, find a node matching a given selector. Selectors can be simple strings or a function.\n *\n * #### Signature\n *\n * ```typescript\n * find: (\n *  selector: string,\n *  searcher?: keyof FormKitNode | FormKitSearchFunction\n * ) => FormKitNode | undefined\n * ```\n *\n * #### Parameters\n *\n * - `selector` — A selector string.\n * - `searcher` *optional* — A keyof {@link FormKitNode | FormKitNode} or {@link FormKitSearchFunction | FormKitSearchFunction}.\n *\n * #### Returns\n *\n * The found {@link FormKitNode | FormKitNode} or `undefined`.\n *\n * @param hook -\n * Set of hooks.\n *\n * #### Signature\n *\n * ```typescript\n * hook: FormKitHooks\n * ```\n *\n * #### Returns\n *\n * The {@link FormKitHooks | FormKitHooks}.\n *\n * @param index -\n * The index of a node compared to its siblings. This is only applicable in cases where a node is a child of a list.\n *\n * #### Signature\n *\n * ```typescript\n * index: number\n * ```\n *\n * #### Returns\n *\n * A `number`.\n *\n * @param input -\n * The function used to set the value of a node. All changes to a node's value\n * should use this function as it ensures the tree's state is always fully tracked.\n *\n * #### Signature\n *\n * ```typescript\n * input: (value: unknown, async?: boolean) => Promise<unknown>\n * ```\n *\n * #### Parameters\n *\n * - `value` — Any value to used for the node.\n * - `async` *optional* — If the input should happen asynchronously.\n *\n * #### Returns\n *\n * A `Promise<unknown>`.\n *\n * @param isCreated -\n * Begins as false, set to true when the node is finished being created.\n *\n * #### Signature\n *\n * ```typescript\n * isCreated: boolean\n * ```\n *\n * #### Returns\n *\n * A `boolean`.\n *\n * @param isSettled -\n * Boolean reflecting the settlement state of the node and its subtree.\n *\n * #### Signature\n *\n * ```typescript\n * isSettled: boolean\n * ```\n *\n * #### Returns\n *\n * A `boolean`.\n *\n * @param ledger -\n * A counting ledger for arbitrary message counters.\n *\n * #### Signature\n *\n * ```typescript\n * ledger: FormKitLedger\n * ```\n *\n * #### Returns\n *\n * A {@link FormKitLedger | FormKitLedger}.\n *\n * @param name -\n * The name of the input in the node tree. When a node is a child of a list,\n * this automatically becomes its index.\n *\n * #### Signature\n *\n * ```typescript\n * name: string\n * ```\n *\n * #### Returns\n *\n * A `string`.\n *\n * @param off -\n * Removes an event listener by its token.\n * Receipts can be shared among many event listeners by explicitly declaring the \"receipt\" property of the listener function.\n *\n * #### Signature\n *\n * ```typescript\n * off: (receipt: string) => FormKitNode\n * ```\n *\n * #### Parameters\n *\n * - `receipt` — A receipt generated by the `on` function.\n *\n * #### Returns\n *\n * A receipt `string`.\n *\n * @param on -\n * Adds an event listener for a given event, and returns a \"receipt\" which is a random string token.\n * This token should be used to remove the listener in the future.\n * Alternatively you can assign a \"receipt\" property to the listener function and that receipt will be used instead.\n * This allows multiple listeners to all be de-registered with a single off() call if they share the same receipt.\n *\n * #### Signature\n *\n * ```typescript\n * on: (eventName: string, listener: FormKitEventListener, pos: 'push' | 'unshift') => string\n * ```\n *\n * #### Parameters\n *\n * - `eventName` — The event name to listen to.\n * - `listener` — A {@link FormKitEventListener | FormKitEventListener} to run when the event happens.\n *\n * #### Returns\n *\n * A receipt `string`.\n *\n * @param parent -\n * The parent of a node.\n *\n * #### Signature\n *\n * ```typescript\n * parent: FormKitNode | null\n * ```\n *\n * #### Returns\n *\n * If found a {@link FormKitNode | FormKitNode} or `null`.\n *\n * @param props -\n * An proxied object of props. These are typically provided by the adapter\n * of choice.\n *\n * #### Signature\n *\n * ```typescript\n * props: Partial<FormKitProps>\n * ```\n *\n * #### Returns\n *\n * An optional list of {@link FormKitProps | FormKitProps}.\n *\n * @param remove -\n * Removes a child from the node.\n *\n * #### Signature\n *\n * ```typescript\n * remove: (node: FormKitNode) => FormKitNode\n * ```\n *\n * #### Parameters\n *\n * - `node` — A {@link FormKitNode | FormKitNode} to be removed.\n *\n * #### Returns\n *\n * The {@link FormKitNode | FormKitNode}.\n *\n * @param reset -\n * Resets the node’s value back to its original value.\n *\n * #### Signature\n *\n * ```typescript\n * reset: () => FormKitNode\n * ```\n *\n * #### Returns\n *\n * The {@link FormKitNode | FormKitNode}.\n *\n * @param root -\n * Retrieves the root node of a tree. This is accomplished via tree-traversal\n * on-request, and as such should not be used in frequently called functions.\n *\n * #### Signature\n *\n * ```typescript\n * root: FormKitNode\n * ```\n *\n * #### Returns\n *\n * The {@link FormKitNode | FormKitNode}.\n *\n * @param setErrors -\n * Sets errors on the input, and optionally to child inputs.\n *\n * #### Signature\n *\n * ```typescript\n * setErrors: (localErrors: ErrorMessages, childErrors?: ErrorMessages) => void\n * ```\n *\n * #### Parameters\n *\n * - `localErrors` — A {@link ErrorMessages | ErrorMessages} to be used.\n * - `childErrors` *optional* — A {@link ErrorMessages | ErrorMessages} to be used for children.\n *\n * @param settled -\n * A promise that resolves when a node and its entire subtree is settled.\n * In other words — all the inputs are done committing their values.\n *\n * #### Signature\n *\n * ```typescript\n * settled: Promise<unknown>\n * ```\n *\n * #### Returns\n *\n * A `Promise<unknown>`.\n *\n * @param store -\n * The internal node store.\n *\n * #### Signature\n *\n * ```typescript\n * store: FormKitStore\n * ```\n *\n * #### Returns\n *\n * A {@link FormKitStore | FormKitStore}.\n *\n * @param submit -\n * Triggers a submit event on the nearest form.\n *\n * #### Signature\n *\n * ```typescript\n * submit: () => void\n * ```\n *\n * @param t -\n * A text or translation function that exposes a given string to the \"text\"\n * hook. All text shown to users should be passed through this function\n * before being displayed — especially for core and plugin authors.\n *\n * #### Signature\n *\n * ```typescript\n * t: (key: string | FormKitTextFragment) => string\n * ```\n *\n * #### Parameters\n *\n * - `key` — A key or a {@link FormKitTextFragment | FormKitTextFragment} to find the translation for.\n *\n * #### Returns\n *\n * The translated `string`.\n *\n * @param type -\n * The type of node, should only be 'input', 'list', or 'group'.\n *\n * #### Signature\n *\n * ```typescript\n * type: FormKitNodeType\n * ```\n *\n * #### Returns\n *\n * A {@link FormKitNodeType | FormKitNodeType}.\n *\n * @param use -\n * Registers a new plugin on the node and its subtree.\n *\n * #### Signature\n *\n * ```typescript\n * use: (\n *  plugin: FormKitPlugin | FormKitPlugin[] | Set<FormKitPlugin>,\n *  run?: boolean,\n *  library?: boolean\n * ) => FormKitNode\n * ```\n *\n * #### Parameters\n *\n * - `plugin` — A {@link FormKitPlugin | FormKitPlugin} or an Array or Set of {@link FormKitPlugin | FormKitPlugin}.\n * - `run` *optional* — Should the plugin be executed on creation.\n * - `library` *optional* — Should the plugin's library function be executed on creation.\n *\n * #### Returns\n *\n * The {@link FormKitNode | FormKitNode}.\n *\n * @param value -\n * The value of the input. This should never be directly modified. Any\n * desired mutations should be made through {@link FormKitNode | input}.\n *\n * #### Signature\n *\n * ```typescript\n * readonly value: unknown\n * ```\n *\n * @param walk -\n * Performs a function on every node in its subtree (but not the node itself).\n * This is an expensive operation so it should be done very rarely and only lifecycle events that are relatively rare like boot up and shut down.\n *\n * #### Signature\n *\n * ```typescript\n * walk: (callback: FormKitChildCallback, stopOnFalse?: boolean, recurseOnFalse?: boolean) => void\n * ```\n *\n * #### Parameters\n *\n * - `callback` — A {@link FormKitChildCallback | FormKitChildCallback} to be executed for each child.\n * - `stopOnFalse` *optional* — If it should stop when the return is false.\n *\n * @public\n */\nexport type FormKitNode<V = unknown> = {\n  /**\n   * Boolean true indicating this object is a valid FormKitNode\n   */\n  readonly __FKNode__: true\n  /**\n   * The value of the input. This should never be directly modified. Any\n   * desired mutations should be made through node.input()\n   */\n  readonly value: V\n  /**\n   * The internal FormKitContext object — this is not a public API and should\n   * never be used outside of the core package itself. It is only here for\n   * internal use and as an escape hatch.\n   */\n  _c: FormKitContext\n  /**\n   * Add a child to a node, the node must be a group or list.\n   */\n  add: (node: FormKitNode, index?: number) => FormKitNode\n  /**\n   * Adds props to the given node by removing them from node.props.attrs and\n   * moving them to the top-level node.props object.\n   */\n  addProps: (props: FormKitPseudoProps) => FormKitNode\n  /**\n   * Gets a node at another address. Addresses are dot-syntax paths (or arrays)\n   * of node names. For example: form.users.0.first_name. There are a few\n   * \"special\" traversal tokens as well:\n   * - $root - Selects the root node\n   * - $parent - Selects the parent node\n   * - $self — Selects the current node\n   */\n  at: (\n    address: FormKitAddress | '$root' | '$parent' | '$self' | (string & {})\n  ) => FormKitNode | undefined\n  /**\n   * The address of the current node from the root of the tree.\n   */\n  address: FormKitAddress\n  /**\n   * An internal function used to bubble an event from a child to a parent.\n   */\n  bubble: (event: FormKitEvent) => FormKitNode\n  /**\n   * An internal mechanism for calming a disturbance — which is a mechanism\n   * used to know the state of input settlement in the tree.\n   */\n  calm: (childValue?: FormKitChildValue) => FormKitNode\n  /**\n   * Clears the errors of the node, and optionally all the children.\n   */\n  clearErrors: (clearChildren?: boolean, sourceKey?: string) => FormKitNode\n  /**\n   * An object that is shared tree-wide with various configuration options that\n   * should be applied to the entire tree.\n   */\n  config: FormKitConfig\n  /**\n   * Defines the current input's library type definition — including node type,\n   * schema, and props.\n   */\n  define: (definition: FormKitTypeDefinition<V>) => void\n  /**\n   * Increments a disturbance. A disturbance is a record that the input or a\n   * member of its subtree is no longer \"settled\". Disturbed nodes are ones\n   * that have had their value modified, but have not yet committed that value\n   * to the rest of the tree.\n   */\n  disturb: () => FormKitNode\n  /**\n   * Removes the node from the global registry, its parent, and emits the\n   * 'destroying' event.\n   */\n  destroy: () => void\n  /**\n   * Perform given callback on each of the given node's children.\n   */\n  each: (callback: FormKitChildCallback) => void\n  /**\n   * Emit an event from the node.\n   */\n  emit: (\n    event: string,\n    payload?: any,\n    bubble?: boolean,\n    meta?: Record<string, unknown>\n  ) => FormKitNode\n  /**\n   * Extend the core node by giving it a key and a trap.\n   */\n  extend: (key: string, trap: FormKitTrap) => FormKitNode\n  /**\n   * Within a given tree, find a node matching a given selector. Selectors\n   * can be simple strings or a function.\n   */\n  find: (\n    selector: string,\n    searcher?: keyof FormKitNode | FormKitSearchFunction\n  ) => FormKitNode | undefined\n  /**\n   * An internal mechanism to hydrate values down a node tree.\n   */\n  hydrate: () => FormKitNode\n  /**\n   * The index of a node compared to its siblings. This is only applicable in\n   * cases where a node is a child of a list.\n   */\n  index: number\n  /**\n   * The function used to set the value of a node. All changes to a node's value\n   * should use this function as it ensures the tree's state is always fully\n   * tracked.\n   */\n  input: (value: unknown, async?: boolean) => Promise<unknown>\n  /**\n   * The name of the input in the node tree. When a node is a child of a list,\n   * this automatically becomes its index.\n   */\n  name: string\n  /**\n   * Adds an event listener for a given event, and returns a \"receipt\" which is\n   * a random string token. This token should be used to remove the listener\n   * in the future. Alternatively you can assign a \"receipt\" property to the\n   * listener function and that receipt will be used instead — this allows\n   * multiple listeners to all be de-registered with a single off() call if they\n   * share the same receipt.\n   */\n  on: (\n    eventName: string,\n    listener: FormKitEventListener,\n    pos?: 'push' | 'unshift'\n  ) => string\n  /**\n   * Removes an event listener by its token. Receipts can be shared among many\n   * event listeners by explicitly declaring the \"receipt\" property of the\n   * listener function.\n   */\n  off: (receipt: string) => FormKitNode\n  /**\n   * Remove a child from a node.\n   */\n  remove: (node: FormKitNode | FormKitPlaceholderNode) => FormKitNode\n  /**\n   * Retrieves the root node of a tree. This is accomplished via tree-traversal\n   * on-request, and as such should not be used in frequently called functions.\n   */\n  root: FormKitNode\n  /**\n   * Resets the configuration of a node.\n   */\n  resetConfig: () => void\n  /**\n   * Reset a node’s value back to its original value.\n   */\n  reset: (value?: unknown) => FormKitNode\n  /**\n   * Sets errors on the input, and optionally to child inputs.\n   */\n  setErrors: (localErrors: ErrorMessages, childErrors?: ErrorMessages) => void\n  /**\n   * A promise that resolves when a node and its entire subtree is settled.\n   * In other words — all the inputs are done committing their values.\n   */\n  settled: Promise<unknown>\n  /**\n   * Triggers a submit event on the nearest form.\n   */\n  submit: () => void\n  /**\n   * A text or translation function that exposes a given string to the \"text\"\n   * hook. All text shown to users should be passed through this function\n   * before being displayed — especially for core and plugin authors.\n   */\n  t: (key: string | FormKitTextFragment) => string\n  /**\n   * Boolean reflecting the settlement state of the node and its subtree.\n   */\n  isSettled: boolean\n  /**\n   * A unique identifier for the node.\n   */\n  uid: symbol\n  /**\n   * Registers a new plugin on the node and its subtree.\n   * run = should the plugin be executed or not\n   * library = should the plugin's library function be executed (if there)\n   */\n  use: (\n    plugin: FormKitPlugin | FormKitPlugin[] | Set<FormKitPlugin>,\n    run?: boolean,\n    library?: boolean\n  ) => FormKitNode\n  /**\n   * Performs a function on every node in the subtree (not itself). This is an\n   * expensive operation so it should be done very rarely and only lifecycle\n   * events that are relatively rare like boot up and shut down.\n   */\n  walk: (\n    callback: FormKitChildCallback,\n    stopOnFalse?: boolean,\n    skipSubtreeOnFalse?: boolean\n  ) => void\n} & Omit<FormKitContext, 'value' | 'name' | 'config'> &\n  FormKitNodeExtensions\n\n/**\n * A faux node that is used as a placeholder in the children node array during\n * various node manipulations.\n * @public\n */\nexport interface FormKitPlaceholderNode<V = unknown> {\n  /**\n   * Flag indicating this is a placeholder.\n   */\n  __FKP: true\n  /**\n   * A unique symbol identifying this placeholder.\n   */\n  uid: symbol\n  /**\n   * The type of placeholder node, if relevant.\n   */\n  type: FormKitNodeType\n  /**\n   * A value at the placeholder location.\n   */\n  value: V\n  /**\n   * The uncommitted value, in a placeholder will always be the same\n   * as the value.\n   */\n  _value: V\n  /**\n   * Artificially use a plugin (performs no-op)\n   */\n  use: (...args: any[]) => void\n  /**\n   * Artificial props\n   */\n  props: Record<string, any>\n  /**\n   * A name to use.\n   */\n  name: string\n  /**\n   * Sets the value of the placeholder.\n   */\n  input: (value: unknown, async?: boolean) => Promise<unknown>\n  /**\n   * A placeholder is always settled.\n   */\n  isSettled: boolean\n}\n\n/**\n * A prop definition for a pseudo prop that defines a type and a default value.\n * @public\n */\nexport type FormKitPseudoProp =\n  | {\n      boolean?: true\n      default?: boolean\n      setter?: undefined\n      getter?: undefined\n    }\n  | {\n      boolean?: undefined\n      default?: unknown\n      setter?: (value: unknown, node: FormKitNode) => unknown\n      getter?: (value: unknown, node: FormKitNode) => unknown\n    }\n\n/**\n * Pseudo props are \"non-runtime\" props. Props that are not initially declared\n * as props, and are fetch out of the attrs object (in the context of VueJS).\n * @public\n */\nexport type FormKitPseudoProps =\n  | string[]\n  | Record<PropertyKey, FormKitPseudoProp>\n\n/**\n * Breadth and depth-first searches can use a callback of this notation.\n *\n * @public\n */\nexport type FormKitSearchFunction = (\n  node: FormKitNode,\n  searchTerm?: string | number\n) => boolean\n\n/**\n * Default configuration options.\n */\nconst defaultConfig: Partial<FormKitConfig> = {\n  delimiter: '.',\n  delay: 0,\n  locale: 'en',\n  rootClasses: (key: string) => ({ [`formkit-${kebab(key)}`]: true }),\n}\n\n/**\n * If a node’s name is set to useIndex, it replaces the node’s name with the\n * index of the node relative to its parent’s children.\n *\n * @internal\n */\nexport const useIndex = Symbol('index')\n\n/**\n * When propagating values up a tree, this value indicates the child should be\n * removed.\n *\n * @internal\n */\nexport const valueRemoved = Symbol('removed')\n\n/**\n * When propagating values up a tree, this value indicates the child should be\n * moved.\n *\n * @internal\n */\nexport const valueMoved = Symbol('moved')\n\n/**\n * When creating a new node and having its value injected directly at a specific\n * location.\n *\n * @internal\n */\nexport const valueInserted = Symbol('inserted')\n\n/**\n * A simple type guard to determine if the context being evaluated is a list\n * type.\n *\n * @param arg - A {@link FormKitContextShape | FormKitContextShape}.\n *\n * @returns Returns a `boolean`.\n *\n * @public\n */\nexport function isList(arg: FormKitContextShape): arg is FormKitListContext {\n  return arg.type === 'list' && Array.isArray(arg._value)\n}\n\n/**\n * Determine if a given object is a node.\n *\n * @example\n *\n * ```javascript\n * import { isNode, createNode } from '@formkit/core'\n *\n * const input = createNode({\n *   type: 'input', // defaults to 'input' if not specified\n *   value: 'hello node world',\n * })\n *\n * const obj = {};\n *\n * isNode(obj)\n * // false\n *\n * isNode(input)\n * // true\n * ```\n *\n * @param node - Any value.\n *\n * @returns Returns a `boolean`.\n *\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function isNode(node: any): node is FormKitNode {\n  return node && typeof node === 'object' && node.__FKNode__ === true\n}\n\n/**\n * The setter you are trying to access is invalid.\n */\nconst invalidSetter = (\n  node: FormKitNode,\n  _context: FormKitContext,\n  property: PropertyKey\n): never => {\n  error(102, [node, property])\n}\n\nconst traps = {\n  _c: trap(getContext, invalidSetter, false),\n  add: trap(addChild),\n  addProps: trap(addProps),\n  address: trap(getAddress, invalidSetter, false),\n  at: trap(getNode),\n  bubble: trap(bubble),\n  clearErrors: trap(clearErrors),\n  calm: trap(calm),\n  config: trap(false),\n  define: trap(define),\n  disturb: trap(disturb),\n  destroy: trap(destroy),\n  extend: trap(extend),\n  hydrate: trap(hydrate),\n  index: trap(getIndex, setIndex, false),\n  input: trap(input),\n  each: trap(eachChild),\n  emit: trap(emit),\n  find: trap(find),\n  on: trap(on),\n  off: trap(off),\n  parent: trap(false, setParent),\n  plugins: trap(false),\n  remove: trap(removeChild),\n  root: trap(getRoot, invalidSetter, false),\n  reset: trap(resetValue),\n  resetConfig: trap(resetConfig),\n  setErrors: trap(setErrors),\n  submit: trap(submit),\n  t: trap(text),\n  use: trap(use),\n  name: trap(getName, false, false),\n  walk: trap(walkTree),\n}\n\n/**\n * These are all the available \"traps\" for a given node. You can think of these\n * a little bit like methods, but they are really Proxy interceptors.\n */\nfunction createTraps(): FormKitTraps {\n  return new Map<string | symbol, FormKitTrap>(Object.entries(traps))\n}\n\n/**\n * Creates a getter/setter trap and curries the context/node pair\n *\n * @param getter - The getter function\n * @param setter - The setter function\n * @param curryGetter - Indicates if the getter should be curried or not\n *\n * @returns A {@link FormKitTrap | FormKitTrap}\n */\nfunction trap(\n  getter?: TrapGetter,\n  setter?: TrapSetter,\n  curryGetter = true\n): FormKitTrap {\n  return {\n    get: getter\n      ? (node, context) =>\n          curryGetter\n            ? (...args: any[]) => getter(node, context, ...args)\n            : getter(node, context)\n      : false,\n    set: setter !== undefined ? setter : invalidSetter.bind(null),\n  }\n}\n\n/**\n * Create all of the node's hook dispatchers.\n */\nfunction createHooks(): FormKitHooks {\n  const hooks: Map<string, FormKitDispatcher<unknown>> = new Map()\n  return new Proxy(hooks, {\n    get(_, property: string) {\n      if (!hooks.has(property)) {\n        hooks.set(property, createDispatcher())\n      }\n      return hooks.get(property)\n    },\n  }) as unknown as FormKitHooks\n}\n\n/**\n * This is a simple integer counter of every createName() where the name needs\n * to be generated.\n */\nlet nameCount = 0\n/**\n * This is a simple integer counter of every default id created.\n */\nlet idCount = 0\n\n/**\n * Resets the global number of node registrations, useful for deterministic\n * node naming.\n *\n * @public\n */\nexport function resetCount(): void {\n  nameCount = 0\n  idCount = 0\n}\n\n/**\n * Create a name-based dictionary of all children in an array.\n *\n * @param children - An array of {@link FormKitNode | FormKitNode}.\n *\n * @returns A dictionary of named {@link FormKitNode | FormKitNode}.\n *\n * @public\n */\nexport function names(children: FormKitNode[]): {\n  [index: string]: FormKitNode\n} {\n  return children.reduce(\n    (named, child) => Object.assign(named, { [child.name]: child }),\n    {}\n  )\n}\n\n/**\n * This node is responsible for deterministically generating an id for this\n * node. This cannot just be a random id, it _must_ be deterministic to ensure\n * re-hydration of the form (like post-SSR) produces the same names/ids.\n *\n * @param options - A {@link FormKitOptions | FormKitOptions}\n *\n * @returns `string | symbol`\n *\n * @internal\n */\nfunction createName(options: FormKitOptions): string | symbol {\n  if (options.parent?.type === 'list') return useIndex\n  return options.name || `${options.props?.type || 'input'}_${++nameCount}`\n}\n\n/**\n * Creates the initial value for a node based on the options passed in and the\n * type of the input.\n *\n * @param options - A {@link FormKitOptions | FormKitOptions}.\n *\n * @returns `unknown`\n *\n * @public\n */\nexport function createValue(options: FormKitOptions): unknown {\n  if (options.type === 'group') {\n    return init(\n      options.value &&\n        typeof options.value === 'object' &&\n        !Array.isArray(options.value)\n        ? options.value\n        : {}\n    )\n  } else if (options.type === 'list') {\n    return init(Array.isArray(options.value) ? options.value : [])\n  }\n  return options.value\n}\n/**\n * Sets the internal value of the node.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n * @param value - A input value to the node\n * @param async - If its an async call\n *\n * @returns `Promise<unknown>`\n *\n * @internal\n */\nfunction input(\n  node: FormKitNode,\n  context: FormKitContext,\n  value: unknown,\n  async = true\n): Promise<unknown> {\n  context._value = validateInput(node, node.hook.input.dispatch(value))\n  node.emit('input', context._value)\n  if (\n    node.isCreated &&\n    node.type === 'input' &&\n    eq(context._value, context.value) &&\n    !node.props.mergeStrategy\n  ) {\n    node.emit('commitRaw', context.value)\n    // Perform an early return if the value hasn't changed during this input.\n    return context.settled\n  }\n  if (context.isSettled) node.disturb()\n  if (async) {\n    if (context._tmo) clearTimeout(context._tmo)\n    context._tmo = setTimeout(\n      commit,\n      node.props.delay,\n      node,\n      context\n    ) as unknown as number\n  } else {\n    commit(node, context)\n  }\n  return context.settled\n}\n\n/**\n * Validate that the current input is allowed.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param value - The value that is being validated\n *\n * @returns `T`\n *\n * @internal\n */\nfunction validateInput<T>(node: FormKitNode, value: T): T {\n  switch (node.type) {\n    // Inputs are allowed to have any type\n    case 'input':\n      break\n    case 'group':\n      if (!value || typeof value !== 'object') error(107, [node, value])\n      break\n    case 'list':\n      if (!Array.isArray(value)) error(108, [node, value])\n      break\n  }\n  return value\n}\n\n/**\n * Commits the working value to the node graph as the value of this node.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n * @param calm - If it calms the node\n * @param hydrate - If it hydrates the node\n *\n * @internal\n */\nfunction commit(\n  node: FormKitNode,\n  context: FormKitContext,\n  calm = true,\n  hydrate = true\n) {\n  context._value = context.value = node.hook.commit.dispatch(context._value)\n  if (node.type !== 'input' && hydrate) node.hydrate()\n  node.emit('commitRaw', context.value)\n  node.emit('commit', context.value)\n  if (calm) node.calm()\n}\n\n/**\n * Perform a modification to a single element of a parent aggregate value. This\n * is only performed on the pre-committed value (_value), although typically\n * the value and _value are both linked in memory.\n *\n * @param context - A {@link FormKitContext | FormKitContext}\n *\n * @internal\n */\nfunction partial(\n  context: FormKitContext,\n  { name, value, from }: FormKitChildValue\n) {\n  if (Object.isFrozen(context._value)) return\n  if (isList(context)) {\n    const insert: any[] =\n      value === valueRemoved\n        ? []\n        : value === valueMoved && typeof from === 'number'\n        ? context._value.splice(from, 1)\n        : [value]\n    context._value.splice(\n      name as number,\n      value === valueMoved || from === valueInserted ? 0 : 1,\n      ...insert\n    )\n    return\n  }\n\n  if (value !== valueRemoved) {\n    ;(context._value as FormKitGroupValue)[name as string] = value\n  } else {\n    delete (context._value as FormKitGroupValue)[name as string]\n  }\n}\n\n/**\n * Hydrate node and its children\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n *\n * @returns A {@link FormKitNode | FormKitNode}\n *\n * @internal\n */\nfunction hydrate(node: FormKitNode, context: FormKitContext): FormKitNode {\n  const _value = context._value as KeyedValue\n  // For \"synced\" lists the underlying nodes need to be synced to their values\n  // before hydration.\n  if (node.type === 'list' && node.sync) syncListNodes(node, context)\n  context.children.forEach((child) => {\n    if (typeof _value !== 'object') return\n    if (child.name in _value) {\n      // In this case, the parent has a value to give to the child, so we\n      // perform a down-tree synchronous input which will cascade values down\n      // and then ultimately back up.\n      const childValue =\n        child.type !== 'input' ||\n        (_value[child.name] && typeof _value[child.name] === 'object')\n          ? init(_value[child.name])\n          : _value[child.name]\n      // If the two are already equal or the child is currently disturbed then\n      // don’t send the value down since it will squash the child’s value.\n      if (\n        !child.isSettled ||\n        ((!isObject(childValue) || child.props.mergeStrategy) &&\n          eq(childValue, child._value))\n      )\n        return\n\n      // If there is a change to the child, push the new value down.\n      child.input(childValue, false)\n    } else {\n      if (node.type !== 'list' || typeof child.name === 'number') {\n        // In this case, the parent’s values have no knowledge of the child\n        // value — this typically occurs on the commit at the end of addChild()\n        // we need to create a value reservation for this node’s name. This is\n        // especially important when dealing with lists where index matters.\n        partial(context, { name: child.name, value: child.value })\n      }\n      if (!_value.__init) {\n        // In this case, someone has explicitly set the value to an empty object\n        // with node.input({}) so we do not define the __init property:\n        if (child.type === 'group') child.input({}, false)\n        else if (child.type === 'list') child.input([], false)\n        else child.input(undefined, false)\n      }\n    }\n  })\n  return node\n}\n\n/**\n * Hydrate a list node and its children. There are some assumptions about the\n * child nodes that are made here:\n * 1. The child nodes are either:\n *    - Are scalars and their values can be exchanged.\n *    - Are groups and should maintain node identity.\n * 2. The value of the list will be a 1-1 representation of the children.\n * 3. If new values are *added* to the list, those nodes must be created by some\n *   other means — adding a value does not add a node automatically.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n */\nfunction syncListNodes(node: FormKitNode, context: FormKitContext) {\n  const _value = node._value\n  if (!Array.isArray(_value)) return\n\n  const newChildren: Array<FormKitNode | FormKitPlaceholderNode | null> = []\n  const unused = new Set(context.children)\n  const placeholderValues = new Map<unknown, number[]>()\n\n  // 1. Iterate over the values and if the values at the same index are equal\n  //    then we can reuse the node. Otherwise we add a `null` placeholder.\n  _value.forEach((value, i) => {\n    if (context.children[i] && context.children[i]._value === value) {\n      newChildren.push(context.children[i])\n      unused.delete(context.children[i])\n    } else {\n      newChildren.push(null)\n\n      const indexes = placeholderValues.get(value) || []\n      indexes.push(i)\n      placeholderValues.set(value, indexes)\n    }\n  })\n\n  // 2. If there are unused nodes, and there are null nodes in the new children\n  //    then we attempt to match those irregardless of their index.\n  if (unused.size && placeholderValues.size) {\n    unused.forEach((child) => {\n      if (placeholderValues.has(child._value)) {\n        /* eslint-disable @typescript-eslint/no-non-null-assertion */\n        const indexes = placeholderValues.get(child._value)!\n        const index = indexes.shift()!\n        /* eslint-enable @typescript-eslint/no-non-null-assertion */\n        newChildren[index] = child\n        unused.delete(child)\n        if (!indexes.length) placeholderValues.delete(child._value)\n      }\n    })\n  }\n\n  // 3. If there are still unused nodes, and unused placeholders, we assign the\n  //    unused nodes to the unused placeholders in order.\n  const emptyIndexes: number[] = []\n  placeholderValues.forEach((indexes) => {\n    emptyIndexes.push(...indexes)\n  })\n\n  while (unused.size && emptyIndexes.length) {\n    const child = unused.values().next().value\n    const index = emptyIndexes.shift()\n    if (index === undefined) break\n    newChildren[index] = child\n    unused.delete(child)\n  }\n\n  // 4. If there are placeholders in the children, we create true placeholders.\n  emptyIndexes.forEach((index, value) => {\n    newChildren[index] = createPlaceholder({ value })\n  })\n\n  // 5. If there are unused nodes, we remove them. To ensure we don’t remove any\n  //    values we explicitly remove each child’s parent and manually unmerge the\n  //    child from the parent’s ledger before destroying the subtree.\n  if (unused.size) {\n    unused.forEach((child) => {\n      if (!('__FKP' in child)) {\n        const parent = child._c.parent\n        if (!parent || isPlaceholder(parent)) return\n        parent.ledger.unmerge(child)\n        child._c.parent = null\n        child.destroy()\n      }\n    })\n  }\n\n  // 6. Finally, we assign the new children to the context.\n  context.children = newChildren as Array<FormKitNode | FormKitPlaceholderNode>\n}\n\n/**\n * Disturbs the state of a node from settled to unsettled — creating appropriate\n * promises and resolutions.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n *\n * @returns A {@link FormKitNode | FormKitNode}\n *\n * @internal\n */\nfunction disturb(node: FormKitNode, context: FormKitContext): FormKitNode {\n  if (context._d <= 0) {\n    context.isSettled = false\n    node.emit('settled', false, false)\n    context.settled = new Promise((resolve) => {\n      context._resolve = resolve\n    })\n    if (node.parent) node.parent?.disturb()\n  }\n  context._d++\n  return node\n}\n\n/**\n * Calms the given node's disturbed state by one.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n * @param value - A {@link FormKitChildValue | FormKitChildValue}\n *\n * @internal\n */\nfunction calm(\n  node: FormKitNode,\n  context: FormKitContext,\n  value?: FormKitChildValue\n) {\n  if (value !== undefined && node.type !== 'input') {\n    partial(context, value)\n    const shouldHydrate = !!(\n      node.config.mergeStrategy && node.config.mergeStrategy[value.name]\n    )\n    // Commit the value up, but do not hydrate back down\n    return commit(node, context, true, shouldHydrate)\n  }\n  if (context._d > 0) context._d--\n  if (context._d === 0) {\n    context.isSettled = true\n    node.emit('settled', true, false)\n    if (node.parent)\n      node.parent?.calm({ name: node.name, value: context.value })\n    if (context._resolve) context._resolve(context.value)\n  }\n}\n\n/**\n * This node is being removed and needs to be cleaned up.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n *\n * @internal\n */\nfunction destroy(node: FormKitNode, context: FormKitContext) {\n  node.emit('destroying', node)\n  // flush all messages out\n  node.store.filter(() => false)\n  if (node.parent) {\n    node.parent.remove(node)\n  }\n  deregister(node)\n  node.emit('destroyed', node)\n  context._e.flush()\n  context._value = context.value = undefined\n  for (const property in context.context) {\n    delete context.context[property]\n  }\n  context.plugins.clear()\n  context.context = null! // eslint-disable-line @typescript-eslint/no-non-null-assertion\n}\n\n/**\n * Defines the current input type concretely.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n * @param definition - A {@link FormKitTypeDefinition | FormKitTypeDefinition}\n *\n * @internal\n */\nfunction define(\n  node: FormKitNode,\n  context: FormKitContext,\n  definition: FormKitTypeDefinition\n) {\n  // Prop definitions that may have been registered before the input was\n  // ever defined, for example with a manual createNode()\n  // Assign the type\n  context.type = definition.type\n  // Assign the definition\n  const clonedDef = clone(definition)\n  // Merge existing prop defs into the cloned input definition.\n  // @ts-ignore-next-line\n  node.props.__propDefs = mergeProps(\n    node.props.__propDefs ?? [],\n    clonedDef?.props || []\n  )\n  // Assign the prop defs to the cloned input definition.\n  clonedDef.props = node.props.__propDefs\n\n  // Assign the definition to the props\n  context.props.definition = clonedDef\n\n  // Ensure the type is seeded with the `__init` value.\n  context.value = context._value = createValue({\n    type: node.type,\n    value: context.value,\n  })\n  /**\n   * If the user has a typename defined, use it here.\n   */\n  if (definition.forceTypeProp) {\n    if (node.props.type) node.props.originalType = node.props.type\n    context.props.type = definition.forceTypeProp\n  }\n  /**\n   * If the input is part of a family of inputs, add that prop.\n   */\n  if (definition.family) {\n    context.props.family = definition.family\n  }\n  // Apply any input features before resetting the props.\n  if (definition.features) {\n    definition.features.forEach((feature) => feature(node))\n  }\n  // Its possible that input-defined \"props\" have ended up in the context attrs\n  // these should be moved back out of the attrs object.\n  if (definition.props) {\n    node.addProps(definition.props)\n  }\n\n  node.emit('defined', definition)\n}\n\n/**\n * Adds props to a given node by stripping them out of the node.props.attrs and\n * then adding them to the nodes.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n * @param props - An array of prop strings (in camelCase!)\n *\n * @returns A {@link FormKitNode | FormKitNode}\n *\n * @internal\n */\nfunction addProps(\n  node: FormKitNode,\n  context: FormKitContext,\n  props: FormKitPseudoProps\n): FormKitNode {\n  const propNames = Array.isArray(props) ? props : Object.keys(props)\n  const defaults: Record<string, unknown> = !Array.isArray(props)\n    ? propNames.reduce((defaults, name) => {\n        if ('default' in props[name]) {\n          defaults[name] = props[name].default\n        }\n        return defaults\n      }, {} as Record<string, unknown>)\n    : {}\n  if (node.props.attrs) {\n    const attrs = { ...node.props.attrs }\n    // Temporarily disable prop emits\n    node.props._emit = false\n    for (const attr in attrs) {\n      const camelName = camel(attr)\n      if (propNames.includes(camelName)) {\n        node.props[camelName] = attrs[attr]\n        delete attrs[attr]\n      }\n    }\n    // Assign defaults to any props\n    if (!Array.isArray(props)) {\n      propNames.forEach((prop) => {\n        if ('default' in props[prop] && node.props[prop] === undefined) {\n          node.props[prop] = defaults[prop]\n        }\n      })\n    }\n    const initial = cloneAny(context._value)\n    node.props.initial =\n      node.type !== 'input' ? init(initial as KeyedValue) : initial\n    // Re-enable prop emits\n    node.props._emit = true\n    node.props.attrs = attrs\n  }\n  const mergedProps = mergeProps(node.props.__propDefs ?? [], props)\n\n  if (node.props.definition) {\n    node.props.definition.props = mergedProps\n  }\n\n  // @ts-ignore-next-line\n  node.props.__propDefs = mergedProps\n\n  node.emit('added-props', props)\n  return node\n}\n\nfunction toPropsObj(\n  props: FormKitPseudoProps\n): Record<PropertyKey, FormKitPseudoProp> {\n  return !Array.isArray(props)\n    ? props\n    : props.reduce((props, prop) => {\n        props[prop] = {}\n        return props\n      }, {} as Record<PropertyKey, FormKitPseudoProp>)\n}\n\nfunction mergeProps(\n  props: FormKitPseudoProps,\n  newProps: FormKitPseudoProps\n): FormKitPseudoProps {\n  if (Array.isArray(props) && Array.isArray(newProps))\n    return props.concat(newProps)\n  return merge(toPropsObj(props), toPropsObj(newProps)) as Record<\n    PropertyKey,\n    FormKitPseudoProp\n  >\n}\n\n/**\n * Adds a child to the node.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param context - A parent {@link FormKitContext | FormKitContext}\n * @param child - A {@link FormKitNode | FormKitNode}\n * @param listIndex - A index number to be added at\n *\n * @internal\n */\nfunction addChild(\n  parent: FormKitNode,\n  parentContext: FormKitContext,\n  child: FormKitNode,\n  listIndex?: number\n) {\n  if (parent.type === 'input') error(100, parent)\n  if (child.parent && child.parent !== parent) {\n    child.parent.remove(child)\n  }\n  // Synchronously set the initial value on the parent\n  if (!parentContext.children.includes(child)) {\n    if (listIndex !== undefined && parent.type === 'list') {\n      // Inject the child:\n      const existingNode = parentContext.children[listIndex]\n      if (existingNode && '__FKP' in existingNode) {\n        // The node index is populated by a placeholderNode so we need to\n        // remove that replace it with the real node (the current child).\n        child._c.uid = existingNode.uid\n        parentContext.children.splice(listIndex, 1, child)\n      } else {\n        parentContext.children.splice(listIndex, 0, child)\n      }\n\n      if (\n        Array.isArray(parent.value) &&\n        parent.value.length < parentContext.children.length\n      ) {\n        // When adding an node or value to a list it is absolutely critical to\n        // know if, at the moment of injection, the parent’s value or the node\n        // children are the source of truth. For example, if a user pushes or\n        // splices a new value onto the lists’s array then we want to use that\n        // value as the value of the new node, but if a user adds a node to the\n        // list then we want the node’s value. In this specific case, we\n        // assume (due to length) that a new node was injected into the list, so\n        // we want that new node’s value injected into the parent list value.\n        parent.disturb().calm({\n          name: listIndex,\n          value: child.value,\n          from: valueInserted,\n        })\n      }\n    } else {\n      parentContext.children.push(child)\n    }\n    if (!child.isSettled) parent.disturb()\n  }\n  if (child.parent !== parent) {\n    child.parent = parent\n    // In this edge case middleware changed the parent assignment so we need to\n    // re-add the child\n    if (child.parent !== parent) {\n      parent.remove(child)\n      child.parent.add(child)\n      return parent\n    }\n  } else {\n    // When a parent is properly assigned, we inject the parent's plugins on the\n    // child.\n    child.use(parent.plugins)\n  }\n  // Finally we call commit here, which sub-calls hydrate(), hydrate() will\n  // resolve any conflict between the parent and child values, and also ensure\n  // proper \"placeholders\" are made on the parent.\n  commit(parent, parentContext, false)\n  parent.ledger.merge(child)\n  parent.emit('child', child)\n  return parent\n}\n\n/**\n * The setter for node.parent = FormKitNode\n * @param child - A child {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n * @param _property - A property to be setted\n * @param parent - A parent {@link FormKitNode | FormKitNode}\n *\n * @returns `boolean`\n *\n * @internal\n */\nfunction setParent(\n  child: FormKitNode,\n  context: FormKitContext,\n  _property: string | number | symbol,\n  parent: FormKitNode\n): boolean {\n  if (isNode(parent)) {\n    if (child.parent && child.parent !== parent) {\n      child.parent.remove(child)\n    }\n    context.parent = parent\n    child.resetConfig()\n    !parent.children.includes(child)\n      ? parent.add(child)\n      : child.use(parent.plugins)\n    return true\n  }\n  if (parent === null) {\n    context.parent = null\n    return true\n  }\n  return false\n}\n\n/**\n * Removes a child from the node.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n * @param child - A child {@link FormKitNode | FormKitNode}\n *\n * @internal\n */\nfunction removeChild(\n  node: FormKitNode,\n  context: FormKitContext,\n  child: FormKitNode\n) {\n  const childIndex = context.children.indexOf(child)\n  if (childIndex !== -1) {\n    if (child.isSettled) node.disturb()\n    context.children.splice(childIndex, 1)\n    // If an ancestor uses the preserve prop, then we are expected to not remove\n    // our values on this node either, see #53\n    let preserve = undefine(child.props.preserve)\n    let parent = child.parent\n    while (preserve === undefined && parent) {\n      preserve = undefine(parent.props.preserve)\n      parent = parent.parent\n    }\n    if (!preserve) {\n      node.calm({\n        name: node.type === 'list' ? childIndex : child.name,\n        value: valueRemoved,\n      })\n    } else {\n      node.calm()\n    }\n    child.parent = null\n    // Remove the child from the config. Is this weird? Yes. Is it ok? Yes.\n    child.config._rmn = child\n  }\n  node.ledger.unmerge(child)\n  node.emit('childRemoved', child)\n  return node\n}\n\n/**\n * Iterate over each immediate child and perform a callback.\n *\n * @param _node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n * @param callback - A {@link FormKitChildCallback | FormKitChildCallback}\n *\n * @internal\n */\nfunction eachChild(\n  _node: FormKitNode,\n  context: FormKitContext,\n  callback: FormKitChildCallback\n) {\n  context.children.forEach((child) => !('__FKP' in child) && callback(child))\n}\n\n/**\n * Walk all nodes below this one and execute a callback.\n *\n * @param _node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n * @param callback - A {@link FormKitChildCallback | FormKitChildCallback}\n * @param stopIfFalse - Boolean to stop running on children\n * @param skipSubtreeOnFalse - Boolean that when true prevents recursion into a deeper node when the callback returns false\n *\n * @internal\n */\nfunction walkTree(\n  _node: FormKitNode,\n  context: FormKitContext,\n  callback: FormKitChildCallback,\n  stopIfFalse = false,\n  skipSubtreeOnFalse = false\n) {\n  context.children.some((child) => {\n    if ('__FKP' in child) return false\n    const val = callback(child)\n    // return true to stop the walk early\n    if (stopIfFalse && val === false) return true\n    if (skipSubtreeOnFalse && val === false) return false\n    return child.walk(callback, stopIfFalse, skipSubtreeOnFalse)\n  })\n}\n\n/**\n * Set the configuration options of the node and it's subtree.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n *\n * @internal\n */\nfunction resetConfig(node: FormKitNode, context: FormKitContext) {\n  const parent = node.parent || undefined\n  context.config = createConfig(node.config._t, parent)\n  node.walk((n) => n.resetConfig())\n}\n\n/**\n * Adds a plugin to the node, its children, and executes it.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n * @param plugin -\n * {@link FormKitPlugin | FormKitPlugin}\n * {@link FormKitPlugin | FormKitPlugin[]}\n * {@link FormKitPlugin | Set<FormKitPlugin>}\n * @param run - If it will run on creation\n * @param library - If it will run on library creation\n *\n * @returns A {@link FormKitNode | FormKitNode}\n *\n * @internal\n */\nexport function use(\n  node: FormKitNode,\n  context: FormKitContext,\n  plugin: FormKitPlugin | FormKitPlugin[] | Set<FormKitPlugin>,\n  run = true,\n  library = true\n): FormKitNode {\n  if (Array.isArray(plugin) || plugin instanceof Set) {\n    plugin.forEach((p: FormKitPlugin) => use(node, context, p))\n    return node\n  }\n  if (!context.plugins.has(plugin)) {\n    if (library && typeof plugin.library === 'function') plugin.library(node)\n    // When plugins return false, they are never added as to the plugins Set\n    // meaning they only ever have access to the single node they were added on.\n    if (run && plugin(node) !== false) {\n      context.plugins.add(plugin)\n      node.children.forEach((child) => child.use(plugin))\n    }\n  }\n  return node\n}\n\n/**\n * Moves a node in the parent’s children to the given index.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param _context - A {@link FormKitContext | FormKitContext}\n * @param _property - A property to add\n * @param setIndex - The index to move the node\n *\n * @internal\n */\nfunction setIndex(\n  node: FormKitNode,\n  _context: FormKitContext,\n  _property: string | number | symbol,\n  setIndex: number\n) {\n  if (isNode(node.parent)) {\n    const children = node.parent.children\n    const index =\n      setIndex >= children.length\n        ? children.length - 1\n        : setIndex < 0\n        ? 0\n        : setIndex\n    const oldIndex = children.indexOf(node)\n    if (oldIndex === -1) return false\n    children.splice(oldIndex, 1)\n    children.splice(index, 0, node)\n    node.parent.children = children\n    if (node.parent.type === 'list')\n      node.parent\n        .disturb()\n        .calm({ name: index, value: valueMoved, from: oldIndex })\n    return true\n  }\n  return false\n}\n\n/**\n * Retrieves the index of a node from the parent’s children.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n *\n * @internal\n */\nfunction getIndex(node: FormKitNode) {\n  if (node.parent) {\n    const index = [...node.parent.children].indexOf(node)\n    // If the index is currently -1 then the node isnt finished booting, so it\n    // must be the next node.\n    return index === -1 ? node.parent.children.length : index\n  }\n  return -1\n}\n\n/**\n * Retrieves the context object of a given node. This is intended to be a\n * private trap and should absolutely not be used in plugins or user-land code.\n *\n * @param _node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n *\n * @internal\n */\nfunction getContext(_node: FormKitNode, context: FormKitContext) {\n  return context\n}\n\n/**\n * Get the name of the current node, allowing for slight mutations.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n *\n * @internal\n */\nfunction getName(node: FormKitNode, context: FormKitContext) {\n  if (node.parent?.type === 'list') return node.index\n  return context.name !== useIndex ? context.name : node.index\n}\n\n/**\n * Returns the address of the current node.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n *\n * @internal\n */\nfunction getAddress(\n  node: FormKitNode,\n  context: FormKitContext\n): FormKitAddress {\n  return context.parent\n    ? context.parent.address.concat([node.name])\n    : [node.name]\n}\n\n/**\n * Fetches a node from the tree by its address.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param _context - A {@link FormKitContext | FormKitContext}\n * @param locator - A string or {@link FormKitAddress | FormKitAddress} to find in the tree.\n *\n * @returns A {@link FormKitNode | FormKitNode}\n *\n * @internal\n */\nfunction getNode(\n  node: FormKitNode,\n  _context: FormKitContext,\n  locator: string | FormKitAddress\n): FormKitNode | undefined {\n  const address =\n    typeof locator === 'string' ? locator.split(node.config.delimiter) : locator\n  if (!address.length) return undefined\n  const first = address[0]\n  let pointer: FormKitNode | null | undefined = node.parent\n  if (!pointer) {\n    // This address names the root node, remove it to get child name:\n    if (String(address[0]) === String(node.name)) address.shift()\n    // All root nodes start at themselves ultimately:\n    pointer = node\n  }\n  // Any addresses starting with $parent should discard it\n  if (first === '$parent') address.shift()\n  while (pointer && address.length) {\n    const name = address.shift() as string | number\n    switch (name) {\n      case '$root':\n        pointer = node.root\n        break\n      case '$parent':\n        pointer = pointer.parent\n        break\n      case '$self':\n        pointer = node\n        break\n      default:\n        pointer =\n          (pointer.children.find(\n            (c) => !('__FKP' in c) && String(c.name) === String(name)\n          ) as FormKitNode | undefined) || select(pointer, name)\n    }\n  }\n  return pointer || undefined\n}\n\n/**\n * Perform selections on a subtree using the address \"selector\" methods.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param selector - A `string | number` to find in the node\n *\n * @returns A {@link FormKitNode | FormKitNode} or `undefined`\n *\n * @internal\n */\nfunction select(\n  node: FormKitNode,\n  selector: string | number\n): FormKitNode | undefined {\n  const matches = String(selector).match(/^(find)\\((.*)\\)$/)\n  if (matches) {\n    const [, action, argStr] = matches\n    const args = argStr.split(',').map((arg) => arg.trim())\n    switch (action) {\n      case 'find':\n        return node.find(args[0], args[1] as keyof FormKitNode)\n      default:\n        return undefined\n    }\n  }\n  return undefined\n}\n\n/**\n * Perform a breadth first search and return the first instance of a node that\n * is found in the subtree or undefined.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param _context - A {@link FormKitContext | FormKitContext}\n * @param searchTerm - The term we are searching for\n * @param searcher - Either a key of {@link FormKitNode | FormKitNode}, or a {@link FormKitSearchFunction | FormKitSearchFunction}\n *\n * @returns A {@link FormKitNode | FormKitNode} or `undefined`\n *\n * @internal\n */\nfunction find(\n  node: FormKitNode,\n  _context: FormKitContext,\n  searchTerm: string,\n  searcher: keyof FormKitNode | FormKitSearchFunction\n): FormKitNode | undefined {\n  return bfs(node, searchTerm, searcher)\n}\n\n/**\n * Perform a breadth-first search on a node subtree and locate the first\n * instance of a match.\n *\n * @param tree - A {@link FormKitNode | FormKitNode} to start from.\n * @param searchValue - A value to be searched.\n * @param searchGoal - A goal value.\n *\n * @returns A {@link FormKitNode | FormKitNode } or `undefined`.\n *\n * @public\n */\nexport function bfs(\n  tree: FormKitNode,\n  searchValue: string | number,\n  searchGoal: keyof FormKitNode | FormKitSearchFunction = 'name'\n): FormKitNode | undefined {\n  const search: FormKitSearchFunction =\n    typeof searchGoal === 'string'\n      ? (n: FormKitNode) => n[searchGoal] == searchValue // non-strict comparison is intentional\n      : searchGoal\n  const stack: Array<FormKitNode | FormKitPlaceholderNode> = [tree]\n  while (stack.length) {\n    const node = stack.shift()! // eslint-disable-line @typescript-eslint/no-non-null-assertion\n    if ('__FKP' in node) continue\n    if (search(node, searchValue)) return node\n    stack.push(...node.children)\n  }\n  return undefined\n}\n\n/**\n * Get the root node of the tree.\n *\n * @param n - A {@link FormKitNode | FormKitNode}\n *\n * @internal\n */\nfunction getRoot(n: FormKitNode) {\n  let node = n\n  while (node.parent) {\n    node = node.parent\n  }\n  return node\n}\n\n/**\n * Creates a new configuration option.\n *\n * @param target - An object of optional properties of {@link FormKitConfig | FormKitConfig}\n * @param parent - A parent {@link FormKitNode | FormKitNode}\n *\n * @returns {@link FormKitNode | FormKitNode}\n *\n * @internal\n */\nfunction createConfig(\n  target: Partial<FormKitConfig> = {},\n  parent?: FormKitNode | null\n): FormKitConfig {\n  let node: FormKitNode | undefined = undefined\n  return new Proxy(target, {\n    get(...args) {\n      const prop = args[1]\n      if (prop === '_t') return target\n      const localValue = Reflect.get(...args)\n      // Check our local values first\n      if (localValue !== undefined) return localValue\n      // Then check our parent values next\n      if (parent) {\n        const parentVal = parent.config[prop as string]\n        if (parentVal !== undefined) return parentVal\n      }\n      if (target.rootConfig && typeof prop === 'string') {\n        const rootValue = target.rootConfig[prop]\n        if (rootValue !== undefined) return rootValue\n      }\n      // The default delay value should be 20\n      if (prop === 'delay' && node?.type === 'input') return 20\n      // Finally check the default values\n      return defaultConfig[prop as string]\n    },\n    set(...args) {\n      const prop = args[1] as string\n      const value = args[2]\n      if (prop === '_n') {\n        node = value as FormKitNode\n        if (target.rootConfig) target.rootConfig._add(node)\n        return true\n      }\n      if (prop === '_rmn') {\n        if (target.rootConfig) target.rootConfig._rm(node as FormKitNode)\n        node = undefined\n        return true\n      }\n      if (!eq(target[prop as string], value, false)) {\n        const didSet = Reflect.set(...args)\n        if (node) {\n          node.emit(`config:${prop}`, value, false)\n          configChange(node, prop, value)\n          // Walk the node tree and notify of config/prop changes where relevant\n          node.walk((n) => configChange(n, prop, value), false, true)\n        }\n        return didSet\n      }\n      return true\n    },\n  }) as FormKitConfig\n}\n\n/**\n * Given a string of text, expose it for modification, translation, or full\n * replacement.\n\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param _context - A {@link FormKitContext | FormKitContext}\n * @param key - A {@link FormKitTextFragment | FormKitTextFragment}, or generic string of text\n * @param type - A string to represent the text type\n *\n * @returns `string`\n *\n * @internal\n */\nfunction text(\n  node: FormKitNode,\n  _context: FormKitContext,\n  key: string | FormKitTextFragment,\n  type = 'ui'\n): string {\n  const fragment = typeof key === 'string' ? { key, value: key, type } : key\n  const value = node.hook.text.dispatch(fragment)\n  node.emit('text', value, false)\n  return value.value\n}\n\n/**\n * Submits the nearest ancestor that is a FormKit \"form\". It determines which\n * node is a form by locating an ancestor where node.props.isForm = true.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n *\n * @internal\n */\nfunction submit(node: FormKitNode): void {\n  const name = node.name\n  do {\n    if (node.props.isForm === true) break\n    if (!node.parent) error(106, name)\n    node = node.parent\n  } while (node)\n  if (node.props.id) {\n    submitForm(node.props.id, node.props.__root)\n  }\n}\n\n/**\n * Reset to the original value.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param _context - A {@link FormKitContext | FormKitContext}\n * @param value - The value to reset to\n *\n * @internal\n */\nfunction resetValue(\n  node: FormKitNode,\n  _context: FormKitContext,\n  value?: unknown\n) {\n  return reset(node, value)\n}\n\n/**\n * Sets errors on the node and optionally its children.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param _context - A {@link FormKitContext | FormKitContext}\n * @param localErrors - An array of {@link ErrorMessages | ErrorMessages} to set on this node\n * @param childErrors - An object of name of {@link ErrorMessages | ErrorMessages} to set on children.\n *\n * @internal\n */\nfunction setErrors(\n  node: FormKitNode,\n  _context: FormKitContext,\n  localErrors: ErrorMessages,\n  childErrors?: ErrorMessages\n) {\n  const sourceKey = `${node.name}-set`\n  const errors = node.hook.setErrors.dispatch({ localErrors, childErrors })\n  createMessages(node, errors.localErrors, errors.childErrors).forEach(\n    (errors) => {\n      node.store.apply(errors, (message) => message.meta.source === sourceKey)\n    }\n  )\n  return node\n}\n\n/**\n * Clears errors on the node and optionally its children.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param _context - A {@link FormKitContext | FormKitContext}\n * @param clearChildErrors - A boolean to clear children error or not.\n * @param sourceKey - The source key string to reset.\n *\n * @internal\n */\nfunction clearErrors(\n  node: FormKitNode,\n  _context: FormKitContext,\n  clearChildErrors = true,\n  sourceKey?: string\n) {\n  // Clear all local errors:\n  node.store.filter((m) => {\n    return !(sourceKey === undefined || m.meta.source === sourceKey)\n  }, 'error')\n  if (clearChildErrors) {\n    sourceKey = sourceKey || `${node.name}-set`\n    node.walk((child) => {\n      child.store.filter((message) => {\n        return !(\n          message.type === 'error' &&\n          message.meta &&\n          message.meta.source === sourceKey\n        )\n      })\n    })\n  }\n  return node\n}\n\n/**\n * Create props based on initial values\n *\n * @param initial - An initial value to be transformed\n *\n * @internal\n */\nfunction createProps(initial: unknown) {\n  const props: Record<PropertyKey, any> = {\n    initial: typeof initial === 'object' ? cloneAny(initial) : initial,\n  }\n  let node: FormKitNode\n  let isEmitting = true\n  let propDefs: Record<PropertyKey, FormKitPseudoProp> = {}\n  return new Proxy(props, {\n    get(...args) {\n      const [_t, prop] = args\n      let val\n      if (has(props, prop)) {\n        val = Reflect.get(...args)\n        if (propDefs[prop]?.boolean) val = boolGetter(val)\n      } else if (\n        node &&\n        typeof prop === 'string' &&\n        node.config[prop] !== undefined\n      ) {\n        val = node.config[prop]\n        // If we are getting the merge strategy for an input, only retrieve this\n        // actual node’s merge strategy.\n        if (\n          prop === 'mergeStrategy' &&\n          node?.type === 'input' &&\n          isRecord(val) &&\n          node.name in val\n        ) {\n          val = val[node.name]\n        }\n      } else {\n        // default or undefined\n        val = propDefs[prop]?.default\n      }\n      const getter = propDefs[prop]?.getter\n      if (propDefs[prop]?.boolean) val = !!val\n      return getter ? getter(val, node) : val\n    },\n    set(target, property, originalValue, receiver) {\n      if (property === '_n') {\n        node = originalValue\n        return true\n      }\n      if (property === '_emit') {\n        isEmitting = originalValue\n        return true\n      }\n      // eslint-disable-next-line prefer-const\n      let { prop, value } = node.hook.prop.dispatch({\n        prop: property,\n        value: originalValue,\n      })\n      const setter = propDefs[prop]?.setter\n      value = setter ? setter(value, node) : value\n      // Typescript compiler cannot handle a symbol index, even though js can:\n      if (\n        !eq(props[prop as string], value, false) ||\n        typeof value === 'object'\n      ) {\n        const didSet = Reflect.set(target, prop, value, receiver)\n        if (prop === '__propDefs') propDefs = toPropsObj(value)\n        if (isEmitting) {\n          node.emit('prop', { prop, value })\n          if (typeof prop === 'string') node.emit(`prop:${prop}`, value)\n        }\n        return didSet\n      }\n      return true\n    },\n  })\n}\n\n/**\n * Applies a new trap to the FormKitNode allowing plugins to extend the\n * base functionality of a FormKitNode.\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n * @param property - A string of the property name\n * @param trap - A {@link FormKitTrap | FormKitTrap}\n * @returns\n */\nfunction extend(\n  node: FormKitNode,\n  context: FormKitContext,\n  property: string,\n  trap: FormKitTrap\n) {\n  context.traps.set(property, trap)\n  return node\n}\n\n/**\n * A cheap function that iterates over all plugins and stops once node.define\n * is called.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param plugins - An array of {@link FormKitPlugin | FormKitPlugin}\n *\n * @internal\n */\nfunction findDefinition(node: FormKitNode, plugins: Set<FormKitPlugin>): void {\n  // If the definition is already there, force call to define.\n  if (node.props.definition) return node.define(node.props.definition)\n  for (const plugin of plugins) {\n    if (node.props.definition) return\n    if (typeof plugin.library === 'function') {\n      plugin.library(node)\n    }\n  }\n}\n\n/**\n * Create a new context object for our a FormKit node, given default information\n *\n * @param options - An options object of {@link FormKitOptions | FormKitOptions} to override the defaults.\n *\n * @returns A {@link FormKitContext | FormKitContext}\n *\n * @internal\n */\nfunction createContext(options: FormKitOptions): FormKitContext {\n  const value = createValue(options)\n  const config = createConfig(options.config || {}, options.parent)\n  return {\n    _d: 0,\n    _e: createEmitter(),\n    uid: Symbol(),\n    _resolve: false,\n    _tmo: false,\n    _value: value,\n    children: dedupe(options.children || []),\n    config,\n    hook: createHooks(),\n    isCreated: false,\n    isSettled: true,\n    ledger: createLedger(),\n    name: createName(options),\n    parent: options.parent || null,\n    plugins: new Set<FormKitPlugin>(),\n    props: createProps(value),\n    settled: Promise.resolve(value),\n    store: createStore(true),\n    sync: options.sync || false,\n    traps: createTraps(),\n    type: options.type || 'input',\n    value,\n  }\n}\n\n/**\n * Initialize a node object's internal properties.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param options - An options object of {@link FormKitOptions | FormKitOptions} to override the defaults.\n *\n * @returns A {@link FormKitNode | FormKitNode}\n *\n * @internal\n */\nfunction nodeInit<V>(\n  node: FormKitNode,\n  options: FormKitOptions\n): FormKitNode<V> {\n  const hasInitialId = options.props?.id\n  if (!hasInitialId) delete options.props?.id\n  // Set the internal node on the props, config, ledger and store\n  node.ledger.init((node.store._n = node.props._n = node.config._n = node))\n  // Apply given in options to the node.\n  node.props._emit = false\n  // Sets the initial props and initial ID if not provided.\n  Object.assign(\n    node.props,\n    hasInitialId ? {} : { id: `input_${idCount++}` },\n    options.props ?? {}\n  )\n  node.props._emit = true\n  // Attempt to find a definition from the pre-existing plugins.\n  findDefinition(\n    node,\n    new Set([\n      ...(options.plugins || []),\n      ...(node.parent ? node.parent.plugins : []),\n    ])\n  )\n  // Then we apply each plugin's root code, we do this with an explicit loop\n  // for that ity-bitty performance bump.\n  if (options.plugins) {\n    for (const plugin of options.plugins) {\n      use(node, node._c, plugin, true, false)\n    }\n  }\n  // Apply the parent to each child.\n  node.each((child) => node.add(child))\n  // If the node has a parent, ensure it's properly nested bi-directionally.\n  if (node.parent) node.parent.add(node, options.index)\n  // Inputs are leafs, and cannot have children\n  if (node.type === 'input' && node.children.length) error(100, node)\n  // Apply the input hook to the initial value.\n  input(node, node._c, node._value, false)\n  // Release the store buffer\n  node.store.release()\n  // Register the node globally if someone explicitly gave it an id\n  if (hasInitialId) register(node)\n  // Our node is finally ready, emit it to the world\n  node.emit('created', node)\n  node.isCreated = true\n  return node as FormKitNode<V>\n}\n\n/**\n * Creates a placeholder node that can be used to hold a place in a the children\n * array until the actual node is created.\n * @param options - FormKitOptions\n * @internal\n */\nexport function createPlaceholder(\n  options?: FormKitOptions & { name?: string }\n): FormKitPlaceholderNode {\n  return {\n    __FKP: true,\n    uid: Symbol(),\n    name: options?.name ?? `p_${nameCount++}`,\n    value: options?.value ?? null,\n    _value: options?.value ?? null,\n    type: options?.type ?? 'input',\n    props: {},\n    use: () => {\n      // noop\n    },\n    input(value: unknown) {\n      this._value = value\n      this.value = value\n      return Promise.resolve()\n    },\n    isSettled: true,\n  }\n}\n\n/**\n * Determines if a node is a placeholder node.\n * @param node - A {@link FormKitNode | FormKitNode}\n * @returns\n * @public\n */\nexport function isPlaceholder(\n  node: FormKitNode | FormKitPlaceholderNode\n): node is FormKitPlaceholderNode {\n  return '__FKP' in node\n}\n\n/**\n * Creates a new instance of a FormKit Node. Nodes are the atomic unit of a FormKit graph.\n *\n * @example\n *\n * ```javascript\n * import { createNode } from '@formkit/core'\n *\n * const input = createNode({\n *   type: 'input', // defaults to 'input' if not specified\n *   value: 'hello node world',\n * })\n *\n * console.log(input.value)\n * // 'hello node world'\n * ```\n *\n * @param options - An options object of {@link FormKitOptions | FormKitOptions} to override the defaults.\n *\n * @returns A {@link @formkit/core#FormKitNode | FormKitNode}.\n *\n * @public\n */\nexport function createNode<V = unknown>(\n  options?: FormKitOptions\n): FormKitNode<V> {\n  const ops = options || {}\n  const context = createContext(ops) as FormKitContext\n  // Note: The typing for the proxy object cannot be fully modeled, thus we are\n  // force-typing to a FormKitNode. See:\n  // https://github.com/microsoft/TypeScript/issues/28067\n  const node = new Proxy(context, {\n    get(...args) {\n      const [, property] = args\n      if (property === '__FKNode__') return true\n      const trap = context.traps.get(property)\n      if (trap && trap.get) return trap.get(node, context)\n      return Reflect.get(...args)\n    },\n    set(...args) {\n      const [, property, value] = args\n      const trap = context.traps.get(property)\n      if (trap && trap.set) return trap.set(node, context, property, value)\n      return Reflect.set(...args)\n    },\n  }) as unknown as FormKitNode\n\n  return nodeInit(node, ops)\n}\n","import { token } from '@formkit/utils'\nimport { FormKitContext, FormKitNode, isNode } from './node'\n\n/**\n * Event listener functions definition.\n *\n * @public\n */\nexport interface FormKitEventListener {\n  (event: FormKitEvent): void\n  receipt?: string\n}\n\n/**\n * The internal structure of a FormKitEvent.\n *\n * @public\n */\nexport interface FormKitEvent {\n  payload: any\n  name: string\n  bubble: boolean\n  origin: FormKitNode\n  meta?: Record<string, unknown>\n}\n\n/**\n * Event listeners are wrapped in this object before being stored.\n *\n * @internal\n */\nexport interface FormKitEventListenerWrapper {\n  event: string\n  listener: FormKitEventListener\n  modifiers: string[]\n  receipt: string\n}\n\n/**\n * The FormKitEventEmitter definition.\n *\n * @public\n */\nexport interface FormKitEventEmitter {\n  (node: FormKitNode, event: FormKitEvent): void\n  on: (\n    eventName: string,\n    listener: FormKitEventListener,\n    pos?: 'push' | 'unshift'\n  ) => string\n  off: (receipt: string) => void\n  pause: (node?: FormKitNode) => void\n  play: (node?: FormKitNode) => void\n  flush: () => void\n}\n\n/**\n * Creates a new event emitter, each node uses one of these to allow it to emit\n * events to local listeners and tree listeners.\n *\n * @returns FormKitEventEmitter\n *\n * @internal\n */\nexport function createEmitter(): FormKitEventEmitter {\n  const listeners = new Map<string, FormKitEventListenerWrapper[]>()\n  const receipts = new Map<string, string[]>()\n  let buffer: undefined | Map<string, [FormKitNode, FormKitEvent]> = undefined\n\n  const emitter = (node: FormKitNode, event: FormKitEvent) => {\n    if (buffer) {\n      buffer.set(event.name, [node, event])\n      return\n    }\n    if (listeners.has(event.name)) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      listeners.get(event.name)!.forEach((wrapper) => {\n        if (event.origin === node || wrapper.modifiers.includes('deep')) {\n          wrapper.listener(event)\n        }\n      })\n    }\n    if (event.bubble) {\n      node.bubble(event)\n    }\n  }\n\n  /**\n   * Completely remove all listeners and receipts and buffers from the emitter.\n   */\n  emitter.flush = () => {\n    listeners.clear()\n    receipts.clear()\n    buffer?.clear()\n  }\n\n  /**\n   * Add an event listener\n   *\n   * @param eventName - The name of the event to listen to\n   * @param listener - The callback\n   * @param pos - The position to add the listener in, can be either 'push' or 'unshift'\n   *\n   * @returns string\n   *\n   * @internal\n   */\n  emitter.on = (\n    eventName: string,\n    listener: FormKitEventListener,\n    pos: 'push' | 'unshift' = 'push'\n  ) => {\n    if (false && pos !== 'push' && pos !== 'unshift') {\n      throw new Error('Event listeners can only be added to the top or bottom')\n    }\n    const [event, ...modifiers] = eventName.split('.')\n    const receipt = listener.receipt || token()\n    const wrapper: FormKitEventListenerWrapper = {\n      modifiers,\n      event,\n      listener,\n      receipt,\n    }\n    /* eslint-disable @typescript-eslint/no-non-null-assertion */\n    listeners.has(event)\n      ? listeners.get(event)![pos](wrapper)\n      : listeners.set(event, [wrapper])\n    receipts.has(receipt)\n      ? receipts.get(receipt)![pos](event)\n      : receipts.set(receipt, [event])\n    /* eslint-enable @typescript-eslint/no-non-null-assertion */\n    return receipt\n  }\n\n  /**\n   * Remove an event listener\n   *\n   * @param listenerOrReceipt - Either a receipt or the callback function.\n   *\n   * @internal\n   */\n  emitter.off = (receipt: string) => {\n    if (receipts.has(receipt)) {\n      receipts.get(receipt)?.forEach((event) => {\n        const eventListeners = listeners.get(event)\n        if (Array.isArray(eventListeners)) {\n          listeners.set(\n            event,\n            eventListeners.filter((wrapper) => wrapper.receipt !== receipt)\n          )\n        }\n      })\n      receipts.delete(receipt)\n    }\n  }\n\n  /**\n   * Pause emitting values. Any events emitted while paused will not be emitted\n   * but rather \"stored\" — and whichever events are emitted last will be output.\n   * For example:\n   * pause()\n   * emit('foo', 1)\n   * emit('foo', 2)\n   * emit('bar', 3)\n   * emit('bar', 4)\n   * play()\n   * // would result in\n   * emit('foo', 2)\n   * emit('bar', 4)\n   * Optionally pauses all children as well.\n   *\n   * @param node - A node to pause all children on.\n   *\n   * @internal\n   */\n  emitter.pause = (node?: FormKitNode) => {\n    if (!buffer) buffer = new Map()\n    if (node) {\n      node.walk((child) => child._e.pause())\n    }\n  }\n\n  /**\n   * Release the current event buffer.\n   *\n   * @param node - A node to unpause all children on.\n   *\n   * @internal\n   */\n  emitter.play = (node?: FormKitNode) => {\n    if (!buffer) return\n    const events = buffer\n    buffer = undefined\n    events.forEach(([node, event]) => emitter(node, event))\n    if (node) {\n      node.walk((child) => child._e.play())\n    }\n  }\n\n  return emitter\n}\n\n/**\n * Emit an event from this node.\n *\n * @param node - The node that is emitting\n * @param context - The context of that node\n * @param name - The name of the event\n * @param payload - The payload to emit\n *\n * @returns FormKitNode\n *\n * @internal\n */\nexport function emit(\n  node: FormKitNode,\n  context: FormKitContext,\n  name: string,\n  payload?: any, // eslint-disable-line @typescript-eslint/explicit-module-boundary-types,\n  bubble = true,\n  meta?: Record<string, unknown>\n): FormKitNode {\n  context._e(node, {\n    payload,\n    name,\n    bubble,\n    origin: node,\n    meta,\n  })\n  return node\n}\n\n/**\n * Send an event from the given node up it's ancestor tree.\n *\n * @param node -\n * @param _context -\n * @param event -\n *\n * @internal\n */\nexport function bubble(\n  node: FormKitNode,\n  _context: FormKitContext,\n  event: FormKitEvent\n): FormKitNode {\n  if (isNode(node.parent)) {\n    node.parent._e(node.parent, event)\n  }\n  return node\n}\n\n/**\n * Adds an event listener to the node for a specific event. The event name is a\n * simple string matching the name of the event to listen to. It can optionally\n * include modifiers like eventName.deep\n *\n * @param node -\n * @param context -\n * @param name -\n * @param listener -\n *\n * @returns FormKitNode\n *\n * @internal\n */\nexport function on(\n  _node: FormKitNode,\n  context: FormKitContext,\n  name: string,\n  listener: FormKitEventListener,\n  pos?: 'push' | 'unshift'\n): string {\n  return context._e.on(name, listener, pos)\n}\n\n/**\n * Removes an event listener from a node by the returned receipt from .on().\n *\n * @param node - The node to remote the listener from\n * @param context - The context to remove\n * @param receipt - The receipt returned by .on()\n *\n * @returns FormKitNode\n *\n * @internal\n */\nexport function off(\n  node: FormKitNode,\n  context: FormKitContext,\n  receipt: string\n): FormKitNode {\n  context._e.off(receipt)\n  return node\n}\n","import createDispatcher from './dispatcher'\n\n/**\n * Describes the data passing through the error and warning handlers.\n *\n * @public\n */\nexport interface FormKitHandlerPayload {\n  code: number\n  data: any\n  message?: string\n}\n\n/**\n * FormKit's global error handler.\n *\n * @public\n */\nexport const errorHandler = createDispatcher<FormKitHandlerPayload>()\nerrorHandler((error, next) => {\n  if (!error.message) error.message = String(`E${error.code}`)\n  return next(error)\n})\n\n/**\n * FormKit's global warning handler.\n *\n * @public\n */\nexport const warningHandler = createDispatcher<FormKitHandlerPayload>()\nwarningHandler((warning, next) => {\n  if (!warning.message) warning.message = String(`W${warning.code}`)\n  const result = next(warning)\n  if (console && typeof console.warn === 'function')\n    console.warn(result.message)\n  return result\n})\n\n/**\n * Globally emits a warning.\n *\n * @param code - The integer warning code.\n * @param data - Usually an object of information to include.\n *\n * @public\n */\nexport function warn(code: number, data: any = {}): void {\n  warningHandler.dispatch({ code, data })\n}\n\n/**\n * Emits an error. Generally should result in an exception.\n *\n * @param code - The integer error code.\n * @param data - Usually an object of information to include.\n *\n * @public\n */\nexport function error(code: number, data: any = {}): never {\n  throw Error(errorHandler.dispatch({ code, data }).message)\n}\n","import { FormKitNode, FormKitTextFragment } from './node'\nimport { error } from './errors'\nimport { has, token, slugify } from '@formkit/utils'\n\n/**\n * The structure of a core FormKitMessage. These messages are used to store\n * information about the state of a node.\n *\n * @public\n */\nexport interface FormKitMessageProps {\n  blocking: boolean\n  key: string\n  meta: FormKitMessageMeta\n  type: string\n  value?: string | number | boolean\n  visible: boolean\n}\n\n/**\n * A FormKit message is immutable, so all properties should be readonly.\n *\n * @public\n */\nexport type FormKitMessage = Readonly<FormKitMessageProps>\n\n/**\n * A registry of input messages that should be applied to children of the node\n * they are passed to — where the string key of the object is the address of\n * the node to apply the messages on and the value is the message itself.\n *\n * @public\n */\nexport interface FormKitInputMessages {\n  [address: string]: FormKitMessage[]\n}\n\n/**\n * Child messages that were not immediately applied due to the child not existing.\n *\n * @public\n */\nexport type ChildMessageBuffer = Map<\n  string,\n  Array<[FormKitMessage[], MessageClearer | undefined]>\n>\n\n/**\n * A string or function that allows clearing messages.\n *\n * @public\n */\nexport type MessageClearer = string | ((message: FormKitMessage) => boolean)\n\n/**\n * Messages have can have any arbitrary meta data attached to them.\n *\n * @public\n */\nexport interface FormKitMessageMeta {\n  [index: string]: any\n  /**\n   * If this property is set, then message producers (like formkit/i18n) should\n   * use this key instead of the message key as the lookup for the proper\n   * message to produce.\n   */\n  messageKey?: string\n  /**\n   * If this property is set on a message then only the values in this property\n   * will be passed as arguments to an i18n message localization function.\n   */\n  i18nArgs?: any[]\n}\n\n/**\n * Defines the actual store of messages.\n *\n * @public\n */\nexport interface FormKitMessageStore {\n  [index: string]: FormKitMessage\n}\n\n/**\n * The message store contains all of the messages that pertain to a given node.\n *\n * @public\n */\nexport type FormKitStore = FormKitMessageStore & {\n  // owner node\n  _n: FormKitNode\n  // buffer array\n  _b: Array<[messages: FormKitMessage[], clear?: MessageClearer]>\n  // missed assignments map\n  _m: ChildMessageBuffer\n  // missed message listener store\n  _r?: string\n  // message buffer\n  buffer: boolean\n} & FormKitStoreTraps\n\n/**\n * The available traps on the FormKit store.\n *\n * @public\n */\nexport interface FormKitStoreTraps {\n  apply: (\n    messages: Array<FormKitMessage> | FormKitInputMessages,\n    clear?: MessageClearer\n  ) => void\n  set: (message: FormKitMessageProps) => FormKitStore\n  remove: (key: string) => FormKitStore\n  filter: (\n    callback: (message: FormKitMessage) => boolean,\n    type?: string\n  ) => FormKitStore\n  reduce: <T>(\n    reducer: (accumulator: T, message: FormKitMessage) => T,\n    accumulator: T\n  ) => T\n  release: () => void\n  touch: () => void\n}\n\n/**\n * Creates a new FormKitMessage object.\n *\n * ```ts\n * // default:\n * {\n *   blocking: false,\n *   key: token(),\n *   meta: {},\n *   type: 'state',\n *   visible: true,\n * }\n * ```\n *\n * @param conf - An object of optional properties of {@link FormKitMessage | FormKitMessage}.\n * @param node - A {@link @formkit/node#FormKitNode | FormKitNode}.\n * @returns A {@link FormKitMessageProps | FormKitMessageProps}.\n *\n * @public\n */\nexport function /* #__PURE__ */ createMessage(\n  conf: Partial<FormKitMessage>,\n  node?: FormKitNode\n): FormKitMessageProps {\n  const m = {\n    blocking: false,\n    key: token(),\n    meta: {} as FormKitMessageMeta,\n    type: 'state',\n    visible: true,\n    ...conf,\n  }\n  if (node && m.value && m.meta.localize !== false) {\n    m.value = node.t(m as FormKitTextFragment)\n    m.meta.locale = node.config.locale\n  }\n  return m\n}\n\n/**\n * The available traps on the node's store.\n *\n * @internal\n */\nconst storeTraps: {\n  [k in keyof FormKitStoreTraps]: (...args: any[]) => unknown\n} = {\n  apply: applyMessages,\n  set: setMessage,\n  remove: removeMessage,\n  filter: filterMessages,\n  reduce: reduceMessages,\n  release: releaseBuffer,\n  touch: touchMessages,\n}\n\n/**\n * Creates a new FormKit message store.\n *\n * @internal\n */\nexport function createStore(_buffer = false): FormKitStore {\n  const messages: FormKitMessageStore = {}\n  let node: FormKitNode\n  let buffer = _buffer\n  let _b = [] as Array<[messages: FormKitMessage[], clear?: MessageClearer]>\n  const _m = new Map()\n  let _r: string | undefined = undefined\n  const store = new Proxy(messages, {\n    get(...args) {\n      const [_target, property] = args\n      if (property === 'buffer') return buffer\n      if (property === '_b') return _b\n      if (property === '_m') return _m\n      if (property === '_r') return _r\n      if (has(storeTraps, property)) {\n        return storeTraps[property as keyof FormKitStoreTraps].bind(\n          null,\n          messages,\n          store,\n          node\n        )\n      }\n      return Reflect.get(...args)\n    },\n    set(_t, prop, value) {\n      if (prop === '_n') {\n        node = value\n        if (_r === '__n') releaseMissed(node, store)\n        return true\n      } else if (prop === '_b') {\n        _b = value\n        return true\n      } else if (prop === 'buffer') {\n        buffer = value\n        return true\n      } else if (prop === '_r') {\n        _r = value\n        return true\n      }\n      error(101, node)\n      return false\n    },\n  }) as FormKitStore\n  return store\n}\n\n/**\n * Adds a new value to a FormKit message bag.\n *\n * @param messageStore - The message store itself\n * @param store - The store interface\n * @param node - The node this store belongs to\n * @param message - The message object\n *\n * @internal\n */\nfunction setMessage(\n  messageStore: FormKitMessageStore,\n  store: FormKitStore,\n  node: FormKitNode,\n  message: FormKitMessageProps\n): FormKitStore {\n  if (store.buffer) {\n    store._b.push([[message]])\n    return store\n  }\n  if (messageStore[message.key] !== message) {\n    if (typeof message.value === 'string' && message.meta.localize !== false) {\n      // Expose the value to translation\n      const previous = message.value\n      message.value = node.t(message as FormKitTextFragment)\n      if (message.value !== previous) {\n        message.meta.locale = node.props.locale\n      }\n    }\n    const e = `message-${has(messageStore, message.key) ? 'updated' : 'added'}`\n    messageStore[message.key] = Object.freeze(\n      node.hook.message.dispatch(message)\n    )\n    node.emit(e, message)\n  }\n  return store\n}\n\n/**\n * Run through each message in the store, and ensure it has been translated\n * to the proper language. This most frequently happens after a locale change.\n *\n * @internal\n */\nfunction touchMessages(\n  messageStore: FormKitMessageStore,\n  store: FormKitStore\n): void {\n  for (const key in messageStore) {\n    const message = { ...messageStore[key] }\n    store.set(message)\n  }\n}\n\n/**\n * Remove a message from the store.\n *\n * @param messageStore - The message store\n * @param store - The store interface\n * @param node - The node this store belongs to\n * @param key - The message key\n *\n * @returns FormKitStore\n *\n * @internal\n */\nfunction removeMessage(\n  messageStore: FormKitMessageStore,\n  store: FormKitStore,\n  node: FormKitNode,\n  key: string\n): FormKitStore {\n  if (has(messageStore, key)) {\n    const message = messageStore[key]\n    delete messageStore[key]\n    node.emit('message-removed', message)\n  }\n  if (store.buffer === true) {\n    store._b = store._b.filter((buffered) => {\n      buffered[0] = buffered[0].filter((m) => m.key !== key)\n      return buffered[1] || buffered[0].length\n    })\n  }\n  return store\n}\n\n/**\n * Iterates over all messages removing those that are no longer wanted.\n *\n * @param messageStore - The store itself\n * @param store - The store interface\n * @param node - The node to filter for\n * @param callback - A callback accepting a message and returning a boolean\n * @param type - Pre filtered by a given message type\n *\n * @internal\n */\nfunction filterMessages(\n  messageStore: FormKitMessageStore,\n  store: FormKitStore,\n  node: FormKitNode,\n  callback: (message: FormKitMessage) => boolean,\n  type: false | string\n) {\n  for (const key in messageStore) {\n    const message = messageStore[key]\n    if ((!type || message.type === type) && !callback(message)) {\n      removeMessage(messageStore, store, node, key)\n    }\n  }\n}\n\n/**\n * Reduce the message store to some other generic value.\n *\n * @param messageStore - The store itself\n * @param _store - Unused but curried — the store interface itself\n * @param _node - The node owner of this store\n * @param reducer - The callback that performs the reduction\n * @param accumulator - The initial value\n *\n * @returns\n *\n * @internal\n */\nfunction reduceMessages<T>(\n  messageStore: FormKitMessageStore,\n  _store: FormKitStore,\n  _node: FormKitNode,\n  reducer: (value: T, message: FormKitMessage) => T,\n  accumulator: T\n) {\n  for (const key in messageStore) {\n    const message = messageStore[key]\n    accumulator = reducer(accumulator, message)\n  }\n  return accumulator\n}\n\n/**\n * @param messageStore - The store itself\n * @param _store - Unused but curried — the store interface itself\n * @param node - The node owner of this store\n * @param messages - An array of FormKitMessages to apply to this input, or an object of messages to apply to children.\n *\n * @internal\n */\nexport function applyMessages(\n  _messageStore: FormKitMessageStore,\n  store: FormKitStore,\n  node: FormKitNode,\n  messages: Array<FormKitMessage> | FormKitInputMessages,\n  clear?: MessageClearer\n): void {\n  if (Array.isArray(messages)) {\n    if (store.buffer) {\n      store._b.push([messages, clear])\n      return\n    }\n    // In this case we are applying messages to this node’s store.\n    const applied = new Set(\n      messages.map((message) => {\n        store.set(message)\n        return message.key\n      })\n    )\n    // Remove any messages that were not part of the initial apply:\n    if (typeof clear === 'string') {\n      store.filter(\n        (message) => message.type !== clear || applied.has(message.key)\n      )\n    } else if (typeof clear === 'function') {\n      store.filter((message) => !clear(message) || applied.has(message.key))\n    }\n  } else {\n    for (const address in messages) {\n      const child = node.at(address)\n      if (child) {\n        child.store.apply(messages[address], clear)\n      } else {\n        missed(node, store, address, messages[address], clear)\n      }\n    }\n  }\n}\n\n/**\n * Error messages.\n *\n * @public\n */\nexport type ErrorMessages =\n  | string\n  | string[]\n  | Record<string, string | string[]>\n\n/**\n * Creates an array of message arrays from strings.\n *\n * @param node - FormKitNode\n * @param errors - Arrays or objects of form errors or input errors\n *\n * @internal\n */\nexport function createMessages(\n  node: FormKitNode,\n  ...errors: Array<ErrorMessages | undefined>\n): Array<FormKitMessage[] | Record<string, FormKitMessage[]>> {\n  const sourceKey = `${node.name}-set`\n  const make = (error: string) =>\n    /* #__PURE__ */ createMessage({\n      key: slugify(error),\n      type: 'error',\n      value: error,\n      meta: { source: sourceKey, autoClear: true },\n    })\n  return errors\n    .filter((m) => !!m)\n    .map((errorSet): FormKitMessage[] | Record<string, FormKitMessage[]> => {\n      if (typeof errorSet === 'string') errorSet = [errorSet]\n      if (Array.isArray(errorSet)) {\n        return errorSet.map((error) => make(error))\n      } else {\n        const errors: Record<string, FormKitMessage[]> = {}\n        for (const key in errorSet) {\n          if (Array.isArray(errorSet[key])) {\n            errors[key] = (errorSet[key] as string[]).map((error) =>\n              make(error)\n            )\n          } else {\n            errors[key] = [make(errorSet[key] as string)]\n          }\n        }\n        return errors\n      }\n    })\n}\n\n/**\n * @param store - The store to apply this missed applications.\n * @param address - The address that was missed (a node path that didn't yet exist)\n * @param messages - The messages that should have been applied.\n * @param clear - The clearing function (if any)\n *\n * @internal\n */\nfunction missed(\n  node: FormKitNode,\n  store: FormKitStore,\n  address: string,\n  messages: FormKitMessage[],\n  clear?: MessageClearer\n) {\n  const misses = store._m\n  if (!misses.has(address)) misses.set(address, [])\n  // The created receipt\n  if (!store._r) store._r = releaseMissed(node, store)\n  misses.get(address)?.push([messages, clear])\n}\n\n/**\n * Releases messages that were applied to a child via parent, but the child did\n * not exist. Once the child does exist, the created event for that child will\n * bubble to this point, and any stored applications will be applied serially.\n *\n * @param store - The store object.\n *\n * @internal\n */\nfunction releaseMissed(node: FormKitNode, store: FormKitStore): string {\n  return node.on(\n    'child.deep',\n    ({ payload: child }: { payload: FormKitNode }) => {\n      store._m.forEach((misses, address) => {\n        if (node.at(address) === child) {\n          misses.forEach(([messages, clear]) => {\n            child.store.apply(messages, clear)\n          })\n          store._m.delete(address)\n        }\n      })\n      // If all the stored misses were applied, remove the listener.\n      if (store._m.size === 0 && store._r) {\n        node.off(store._r)\n        store._r = undefined\n      }\n    }\n  )\n}\n\n/**\n * Iterates over all buffered messages and applies them in sequence.\n *\n * @param messageStore - The store itself\n * @param store - The store interface\n * @param node - The node to filter for\n *\n * @internal\n */\nfunction releaseBuffer(\n  _messageStore: FormKitMessageStore,\n  store: FormKitStore\n) {\n  store.buffer = false\n  store._b.forEach(([messages, clear]) => store.apply(messages, clear))\n  store._b = []\n}\n","import { FormKitNode } from './node'\nimport { FormKitEvent } from './events'\nimport { FormKitMessage } from './store'\nimport { has } from '@formkit/utils'\n\n/**\n * The FormKit ledger, a general-purpose message counting service provided by\n * FormKit core for counting messages throughout a tree.\n *\n * @public\n */\nexport interface FormKitLedger {\n  count: (\n    name: string,\n    condition?: FormKitCounterCondition,\n    increment?: number\n  ) => Promise<void>\n  init: (node: FormKitNode) => void\n  merge: (child: FormKitNode) => void\n  settled: (name: string) => Promise<void>\n  unmerge: (child: FormKitNode) => void\n  value: (name: string) => number\n}\n\n/**\n * Ledger counters require a condition function that determines if a given\n * message applies to it or not.\n *\n * @public\n */\nexport interface FormKitCounterCondition {\n  (message: FormKitMessage): boolean\n}\n\n/**\n * The counter object used to perform instance counting within\n * a tree.\n *\n * @public\n */\nexport interface FormKitCounter {\n  condition: FormKitCounterCondition\n  count: number\n  name: string\n  node: FormKitNode\n  promise: Promise<void>\n  resolve: () => void\n}\n\n/**\n * The internal ledger store structure.\n *\n * @internal\n */\ninterface FormKitLedgerStore {\n  [index: string]: FormKitCounter\n}\n\n/**\n * Creates a new ledger for use on a single node's context.\n *\n * @internal\n */\nexport function createLedger(): FormKitLedger {\n  const ledger: FormKitLedgerStore = {}\n  let n: FormKitNode\n  return {\n    count: (...args) => createCounter(n, ledger, ...args),\n    init(node: FormKitNode) {\n      n = node\n      node.on('message-added.deep', add(ledger, 1))\n      node.on('message-removed.deep', add(ledger, -1))\n    },\n    merge: (child) => merge(n, ledger, child),\n    settled(counterName: string): Promise<void> {\n      return has(ledger, counterName)\n        ? ledger[counterName].promise\n        : Promise.resolve()\n    },\n    unmerge: (child) => merge(n, ledger, child, true),\n    value(counterName: string) {\n      return has(ledger, counterName) ? ledger[counterName].count : 0\n    },\n  }\n}\n\n/**\n * Creates a new counter object in the counting ledger.\n *\n * @param node - FormKitNode\n * @param ledger - The actual ledger storage object\n * @param counterName - The name of the counter, can be arbitrary\n * @param condition - The condition function (or string) that filters messages\n * @param increment - The increment value\n *\n * @internal\n */\nfunction createCounter(\n  node: FormKitNode,\n  ledger: FormKitLedgerStore,\n  counterName: string,\n  condition?: FormKitCounterCondition | string,\n  increment = 0\n): Promise<void> {\n  condition = parseCondition(condition || counterName)\n  if (!has(ledger, counterName)) {\n    const counter: FormKitCounter = {\n      condition,\n      count: 0,\n      name: counterName,\n      node,\n      promise: Promise.resolve(),\n      resolve: () => {}, // eslint-disable-line @typescript-eslint/no-empty-function\n    }\n    ledger[counterName] = counter\n    increment = node.store.reduce(\n      (sum, m) => sum + (counter.condition(m) as unknown as number) * 1,\n      increment\n    )\n    node.each((child) => {\n      child.ledger.count(counter.name, counter.condition)\n      increment += child.ledger.value(counter.name)\n    })\n  }\n  return count(ledger[counterName], increment).promise\n}\n\n/**\n * We parse the condition to allow flexibility in how counters are specified.\n *\n * @param condition - The condition that, if true, allows a message to change a counter's value\n *\n * @internal\n */\nfunction parseCondition(\n  condition: string | FormKitCounterCondition\n): FormKitCounterCondition {\n  if (typeof condition === 'function') {\n    return condition\n  }\n  return (m: FormKitMessage) => m.type === condition\n}\n\n/**\n * Perform a counting action on the a given counter object of the ledger.\n *\n * @param counter - A counter object\n * @param increment - The amount by which we are changing the count value\n *\n * @internal\n */\nfunction count(counter: FormKitCounter, increment: number): FormKitCounter {\n  const initial = counter.count\n  const post = counter.count + increment\n  counter.count = post\n  if (initial === 0 && post !== 0) {\n    counter.node.emit(`unsettled:${counter.name}`, counter.count, false)\n    counter.promise = new Promise((r) => (counter.resolve = r))\n  } else if (initial !== 0 && post === 0) {\n    counter.node.emit(`settled:${counter.name}`, counter.count, false)\n    counter.resolve()\n  }\n  counter.node.emit(`count:${counter.name}`, counter.count, false)\n  return counter\n}\n\n/**\n * Returns a function to be used as an event listener for message events.\n *\n * @param ledger - A ledger to operate on\n * @param delta - The amount to add or subtract\n *\n * @internal\n */\nfunction add(ledger: FormKitLedgerStore, delta: number) {\n  return (e: FormKitEvent) => {\n    for (const name in ledger) {\n      const counter = ledger[name]\n      if (counter.condition(e.payload)) {\n        count(counter, delta)\n      }\n    }\n  }\n}\n\n/**\n * Given a child node, add the parent node's counters to the child and then\n * rectify the upstream ledger counts. Generally used when attaching a child\n * to an already counted tree.\n *\n * @param parent - The parent that is \"receiving\" the child\n * @param ledger - The ledger object\n * @param child - The child (can be a subtree) that is being attached\n * @param remove - If the merge is removing instead of adding\n *\n * @internal\n */\nfunction merge(\n  parent: FormKitNode | null,\n  ledger: FormKitLedgerStore,\n  child: FormKitNode,\n  remove = false\n) {\n  const originalParent = parent\n  for (const key in ledger) {\n    const condition = ledger[key].condition\n    if (!remove) child.ledger.count(key, condition)\n    const increment = child.ledger.value(key) * (remove ? -1 : 1)\n    if (!parent) continue\n    do {\n      parent.ledger.count(key, condition, increment)\n      parent = parent.parent\n    } while (parent)\n    parent = originalParent\n  }\n}\n","import { FormKitNode } from './node'\nimport { createEmitter, FormKitEventListener } from './events'\n\n/**\n * A global registry of nodes by their alias or name (if root).\n */\nconst registry: Map<string, FormKitNode> = new Map()\nconst reflected: Map<FormKitNode, string> = new Map()\n\n/**\n * An event emitter for registered/set/unset nodes\n */\nconst emit = createEmitter()\n/**\n * Receipts of listeners.\n */\nconst receipts: string[] = []\n\n/**\n * Registers a node to the registry _if_ the node is a root node, _or_ if the\n * node has an explicit node.props.alias. If these two things are not true,\n * then no node is registered (idempotent).\n *\n * @param node - A {@link FormKitNode | FormKitNode}.\n *\n * @public\n */\nexport function register(node: FormKitNode): void {\n  if (node.props.id) {\n    registry.set(node.props.id, node)\n    reflected.set(node, node.props.id)\n    emit(node, {\n      payload: node,\n      name: node.props.id,\n      bubble: false,\n      origin: node,\n    })\n  }\n}\n\n/**\n * Deregister a node from the registry.\n *\n * @param node - A {@link FormKitNode | FormKitNode}.\n *\n * @public\n */\nexport function deregister(node: FormKitNode): void {\n  if (reflected.has(node)) {\n    const id = reflected.get(node)! // eslint-disable-line @typescript-eslint/no-non-null-assertion\n    reflected.delete(node)\n    registry.delete(id)\n    emit(node, {\n      payload: null,\n      name: id,\n      bubble: false,\n      origin: node,\n    })\n  }\n}\n\n/**\n * Get a node by a particular id.\n *\n * @param id - Get a node by a given id.\n *\n * @returns A {@link FormKitNode | FormKitNode} or `undefined`.\n *\n * @public\n */\nexport function getNode<T = unknown>(id: string): FormKitNode<T> | undefined {\n  return registry.get(id) as FormKitNode<T> | undefined\n}\n\n/**\n * Resets the entire registry. Deregisters all nodes and removes all listeners.\n *\n * @public\n */\nexport function resetRegistry(): void {\n  registry.forEach((node) => {\n    deregister(node)\n  })\n  receipts.forEach((receipt) => emit.off(receipt))\n}\n\n/**\n * A way of watching changes in the global registry.\n *\n * @param id - A dot-syntax id where the node is located.\n * @param callback - A callback in the format of {@link FormKitEventListener | FormKitEventListener} to notify when the node is set or removed.\n *\n * @public\n */\nexport function watchRegistry(\n  id: string,\n  callback: FormKitEventListener\n): string {\n  // register a listener\n  const receipt = emit.on(id, callback)\n  receipts.push(receipt)\n  return receipt\n}\n\n/**\n * Stop watching the registry for a given receipt.\n * @param receipt - a receipt to stop watching\n */\nexport function stopWatch(receipt: string): void {\n  emit.off(receipt)\n}\n","import { FormKitConfig, FormKitNode } from './node'\n\n/**\n * Applies a given config change to the node.\n *\n * @param node - The node to check for config change\n * @param prop - Checks if this property exists in the local config or props\n * @param value - The value to set\n *\n * @internal\n */\nexport function configChange(\n  node: FormKitNode,\n  prop: string,\n  value: unknown\n): boolean {\n  // When we return false, node.walk will not continue into that child.\n  let usingFallback = true\n  !(prop in node.config._t)\n    ? node.emit(`config:${prop}`, value, false)\n    : (usingFallback = false)\n\n  if (!(prop in node.props)) {\n    node.emit('prop', { prop, value })\n    node.emit(`prop:${prop}`, value)\n  }\n  return usingFallback\n}\n\n/**\n * Global configuration options.\n *\n * @public\n */\nexport type FormKitRootConfig = Partial<FormKitConfig> & {\n  _add: (node: FormKitNode) => void\n  _rm: (node: FormKitNode) => void\n}\n\n/**\n * Creates a new instance of a global configuration option. This object is\n * essentially just a FormKitOption object, but it can be used as the root for\n * FormKitConfig's proxy and retain event \"emitting\".\n *\n * @param options - An object of optional properties of {@link FormKitConfig | FormKitConfig}.\n *\n * @returns A {@link FormKitRootConfig | FormKitRootConfig}.\n *\n * @public\n */\nexport function createConfig(\n  options: Partial<FormKitConfig> = {}\n): FormKitRootConfig {\n  const nodes = new Set<FormKitNode>()\n  const target = {\n    ...options,\n    ...{\n      _add: (node: FormKitNode) => nodes.add(node),\n      _rm: (node: FormKitNode) => nodes.delete(node),\n    },\n  }\n  const rootConfig = new Proxy(target, {\n    set(t, prop, value, r) {\n      if (typeof prop === 'string') {\n        nodes.forEach((node) => configChange(node, prop, value))\n      }\n      return Reflect.set(t, prop, value, r)\n    },\n  })\n  return rootConfig\n}\n","import { warn } from './errors'\n\n/**\n * Submits a FormKit form programmatically.\n *\n * @param id - The id of the form.\n *\n * @public\n */\nexport function submitForm(id: string, root?: ShadowRoot | Document): void {\n  const formElement = (root || document).getElementById(id)\n  if (formElement instanceof HTMLFormElement) {\n    const event = new Event('submit', { cancelable: true, bubbles: true })\n    formElement.dispatchEvent(event)\n    return\n  }\n  warn(151, id)\n}\n","import { cloneAny, init, isObject, empty } from '@formkit/utils'\nimport { FormKitNode } from './node'\nimport { warn } from './errors'\nimport { getNode } from './registry'\n\n/**\n * Clear all state and error messages.\n *\n * @internal\n */\nfunction clearState(node: FormKitNode) {\n  const clear = (n: FormKitNode) => {\n    for (const key in n.store) {\n      const message = n.store[key]\n      if (\n        message.type === 'error' ||\n        (message.type === 'ui' && key === 'incomplete')\n      ) {\n        n.store.remove(key)\n      } else if (message.type === 'state') {\n        n.store.set({ ...message, value: false })\n      }\n    }\n  }\n  clear(node)\n  node.walk(clear)\n}\n\n/**\n * Resets an input to its \"initial\" value. If the input is a group or list it\n * resets all the children as well.\n *\n * @param id - The id of an input to reset.\n * @param resetTo - A value to reset the node to.\n *\n * @returns A {@link FormKitNode | FormKitNode} or `undefined`.\n *\n * @public\n */\nexport function reset(\n  id: string | FormKitNode,\n  resetTo?: unknown\n): FormKitNode | undefined {\n  const node = typeof id === 'string' ? getNode(id) : id\n  if (node) {\n    const initial = (n: FormKitNode) =>\n      cloneAny(n.props.initial) ||\n      (n.type === 'group' ? {} : n.type === 'list' ? [] : undefined)\n\n    // pause all events in this tree.\n    node._e.pause(node)\n    // Set it back to basics\n    const resetValue = cloneAny(resetTo)\n    if (resetTo && !empty(resetTo)) {\n      node.props.initial = isObject(resetValue) ? init(resetValue) : resetValue\n      node.props._init = node.props.initial\n    }\n    node.input(initial(node), false)\n\n    // Set children back to basics in case they were additive (had their own value for example)\n    node.walk((child) => {\n      // Skip resetting synced lists to default.\n      if (child.type === 'list' && child.sync) return\n      child.input(initial(child), false)\n    })\n    // Finally we need to lay any values back on top (if it is a group/list) since group values\n    // take precedence over child values.\n    node.input(\n      empty(resetValue) && resetValue ? resetValue : initial(node),\n      false\n    )\n\n    // If this is a deep reset, we need to make sure the \"initial\" state of all\n    // children are also reset. Fixes https://github.com/formkit/formkit/issues/791#issuecomment-1651213253\n    const isDeepReset =\n      node.type !== 'input' && resetTo && !empty(resetTo) && isObject(resetTo)\n    if (isDeepReset) {\n      node.walk((child) => {\n        child.props.initial = isObject(child.value)\n          ? init(child.value)\n          : child.value\n        child.props._init = child.props.initial\n      })\n    }\n    // release the events.\n    node._e.play(node)\n    clearState(node)\n    node.emit('reset', node)\n    return node\n  }\n  warn(152, id)\n  return\n}\n","import { has } from '@formkit/utils'\n\n/**\n * The value being listed out. Can be an array, an object, or a number.\n *\n * @public\n */\nexport type FormKitListValue =\n  | string\n  | Record<string, any>\n  | Array<string | number | Record<string, any>>\n  | number\n\n/**\n * A full loop statement in tuple syntax. Can be read like \"foreach value, key? in list\".\n *\n * @public\n */\nexport type FormKitListStatement =\n  | [value: any, key: number | string, list: FormKitListValue]\n  | [value: any, list: FormKitListValue]\n\n/**\n * Meta attributes are not used when parsing the schema, but can be used to\n * create tooling.\n *\n * @public\n */\nexport type FormKitSchemaMeta = {\n  [key: string]:\n    | string\n    | number\n    | boolean\n    | undefined\n    | null\n    | CallableFunction\n    | FormKitSchemaMeta\n}\n\n/**\n * Properties available in all schema nodes.\n *\n * @public\n */\nexport interface FormKitSchemaProps {\n  children?: string | FormKitSchemaNode[] | FormKitSchemaCondition\n  key?: string\n  if?: string\n  for?: FormKitListStatement\n  bind?: string\n  meta?: FormKitSchemaMeta\n}\n\n/**\n * Properties available when using a DOM node.\n *\n * @public\n */\nexport type FormKitSchemaDOMNode = {\n  $el: string | null\n  attrs?: FormKitSchemaAttributes\n} & FormKitSchemaProps\n\n/**\n * A simple text node.\n *\n * @public\n */\nexport type FormKitSchemaTextNode = string\n\n/**\n * The possible value types of attributes (in the schema).\n *\n * @public\n */\nexport type FormKitAttributeValue =\n  | string\n  | number\n  | boolean\n  | undefined\n  | FormKitSchemaAttributes\n  | FormKitSchemaAttributesCondition\n\n/**\n * Conditions nested inside attribute declarations.\n *\n * @public\n */\nexport interface FormKitSchemaAttributesCondition {\n  if: string\n  then: FormKitAttributeValue\n  else?: FormKitAttributeValue\n}\n\n/**\n * DOM attributes are simple string dictionaries.\n *\n * @public\n */\nexport type FormKitSchemaAttributes =\n  | {\n      [index: string]: FormKitAttributeValue\n    }\n  | null\n  | FormKitSchemaAttributesCondition\n\n/**\n * Properties available when defining a generic non-FormKit component.\n *\n * @public\n */\nexport type FormKitSchemaComponent = {\n  $cmp: string\n  props?: Record<string, any>\n} & FormKitSchemaProps\n\n/**\n * Syntactic sugar for a FormKitSchemaComponent node that uses FormKit.\n *\n * @public\n */\nexport type FormKitSchemaFormKit = {\n  $formkit: string\n} & Record<string, any> &\n  FormKitSchemaProps\n\n/**\n * A schema node that determines _which_ content to render.\n *\n * @public\n */\nexport type FormKitSchemaCondition = {\n  if: string\n  then: FormKitSchemaNode | FormKitSchemaNode[]\n  else?: FormKitSchemaNode | FormKitSchemaNode[]\n}\n\n/**\n * The context that is passed from one schema render to the next.\n *\n * @public\n */\nexport interface FormKitSchemaContext {\n  [index: string]: any\n  __FK_SCP: Map<symbol, Record<string, any>>\n}\n\n/**\n * Properties available then defining a schema node.\n *\n * @public\n */\nexport type FormKitSchemaNode =\n  | FormKitSchemaDOMNode\n  | FormKitSchemaComponent\n  | FormKitSchemaTextNode\n  | FormKitSchemaCondition\n  | FormKitSchemaFormKit\n\n/**\n * An entire schema object or subtree from any entry point. Can be a single\n * node, an array of nodes, or a conditional. This is the type that is passed to\n * the FormKitSchema constructor.\n *\n * @public\n */\nexport type FormKitSchemaDefinition =\n  | FormKitSchemaNode\n  | FormKitSchemaNode[]\n  | FormKitSchemaCondition\n\n/**\n * Definition for a function that can extend a given schema node.\n *\n * @public\n */\nexport interface FormKitSchemaComposable {\n  (\n    extendWith?: Partial<FormKitSchemaNode>,\n    children?: string | FormKitSchemaNode[] | FormKitSchemaCondition,\n    ...args: any[]\n  ): FormKitSchemaNode\n}\n\n/**\n * The shape of the schema definition overrides/extensions.\n * @public\n */\nexport type FormKitSectionsSchema = Record<\n  string,\n  Partial<FormKitSchemaNode> | FormKitSchemaCondition | null\n>\n\n/**\n * Defines a function that allows selectively overriding a given schema.\n *\n * @public\n */\nexport interface FormKitExtendableSchemaRoot {\n  (extensions: FormKitSectionsSchema): FormKitSchemaDefinition\n  memoKey?: string\n}\n\n/**\n * Type narrow that a node is a DOM node.\n *\n * @param node - A schema node to check\n *\n * @returns `boolean`\n *\n * @public\n */\nexport function isDOM(\n  node: string | Record<PropertyKey, any>\n): node is FormKitSchemaDOMNode {\n  return typeof node !== 'string' && has(node, '$el')\n}\n\n/**\n * Type narrow that a node is a DOM node.\n *\n * @param node - A schema node to check.\n *\n * @returns `boolean`\n *\n * @public\n */\nexport function isComponent(\n  node: string | Record<PropertyKey, any>\n): node is FormKitSchemaComponent {\n  return typeof node !== 'string' && has(node, '$cmp')\n}\n\n/**\n * Determines if a node is conditionally rendered or not.\n *\n * @param node - A schema node to check.\n *\n * @returns `boolean`\n *\n * @public\n */\nexport function isConditional(\n  node: FormKitSchemaNode\n): node is FormKitSchemaCondition\n\n/**\n * Determines if an attribute is a conditional.\n *\n * @param node - A schema node to check.\n *\n * @returns `boolean`\n *\n * @public\n */\nexport function isConditional(\n  node: FormKitSchemaAttributesCondition | FormKitSchemaAttributes\n): node is FormKitSchemaAttributesCondition\n\n/**\n * Root declaration.\n *\n * @param node - An object to check.\n */\nexport function isConditional(\n  node:\n    | FormKitSchemaNode\n    | FormKitSchemaAttributesCondition\n    | FormKitSchemaAttributes\n): node is FormKitSchemaNode | FormKitSchemaAttributesCondition {\n  if (!node || typeof node === 'string') return false\n  return has(node, 'if') && has(node, 'then')\n}\n\n/**\n * Determines if the node is syntactic sugar or not.\n *\n * @param node - A schema node to check.\n *\n * @returns `boolean`\n *\n * @public\n */\nexport function isSugar(node: FormKitSchemaNode): node is FormKitSchemaFormKit {\n  return typeof node !== 'string' && '$formkit' in node\n}\n\n/**\n * Converts syntactic sugar nodes to standard nodes.\n *\n * @param node - A node to covert.\n *\n * @returns A {@link FormKitSchemaNode | FormKitSchemaNode} without the properties of {@link FormKitSchemaFormKit | FormKitSchemaFormKit}.\n *\n * @public\n */\nexport function sugar<T extends FormKitSchemaNode>(\n  node: T\n): Exclude<FormKitSchemaNode, string | FormKitSchemaFormKit> {\n  if (typeof node === 'string') {\n    return {\n      $el: 'text',\n      children: node,\n    }\n  }\n  if (isSugar(node)) {\n    const {\n      $formkit: type,\n      for: iterator,\n      if: condition,\n      children,\n      bind,\n      ...props\n    } = node as FormKitSchemaFormKit\n    return Object.assign(\n      {\n        $cmp: 'FormKit',\n        props: { ...props, type },\n      },\n      condition ? { if: condition } : {},\n      iterator ? { for: iterator } : {},\n      children ? { children } : {},\n      bind ? { bind } : {}\n    )\n  }\n  return node\n}\n","import { isQuotedString, rmEscapes, parseArgs, getAt } from '@formkit/utils'\nimport { warn, error } from './errors'\n\n/**\n * Tokens are strings that map to functions.\n *\n * @internal\n */\ninterface FormKitTokens {\n  [index: string]: (...args: any[]) => any\n}\n/**\n * The compiler output, a function that adds the required tokens.\n *\n * @public\n */\nexport interface FormKitCompilerOutput {\n  (tokens?: Record<string, any>): boolean | number | string\n  provide: FormKitCompilerProvider\n}\n\n/**\n * A function that accepts a callback with a token as the only argument, and\n * must return a function that provides the true value of the token.\n *\n * @public\n */\nexport type FormKitCompilerProvider = (\n  callback: (requirements: string[]) => Record<string, () => any>\n) => FormKitCompilerOutput\n\n/**\n * The operand is a value that can be used in a logical operation.\n *\n * @internal\n */\ntype Operand =\n  | string\n  | number\n  | boolean\n  | undefined\n  | ((...args: any[]) => boolean | number | string | CallableFunction)\n\n/**\n * Logical operations are always a left/right fn\n *\n * @internal\n */\ntype LogicOperator = (\n  l: any,\n  r: any,\n  t?: Record<string, any>,\n  tt?: any\n) => boolean | number | string\n\n/**\n * A set of logical operators used for parsing string logic.\n *\n * @internal\n */\ninterface LogicOperators {\n  [index: string]: LogicOperator\n}\n\n/**\n * Describes a registry of operators that occur at different periods during\n * the order of operations. Typically this is:\n * 0: Boolean\n * 1: Comparison\n * 2: Arithmetic\n *\n * @internal\n */\ntype OperatorRegistry = LogicOperators[]\n\n/**\n * Compiles a logical string like `\"a != z || b == c\"` into a single function.\n * The return value is an object with a \"provide\" method that iterates over all\n * requirement tokens to use as replacements.\n *\n * @example\n *\n * ```typescript\n * let name = {\n *   value: 'jon'\n * }\n * const condition = compile(\"$name == 'bob'\").provide((token) => {\n *  return () => name.value // must return a function!\n * })\n *\n * condition() // false\n * ```\n *\n * @param expr - A string to compile.\n *\n * @returns A {@link FormKitCompilerOutput | FormKitCompilerOutput}.\n *\n * @public\n */\nexport function compile(expr: string): FormKitCompilerOutput {\n  /**\n   * These tokens are replacements used in evaluating a given condition.\n   */\n  // const tokens: FormKitTokens = {}\n\n  /**\n   * The value of the provide() callback. Used for late binding.\n   */\n  let provideTokens: (requirements: string[]) => Record<string, () => any>\n\n  /**\n   * These are token requirements like \"$name.value\" that are need to fulfill\n   * a given condition call.\n   */\n  const requirements = new Set<string>()\n\n  /**\n   * Expands the current value if it is a function.\n   * @param operand - A left or right hand operand\n   * @returns\n   */\n  const x = function expand(operand: any, tokens?: Record<string, any>): any {\n    return typeof operand === 'function' ? operand(tokens) : operand\n  }\n\n  /**\n   * Comprehensive list of operators. This list MUST be\n   * ordered by the length of the operator characters in descending order.\n   */\n  const operatorRegistry: OperatorRegistry = [\n    {\n      '&&': (l, r, t) => x(l, t) && x(r, t),\n      '||': (l, r, t) => x(l, t) || x(r, t),\n    },\n    {\n      '===': (l, r, t) => !!(x(l, t) === x(r, t)),\n      '!==': (l, r, t) => !!(x(l, t) !== x(r, t)),\n      '==': (l, r, t) => !!(x(l, t) == x(r, t)),\n      '!=': (l, r, t) => !!(x(l, t) != x(r, t)),\n      '>=': (l, r, t) => !!(x(l, t) >= x(r, t)),\n      '<=': (l, r, t) => !!(x(l, t) <= x(r, t)),\n      '>': (l, r, t) => !!(x(l, t) > x(r, t)),\n      '<': (l, r, t) => !!(x(l, t) < x(r, t)),\n    },\n    {\n      '+': (l, r, t) => x(l, t) + x(r, t),\n      '-': (l, r, t) => x(l, t) - x(r, t),\n    },\n    {\n      '*': (l, r, t) => x(l, t) * x(r, t),\n      '/': (l, r, t) => x(l, t) / x(r, t),\n      '%': (l, r, t) => x(l, t) % x(r, t),\n    },\n  ]\n\n  /**\n   * A full list of all operator symbols.\n   */\n  const operatorSymbols = operatorRegistry.reduce((s, g) => {\n    return s.concat(Object.keys(g))\n  }, [] as string[])\n\n  /**\n   * An array of the first character of each operator.\n   */\n  const operatorChars = new Set(operatorSymbols.map((key) => key.charAt(0)))\n\n  /**\n   * Determines if the current character is the start of an operator symbol, if it\n   * is, it returns that symbol.\n   * @param symbols - An array of symbols that are considered operators\n   * @param char - The current character being operated on\n   * @param p - The position of the pointer\n   * @param expression - The full string expression\n   * @returns\n   */\n  function getOp(\n    symbols: string[],\n    char: string,\n    p: number,\n    expression: string\n  ): false | undefined | string {\n    const candidates = symbols.filter((s) => s.startsWith(char))\n    if (!candidates.length) return false\n    return candidates.find((symbol) => {\n      if (expression.length >= p + symbol.length) {\n        const nextChars = expression.substring(p, p + symbol.length)\n        if (nextChars === symbol) return symbol\n      }\n      return false\n    })\n  }\n\n  /**\n   * Determines the step number of the right or left hand operator.\n   * @param p - The position of the pointer\n   * @param expression - The full string expression\n   * @param direction - 1 = right, 0 = left\n   */\n  function getStep(p: number, expression: string, direction = 1): number {\n    let next = direction\n      ? expression.substring(p + 1).trim()\n      : expression.substring(0, p).trim()\n    if (!next.length) return -1\n    if (!direction) {\n      // left hand direction could include a function name we need to remove\n      const reversed = next.split('').reverse()\n      const start = reversed.findIndex((char) => operatorChars.has(char))\n      next = reversed.slice(start).join('')\n    }\n    const char = next[0]\n    return operatorRegistry.findIndex((operators) => {\n      const symbols = Object.keys(operators)\n      return !!getOp(symbols, char, 0, next)\n    })\n  }\n\n  /**\n   * Extracts a tail call. For example:\n   * ```\n   * $foo().bar(baz) + 7\n   * ```\n   * Would extract \"bar(baz)\" and return p of 15 (after the (baz)).\n   *\n   * @param p - The position of a closing parenthetical.\n   * @param expression - The full expression being parsed.\n   */\n  function getTail(pos: number, expression: string): [tail: string, p: number] {\n    let tail = ''\n    const length = expression.length\n    let depth = 0\n    for (let p = pos; p < length; p++) {\n      const char = expression.charAt(p)\n      if (char === '(') {\n        depth++\n      } else if (char === ')') {\n        depth--\n      } else if (depth === 0 && char === ' ') {\n        continue\n      }\n      if (depth === 0 && getOp(operatorSymbols, char, p, expression)) {\n        return [tail, p - 1]\n      } else {\n        tail += char\n      }\n    }\n    return [tail, expression.length - 1]\n  }\n\n  /**\n   * Parse a string expression into a function that returns a boolean. This is\n   * the magic behind schema logic like $if.\n   * @param expression - A string expression to parse\n   * @returns\n   */\n  function parseLogicals(\n    expression: string,\n    step = 0\n  ): () => boolean | number | string {\n    const operators = operatorRegistry[step]\n    const length = expression.length\n    const symbols = Object.keys(operators)\n    let depth = 0\n    let quote: false | string = false\n    let op: null | ((l: any, r: any) => boolean | number | string) = null\n    let operand: Operand = ''\n    let left: null | ((r?: any) => boolean | number | string) = null\n    let operation: false | undefined | string\n    let lastChar = ''\n    let char = ''\n    let parenthetical = ''\n    let parenQuote: false | string = ''\n    let startP = 0\n    const addTo = (depth: number, char: string) => {\n      depth ? (parenthetical += char) : (operand += char)\n    }\n    for (let p = 0; p < length; p++) {\n      lastChar = char\n      char = expression.charAt(p)\n      if (\n        (char === \"'\" || char === '\"') &&\n        lastChar !== '\\\\' &&\n        ((depth === 0 && !quote) || (depth && !parenQuote))\n      ) {\n        if (depth) {\n          parenQuote = char\n        } else {\n          quote = char\n        }\n        addTo(depth, char)\n        continue\n      } else if (\n        (quote && (char !== quote || lastChar === '\\\\')) ||\n        (parenQuote && (char !== parenQuote || lastChar === '\\\\'))\n      ) {\n        addTo(depth, char)\n        continue\n      } else if (quote === char) {\n        quote = false\n        addTo(depth, char)\n        continue\n      } else if (parenQuote === char) {\n        parenQuote = false\n        addTo(depth, char)\n        continue\n      } else if (char === ' ') {\n        continue\n      } else if (char === '(') {\n        if (depth === 0) {\n          startP = p\n        } else {\n          parenthetical += char\n        }\n        depth++\n      } else if (char === ')') {\n        depth--\n        if (depth === 0) {\n          // Parenthetical statements cannot be grouped up in the implicit order\n          // of left/right statements based on which step they are on because\n          // they are parsed on every step and then must be applied to the\n          // operator. Example:\n          //\n          // 5 + (3) * 2\n          //\n          // This should yield 11 not 16. This order is normally implicit in the\n          // sequence of operators being parsed, but with parenthesis the parse\n          // happens each time. Instead we need to know if the resulting value\n          // should be applied to the left or the right hand operator. The\n          // general algorithm is:\n          //\n          // 1. Does this paren have an operator on the left or right side\n          // 2. If not, it's unnecessarily wrapped (3 + 2)\n          // 3. If it does, then which order of operation is highest?\n          // 4. Wait for the highest order of operation to bind to an operator.\n\n          // If the parenthetical has a preceding token like $fn(1 + 2) then we\n          // need to subtract the existing operand length from the start\n          // to determine if this is a left or right operation\n          const fn =\n            typeof operand === 'string' && operand.startsWith('$')\n              ? operand\n              : undefined\n          const hasTail = fn && expression.charAt(p + 1) === '.'\n          // It's possible the function has a chained tail call:\n          let tail = ''\n          if (hasTail) {\n            ;[tail, p] = getTail(p + 2, expression)\n          }\n          const lStep = op ? step : getStep(startP, expression, 0)\n          const rStep = getStep(p, expression)\n          if (lStep === -1 && rStep === -1) {\n            // This parenthetical was unnecessarily wrapped at the root, or\n            // these are args of a function call.\n            operand = evaluate(parenthetical, -1, fn, tail)\n            // If the operand is still a string after evaluation, then it was a\n            // quoted string like (\"1 + 2\") which should actually evaluate to\n            // a literal of \"1 + 2\". It will be cleaned/trimmed as a string a\n            // little further on in this block at `if (!op && operand)`.\n            if (typeof operand === 'string') operand = parenthetical\n          } else if (op && (lStep >= rStep || rStep === -1) && step === lStep) {\n            // has a left hand operator with a higher order of operation\n            left = op.bind(null, evaluate(parenthetical, -1, fn, tail))\n            op = null\n            operand = ''\n          } else if (rStep > lStep && step === rStep) {\n            // should be applied to the right hand operator when it gets one\n            operand = evaluate(parenthetical, -1, fn, tail) as string\n          } else {\n            operand += `(${parenthetical})${hasTail ? `.${tail}` : ''}`\n          }\n          parenthetical = ''\n        } else {\n          parenthetical += char\n        }\n      } else if (\n        depth === 0 &&\n        (operation = getOp(symbols, char, p, expression))\n      ) {\n        if (p === 0) {\n          error(103, [operation, expression])\n        }\n\n        // We identified the operator by looking ahead in the string, so we need\n        // our position to move past the operator\n        p += operation.length - 1\n        if (p === expression.length - 1) {\n          error(104, [operation, expression])\n        }\n        if (!op) {\n          // Bind the left hand operand\n          if (left) {\n            // In this case we've already parsed the left hand operator\n            op = operators[operation].bind(null, evaluate(left, step))\n            left = null\n          } else {\n            op = operators[operation].bind(null, evaluate(operand, step))\n            operand = ''\n          }\n        } else if (operand) {\n          // Bind the right hand operand, and return the resulting expression as a new left hand operator\n          left = op.bind(null, evaluate(operand, step)) as () =>\n            | boolean\n            | number\n            | string\n          op = operators[operation].bind(null, left)\n          operand = ''\n        }\n        continue\n      } else {\n        addTo(depth, char)\n      }\n    }\n    if (operand && op) {\n      // If we were left with an operand after the loop, and an op, it should\n      // be the right hand assignment.\n      op = op.bind(null, evaluate(operand, step))\n    }\n\n    // If we don't have an op, but we do have a left hand assignment, then that\n    // is actually our operator, so just re-assign it to op\n    op = !op && left ? left : op\n\n    if (!op && operand) {\n      // If we don't have any op but we do have an operand so there is no boolean\n      // logic to perform, but that operand still means something so we need to\n      // evaluate it and return it as a function\n      op = (v: any, t: Record<string, any>): boolean => {\n        return typeof v === 'function' ? v(t) : v\n      }\n      op = op.bind(null, evaluate(operand, step))\n    }\n\n    if (!op && !operand) {\n      error(105, expression)\n    }\n    return op as () => boolean | number | string\n  }\n\n  /**\n   * Given a string like '$name==bobby' evaluate it to true or false\n   * @param operand - A left or right boolean operand — usually conditions\n   * @param step - The current order of operation\n   * @param fnToken - The token (string) representation of a function being called\n   * @returns\n   */\n  function evaluate(\n    operand: Operand,\n    step: number,\n    fnToken?: string,\n    tail?: string //eslint-disable-line\n  ): Operand {\n    if (fnToken) {\n      const fn = evaluate(fnToken, operatorRegistry.length)\n      let userFuncReturn: unknown\n      // \"Tail calls\" are dot accessors after a function $foo().value. We need\n      // to compile tail calls, and then provide the function result to the\n      // exposed tokens.\n      let tailCall: false | FormKitCompilerOutput = tail\n        ? compile(`$${tail}`)\n        : false\n      if (typeof fn === 'function') {\n        const args = parseArgs(String(operand)).map((arg: string) =>\n          evaluate(arg, -1)\n        )\n        return (tokens: Record<string, any>) => {\n          const userFunc = fn(tokens)\n          if (typeof userFunc !== 'function') {\n            warn(150, fnToken)\n            return userFunc\n          }\n          userFuncReturn = userFunc(\n            ...args.map((arg) =>\n              typeof arg === 'function' ? arg(tokens) : arg\n            )\n          )\n          if (tailCall) {\n            tailCall = tailCall.provide((subTokens) => {\n              const rootTokens = provideTokens(subTokens)\n              const t = subTokens.reduce(\n                (tokenSet: Record<string, any>, token: string) => {\n                  const isTail = token === tail || tail?.startsWith(`${token}(`)\n                  if (isTail) {\n                    const value = getAt(userFuncReturn, token)\n                    tokenSet[token] = () => value\n                  } else {\n                    tokenSet[token] = rootTokens[token]\n                  }\n                  return tokenSet\n                },\n                {} as Record<string, any>\n              )\n              return t\n            })\n          }\n          return tailCall ? tailCall() : (userFuncReturn as string)\n        }\n      }\n    } else if (typeof operand === 'string') {\n      // the word true or false will never contain further operations\n      if (operand === 'true') return true\n      if (operand === 'false') return false\n      if (operand === 'undefined') return undefined\n\n      // Truly quotes strings cannot contain an operation, return the string\n      if (isQuotedString(operand))\n        return rmEscapes(operand.substring(1, operand.length - 1))\n\n      // Actual numbers cannot be contain an operation\n      if (!isNaN(+operand)) return Number(operand)\n\n      if (step < operatorRegistry.length - 1) {\n        return parseLogicals(operand, step + 1)\n      } else {\n        if (operand.startsWith('$')) {\n          const cleaned = operand.substring(1)\n          requirements.add(cleaned)\n          return function getToken(tokens: FormKitTokens) {\n            return cleaned in tokens ? tokens[cleaned]() : undefined\n          }\n        }\n        // In this case we are dealing with an unquoted string, just treat it\n        // as a plain string.\n        return operand\n      }\n    }\n    return operand\n  }\n\n  /**\n   * Compile the string.\n   */\n  const compiled = parseLogicals(\n    expr.startsWith('$:') ? expr.substring(2) : expr\n  )\n\n  /**\n   * Convert compiled requirements to an array.\n   */\n  const reqs = Array.from(requirements)\n\n  /**\n   * Provides token values via callback to compiled output.\n   * @param callback - A callback that needs to provide all token requirements\n   * @returns\n   */\n  function provide(\n    callback: (requirements: string[]) => Record<string, () => any>\n  ): FormKitCompilerOutput {\n    provideTokens = callback\n    return Object.assign(\n      // @ts-ignore - @rollup/plugin-typescript doesn't like this\n      compiled.bind(null, callback(reqs)),\n      { provide }\n    )\n  }\n  return Object.assign(compiled, {\n    provide,\n  })\n}\n","import { FormKitNode } from './node'\n\n/**\n * Definition for a function that produces CSS classes.\n *\n * @public\n */\nexport interface FormKitClasses {\n  (node: FormKitNode, sectionKey: string): string | Record<string, boolean>\n}\n\n/**\n * Function that produces a standardized object representation of CSS classes.\n *\n * @param propertyKey - the section key.\n * @param node - A {@link FormKitNode | FormKitNode}.\n * @param sectionClassList - A `string | Record<string, boolean>` or a {@link FormKitClasses | FormKitClasses}.\n *\n * @returns `Record<string, boolean>`\n *\n * @public\n */\nexport function createClasses(\n  propertyKey: string,\n  node: FormKitNode,\n  sectionClassList?: FormKitClasses | string | Record<string, boolean>\n): Record<string, boolean> {\n  if (!sectionClassList) return {}\n  if (typeof sectionClassList === 'string') {\n    const classKeys = sectionClassList.split(' ')\n    return classKeys.reduce(\n      (obj, key) => Object.assign(obj, { [key]: true }),\n      {}\n    )\n  } else if (typeof sectionClassList === 'function') {\n    return createClasses(\n      propertyKey,\n      node,\n      sectionClassList(node, propertyKey)\n    )\n  }\n  return sectionClassList\n}\n\n/**\n * Combines multiple class lists into a single list.\n *\n * @param node - A {@link FormKitNode | FormKitNode}.\n * @param property - The property key to which the class list will be applied.\n * @param args - And array of `Record<string, boolean>` of CSS class list(s).\n *\n * @returns `string | null`\n *\n * @public\n */\nexport function generateClassList(\n  node: FormKitNode,\n  property: string,\n  ...args: Record<string, boolean>[]\n): string | null {\n  const combinedClassList = args.reduce((finalClassList, currentClassList) => {\n    if (!currentClassList) return handleNegativeClasses(finalClassList)\n    const { $reset, ...classList } = currentClassList\n    if ($reset) {\n      return handleNegativeClasses(classList)\n    }\n    return handleNegativeClasses(Object.assign(finalClassList, classList))\n  }, {})\n\n  return Object.keys(\n    node.hook.classes.dispatch({ property, classes: combinedClassList })\n      .classes\n  )\n    .filter((key) => combinedClassList[key])\n    .join(' ') || null\n}\n\nfunction handleNegativeClasses(classList: Record<string, boolean>): Record<string, boolean> {\n  const removalToken = '$remove:'\n  let hasNegativeClassValue = false\n  const applicableClasses = Object.keys(classList).filter((className) => {\n    if (classList[className] && className.startsWith(removalToken)) {\n      hasNegativeClassValue = true\n    }\n    return classList[className]\n  })\n  if (applicableClasses.length > 1 && hasNegativeClassValue) {\n    const negativeClasses = applicableClasses.filter(className => className.startsWith(removalToken))\n    negativeClasses.map((negativeClass) => {\n      const targetClass = negativeClass.substring(removalToken.length)\n      classList[targetClass] = false\n      classList[negativeClass] = false\n    })\n  }\n  return classList\n}\n","import { getNode } from './registry'\nimport { ErrorMessages } from './store'\nimport { warn } from './errors'\n\n/**\n * Sets errors on a form, group, or input.\n *\n * @param id - The id of a form.\n * @param localErrors - The errors to set on the form or the form’s inputs in\n * the format of {@link ErrorMessages | ErrorMessages}.\n * @param childErrors - (optional) The errors to set on the form or the form’s\n * inputs in the format of {@link ErrorMessages | ErrorMessages}.\n *\n * @public\n */\nexport function setErrors(\n  id: string,\n  localErrors: ErrorMessages,\n  childErrors?: ErrorMessages\n): void {\n  const node = getNode(id)\n  if (node) {\n    node.setErrors(localErrors, childErrors)\n  } else {\n    warn(651, id)\n  }\n}\n\n/**\n * Clears errors on the node and optionally its children.\n *\n * @param id - The id of the node you want to clear errors for.\n * @param clearChildren - Determines if the children of this node should have\n * their errors cleared.\n *\n * @public\n */\nexport function clearErrors(id: string, clearChildren = true): void {\n  const node = getNode(id)\n  if (node) {\n    node.clearErrors(clearChildren)\n  } else {\n    warn(652, id)\n  }\n}\n","/**\n * The official FormKit core library. This package is responsible for most of FormKit’s internal functionality.\n * You can read documentation specifically on how it works at formkit.com.\n *\n * You can add this package by using `npm install @formkit/core` or `yarn add @formkit/core`.\n *\n * @packageDocumentation\n */\n\n/**\n * The current version of FormKit at the time the package is published. Is replaced\n * as part of the publishing script.\n *\n * @internal\n */\nexport const FORMKIT_VERSION = '__FKV__'\n\n/**\n * Include all exported methods from node, this is the primary API.\n */\nexport * from './node'\n\n/**\n * Include createMessage to create new messages.\n */\nexport {\n  createMessage,\n  ChildMessageBuffer,\n  FormKitInputMessages,\n  FormKitMessage,\n  FormKitMessageMeta,\n  FormKitMessageStore,\n  FormKitMessageProps,\n  FormKitStore,\n  ErrorMessages,\n  FormKitStoreTraps,\n  MessageClearer,\n} from './store'\n\n/**\n * The FormKit ledger.\n */\nexport {\n  FormKitLedger,\n  FormKitCounterCondition,\n  FormKitCounter,\n} from './ledger'\n\n/**\n * Export dispatcher typings.\n */\nexport { FormKitDispatcher, FormKitMiddleware } from './dispatcher'\n\n/**\n * Export event typings.\n */\nexport {\n  FormKitEventListener,\n  FormKitEvent,\n  FormKitEventEmitter,\n} from './events'\n\n/**\n * Export errors emitters.\n */\nexport {\n  FormKitHandlerPayload,\n  errorHandler,\n  warningHandler,\n  warn,\n  error,\n} from './errors'\n\n/**\n * Export all schema features.\n */\nexport {\n  FormKitAttributeValue,\n  FormKitExtendableSchemaRoot,\n  FormKitListStatement,\n  FormKitListValue,\n  FormKitSchemaAttributes,\n  FormKitSchemaAttributesCondition,\n  FormKitSchemaComponent,\n  FormKitSchemaComposable,\n  FormKitSchemaCondition,\n  FormKitSchemaContext,\n  FormKitSchemaDOMNode,\n  FormKitSchemaFormKit,\n  FormKitSchemaMeta,\n  FormKitSchemaNode,\n  FormKitSchemaProps,\n  FormKitSchemaTextNode,\n  FormKitSchemaDefinition,\n  FormKitSectionsSchema,\n  isComponent,\n  isConditional,\n  isDOM,\n  isSugar,\n  sugar,\n} from './schema'\n\n/**\n * Export the FormKit logic compiler.\n */\nexport {\n  compile,\n  FormKitCompilerOutput,\n  FormKitCompilerProvider,\n} from './compiler'\n\n/**\n * Export classes.\n */\nexport * from './classes'\n\n/**\n * Export the global registry.\n */\nexport * from './registry'\n\n/**\n * The root configuration creator.\n */\nexport { createConfig, FormKitRootConfig } from './config'\n\n/**\n * Sets error store messages on inputs.\n */\nexport * from './setErrors'\n\n/**\n * Programmatically submits a form by the id.\n */\nexport { submitForm } from './submitForm'\n\n/**\n * Programmatically reset an input.\n */\nexport { reset } from './reset'\n"]}