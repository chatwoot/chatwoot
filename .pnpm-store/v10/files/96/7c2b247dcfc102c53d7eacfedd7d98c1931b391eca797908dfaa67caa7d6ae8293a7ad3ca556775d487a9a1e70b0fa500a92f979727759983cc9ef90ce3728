{"version":3,"file":"autocapture-utils.js","sourceRoot":"","sources":["../../src/autocapture-utils.ts"],"names":[],"mappings":"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","sourcesContent":["import { AutocaptureConfig, Properties } from './types'\nimport { each, entries } from './utils'\n\nimport { isNullish, isString, isUndefined, isArray } from '@posthog/core'\nimport { logger } from './utils/logger'\nimport { window } from './utils/globals'\nimport { isDocumentFragment, isElementNode, isTag, isTextNode } from './utils/element-utils'\nimport { includes, trim } from '@posthog/core'\n\nexport function splitClassString(s: string): string[] {\n    return s ? trim(s).split(/\\s+/) : []\n}\n\nfunction checkForURLMatches(urlsList: (string | RegExp)[]): boolean {\n    const url = window?.location.href\n    return !!(url && urlsList && urlsList.some((regex) => url.match(regex)))\n}\n\n/*\n * Get the className of an element, accounting for edge cases where element.className is an object\n *\n * Because this is a string it can contain unexpected characters\n * So, this method safely splits the className and returns that array.\n */\nexport function getClassNames(el: Element): string[] {\n    let className = ''\n    switch (typeof el.className) {\n        case 'string':\n            className = el.className\n            break\n        // TODO: when is this ever used?\n        case 'object': // handle cases where className might be SVGAnimatedString or some other type\n            className =\n                (el.className && 'baseVal' in el.className ? (el.className as any).baseVal : null) ||\n                el.getAttribute('class') ||\n                ''\n            break\n        default:\n            className = ''\n    }\n\n    return splitClassString(className)\n}\n\nexport function makeSafeText(s: string | null | undefined): string | null {\n    if (isNullish(s)) {\n        return null\n    }\n\n    return (\n        trim(s)\n            // scrub potentially sensitive values\n            .split(/(\\s+)/)\n            .filter((s) => shouldCaptureValue(s))\n            .join('')\n            // normalize whitespace\n            .replace(/[\\r\\n]/g, ' ')\n            .replace(/[ ]+/g, ' ')\n            // truncate\n            .substring(0, 255)\n    )\n}\n\n/*\n * Get the direct text content of an element, protecting against sensitive data collection.\n * Concats textContent of each of the element's text node children; this avoids potential\n * collection of sensitive data that could happen if we used element.textContent and the\n * element had sensitive child elements, since element.textContent includes child content.\n * Scrubs values that look like they could be sensitive (i.e. cc or ssn number).\n * @param {Element} el - element to get the text of\n * @returns {string} the element's direct text content\n */\nexport function getSafeText(el: Element): string {\n    let elText = ''\n\n    if (shouldCaptureElement(el) && !isSensitiveElement(el) && el.childNodes && el.childNodes.length) {\n        each(el.childNodes, function (child) {\n            if (isTextNode(child) && child.textContent) {\n                elText += makeSafeText(child.textContent) ?? ''\n            }\n        })\n    }\n\n    return trim(elText)\n}\n\nexport function getEventTarget(e: Event): Element | null {\n    // https://developer.mozilla.org/en-US/docs/Web/API/Event/target#Compatibility_notes\n    if (isUndefined(e.target)) {\n        return (e.srcElement as Element) || null\n    } else {\n        if ((e.target as HTMLElement)?.shadowRoot) {\n            return (e.composedPath()[0] as Element) || null\n        }\n        return (e.target as Element) || null\n    }\n}\n\nexport const autocaptureCompatibleElements = ['a', 'button', 'form', 'input', 'select', 'textarea', 'label']\n\n/*\n if there is no config, then all elements are allowed\n if there is a config, and there is an allow list, then only elements in the allow list are allowed\n assumes that some other code is checking this element's parents\n */\nfunction checkIfElementTreePassesElementAllowList(\n    elements: Element[],\n    autocaptureConfig: AutocaptureConfig | undefined\n): boolean {\n    const allowlist = autocaptureConfig?.element_allowlist\n    if (isUndefined(allowlist)) {\n        // everything is allowed, when there is no allow list\n        return true\n    }\n\n    // check each element in the tree\n    // if any of the elements are in the allow list, then the tree is allowed\n    for (const el of elements) {\n        if (allowlist.some((elementType) => el.tagName.toLowerCase() === elementType)) {\n            return true\n        }\n    }\n\n    // otherwise there is an allow list and this element tree didn't match it\n    return false\n}\n\n/*\n if there is no config, then all elements are allowed\n if there is a config, and there is an allow list, then\n only elements that match the css selector in the allow list are allowed\n assumes that some other code is checking this element's parents\n */\nfunction checkIfElementTreePassesCSSSelectorAllowList(\n    elements: Element[],\n    autocaptureConfig: AutocaptureConfig | undefined\n): boolean {\n    const allowlist = autocaptureConfig?.css_selector_allowlist\n    if (isUndefined(allowlist)) {\n        // everything is allowed, when there is no allow list\n        return true\n    }\n\n    // check each element in the tree\n    // if any of the elements are in the allow list, then the tree is allowed\n    for (const el of elements) {\n        if (allowlist.some((selector) => el.matches(selector))) {\n            return true\n        }\n    }\n\n    // otherwise there is an allow list and this element tree didn't match it\n    return false\n}\n\nexport function getParentElement(curEl: Element): Element | false {\n    const parentNode = curEl.parentNode\n    if (!parentNode || !isElementNode(parentNode)) return false\n    return parentNode\n}\n\n/*\n * Check whether a DOM event should be \"captured\" or if it may contain sentitive data\n * using a variety of heuristics.\n * @param {Element} el - element to check\n * @param {Event} event - event to check\n * @param {Object} autocaptureConfig - autocapture config\n * @param {boolean} captureOnAnyElement - whether to capture on any element, clipboard autocapture doesn't restrict to \"clickable\" elements\n * @param {string[]} allowedEventTypes - event types to capture, normally just 'click', but some autocapture types react to different events, some elements have fixed events (e.g., form has \"submit\")\n * @returns {boolean} whether the event should be captured\n */\nexport function shouldCaptureDomEvent(\n    el: Element,\n    event: Event,\n    autocaptureConfig: AutocaptureConfig | undefined = undefined,\n    captureOnAnyElement?: boolean,\n    allowedEventTypes?: string[]\n): boolean {\n    if (!window || !el || isTag(el, 'html') || !isElementNode(el)) {\n        return false\n    }\n\n    if (autocaptureConfig?.url_allowlist) {\n        // if the current URL is not in the allow list, don't capture\n        if (!checkForURLMatches(autocaptureConfig.url_allowlist)) {\n            return false\n        }\n    }\n\n    if (autocaptureConfig?.url_ignorelist) {\n        // if the current URL is in the ignore list, don't capture\n        if (checkForURLMatches(autocaptureConfig.url_ignorelist)) {\n            return false\n        }\n    }\n\n    if (autocaptureConfig?.dom_event_allowlist) {\n        const allowlist = autocaptureConfig.dom_event_allowlist\n        if (allowlist && !allowlist.some((eventType) => event.type === eventType)) {\n            return false\n        }\n    }\n\n    let parentIsUsefulElement = false\n    const targetElementList: Element[] = [el]\n    let parentNode: Element | boolean = true\n    let curEl: Element = el\n    while (curEl.parentNode && !isTag(curEl, 'body')) {\n        // If element is a shadow root, we skip it\n        if (isDocumentFragment(curEl.parentNode)) {\n            targetElementList.push((curEl.parentNode as any).host)\n            curEl = (curEl.parentNode as any).host\n            continue\n        }\n        parentNode = getParentElement(curEl)\n        if (!parentNode) break\n        if (captureOnAnyElement || autocaptureCompatibleElements.indexOf(parentNode.tagName.toLowerCase()) > -1) {\n            parentIsUsefulElement = true\n        } else {\n            const compStyles = window.getComputedStyle(parentNode)\n            if (compStyles && compStyles.getPropertyValue('cursor') === 'pointer') {\n                parentIsUsefulElement = true\n            }\n        }\n\n        targetElementList.push(parentNode)\n        curEl = parentNode\n    }\n\n    if (!checkIfElementTreePassesElementAllowList(targetElementList, autocaptureConfig)) {\n        return false\n    }\n\n    if (!checkIfElementTreePassesCSSSelectorAllowList(targetElementList, autocaptureConfig)) {\n        return false\n    }\n\n    const compStyles = window.getComputedStyle(el)\n    if (compStyles && compStyles.getPropertyValue('cursor') === 'pointer' && event.type === 'click') {\n        return true\n    }\n\n    const tag = el.tagName.toLowerCase()\n    switch (tag) {\n        case 'html':\n            return false\n        case 'form':\n            return (allowedEventTypes || ['submit']).indexOf(event.type) >= 0\n        case 'input':\n        case 'select':\n        case 'textarea':\n            return (allowedEventTypes || ['change', 'click']).indexOf(event.type) >= 0\n        default:\n            if (parentIsUsefulElement) return (allowedEventTypes || ['click']).indexOf(event.type) >= 0\n            return (\n                (allowedEventTypes || ['click']).indexOf(event.type) >= 0 &&\n                (autocaptureCompatibleElements.indexOf(tag) > -1 || el.getAttribute('contenteditable') === 'true')\n            )\n    }\n}\n\n/*\n * Check whether a DOM element should be \"captured\" or if it may contain sentitive data\n * using a variety of heuristics.\n * @param {Element} el - element to check\n * @returns {boolean} whether the element should be captured\n */\nexport function shouldCaptureElement(el: Element): boolean {\n    for (let curEl = el; curEl.parentNode && !isTag(curEl, 'body'); curEl = curEl.parentNode as Element) {\n        const classes = getClassNames(curEl)\n        if (includes(classes, 'ph-sensitive') || includes(classes, 'ph-no-capture')) {\n            return false\n        }\n    }\n\n    if (includes(getClassNames(el), 'ph-include')) {\n        return true\n    }\n\n    // don't include hidden or password fields\n    const type = (el as HTMLInputElement).type || ''\n    if (isString(type)) {\n        // it's possible for el.type to be a DOM element if el is a form with a child input[name=\"type\"]\n        switch (type.toLowerCase()) {\n            case 'hidden':\n                return false\n            case 'password':\n                return false\n        }\n    }\n\n    // filter out data from fields that look like sensitive fields\n    const name = (el as HTMLInputElement).name || el.id || ''\n    // See https://github.com/posthog/posthog-js/issues/165\n    // Under specific circumstances a bug caused .replace to be called on a DOM element\n    // instead of a string, removing the element from the page. Ensure this issue is mitigated.\n    if (isString(name)) {\n        // it's possible for el.name or el.id to be a DOM element if el is a form with a child input[name=\"name\"]\n        const sensitiveNameRegex =\n            /^cc|cardnum|ccnum|creditcard|csc|cvc|cvv|exp|pass|pwd|routing|seccode|securitycode|securitynum|socialsec|socsec|ssn/i\n        if (sensitiveNameRegex.test(name.replace(/[^a-zA-Z0-9]/g, ''))) {\n            return false\n        }\n    }\n\n    return true\n}\n\n/*\n * Check whether a DOM element is 'sensitive' and we should only capture limited data\n * @param {Element} el - element to check\n * @returns {boolean} whether the element should be captured\n */\nexport function isSensitiveElement(el: Element): boolean {\n    // don't send data from inputs or similar elements since there will always be\n    // a risk of clientside javascript placing sensitive data in attributes\n    const allowedInputTypes = ['button', 'checkbox', 'submit', 'reset']\n    if (\n        (isTag(el, 'input') && !allowedInputTypes.includes((el as HTMLInputElement).type)) ||\n        isTag(el, 'select') ||\n        isTag(el, 'textarea') ||\n        el.getAttribute('contenteditable') === 'true'\n    ) {\n        return true\n    }\n    return false\n}\n\n// Define the core pattern for matching credit card numbers\nconst coreCCPattern = `(4[0-9]{12}(?:[0-9]{3})?)|(5[1-5][0-9]{14})|(6(?:011|5[0-9]{2})[0-9]{12})|(3[47][0-9]{13})|(3(?:0[0-5]|[68][0-9])[0-9]{11})|((?:2131|1800|35[0-9]{3})[0-9]{11})`\n// Create the Anchored version of the regex by adding '^' at the start and '$' at the end\nconst anchoredCCRegex = new RegExp(`^(?:${coreCCPattern})$`)\n// The Unanchored version is essentially the core pattern, usable as is for partial matches\nconst unanchoredCCRegex = new RegExp(coreCCPattern)\n\n// Define the core pattern for matching SSNs with optional dashes\nconst coreSSNPattern = `\\\\d{3}-?\\\\d{2}-?\\\\d{4}`\n// Create the Anchored version of the regex by adding '^' at the start and '$' at the end\nconst anchoredSSNRegex = new RegExp(`^(${coreSSNPattern})$`)\n// The Unanchored version is essentially the core pattern itself, usable for partial matches\nconst unanchoredSSNRegex = new RegExp(`(${coreSSNPattern})`)\n\n/*\n * Check whether a string value should be \"captured\" or if it may contain sensitive data\n * using a variety of heuristics.\n * @param {string} value - string value to check\n * @param {boolean} anchorRegexes - whether to anchor the regexes to the start and end of the string\n * @returns {boolean} whether the element should be captured\n */\nexport function shouldCaptureValue(value: string, anchorRegexes = true): boolean {\n    if (isNullish(value)) {\n        return false\n    }\n\n    if (isString(value)) {\n        value = trim(value)\n\n        // check to see if input value looks like a credit card number\n        // see: https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9781449327453/ch04s20.html\n        const ccRegex = anchorRegexes ? anchoredCCRegex : unanchoredCCRegex\n        if (ccRegex.test((value || '').replace(/[- ]/g, ''))) {\n            return false\n        }\n\n        // check to see if input value looks like a social security number\n        const ssnRegex = anchorRegexes ? anchoredSSNRegex : unanchoredSSNRegex\n        if (ssnRegex.test(value)) {\n            return false\n        }\n    }\n\n    return true\n}\n\n/*\n * Check whether an attribute name is an Angular style attr (either _ngcontent or _nghost)\n * These update on each build and lead to noise in the element chain\n * More details on the attributes here: https://angular.io/guide/view-encapsulation\n * @param {string} attributeName - string value to check\n * @returns {boolean} whether the element is an angular tag\n */\nexport function isAngularStyleAttr(attributeName: string): boolean {\n    if (isString(attributeName)) {\n        return attributeName.substring(0, 10) === '_ngcontent' || attributeName.substring(0, 7) === '_nghost'\n    }\n    return false\n}\n\n/*\n * Iterate through children of a target element looking for span tags\n * and return the text content of the span tags, separated by spaces,\n * along with the direct text content of the target element\n * @param {Element} target - element to check\n * @returns {string} text content of the target element and its child span tags\n */\nexport function getDirectAndNestedSpanText(target: Element): string {\n    let text = getSafeText(target)\n    text = `${text} ${getNestedSpanText(target)}`.trim()\n    return shouldCaptureValue(text) ? text : ''\n}\n\n/*\n * Iterate through children of a target element looking for span tags\n * and return the text content of the span tags, separated by spaces\n * @param {Element} target - element to check\n * @returns {string} text content of span tags\n */\nexport function getNestedSpanText(target: Element): string {\n    let text = ''\n    if (target && target.childNodes && target.childNodes.length) {\n        each(target.childNodes, function (child) {\n            if (child && child.tagName?.toLowerCase() === 'span') {\n                try {\n                    const spanText = getSafeText(child)\n                    text = `${text} ${spanText}`.trim()\n\n                    if (child.childNodes && child.childNodes.length) {\n                        text = `${text} ${getNestedSpanText(child)}`.trim()\n                    }\n                } catch (e) {\n                    logger.error('[AutoCapture]', e)\n                }\n            }\n        })\n    }\n    return text\n}\n\n/*\nBack in the day storing events in Postgres we use Elements for autocapture events.\nNow we're using elements_chain. We used to do this parsing/processing during ingestion.\nThis code is just copied over from ingestion, but we should optimize it\nto create elements_chain string directly.\n*/\nexport function getElementsChainString(elements: Properties[]): string {\n    return elementsToString(extractElements(elements))\n}\n\n// This interface is called 'Element' in plugin-scaffold https://github.com/PostHog/plugin-scaffold/blob/b07d3b879796ecc7e22deb71bf627694ba05386b/src/types.ts#L200\n// However 'Element' is a DOM Element when run in the browser, so we have to rename it\ninterface PHElement {\n    text?: string\n    tag_name?: string\n    href?: string\n    attr_id?: string\n    attr_class?: string[]\n    nth_child?: number\n    nth_of_type?: number\n    attributes?: Record<string, any>\n    event_id?: number\n    order?: number\n    group_id?: number\n}\n\nfunction escapeQuotes(input: string): string {\n    return input.replace(/\"|\\\\\"/g, '\\\\\"')\n}\n\nfunction elementsToString(elements: PHElement[]): string {\n    const ret = elements.map((element) => {\n        let el_string = ''\n        if (element.tag_name) {\n            el_string += element.tag_name\n        }\n        if (element.attr_class) {\n            element.attr_class.sort()\n            for (const single_class of element.attr_class) {\n                el_string += `.${single_class.replace(/\"/g, '')}`\n            }\n        }\n        const attributes: Record<string, any> = {\n            ...(element.text ? { text: element.text } : {}),\n            'nth-child': element.nth_child ?? 0,\n            'nth-of-type': element.nth_of_type ?? 0,\n            ...(element.href ? { href: element.href } : {}),\n            ...(element.attr_id ? { attr_id: element.attr_id } : {}),\n            ...element.attributes,\n        }\n        const sortedAttributes: Record<string, any> = {}\n        entries(attributes)\n            .sort(([a], [b]) => a.localeCompare(b))\n            .forEach(\n                ([key, value]) => (sortedAttributes[escapeQuotes(key.toString())] = escapeQuotes(value.toString()))\n            )\n        el_string += ':'\n        el_string += entries(sortedAttributes)\n            .map(([key, value]) => `${key}=\"${value}\"`)\n            .join('')\n        return el_string\n    })\n    return ret.join(';')\n}\n\nfunction extractElements(elements: Properties[]): PHElement[] {\n    return elements.map((el) => {\n        const response = {\n            text: el['$el_text']?.slice(0, 400),\n            tag_name: el['tag_name'],\n            href: el['attr__href']?.slice(0, 2048),\n            attr_class: extractAttrClass(el),\n            attr_id: el['attr__id'],\n            nth_child: el['nth_child'],\n            nth_of_type: el['nth_of_type'],\n            attributes: {} as { [id: string]: any },\n        }\n\n        entries(el)\n            .filter(([key]) => key.indexOf('attr__') === 0)\n            .forEach(([key, value]) => (response.attributes[key] = value))\n        return response\n    })\n}\n\nfunction extractAttrClass(el: Properties): PHElement['attr_class'] {\n    const attr_class = el['attr__class']\n    if (!attr_class) {\n        return undefined\n    } else if (isArray(attr_class)) {\n        return attr_class\n    } else {\n        return splitClassString(attr_class)\n    }\n}\n"]}