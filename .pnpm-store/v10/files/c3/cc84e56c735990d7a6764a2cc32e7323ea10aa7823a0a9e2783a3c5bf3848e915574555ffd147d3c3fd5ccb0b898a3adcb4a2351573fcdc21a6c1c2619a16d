{"version":3,"file":"request-utils.js","sourceRoot":"","sources":["../../../src/utils/request-utils.ts"],"names":[],"mappings":"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","sourcesContent":["import { each } from './'\n\nimport { isArray, isFile, isUndefined } from '@posthog/core'\nimport { logger } from './logger'\nimport { document } from './globals'\n\nconst localDomains = ['localhost', '127.0.0.1']\n\n/**\n * IE11 doesn't support `new URL`\n * so we can create an anchor element and use that to parse the URL\n * there's a lot of overlap between HTMLHyperlinkElementUtils and URL\n * meaning useful properties like `pathname` are available on both\n */\nexport const convertToURL = (url: string): HTMLAnchorElement | null => {\n    const location = document?.createElement('a')\n    if (isUndefined(location)) {\n        return null\n    }\n\n    location.href = url\n    return location\n}\n\nexport const formDataToQuery = function (formdata: Record<string, any> | FormData, arg_separator = '&'): string {\n    let use_val: string\n    let use_key: string\n    const tph_arr: string[] = []\n\n    each(formdata, function (val: File | string | undefined, key: string | undefined) {\n        // the key might be literally the string undefined for e.g. if {undefined: 'something'}\n        if (isUndefined(val) || isUndefined(key) || key === 'undefined') {\n            return\n        }\n\n        use_val = encodeURIComponent(isFile(val) ? val.name : val.toString())\n        use_key = encodeURIComponent(key)\n        tph_arr[tph_arr.length] = use_key + '=' + use_val\n    })\n\n    return tph_arr.join(arg_separator)\n}\n\n// NOTE: Once we get rid of IE11/op_mini we can start using URLSearchParams\nexport const getQueryParam = function (url: string, param: string): string {\n    const withoutHash: string = url.split('#')[0] || ''\n\n    // Split only on the first ? to sort problem out for those with multiple ?s\n    // and then remove them\n    const queryParams: string = withoutHash.split(/\\?(.*)/)[1] || ''\n    const cleanedQueryParams = queryParams.replace(/^\\?+/g, '')\n\n    const queryParts = cleanedQueryParams.split('&')\n    let keyValuePair\n\n    for (let i = 0; i < queryParts.length; i++) {\n        const parts = queryParts[i].split('=')\n        if (parts[0] === param) {\n            keyValuePair = parts\n            break\n        }\n    }\n\n    if (!isArray(keyValuePair) || keyValuePair.length < 2) {\n        return ''\n    } else {\n        let result = keyValuePair[1]\n        try {\n            result = decodeURIComponent(result)\n        } catch {\n            logger.error('Skipping decoding for malformed query param: ' + result)\n        }\n        return result.replace(/\\+/g, ' ')\n    }\n}\n\n// replace any query params in the url with the provided mask value. Tries to keep the URL as instant as possible,\n// including preserving malformed text in most cases\nexport const maskQueryParams = function <T extends string | undefined>(\n    url: T,\n    maskedParams: string[] | undefined,\n    mask: string\n): T extends string ? string : undefined {\n    if (!url || !maskedParams || !maskedParams.length) {\n        return url as any\n    }\n\n    const splitHash = url.split('#')\n    const withoutHash: string = splitHash[0] || ''\n    const hash = splitHash[1]\n\n    const splitQuery: string[] = withoutHash.split('?')\n    const queryString: string = splitQuery[1]\n    const urlWithoutQueryAndHash: string = splitQuery[0]\n    const queryParts = (queryString || '').split('&')\n\n    // use an array of strings rather than an object to preserve ordering and duplicates\n    const paramStrings: string[] = []\n\n    for (let i = 0; i < queryParts.length; i++) {\n        const keyValuePair = queryParts[i].split('=')\n        if (!isArray(keyValuePair)) {\n            continue\n        } else if (maskedParams.includes(keyValuePair[0])) {\n            paramStrings.push(keyValuePair[0] + '=' + mask)\n        } else {\n            paramStrings.push(queryParts[i])\n        }\n    }\n\n    let result = urlWithoutQueryAndHash\n    if (queryString != null) {\n        result += '?' + paramStrings.join('&')\n    }\n    if (hash != null) {\n        result += '#' + hash\n    }\n\n    return result as any\n}\n\nexport const _getHashParam = function (hash: string, param: string): string | null {\n    const matches = hash.match(new RegExp(param + '=([^&]*)'))\n    return matches ? matches[1] : null\n}\n\nexport const isLocalhost = (): boolean => {\n    return localDomains.includes(location.hostname)\n}\n"]}