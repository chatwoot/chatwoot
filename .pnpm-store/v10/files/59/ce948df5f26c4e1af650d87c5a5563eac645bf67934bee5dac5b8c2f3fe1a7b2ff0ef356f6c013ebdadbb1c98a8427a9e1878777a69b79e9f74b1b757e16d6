{"version":3,"sources":["../src/bindings.ts","../src/defaultConfig.ts","../src/FormKit.ts","../src/FormKitSchema.ts","../src/composables/onSSRComplete.ts","../src/FormKitRoot.ts","../src/composables/useInput.ts","../src/plugin.ts","../src/composables/createInput.ts","../src/composables/defineFormKitConfig.ts","../src/FormKitKitchenSink.ts","../src/FormKitMessages.ts","../src/FormKitProvider.ts","../src/composables/useContext.ts","../src/FormKitSummary.ts","../src/index.ts","../src/FormKitIcon.ts","../src/utilities/resetCount.ts"],"names":["reactive","computed","ref","watch","markRaw","isRef","createMessage","eq","has","camel","undefine","cloneAny","shallowClone","vueBindings","message","messages","classes","node","value","definition","extend","h","defineComponent","isServer","token","library","getValue","slotData","schema","element","data","instanceKey","getCurrentInstance","stopWatch","error","watchEffect","provide","onMounted","getNode","initialProps","isComponent","schemaDefinitions","inject","createSection","createConfig","FormKitProvider","FormKitConfigLoader","defaultConfig","FormKitLazyProvider","watchRegistry","onUnmounted","nextTick","context","id","plugin","setErrors","clearErrors","submitForm","reset"],"mappings":"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","sourcesContent":["import {\n  reactive,\n  computed,\n  ref,\n  watch,\n  markRaw,\n  triggerRef,\n  nextTick,\n  isRef,\n  isReactive,\n} from 'vue'\nimport {\n  FormKitPlugin,\n  FormKitFrameworkContext,\n  FormKitMessage,\n  createClasses,\n  createMessage,\n  generateClassList,\n  FormKitTypeDefinition,\n} from '@formkit/core'\nimport {\n  eq,\n  has,\n  camel,\n  empty,\n  undefine,\n  cloneAny,\n  shallowClone,\n} from '@formkit/utils'\nimport { createObserver } from '@formkit/observer'\nimport { FormKitPseudoProps } from '@formkit/core'\n\n/**\n * A plugin that creates Vue-specific context object on each given node.\n *\n * @param node - FormKitNode to create the context on.\n *\n * @public\n */\nconst vueBindings: FormKitPlugin = function vueBindings(node) {\n  /**\n   * Start a validity counter on all blocking messages.\n   */\n  node.ledger.count('blocking', (m) => m.blocking)\n  const isValid = ref<boolean>(!node.ledger.value('blocking'))\n  /**\n   * Start an error message counter.\n   */\n  node.ledger.count('errors', (m) => m.type === 'error')\n  const hasErrors = ref<boolean>(!!node.ledger.value('errors'))\n\n  /**\n   * Keep track of the first time a Vue tick cycle has passed.\n   */\n  let hasTicked = false\n  nextTick(() => {\n    hasTicked = true\n  })\n\n  /**\n   * All messages with the visibility state set to true.\n   */\n  const availableMessages = reactive<Record<string, FormKitMessage>>(\n    node.store.reduce((store, message) => {\n      if (message.visible) {\n        store[message.key] = message\n      }\n      return store\n    }, {} as Record<string, FormKitMessage>)\n  )\n  /**\n   * A flag that determines when validation messages should be displayed.\n   */\n  const validationVisibility = ref<string>(\n    node.props.validationVisibility ||\n      (node.props.type === 'checkbox' ? 'dirty' : 'blur')\n  )\n  node.on('prop:validationVisibility', ({ payload }) => {\n    validationVisibility.value = payload\n  })\n\n  /**\n   * Keep track of if this input has ever shown validation errors.\n   */\n  const hasShownErrors = ref(validationVisibility.value === 'live')\n\n  /**\n   * If the input is required or not, this is the only validation rule that\n   * needs to be explicitly called out since it powers the aria-required attr.\n   */\n  const isRequired = ref<boolean>(false)\n  const checkForRequired = (parsedRules?: Array<{ name: string }>) => {\n    isRequired.value = (parsedRules ?? []).some(\n      (rule) => rule.name === 'required'\n    )\n  }\n  checkForRequired(node.props.parsedRules)\n  node.on('prop:parsedRules', ({ payload }) => checkForRequired(payload))\n\n  /**\n   * An array of unique identifiers that should only be used for iterating\n   * inside a synced list.\n   */\n  const items = ref(node.children.map((child) => child.uid))\n\n  /**\n   * The current visibility state of validation messages.\n   */\n  const validationVisible = computed<boolean>(() => {\n    if (!context.state) return false\n    if (context.state.submitted) return true\n    if (!hasShownErrors.value && !context.state.settled) {\n      return false\n    }\n    switch (validationVisibility.value) {\n      case 'live':\n        return true\n      case 'blur':\n        return context.state.blurred\n      case 'dirty':\n        return context.state.dirty\n      default:\n        return false\n    }\n  })\n\n  /**\n   * Determines if the input should be considered \"invalid\" — note that this is different than a valid input! A\n   * valid input is one where the input is not loading, not pending validation, not unsettled, and passes all\n   * validation rules. An invalid input is one whose validation rules are not explicitly not passing, and those rules\n   * are visible to the user.\n   */\n  const isInvalid = computed<boolean>(() => {\n    return context.state.failing && validationVisible.value\n  })\n\n  /**\n   * Determines if the input should be considered \"complete\".\n   */\n  const isComplete = computed<boolean>(() => {\n    return context && hasValidation.value\n      ? isValid.value && !hasErrors.value\n      : context.state.dirty && !empty(context.value)\n  })\n\n  /**\n   * If the input has validation rules or not.\n   */\n  const hasValidation = ref<boolean>(\n    Array.isArray(node.props.parsedRules) && node.props.parsedRules.length > 0\n  )\n  node.on('prop:parsedRules', ({ payload: rules }) => {\n    hasValidation.value = Array.isArray(rules) && rules.length > 0\n  })\n\n  /**\n   * All messages that are currently on display to an end user. This changes\n   * based on the current message type visibility, like errorVisibility.\n   */\n  const messages = computed<Record<string, FormKitMessage>>(() => {\n    const visibleMessages: Record<string, FormKitMessage> = {}\n    for (const key in availableMessages) {\n      const message = availableMessages[key]\n      if (message.type !== 'validation' || validationVisible.value) {\n        visibleMessages[key] = message\n      }\n    }\n    return visibleMessages\n  })\n\n  /**\n   * UI Messages.\n   */\n  const ui = reactive(\n    node.store.reduce((messages, message) => {\n      if (message.type === 'ui' && message.visible)\n        messages[message.key] = message\n      return messages\n    }, {} as Record<string, FormKitMessage>)\n  )\n\n  const passing = computed<boolean>(() => !context.state.failing)\n\n  /**\n   * This is the reactive data object that is provided to all schemas and\n   * forms. It is a subset of data in the core node object.\n   */\n  const cachedClasses = reactive<Record<string, string>>({})\n  const classes = new Proxy(cachedClasses as Record<PropertyKey, string>, {\n    get(...args) {\n      if (!node) return ''\n      const [target, property] = args\n      let className: string | null = Reflect.get(...args)\n      if (!className && typeof property === 'string') {\n        if (!has(target, property) && !property.startsWith('__v')) {\n          const observedNode = createObserver(node)\n          observedNode.watch((node) => {\n            const rootClasses =\n              typeof node.config.rootClasses === 'function'\n                ? node.config.rootClasses(property, node)\n                : {}\n            const globalConfigClasses = node.config.classes\n              ? createClasses(property, node, node.config.classes[property])\n              : {}\n            const classesPropClasses = createClasses(\n              property,\n              node,\n              node.props[`_${property}Class`]\n            )\n            const sectionPropClasses = createClasses(\n              property,\n              node,\n              node.props[`${property}Class`]\n            )\n            className = generateClassList(\n              node,\n              property,\n              rootClasses,\n              globalConfigClasses,\n              classesPropClasses,\n              sectionPropClasses\n            )\n            target[property] = className ?? ''\n          })\n        }\n      }\n      return className\n    },\n  })\n\n  node.on('prop:rootClasses', () => {\n    const keys = Object.keys(cachedClasses)\n    for (const key of keys) {\n      delete cachedClasses[key]\n    }\n  })\n\n  const describedBy = computed<string | undefined>(() => {\n    if (!node) return undefined\n    const describers = []\n    if (context.help) {\n      describers.push(`help-${node.props.id}`)\n    }\n    for (const key in messages.value) {\n      describers.push(`${node.props.id}-${key}`)\n    }\n    return describers.length ? describers.join(' ') : undefined\n  })\n\n  const value = ref(node.value)\n  const _value = ref(node.value)\n\n  const context: FormKitFrameworkContext = reactive({\n    _value,\n    attrs: node.props.attrs,\n    disabled: node.props.disabled,\n    describedBy,\n    fns: {\n      length: (obj: Record<PropertyKey, any>) => Object.keys(obj).length,\n      number: (value: any) => Number(value),\n      string: (value: any) => String(value),\n      json: (value: any) => JSON.stringify(value),\n      eq,\n    },\n    handlers: {\n      blur: (e?: Event) => {\n        if (!node) return\n        node.store.set(\n          /* #__PURE__ */ createMessage({ key: 'blurred', visible: false, value: true })\n        )\n        if (typeof node.props.attrs.onBlur === 'function') {\n          node.props.attrs.onBlur(e)\n        }\n      },\n      touch: () => {\n        const doCompare = context.dirtyBehavior === 'compare'\n        if (node.store.dirty?.value && !doCompare) return\n        const isDirty = !eq(node.props._init, node._value)\n        if (!isDirty && !doCompare) return\n        node.store.set(\n          /* #__PURE__ */ createMessage({ key: 'dirty', visible: false, value: isDirty })\n        )\n      },\n      DOMInput: (e: Event) => {\n        node.input((e.target as HTMLInputElement).value)\n        node.emit('dom-input-event', e)\n      },\n    },\n    help: node.props.help,\n    id: node.props.id as string,\n    items,\n    label: node.props.label,\n    messages,\n    didMount: false,\n    node: markRaw(node),\n    options: node.props.options,\n    defaultMessagePlacement: true,\n    slots: node.props.__slots,\n    state: {\n      blurred: false,\n      complete: isComplete,\n      dirty: false,\n      empty: empty(value),\n      submitted: false,\n      settled: node.isSettled,\n      valid: isValid,\n      invalid: isInvalid,\n      errors: hasErrors,\n      rules: hasValidation,\n      validationVisible,\n      required: isRequired,\n      failing: false,\n      passing,\n    },\n    type: node.props.type,\n    family: node.props.family,\n    ui,\n    value,\n    classes,\n  })\n\n  /**\n   * Ensure the context object is properly configured after booting up.\n   */\n  node.on('created', () => {\n    if (!eq(context.value, node.value)) {\n      _value.value = node.value\n      value.value = node.value\n      triggerRef(value)\n      triggerRef(_value)\n    }\n    ;(async () => {\n      await node.settled\n      if (node) node.props._init = cloneAny(node.value)\n    })()\n  })\n\n  /**\n   * When the node mounts, set the didMount flag.\n   */\n  node.on('mounted', () => {\n    context.didMount = true\n  })\n\n  /**\n   * Sets the settled state.\n   */\n  node.on('settled', ({ payload: isSettled }) => {\n    context.state.settled = isSettled\n  })\n\n  /**\n   * Observes node.props properties explicitly and updates them in the context\n   * object.\n   * @param observe - Props to observe and register as context data.\n   */\n  function observeProps(observe: FormKitPseudoProps) {\n    const propNames = Array.isArray(observe) ? observe : Object.keys(observe)\n    propNames.forEach((prop) => {\n      prop = camel(prop)\n      if (!has(context, prop)) {\n        context[prop] = node.props[prop]\n      }\n      node.on(`prop:${prop}`, ({ payload }) => {\n        context[prop as keyof FormKitFrameworkContext] = payload\n      })\n    })\n  }\n\n  /**\n   * We use a node observer to individually observe node props.\n   */\n  const rootProps = () => {\n    const props = [\n      '__root',\n      'help',\n      'label',\n      'disabled',\n      'options',\n      'type',\n      'attrs',\n      'preserve',\n      'preserveErrors',\n      'id',\n      'dirtyBehavior',\n    ]\n    const iconPattern = /^[a-zA-Z-]+(?:-icon|Icon)$/\n    const matchingProps = Object.keys(node.props).filter((prop) => {\n      return iconPattern.test(prop)\n    })\n    return props.concat(matchingProps)\n  }\n  observeProps(rootProps())\n\n  /**\n   * Once the input is defined, deal with it.\n   * @param definition - Type definition.\n   */\n  function definedAs<V = unknown>(definition: FormKitTypeDefinition<V>) {\n    if (definition.props) observeProps(definition.props)\n  }\n\n  node.props.definition && definedAs(node.props.definition)\n\n  /**\n   * When new props are added to the core node as \"props\" (ie not attrs) then\n   * we automatically need to start tracking them here.\n   */\n  node.on('added-props', ({ payload }) => observeProps(payload))\n\n  /**\n   * Watch for input events from core.\n   */\n  node.on('input', ({ payload }) => {\n    if (node.type !== 'input' && !isRef(payload) && !isReactive(payload)) {\n      _value.value = shallowClone(payload)\n    } else {\n      _value.value = payload\n      triggerRef(_value)\n    }\n  })\n\n  /**\n   * Model updates from core. This is the raw value and should emitted as a\n   * model update even if the value did not update internally. Why? Because\n   * the model that created this event may have not be the same value as our\n   * internal value.\n   *\n   * See test: \"emits a modelUpdated event even when the value results in the\n   * same value\"\n   */\n  node.on('commitRaw', ({ payload }) => {\n    if (node.type !== 'input' && !isRef(payload) && !isReactive(payload)) {\n      value.value = _value.value = shallowClone(payload)\n    } else {\n      value.value = _value.value = payload\n      triggerRef(value)\n    }\n    node.emit('modelUpdated')\n  })\n\n  /**\n   * Watch for input commits from core.\n   */\n  node.on('commit', ({ payload }) => {\n    // The input is dirty after a value has been input by a user\n    if (\n      (!context.state.dirty || context.dirtyBehavior === 'compare') &&\n      node.isCreated &&\n      hasTicked\n    ) {\n      if (!node.store.validating?.value) {\n        context.handlers.touch()\n      } else {\n        const receipt = node.on('message-removed', ({ payload: message }) => {\n          if (message.key === 'validating') {\n            context.handlers.touch()\n            node.off(receipt)\n          }\n        })\n      }\n    }\n    if (\n      isComplete &&\n      node.type === 'input' &&\n      hasErrors.value &&\n      !undefine(node.props.preserveErrors)\n    ) {\n      node.store.filter(\n        (message) =>\n          !(message.type === 'error' && message.meta?.autoClear === true)\n      )\n    }\n    if (node.type === 'list' && node.sync) {\n      items.value = node.children.map((child) => child.uid)\n    }\n    context.state.empty = empty(payload)\n  })\n\n  /**\n   * Update the local state in response to messages.\n   * @param message - A formkit message\n   */\n  const updateState = async (message: FormKitMessage) => {\n    if (\n      message.type === 'ui' &&\n      message.visible &&\n      !message.meta.showAsMessage\n    ) {\n      ui[message.key] = message\n    } else if (message.visible) {\n      availableMessages[message.key] = message\n    } else if (message.type === 'state') {\n      context.state[message.key] = !!message.value\n    }\n  }\n\n  /**\n   * Listen to message events and modify the local message data values.\n   */\n  node.on('message-added', (e) => updateState(e.payload))\n  node.on('message-updated', (e) => updateState(e.payload))\n  node.on('message-removed', ({ payload: message }) => {\n    delete ui[message.key]\n    delete availableMessages[message.key]\n    delete context.state[message.key]\n  })\n  node.on('settled:blocking', () => {\n    isValid.value = true\n  })\n  node.on('unsettled:blocking', () => {\n    isValid.value = false\n  })\n  node.on('settled:errors', () => {\n    hasErrors.value = false\n  })\n  node.on('unsettled:errors', () => {\n    hasErrors.value = true\n  })\n\n  /**\n   * Watch the validation visible prop and set the hasShownErrors state.\n   */\n  watch(validationVisible, (value) => {\n    if (value) {\n      hasShownErrors.value = true\n    }\n  })\n\n  node.context = context\n\n  // The context is complete\n  node.emit('context', node, false)\n\n  node.on('destroyed', () => {\n    node.context = undefined\n    /* @ts-ignore */ // eslint-disable-line\n    node = null\n  })\n}\n\nexport default vueBindings\n","import { FormKitOptions, FormKitLibrary } from '@formkit/core'\nimport { extend } from '@formkit/utils'\nimport * as defaultRules from '@formkit/rules'\nimport {\n  createValidationPlugin,\n  FormKitValidationRule,\n} from '@formkit/validation'\nimport {\n  createI18nPlugin,\n  FormKitLocale,\n  FormKitLocaleRegistry,\n  en,\n} from '@formkit/i18n'\nimport { createLibraryPlugin, inputs as defaultInputs } from '@formkit/inputs'\nimport {\n  createThemePlugin,\n  FormKitIconLoader,\n  FormKitIconLoaderUrl,\n} from '@formkit/themes'\nimport bindings from './bindings'\nimport { register as decodeErrors } from '@formkit/dev'\n\n/**\n * Configuration for plugins\n *\n * @public\n */\nexport interface PluginConfigs {\n  rules: Record<string, FormKitValidationRule>\n  locales: FormKitLocaleRegistry\n  inputs: FormKitLibrary\n  messages: Record<string, Partial<FormKitLocale>>\n  locale: string\n  theme: string\n  iconLoaderUrl: FormKitIconLoaderUrl\n  iconLoader: FormKitIconLoader\n  icons: Record<string, string | undefined>\n}\n\n/**\n * The allowed options for defaultConfig.\n *\n * @public\n */\nexport type DefaultConfigOptions = FormKitOptions &\n  Partial<PluginConfigs> &\n  Record<string, unknown>\n\n/**\n * Default configuration options. Includes all validation rules,\n * en i18n messages.\n *\n * @public\n */\nexport const defaultConfig = (\n  options: DefaultConfigOptions = {}\n): FormKitOptions => {\n  decodeErrors()\n  const {\n    rules = {},\n    locales = {},\n    inputs = {},\n    messages = {},\n    locale = undefined,\n    theme = undefined,\n    iconLoaderUrl = undefined,\n    iconLoader = undefined,\n    icons = {},\n    ...nodeOptions\n  } = options\n  /**\n   * The default configuration includes the validation plugin,\n   * with all core-available validation rules.\n   */\n  const validation = createValidationPlugin({\n    ...defaultRules,\n    ...(rules || {}),\n  })\n\n  /**\n   * Includes the i18n plugin with only the english language\n   * messages.\n   */\n  const i18n = createI18nPlugin(\n    extend({ en, ...(locales || {}) }, messages) as FormKitLocaleRegistry\n  )\n\n  /**\n   * Create the library of inputs that are generally available. This default\n   * config imports all \"native\" inputs by default, but\n   */\n  const library = createLibraryPlugin(defaultInputs, inputs)\n\n  /**\n   * Create the theme plugin for the user provided theme\n   */\n  const themePlugin = createThemePlugin(theme, icons, iconLoaderUrl, iconLoader)\n\n  return extend(\n    {\n      plugins: [library, themePlugin, bindings, i18n, validation],\n      ...(!locale ? {} : { config: { locale } }),\n    },\n    nodeOptions || {},\n    true\n  ) as FormKitOptions\n}\n","import { error, FormKitNode, FormKitSchemaDefinition } from '@formkit/core'\nimport {\n  h,\n  ref,\n  defineComponent,\n  InjectionKey,\n  ConcreteComponent,\n  VNode,\n  RendererNode,\n  RendererElement,\n  SetupContext,\n  RenderFunction,\n  VNodeProps,\n  AllowedComponentProps,\n  ComponentCustomProps,\n  markRaw,\n} from 'vue'\nimport { useInput } from './composables/useInput'\nimport { FormKitSchema } from './FormKitSchema'\nimport {\n  FormKitInputs,\n  FormKitInputSlots,\n  FormKitEvents,\n  InputType,\n  runtimeProps,\n} from '@formkit/inputs'\nimport { getCurrentInstance } from 'vue'\n\n/**\n * The type definition for the FormKit’s slots, this is not intended to be used\n * directly.\n * @public\n */\nexport type Slots<Props extends FormKitInputs<Props>> =\n  InputType<Props> extends keyof FormKitInputSlots<Props>\n    ? FormKitInputSlots<Props>[InputType<Props>]\n    : {}\n\n/**\n * The TypeScript definition for the FormKit component.\n * @public\n */\nexport type FormKitComponent = <Props extends FormKitInputs<Props>>(\n  props: Props & VNodeProps & AllowedComponentProps & ComponentCustomProps,\n  context?: Pick<FormKitSetupContext<Props>, 'attrs' | 'emit' | 'slots'>,\n  setup?: FormKitSetupContext<Props>\n) => VNode<\n  RendererNode,\n  RendererElement,\n  {\n    [key: string]: any\n  }\n> & { __ctx?: FormKitSetupContext<Props> }\n\n/**\n * Type definition for the FormKit component Vue context.\n * @public\n */\nexport interface FormKitSetupContext<Props extends FormKitInputs<Props>> {\n  props: {} & Props\n  expose(exposed: {}): void\n  attrs: any\n  slots: Slots<Props>\n  emit: FormKitEvents<Props>\n}\n\n/**\n * Flag to determine if we are running on the server.\n */\nconst isServer = typeof window === 'undefined'\n\n/**\n * The symbol that represents the formkit parent injection value.\n *\n * @public\n */\nexport const parentSymbol: InjectionKey<FormKitNode> = Symbol('FormKitParent')\n\n/**\n * The symbol that represents the formkit component callback injection value.\n * This is used by tooling to know which component \"owns\" this node — some\n * effects are linked to that component, for example, hot module reloading.\n *\n * @internal\n */\nexport const componentSymbol: InjectionKey<(node: FormKitNode) => void> =\n  Symbol('FormKitComponentCallback')\n\n/**\n * This variable is set to the node that is currently having its schema created.\n *\n * @internal\n */\nlet currentSchemaNode: FormKitNode | null = null\n\n/**\n * Returns the node that is currently having its schema created.\n *\n * @public\n */\nexport const getCurrentSchemaNode = () => currentSchemaNode\n/**\n * The actual runtime setup function for the FormKit component.\n *\n * @param props - The props passed to the component.\n * @param context - The context passed to the component.\n */\nfunction FormKit<Props extends FormKitInputs<Props>>(\n  props: Props,\n  context: SetupContext<{}, {}>\n): RenderFunction {\n  const node = useInput<Props, any>(props, context)\n  if (!node.props.definition) error(600, node)\n  if (node.props.definition.component) {\n    return () =>\n      h(\n        node.props.definition?.component as any,\n        {\n          context: node.context,\n        },\n        { ...context.slots }\n      )\n  }\n  if (false && import.meta.hot) {\n    const instance = getCurrentInstance()\n    let initPreserve: boolean | undefined\n    import.meta.hot?.on('vite:beforeUpdate', () => {\n      initPreserve = node.props.preserve\n      node.props.preserve = true\n    })\n    import.meta.hot?.on('vite:afterUpdate', () => {\n      instance?.proxy?.$forceUpdate()\n      node.props.preserve = initPreserve\n    })\n  }\n  const schema = ref<FormKitSchemaDefinition>([])\n  let memoKey: string | undefined = node.props.definition.schemaMemoKey\n  const generateSchema = () => {\n    const schemaDefinition = node.props?.definition?.schema\n    if (!schemaDefinition) error(601, node)\n    if (typeof schemaDefinition === 'function') {\n      currentSchemaNode = node\n      schema.value = schemaDefinition({ ...(props.sectionsSchema || {}) })\n      currentSchemaNode = null\n      if (\n        (memoKey && props.sectionsSchema) ||\n        ('memoKey' in schemaDefinition &&\n          typeof schemaDefinition.memoKey === 'string')\n      ) {\n        memoKey =\n          (memoKey ?? schemaDefinition?.memoKey) +\n          JSON.stringify(props.sectionsSchema)\n      }\n    } else {\n      schema.value = schemaDefinition\n    }\n  }\n  generateSchema()\n\n  // If someone emits the schema event, we re-generate the schema\n  if (!isServer) {\n    node.on('schema', () => {\n      memoKey += '♻️'\n      generateSchema()\n    })\n  }\n\n  context.emit('node', node)\n  const definitionLibrary = node.props.definition.library as\n    | Record<string, ConcreteComponent>\n    | undefined\n\n  const library = {\n    FormKit: markRaw(formkitComponent),\n    ...definitionLibrary,\n    ...(props.library ?? {}),\n  }\n\n  /**\n   * Emit the mounted event.\n   */\n  function didMount() {\n    node.emit('mounted')\n  }\n\n  // // Expose the FormKitNode to template refs.\n  context.expose({ node })\n  return () =>\n    h(\n      FormKitSchema,\n      {\n        schema: schema.value,\n        data: node.context,\n        onMounted: didMount,\n        library,\n        memoKey,\n      },\n      { ...context.slots }\n    )\n}\n\n/**\n * The root FormKit component. Use it to craft all inputs and structure of your\n * forms. For example:\n *\n * ```vue\n * <FormKit\n *  type=\"text\"\n *  label=\"Name\"\n *  help=\"Please enter your name\"\n *  validation=\"required|length:2\"\n * />\n * ```\n *\n * @public\n */\nexport const formkitComponent = /* #__PURE__ */ defineComponent(\n  FormKit as any,\n  {\n    props: runtimeProps as any,\n    inheritAttrs: false,\n  }\n) as unknown as FormKitComponent\n\n// ☝️ We need to cheat here a little bit since our runtime props and our\n// public prop interface are different (we treat some attrs as props to allow\n// for runtime \"prop\" creation).\n\nexport default formkitComponent\n","import {\n  Component,\n  PropType,\n  RendererElement,\n  RendererNode,\n  VNode,\n  createTextVNode,\n  defineComponent,\n  h,\n  ref,\n  isRef,\n  reactive,\n  resolveComponent,\n  watchEffect,\n  watch,\n  Ref,\n  getCurrentInstance,\n  ConcreteComponent,\n  onUnmounted,\n  markRaw,\n  onMounted,\n} from 'vue'\nimport { has, isPojo } from '@formkit/utils'\nimport {\n  FormKitSchemaAttributes,\n  FormKitSchemaNode,\n  isDOM,\n  isConditional,\n  isComponent,\n  compile,\n  FormKitSchemaCondition,\n  FormKitSchemaAttributesCondition,\n  FormKitAttributeValue,\n  FormKitCompilerOutput,\n  FormKitSchemaDefinition,\n  getNode,\n  warn,\n  watchRegistry,\n  isNode,\n  sugar,\n} from '@formkit/core'\nimport { onSSRComplete } from './composables/onSSRComplete'\nimport FormKit from './FormKit'\n\n/**\n * A simple flag to tell if we are running on the server or not.\n */\nconst isServer = typeof window === 'undefined'\n\n/**\n * A library of components available to the schema (in addition to globally\n * registered ones)\n *\n * @public\n */\nexport interface FormKitComponentLibrary {\n  [index: string]: Component\n}\n\n/**\n * Defines the structure a parsed node.\n */\ntype RenderContent = [\n  condition: false | (() => boolean | number | string),\n  element: string | Component | null,\n  attrs: () => FormKitSchemaAttributes,\n  children: RenderChildren | null,\n  alternate: RenderChildren | null,\n  iterator:\n    | null\n    | [\n        getNodeValues: () =>\n          | number\n          | string\n          | boolean\n          | any[]\n          | Record<string, any>,\n        valueName: string,\n        keyName: string | null\n      ],\n  resolve: boolean\n]\n/**\n * The actual signature of a VNode in Vue.\n *\n * @public\n */\nexport type VirtualNode = VNode<\n  RendererNode,\n  RendererElement,\n  { [key: string]: any }\n>\n/**\n * The types of values that can be rendered by Vue.\n *\n * @public\n */\nexport type Renderable = null | string | number | boolean | VirtualNode\n/**\n * A list of renderable items.\n *\n * @public\n */\nexport type RenderableList =\n  | Renderable\n  | Renderable[]\n  | (Renderable | Renderable[])[]\n\n/**\n * An object of slots\n *\n * @public\n */\nexport type RenderableSlots = Record<string, RenderableSlot>\n\n/**\n * A slot function that can be rendered.\n *\n * @public\n */\nexport type RenderableSlot = (\n  data?: Record<string, any>,\n  key?: object\n) => RenderableList\n/**\n * Describes renderable children.\n */\ninterface RenderChildren {\n  (iterationData?: Record<string, unknown>): RenderableList | RenderableSlots\n  slot?: boolean\n}\n\n/**\n * The format children elements can be in.\n */\ninterface RenderNodes {\n  (iterationData?: Record<string, unknown>): Renderable | Renderable[]\n}\n\ninterface SchemaProvider {\n  (\n    providerCallback: SchemaProviderCallback,\n    instanceKey: object\n  ): RenderChildren\n}\n\ntype SchemaProviderCallback = (\n  requirements: string[],\n  hints?: Record<string, boolean>\n) => Record<string, () => any>\n\ntype ProviderRegistry = ((\n  providerCallback: SchemaProviderCallback,\n  key: object\n) => void)[]\n\n/**\n * A registry of memoized schemas (in JSON) to their respective render function\n * and provider registry.\n */\nconst memo: Record<string, [RenderChildren, ProviderRegistry]> = {}\n\n/**\n * A map of memoized keys to how many instances of that memo are currently in\n * use.\n */\nconst memoKeys: Record<string, number> = {}\n\n/**\n * This object represents the current component instance during render. It is\n * critical for linking the current instance to the data required for render.\n */\nlet instanceKey: object\n\n/**\n * A registry of scoped data produced during runtime that is keyed by the\n * instance object. For example data from: for-loop instances and slot data.\n */\n// NOTE: This is a hack to get around the fact that the TS compiler doesn't\n// understand WeakMap's allowing us to use a object as a keys, see:\n// https://github.com/microsoft/TypeScript/issues/52534\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\nconst instanceScopes = new WeakMap<object, Record<string, any>[]>()\n\n/**\n * Indicates the a section of the schema is raw.\n */\nconst raw = '__raw__'\n\n/**\n * Is a class prop.\n */\nconst isClassProp = /[a-zA-Z0-9\\-][cC]lass$/\n\n/**\n * Returns a reference as a placeholder to a specific location on an object.\n * @param data - A reactive data object\n * @param token - A dot-syntax string representing the object path\n * @returns\n */\nfunction getRef(\n  token: string,\n  data: Record<string, any> | Ref<Record<string, any>>\n): Ref<unknown> {\n  const value = ref<any>(null)\n  if (token === 'get') {\n    const nodeRefs: Record<string, Ref<unknown>> = {}\n    value.value = get.bind(null, nodeRefs)\n    return value\n  }\n  const path = token.split('.')\n  watchEffect(() => {\n    value.value = getValue(\n      isRef<Record<string, any>>(data) ? data.value : data,\n      path\n    )\n  })\n  return value\n}\n\n/**\n * Returns a value inside a set of data objects.\n * @param sets - An array of objects to search through\n * @param path - A array of string paths easily produced by split()\n * @returns\n */\nfunction getValue(\n  set: (false | Record<string, any>)[] | Record<string, any>,\n  path: string[]\n): any {\n  if (Array.isArray(set)) {\n    for (const subset of set) {\n      const value = subset !== false && getValue(subset, path)\n      if (value !== undefined) return value\n    }\n    return undefined\n  }\n  let foundValue: any = undefined\n\n  let obj: unknown = set\n  for (const i in path) {\n    const key = path[i]\n    if (typeof obj !== 'object' || obj === null) {\n      foundValue = undefined\n      break\n    }\n    const currentValue: unknown = (obj as Record<string, any>)[key]\n    if (Number(i) === path.length - 1 && currentValue !== undefined) {\n      // When the value is a function, we need to bind the `this` value\n      // before providing this back to the compiler.\n      foundValue =\n        typeof currentValue === 'function'\n          ? currentValue.bind(obj)\n          : currentValue\n      break\n    }\n    obj = currentValue\n  }\n  return foundValue\n}\n\n/**\n * Get the node from the global registry\n * @param id - A dot-syntax string where the node is located.\n */\nfunction get(nodeRefs: Record<string, Ref<unknown>>, id?: string) {\n  if (typeof id !== 'string') return warn(650)\n  if (!(id in nodeRefs)) nodeRefs[id] = ref<unknown>(undefined)\n  if (nodeRefs[id].value === undefined) {\n    nodeRefs[id].value = null\n    const root = getNode(id)\n    if (root) nodeRefs[id].value = root.context\n    watchRegistry(id, ({ payload: node }) => {\n      nodeRefs[id].value = isNode(node) ? node.context : node\n    })\n  }\n  return nodeRefs[id].value\n}\n\n/**\n *\n * @param library - A library of concrete components to use\n * @param schema -\n * @returns\n */\nfunction parseSchema(\n  library: FormKitComponentLibrary,\n  schema: FormKitSchemaNode | FormKitSchemaNode[],\n  memoKey?: string\n): SchemaProvider {\n  /**\n   * Given an if/then/else schema node, pre-compile the node and return the\n   * artifacts for the render function.\n   * @param data - The schema context object\n   * @param library - The available components\n   * @param node - The node to parse\n   */\n  function parseCondition(\n    library: FormKitComponentLibrary,\n    node: FormKitSchemaCondition\n  ): [RenderContent[0], RenderContent[3], RenderContent[4]] {\n    const condition = provider(compile(node.if), { if: true })\n    const children = createElements(library, node.then)\n    const alternate = node.else ? createElements(library, node.else) : null\n    return [condition, children, alternate]\n  }\n\n  /**\n   * Parses a conditional if/then/else attribute statement.\n   * @param data - The data object\n   * @param attr - The attribute\n   * @param _default - The default value\n   * @returns\n   */\n  function parseConditionAttr(\n    attr: FormKitSchemaAttributesCondition,\n    _default: FormKitAttributeValue\n  ): () => FormKitAttributeValue | FormKitSchemaAttributes {\n    const condition = provider(compile(attr.if))\n    let b: () => FormKitAttributeValue = () => _default\n    let a: () => FormKitAttributeValue = () => _default\n\n    if (typeof attr.then === 'object') {\n      a = parseAttrs(attr.then, undefined)\n    } else if (typeof attr.then === 'string' && attr.then?.startsWith('$')) {\n      a = provider(compile(attr.then))\n    } else {\n      a = () => attr.then\n    }\n\n    if (has(attr, 'else')) {\n      if (typeof attr.else === 'object') {\n        b = parseAttrs(attr.else)\n      } else if (typeof attr.else === 'string' && attr.else?.startsWith('$')) {\n        b = provider(compile(attr.else))\n      } else {\n        b = () => attr.else\n      }\n    }\n    return () => (condition() ? a() : b())\n  }\n\n  /**\n   * Parse attributes for dynamic content.\n   * @param attrs - Object of attributes\n   * @returns\n   */\n  function parseAttrs(\n    unparsedAttrs?: FormKitSchemaAttributes | FormKitSchemaAttributesCondition,\n    bindExp?: string,\n    _default = {}\n  ): () => FormKitSchemaAttributes {\n    const explicitAttrs = new Set(Object.keys(unparsedAttrs || {}))\n    const boundAttrs = bindExp ? provider(compile(bindExp)) : () => ({})\n    const staticAttrs: FormKitSchemaAttributes = {}\n    const setters: Array<(obj: Record<string, any>) => void> = [\n      (attrs) => {\n        const bound: Record<string, any> = boundAttrs()\n        for (const attr in bound) {\n          if (!explicitAttrs.has(attr)) {\n            attrs[attr] = bound[attr]\n          }\n        }\n      },\n    ]\n    if (unparsedAttrs) {\n      if (isConditional(unparsedAttrs)) {\n        // This is a root conditional object that must produce an object of\n        // attributes.\n        const condition = parseConditionAttr(\n          unparsedAttrs,\n          _default\n        ) as () => FormKitSchemaAttributes\n        return condition\n      }\n      // Some attributes are explicitly bound, we need to parse those ones\n      // using the compiler and create a dynamic \"setter\".\n      for (let attr in unparsedAttrs) {\n        const value = unparsedAttrs[attr]\n        let getValue: () => any\n        const isStr = typeof value === 'string'\n\n        if (attr.startsWith(raw)) {\n          // attributes prefixed with __raw__ should not be parsed\n          attr = attr.substring(7)\n          getValue = () => value\n        } else if (\n          isStr &&\n          value.startsWith('$') &&\n          value.length > 1 &&\n          !(value.startsWith('$reset') && isClassProp.test(attr))\n        ) {\n          // Most attribute values starting with $ should be compiled\n          // -class attributes starting with `$reset` should not be compiled\n          getValue = provider(compile(value))\n        } else if (typeof value === 'object' && isConditional(value)) {\n          // Conditional attrs require further processing\n          getValue = parseConditionAttr(value, undefined)\n        } else if (typeof value === 'object' && isPojo(value)) {\n          // Sub-parse pojos\n          getValue = parseAttrs(value)\n        } else {\n          // In all other cases, the value is static\n          getValue = () => value\n          staticAttrs[attr] = value\n        }\n        setters.push((attrs) => {\n          attrs[attr] = getValue()\n        })\n      }\n    }\n    return () => {\n      const attrs = Array.isArray(unparsedAttrs) ? [] : {}\n      setters.forEach((setter) => setter(attrs))\n      return attrs\n    }\n  }\n\n  /**\n   * Given a single schema node, parse it and extract the value.\n   * @param data - A state object provided to each node\n   * @param node - The schema node being parsed\n   * @returns\n   */\n  function parseNode(\n    library: FormKitComponentLibrary,\n    _node: FormKitSchemaNode\n  ): RenderContent {\n    let element: RenderContent[1] = null\n    let attrs: () => FormKitSchemaAttributes = () => null\n    let condition: false | (() => boolean | number | string) = false\n    let children: RenderContent[3] = null\n    let alternate: RenderContent[4] = null\n    let iterator: RenderContent[5] = null\n    let resolve = false\n    const node = sugar(_node)\n    if (isDOM(node)) {\n      // This is an actual HTML DOM element\n      element = node.$el\n      attrs =\n        node.$el !== 'text' ? parseAttrs(node.attrs, node.bind) : () => null\n    } else if (isComponent(node)) {\n      // This is a Vue Component\n      if (typeof node.$cmp === 'string') {\n        if (has(library, node.$cmp)) {\n          element = library[node.$cmp]\n        } else {\n          element = node.$cmp\n          resolve = true\n        }\n      } else {\n        // in this case it must be an actual component\n        element = node.$cmp\n      }\n      attrs = parseAttrs(node.props, node.bind)\n    } else if (isConditional(node)) {\n      // This is an if/then schema statement\n      ;[condition, children, alternate] = parseCondition(library, node)\n    }\n\n    // This is the same as a \"v-if\" statement — not an if/else statement\n    if (!isConditional(node) && 'if' in node) {\n      condition = provider(compile(node.if as string))\n    } else if (!isConditional(node) && element === null) {\n      // In this odd case our element is actually a partial and\n      // we only want to render the children.\n      condition = () => true\n    }\n\n    // Compile children down to a function\n    if ('children' in node && node.children) {\n      if (typeof node.children === 'string') {\n        // We are dealing with a raw string value\n        if (node.children.startsWith('$slots.')) {\n          // this is a lone text node, turn it into a slot\n          element = element === 'text' ? 'slot' : element\n          children = provider(compile(node.children))\n        } else if (node.children.startsWith('$') && node.children.length > 1) {\n          const value = provider(compile(node.children))\n          children = () => String(value())\n        } else {\n          children = () => String(node.children)\n        }\n      } else if (Array.isArray(node.children)) {\n        // We are dealing with node sub-children\n        children = createElements(library, node.children)\n      } else {\n        // This is a conditional if/else clause\n        const [childCondition, c, a] = parseCondition(library, node.children)\n        children = (iterationData?: Record<string, unknown>) =>\n          childCondition && childCondition()\n            ? c && c(iterationData)\n            : a && a(iterationData)\n      }\n    }\n\n    if (isComponent(node)) {\n      if (children) {\n        // Children of components need to be provided as an object of slots\n        // so we provide an object with the default slot provided as children.\n        // We also create a new scope for this default slot, and then on each\n        // render pass the scoped slot props to the scope.\n        const produceChildren = children\n        children = (iterationData?: Record<string, unknown>) => {\n          return {\n            default(\n              slotData?: Record<string, any>,\n              key?: object\n            ): RenderableList {\n              // We need to switch the current instance key back to the one that\n              // originally called this component's render function.\n              const currentKey = instanceKey\n              if (key) instanceKey = key\n              if (slotData) instanceScopes.get(instanceKey)?.unshift(slotData)\n              if (iterationData)\n                instanceScopes.get(instanceKey)?.unshift(iterationData)\n              const c = produceChildren(iterationData)\n              // Ensure our instance key never changed during runtime\n              if (slotData) instanceScopes.get(instanceKey)?.shift()\n              if (iterationData) instanceScopes.get(instanceKey)?.shift()\n              instanceKey = currentKey\n              return c as RenderableList\n            },\n          }\n        }\n        children.slot = true\n      } else {\n        // If we dont have any children, we still need to provide an object\n        // instead of an empty array (which raises a warning in vue)\n        children = () => ({})\n      }\n    }\n\n    // Compile the for loop down\n    if ('for' in node && node.for) {\n      const values = node.for.length === 3 ? node.for[2] : node.for[1]\n      const getValues =\n        typeof values === 'string' && values.startsWith('$')\n          ? provider(compile(values))\n          : () => values\n      iterator = [\n        getValues,\n        node.for[0],\n        node.for.length === 3 ? String(node.for[1]) : null,\n      ]\n    }\n    return [condition, element, attrs, children, alternate, iterator, resolve]\n  }\n\n  /**\n   * Given a particular function that produces children, ensure that the second\n   * argument of all these slots is the original instance key being used to\n   * render the slots.\n   * @param children - The children() function that will produce slots\n   */\n  function createSlots(\n    children: RenderChildren,\n    iterationData?: Record<string, unknown>\n  ): RenderableSlots | null {\n    const slots = children(iterationData) as RenderableSlots\n    const currentKey = instanceKey\n    return Object.keys(slots).reduce((allSlots, slotName) => {\n      const slotFn = slots && slots[slotName]\n      allSlots[slotName] = (data?: Record<string, any>) => {\n        return (slotFn && slotFn(data, currentKey)) || null\n      }\n      return allSlots\n    }, {} as RenderableSlots)\n  }\n\n  /**\n   * Creates an element\n   * @param data - The context data available to the node\n   * @param node - The schema node to render\n   * @returns\n   */\n  function createElement(\n    library: FormKitComponentLibrary,\n    node: FormKitSchemaNode\n  ): RenderNodes {\n    // Parses the schema node into pertinent parts\n    const [condition, element, attrs, children, alternate, iterator, resolve] =\n      parseNode(library, node)\n    // This is a sub-render function (called within a render function). It must\n    // only use pre-compiled features, and be organized in the most efficient\n    // manner possible.\n    let createNodes: RenderNodes = ((\n      iterationData?: Record<string, unknown>\n    ) => {\n      if (condition && element === null && children) {\n        // Handle conditional if/then statements\n        return condition()\n          ? children(iterationData)\n          : alternate && alternate(iterationData)\n      }\n\n      if (element && (!condition || condition())) {\n        // handle text nodes\n        if (element === 'text' && children) {\n          return createTextVNode(String(children()))\n        }\n        // Handle lone slots\n        if (element === 'slot' && children) return children(iterationData)\n        // Handle resolving components\n        const el = resolve ? resolveComponent(element as string) : element\n        // If we are rendering slots as children, ensure their instanceKey is properly added\n        const slots: RenderableSlots | null = children?.slot\n          ? createSlots(children, iterationData)\n          : null\n        // Handle dom elements and components\n        return h(\n          el as ConcreteComponent,\n          attrs(),\n          (slots || (children ? children(iterationData) : [])) as Renderable[]\n        )\n      }\n\n      return typeof alternate === 'function'\n        ? alternate(iterationData)\n        : alternate\n    }) as RenderNodes\n\n    if (iterator) {\n      const repeatedNode = createNodes\n      const [getValues, valueName, keyName] = iterator\n      createNodes = (() => {\n        const _v = getValues()\n        const values = Number.isFinite(_v)\n          ? Array(Number(_v))\n              .fill(0)\n              .map((_, i) => i)\n          : _v\n        const fragment = []\n        if (typeof values !== 'object') return null\n        const instanceScope = instanceScopes.get(instanceKey) || []\n        const isArray = Array.isArray(values)\n        for (const key in values) {\n          if (isArray && key in Array.prototype) continue // Fix #299\n          const iterationData: Record<string, unknown> = Object.defineProperty(\n            {\n              ...instanceScope.reduce(\n                (\n                  previousIterationData: Record<string, undefined>,\n                  scopedData: Record<string, undefined>\n                ) => {\n                  if (previousIterationData.__idata) {\n                    return { ...previousIterationData, ...scopedData }\n                  }\n                  return scopedData\n                },\n                {} as Record<string, undefined>\n              ),\n              [valueName]: (values as Record<string, any>)[key],\n              ...(keyName !== null\n                ? { [keyName]: isArray ? Number(key) : key }\n                : {}),\n            },\n            '__idata',\n            { enumerable: false, value: true }\n          )\n          instanceScope.unshift(iterationData)\n          fragment.push(repeatedNode.bind(null, iterationData)())\n          instanceScope.shift()\n        }\n        return fragment\n      }) as RenderNodes\n    }\n    return createNodes as RenderNodes\n  }\n\n  /**\n   * Given a schema, parse it and return the resulting renderable nodes.\n   * @param data - The schema context object\n   * @param library - The available components\n   * @param node - The node to parse\n   * @returns\n   */\n  function createElements(\n    library: FormKitComponentLibrary,\n    schema: FormKitSchemaNode | FormKitSchemaNode[]\n  ): RenderChildren {\n    if (Array.isArray(schema)) {\n      const els = schema.map(createElement.bind(null, library))\n      return (iterationData?: Record<string, unknown>) =>\n        els.map((element) => element(iterationData))\n    }\n    // Single node to render\n    const element = createElement(library, schema)\n    return (iterationData?: Record<string, unknown>) => element(iterationData)\n  }\n\n  /**\n   * Data providers produced as a result of the compiler.\n   */\n  const providers: ProviderRegistry = []\n\n  /**\n   * Append the requisite compiler provider and return the compiled function.\n   * @param compiled - A compiled function\n   * @returns\n   */\n  function provider(\n    compiled: FormKitCompilerOutput,\n    hints: Record<string, boolean> = {}\n  ) {\n    const compiledFns = new WeakMap<object, FormKitCompilerOutput>()\n    providers.push((callback: SchemaProviderCallback, key: object) => {\n      compiledFns.set(\n        key,\n        compiled.provide((tokens) => callback(tokens, hints))\n      )\n    })\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return () => compiledFns.get(instanceKey)!()\n  }\n\n  /**\n   * Creates a new instance of a given schema — this either comes from a\n   * memoized copy of the parsed schema or a freshly parsed version. An object\n   * instance key, and dataProvider functions are passed in.\n   * @param providerCallback - A function that is called for each required provider\n   * @param key - a object representing the current instance\n   */\n  function createInstance(\n    providerCallback: SchemaProviderCallback,\n    key: object\n  ) {\n    memoKey ??= toMemoKey(schema)\n    const [render, compiledProviders] = has(memo, memoKey)\n      ? memo[memoKey]\n      : [createElements(library, schema), providers]\n\n    if (!isServer) {\n      memoKeys[memoKey] ??= 0\n      memoKeys[memoKey]++\n      memo[memoKey] = [render, compiledProviders]\n    }\n\n    compiledProviders.forEach((compiledProvider) => {\n      compiledProvider(providerCallback, key)\n    })\n    return () => {\n      // Set the instance key for this pass of rendering.\n      instanceKey = key\n      return render()\n    }\n  }\n  return createInstance\n}\n\n/**\n * Checks the current runtime scope for data.\n * @param token - The token to lookup in the current scope\n * @param defaultValue - The default ref value to use if no scope is found.\n */\nfunction useScope(token: string, defaultValue: any) {\n  const scopedData = instanceScopes.get(instanceKey) || []\n  let scopedValue: any = undefined\n  if (scopedData.length) {\n    scopedValue = getValue(scopedData, token.split('.'))\n  }\n  return scopedValue === undefined ? defaultValue : scopedValue\n}\n\n/**\n * Get the current scoped data and flatten it.\n */\nfunction slotData(data: Record<string, any>, key: object) {\n  return new Proxy(data, {\n    get(...args) {\n      let data: any = undefined\n      const property = args[1]\n      if (typeof property === 'string') {\n        const prevKey = instanceKey\n        instanceKey = key\n        data = useScope(property, undefined)\n        instanceKey = prevKey\n      }\n      return data !== undefined ? data : Reflect.get(...args)\n    },\n  })\n}\n\n/**\n * Provides data to a parsed schema.\n * @param provider - The SchemaProvider (output of calling parseSchema)\n * @param data - Data to fetch values from\n * @returns\n */\nfunction createRenderFn(\n  instanceCreator: SchemaProvider,\n  data: Record<string, any>,\n  instanceKey: object\n) {\n  return instanceCreator(\n    (requirements, hints: Record<string, boolean> = {}) => {\n      return requirements.reduce((tokens, token) => {\n        if (token.startsWith('slots.')) {\n          const slot = token.substring(6)\n          const hasSlot = () =>\n            data.slots &&\n            has(data.slots, slot) &&\n            typeof data.slots[slot] === 'function'\n          if (hints.if) {\n            // If statement — dont render the slot, check if it exists\n            tokens[token] = hasSlot\n          } else if (data.slots) {\n            // Render the slot with current scope data\n            const scopedData = slotData(data, instanceKey)\n            tokens[token] = () =>\n              hasSlot() ? data.slots[slot](scopedData) : null\n          }\n        } else {\n          const value = getRef(token, data)\n          tokens[token] = () => useScope(token, value.value)\n        }\n        return tokens\n      }, {} as Record<string, any>)\n    },\n    instanceKey\n  )\n}\n\n/**\n * Removes the schema from the memo and cleans up the instance scope.\n * @param schema - The schema to remove from memo.\n * @param instanceKey - The instance key to remove.\n */\nfunction clean(\n  schema: FormKitSchemaDefinition,\n  memoKey: string | undefined,\n  instanceKey: object\n) {\n  memoKey ??= toMemoKey(schema)\n  memoKeys[memoKey]--\n  if (memoKeys[memoKey] === 0) {\n    delete memoKeys[memoKey]\n    const [, providers] = memo[memoKey]\n    delete memo[memoKey]\n    providers.length = 0\n  }\n  instanceScopes.delete(instanceKey)\n}\n\n/**\n * Convert a schema to a memo key.\n * @param schema - A schema to convert to a memo key\n */\nfunction toMemoKey(schema: FormKitSchemaDefinition) {\n  return JSON.stringify(schema, (_, value) => {\n    // Technically there shouldn’t be any functions in here, but just in case\n    // we want to sniff them out and convert them to strings\n    // See: https://github.com/formkit/formkit/issues/933\n    if (typeof value === 'function') {\n      return value.toString()\n    }\n    return value\n  })\n}\n\n/**\n * The FormKitSchema vue component:\n *\n * @public\n */\nexport const FormKitSchema = /* #__PURE__ */ defineComponent({\n  name: 'FormKitSchema',\n  props: {\n    schema: {\n      type: [Array, Object] as PropType<FormKitSchemaDefinition>,\n      required: true,\n    },\n    data: {\n      type: Object as PropType<Record<string, any>>,\n      default: () => ({}),\n    },\n    library: {\n      type: Object as PropType<FormKitComponentLibrary>,\n      default: () => ({}),\n    },\n    memoKey: {\n      type: String,\n      required: false,\n    },\n  },\n  emits: ['mounted'],\n  setup(props, context) {\n    const instance = getCurrentInstance()\n    let instanceKey = {}\n    instanceScopes.set(instanceKey, [])\n    const library = { FormKit: markRaw(FormKit), ...props.library }\n    let provider = parseSchema(library, props.schema, props.memoKey)\n    let render: RenderChildren\n    let data: Record<string, any>\n    // // Re-parse the schema if it changes:\n    if (!isServer) {\n      watch(\n        () => props.schema,\n        (newSchema, oldSchema) => {\n          const oldKey = instanceKey\n          instanceKey = {}\n          instanceScopes.set(instanceKey, [])\n          provider = parseSchema(library, props.schema, props.memoKey)\n          render = createRenderFn(provider, data, instanceKey)\n          if (newSchema === oldSchema) {\n            // In this edge case, someone pushed/modified something in the schema\n            // and we've successfully re-parsed, but since the schema is not\n            // referenced in the render function it technically isnt a dependency\n            // and we need to force a re-render since we swapped out the render\n            // function completely.\n            ;(instance?.proxy?.$forceUpdate as unknown as CallableFunction)()\n          }\n          clean(props.schema, props.memoKey, oldKey)\n        },\n        { deep: true }\n      )\n    }\n\n    // // Watch the data object explicitly\n    watchEffect(() => {\n      data = Object.assign(reactive(props.data ?? {}), {\n        slots: context.slots,\n      })\n      context.slots\n      render = createRenderFn(provider, data, instanceKey)\n    })\n\n    /**\n     * Perform cleanup operations when the component is unmounted. This should\n     * remove any memory allocations that were made during the render process.\n     */\n    function cleanUp() {\n      // Perform cleanup operations\n      clean(props.schema, props.memoKey, instanceKey)\n      /* eslint-disable @typescript-eslint/no-non-null-assertion */\n      if (data) {\n        if (data.node) data.node.destroy()\n        data.slots = null!\n        data = null!\n      }\n      render = null!\n      /* eslint-enable @typescript-eslint/no-non-null-assertion */\n    }\n\n    // When the component is mounted, emit the mounted event\n    onMounted(() => context.emit('mounted'))\n    // For browser rendering:\n    onUnmounted(cleanUp)\n    // For SSR rendering:\n    onSSRComplete(getCurrentInstance()?.appContext.app, cleanUp)\n\n    return () => (render ? render() : null)\n  },\n})\n\nexport default FormKitSchema\n","import { App } from 'vue'\n\n/**\n * A flag indicating if this is (likely) a server context.\n */\nconst isServer = typeof window === 'undefined'\n\n/**\n * A map of Vue applications to a set of callbacks to be flushed after SSR is\n * complete.\n */\nconst ssrCompleteRegistry = new Map<App<any>, Set<CallableFunction>>()\n\n/**\n * Flush all callbacks registered with onSSRComplete for a given app.\n * @param app - The Vue application.\n * @public\n */\nexport function ssrComplete(app: App<any>) {\n  if (!isServer) return\n  const callbacks = ssrCompleteRegistry.get(app)\n  if (!callbacks) return\n  for (const callback of callbacks) {\n    callback()\n  }\n  callbacks.clear()\n  ssrCompleteRegistry.delete(app)\n}\n\n/**\n * Register a callback for when SSR is complete. No-op if not in a server\n * context.\n * @param app - The Vue application.\n * @param callback - The callback to be called after SSR is complete.\n * @public\n */\nexport function onSSRComplete(\n  app: App<any> | undefined,\n  callback: CallableFunction\n) {\n  if (!isServer || !app) return\n  if (!ssrCompleteRegistry.has(app)) ssrCompleteRegistry.set(app, new Set())\n  ssrCompleteRegistry.get(app)?.add(callback)\n}\n","import { h, ref, watch, provide, InjectionKey, Ref } from 'vue'\nimport { defineComponent } from 'vue'\n\n/**\n * The symbol that represents the formkit’s root element injection value.\n *\n * @public\n */\nexport const rootSymbol: InjectionKey<Ref<Document | ShadowRoot | undefined>> =\n  Symbol()\n\n/**\n * The FormKitRoot wrapper component used to provide context to FormKit about\n * whether a FormKit input is booting in a Document or ShadowRoot. This is\n * generally only necessary when booting FormKit nodes in contexts that do not\n * have a document. For example, if running code like this:\n *\n * ```ts\n * document.getElementById(node.props.id)\n * ```\n *\n * does not work because the `document` is not available or is not in the same\n * scope, you can place a `<FormKitRoot>` component somewhere near the root of\n * of your shadowRoot and it will inform any FormKitNode child (at any depth)\n * that it is running in a shadow root. The \"root\" (`Document` or `ShadowRoot`)\n * will be made available to all child nodes at `node.context._root`\n *\n * @public\n */\nexport const FormKitRoot = /* #__PURE__ */ defineComponent((_p, context) => {\n  const boundary = ref<null | HTMLElement>(null)\n  const showBody = ref(false)\n  const shadowRoot = ref<Document | ShadowRoot | undefined>(undefined)\n\n  const stopWatch = watch(boundary, (el) => {\n    let parent: Node | null | undefined = el\n    let root: null | Node = null\n    while ((parent = parent?.parentNode)) {\n      root = parent\n      if (root instanceof ShadowRoot || root instanceof Document) {\n        foundRoot(root)\n        break\n      }\n    }\n    stopWatch()\n    showBody.value = true\n  })\n  provide(rootSymbol, shadowRoot)\n\n  function foundRoot(root: Document | ShadowRoot) {\n    shadowRoot.value = root\n  }\n\n  return () =>\n    showBody.value && context.slots.default\n      ? context.slots.default()\n      : h('template', { ref: boundary })\n})\n","import { parentSymbol, componentSymbol } from '../FormKit'\nimport { rootSymbol } from '../FormKitRoot'\nimport {\n  error,\n  createNode,\n  FormKitNode,\n  FormKitOptions,\n  FormKitMessage,\n  createMessage,\n} from '@formkit/core'\nimport { FormKitRuntimeProps } from '@formkit/inputs'\nimport {\n  nodeProps,\n  except,\n  camel,\n  extend,\n  only,\n  kebab,\n  cloneAny,\n  slugify,\n  isObject,\n  token,\n  undefine,\n  oncePerTick,\n  eq,\n  shallowClone,\n} from '@formkit/utils'\nimport {\n  toRef,\n  watchEffect,\n  inject,\n  provide,\n  watch,\n  getCurrentInstance,\n  computed,\n  ref,\n  WatchStopHandle,\n  onBeforeUnmount,\n  onMounted,\n  SetupContext,\n} from 'vue'\nimport { FormKitInputs } from '@formkit/inputs'\nimport { optionsSymbol } from '../plugin'\nimport { FormKitGroupValue } from 'packages/core/src'\nimport { FormKitPseudoProps } from '@formkit/core'\n\ninterface FormKitComponentListeners {\n  onSubmit?: (payload?: FormKitGroupValue) => Promise<unknown> | unknown\n  onSubmitRaw?: (event?: Event) => unknown\n  onSubmitInvalid?: (node?: Node) => unknown\n}\n\nconst isBrowser = typeof window !== 'undefined'\n\n/**\n * Props that are extracted from the attrs object.\n * TODO: Currently local, this should probably exported to a inputs or another\n * package.\n */\nconst pseudoProps = [\n  // Boolean props\n  'ignore',\n  'disabled',\n  'preserve',\n  // String props\n  'help',\n  'label',\n  /^preserve(-e|E)rrors/,\n  /^[a-z]+(?:-visibility|Visibility|-behavior|Behavior)$/,\n  /^[a-zA-Z-]+(?:-class|Class)$/,\n  'prefixIcon',\n  'suffixIcon',\n  /^[a-zA-Z-]+(?:-icon|Icon)$/,\n]\n\nconst boolProps = ['disabled', 'ignore', 'preserve']\n\n/**\n * Given some props, map those props to individualized props internally.\n * @param node - A formkit node\n * @param props - Some props that may include a classes object\n */\nfunction classesToNodeProps(node: FormKitNode, props: Record<string, any>) {\n  if (props.classes) {\n    Object.keys(props.classes).forEach(\n      (key: keyof (typeof props)['classes']) => {\n        if (typeof key === 'string') {\n          node.props[`_${key}Class`] = props.classes[key]\n          // We need to ensure Vue is aware that we want to actually observe the\n          // child values too, so we touch them here.\n          if (isObject(props.classes[key]) && key === 'inner')\n            Object.values(props.classes[key])\n        }\n      }\n    )\n  }\n}\n\n/**\n * Extracts known FormKit listeners.\n * @param props - Extract known FormKit listeners.\n * @returns\n */\nfunction onlyListeners(\n  props: Record<string, unknown> | null | undefined\n): FormKitComponentListeners {\n  if (!props) return {}\n  const knownListeners = ['Submit', 'SubmitRaw', 'SubmitInvalid'].reduce(\n    (listeners, listener) => {\n      const name = `on${listener}`\n      if (name in props) {\n        if (typeof props[name] === 'function') {\n          listeners[name] = props[name] as CallableFunction\n        }\n      }\n      return listeners\n    },\n    {} as Record<string, CallableFunction>\n  )\n  return knownListeners as FormKitComponentListeners\n}\n\n/**\n * A composable for creating a new FormKit node.\n *\n * @param type - The type of node (input, group, list)\n * @param attrs - The FormKit \"props\" — which is really the attrs list.\n *\n * @returns {@link @formkit/core#FormKitNode | FormKitNode}\n *\n * @public\n */\nexport function useInput<\n  Props extends FormKitInputs<Props>,\n  Context extends SetupContext<any, any>\n>(props: Props, context: Context, options: FormKitOptions = {}): FormKitNode {\n  /**\n   * The configuration options, these are provided by either the plugin or by\n   * explicit props.\n   */\n  const config = Object.assign({}, inject(optionsSymbol) || {}, options)\n\n  /**\n   * The root element — generally this is either a Document or ShadowRoot.\n   */\n  const __root = inject(rootSymbol, ref(isBrowser ? document : undefined))\n\n  /**\n   * The component symbol, this is used to register the node with the \"owner\"\n   * component.\n   */\n  const __cmpCallback = inject(componentSymbol, () => {\n    /* void */\n  })\n\n  /**\n   * The current instance.\n   */\n  const instance = getCurrentInstance()\n\n  /**\n   * Extracts the listeners.\n   */\n  const listeners = onlyListeners(instance?.vnode.props)\n\n  /**\n   * Determines if the prop is v-modeled. Credit to:\n   * {@link https://github.com/LinusBorg | Thorsten Lünborg}\n   * for coming up with this solution.\n   */\n  const isVModeled = ['modelValue', 'model-value'].some(\n    (prop) => prop in (instance?.vnode.props ?? {})\n  )\n\n  // Track if the input has mounted or not.\n  let isMounted = false\n  onMounted(() => {\n    isMounted = true\n  })\n\n  /**\n   * Determines if the object being passed as a v-model is reactive.\n   */\n  // const isReactiveVModel = isVModeled && isReactive(props.modelValue)\n\n  /**\n   * Define the initial component\n   */\n  const value: any =\n    props.modelValue !== undefined\n      ? props.modelValue\n      : cloneAny(context.attrs.value)\n\n  /**\n   * Creates the node's initial props from the context, props, and definition\n   * @returns\n   */\n  function createInitialProps(): Record<string, any> {\n    const initialProps: Record<string, any> = {\n      ...nodeProps(props),\n      ...listeners,\n      type: props.type ?? 'text',\n      __root: __root.value,\n      __slots: context.slots,\n    }\n    const attrs = except(nodeProps(context.attrs), pseudoProps)\n    if (!attrs.key) attrs.key = token()\n    initialProps.attrs = attrs\n    const propValues = only(nodeProps(context.attrs), pseudoProps)\n    for (const propName in propValues) {\n      if (boolProps.includes(propName) && propValues[propName] === '') {\n        propValues[propName] = true\n      }\n      initialProps[camel(propName)] = propValues[propName]\n    }\n    const classesProps = { props: {} }\n    classesToNodeProps(classesProps as FormKitNode, props)\n    Object.assign(initialProps, classesProps.props)\n    if (typeof initialProps.type !== 'string') {\n      initialProps.definition = initialProps.type\n      delete initialProps.type\n    }\n    return initialProps\n  }\n\n  /**\n   * Create the FormKitNode.\n   */\n  const initialProps = createInitialProps()\n\n  /**\n   * The parent node.\n   */\n  const parent = initialProps.ignore\n    ? null\n    : props.parent || inject(parentSymbol, null)\n  const node = createNode(\n    extend(\n      config || {},\n      {\n        name: props.name || undefined,\n        value,\n        parent,\n        plugins: (config.plugins || []).concat(props.plugins ?? []),\n        config: props.config || {},\n        props: initialProps,\n        index: props.index,\n        sync: !!undefine(context.attrs.sync || context.attrs.dynamic),\n      },\n      false,\n      true\n    ) as Partial<FormKitOptions>\n  ) as FormKitNode\n\n  /**\n   * Call the component callback.\n   */\n  __cmpCallback(node)\n\n  /**\n   * If no definition has been assigned at this point — we're out!\n   */\n  if (!node.props.definition) error(600, node)\n\n  /**\n   * All props that are bound \"late\" (after node creation) — are added to a set\n   * which is used to watch the context.attrs object.\n   */\n  const lateBoundProps = ref<Set<string | RegExp>>(\n    new Set(\n      Array.isArray(node.props.__propDefs)\n        ? node.props.__propDefs\n        : Object.keys(node.props.__propDefs ?? {})\n    )\n  )\n\n  /**\n   * Any additional props added at a \"later\" time should also be part of the\n   * late bound props.\n   */\n  node.on(\n    'added-props',\n    ({ payload: lateProps }: { payload: FormKitPseudoProps }) => {\n      const propNames = Array.isArray(lateProps)\n        ? lateProps\n        : Object.keys(lateProps ?? {})\n      propNames.forEach((newProp) => lateBoundProps.value.add(newProp))\n    }\n  )\n\n  /**\n   * These prop names must be assigned.\n   */\n  const pseudoPropNames = computed(() =>\n    pseudoProps.concat([...lateBoundProps.value]).reduce((names, prop) => {\n      if (typeof prop === 'string') {\n        names.push(camel(prop))\n        names.push(kebab(prop))\n      } else {\n        names.push(prop)\n      }\n      return names\n    }, [] as Array<string | RegExp>)\n  )\n\n  /* Splits Classes object into discrete props for each key */\n  watchEffect(() => classesToNodeProps(node, props))\n\n  /**\n   * The props object already has properties even if they start as \"undefined\"\n   * so we can loop over them and individual watchEffect to prevent responding\n   * inappropriately.\n   */\n  const passThrough = nodeProps(props)\n  for (const prop in passThrough) {\n    watch(\n      () => props[prop as keyof FormKitRuntimeProps<Props>],\n      () => {\n        if (props[prop as keyof FormKitRuntimeProps<Props>] !== undefined) {\n          node.props[prop] = props[prop as keyof FormKitRuntimeProps<Props>]\n        }\n      }\n    )\n  }\n\n  // Ensure the root always stays up to date.\n  watchEffect(() => {\n    node.props.__root = __root.value\n  })\n\n  /**\n   * Watch \"pseudoProp\" attributes explicitly.\n   */\n  const attributeWatchers = new Set<WatchStopHandle>()\n  const possibleProps = nodeProps(context.attrs)\n  watchEffect(() => {\n    watchAttributes(only(possibleProps, pseudoPropNames.value))\n  })\n\n  /**\n   * Defines attributes that should be used as props.\n   * @param attrProps - Attributes that should be used as props instead\n   */\n  function watchAttributes(attrProps: Record<string, any>) {\n    attributeWatchers.forEach((stop) => {\n      stop()\n      attributeWatchers.delete(stop)\n    })\n    for (const prop in attrProps) {\n      const camelName = camel(prop)\n      attributeWatchers.add(\n        watch(\n          () => context.attrs[prop],\n          () => {\n            node.props[camelName] = context.attrs[prop]\n          }\n        )\n      )\n    }\n  }\n\n  /**\n   * Watch and dynamically set attribute values, those values that are not\n   * props and are not pseudoProps\n   */\n  watchEffect(() => {\n    const attrs = except(nodeProps(context.attrs), pseudoPropNames.value)\n    // An explicit exception to ensure naked \"multiple\" attributes appear on the\n    // outer wrapper as data-multiple=\"true\"\n    if ('multiple' in attrs) attrs.multiple = undefine(attrs.multiple)\n    if (typeof attrs.onBlur === 'function') {\n      attrs.onBlur = oncePerTick(attrs.onBlur)\n    }\n    node.props.attrs = Object.assign({}, node.props.attrs || {}, attrs)\n  })\n\n  /**\n   * Add any/all \"prop\" errors to the store.\n   */\n  watchEffect(() => {\n    const messages = (props.errors ?? []).map((error) =>\n      /* #__PURE__ */ createMessage({\n        key: slugify(error),\n        type: 'error',\n        value: error,\n        meta: { source: 'prop' },\n      })\n    )\n    node.store.apply(\n      messages,\n      (message) => message.type === 'error' && message.meta.source === 'prop'\n    )\n  })\n\n  /**\n   * Add input errors.\n   */\n  if (node.type !== 'input') {\n    const sourceKey = `${node.name}-prop`\n    watchEffect(() => {\n      const inputErrors = props.inputErrors ?? {}\n      const keys = Object.keys(inputErrors)\n      if (!keys.length) node.clearErrors(true, sourceKey)\n      const messages = keys.reduce((messages, key) => {\n        let value = inputErrors[key]\n        if (typeof value === 'string') value = [value]\n        if (Array.isArray(value)) {\n          messages[key] = value.map((error) =>\n            /* #__PURE__ */ createMessage({\n              key: error,\n              type: 'error',\n              value: error,\n              meta: { source: sourceKey },\n            })\n          )\n        }\n        return messages\n      }, {} as Record<string, FormKitMessage[]>)\n      node.store.apply(\n        messages,\n        (message) =>\n          message.type === 'error' && message.meta.source === sourceKey\n      )\n    })\n  }\n\n  /**\n   * Watch the config prop for any changes.\n   */\n  watchEffect(() => Object.assign(node.config, props.config))\n\n  /**\n   * Produce another parent object.\n   */\n  if (node.type !== 'input') {\n    provide(parentSymbol, node)\n  }\n\n  // let inputTimeout: number | undefined\n\n  let clonedValueBeforeVmodel: unknown = undefined\n  /**\n   * Explicitly watch the input value, and emit changes (lazy)\n   */\n  node.on('modelUpdated', () => {\n    // Emit the values after commit\n    context.emit('inputRaw', node.context?.value, node)\n    if (isMounted) {\n      context.emit('input', node.context?.value, node)\n    }\n    if (isVModeled && node.context) {\n      clonedValueBeforeVmodel = cloneAny(node.value)\n      context.emit('update:modelValue', shallowClone(node.value))\n    }\n  })\n\n  /**\n   * Enabled support for v-model, using this for groups/lists is not recommended\n   */\n  if (isVModeled) {\n    watch(\n      toRef(props, 'modelValue'),\n      (value) => {\n        if (!eq(clonedValueBeforeVmodel, value)) {\n          node.input(value, false)\n        }\n      },\n      { deep: true }\n    )\n\n    /**\n     * On initialization, if the node’s value was updated (like in a plugin\n     * hook) then we should emit a `modelUpdated` event.\n     */\n    if (node.value !== value) {\n      node.emit('modelUpdated')\n    }\n  }\n\n  /**\n   * When this input shuts down, we need to \"delete\" the node too.\n   */\n  onBeforeUnmount(() => node.destroy())\n\n  return node\n}\n","import {\n  FormKitOptions,\n  FormKitNode,\n  FormKitRootConfig,\n  getNode,\n  createConfig,\n  setErrors,\n  clearErrors,\n  submitForm,\n  reset,\n} from '@formkit/core'\nimport type { App, Plugin, InjectionKey } from 'vue'\nimport FormKit, { FormKitComponent } from './FormKit'\nimport FormKitSchema from './FormKitSchema'\n\ndeclare module 'vue' {\n  interface ComponentCustomProperties {\n    $formkit: FormKitVuePlugin\n  }\n  interface GlobalComponents {\n    // @ts-ignore\n    FormKit: FormKitComponent\n    FormKitSchema: typeof FormKitSchema\n  }\n}\n/**\n * The global instance of the FormKit plugin.\n *\n * @public\n */\nexport interface FormKitVuePlugin {\n  get: (id: string) => FormKitNode | undefined\n  setLocale: (locale: string) => void\n  setErrors: (\n    formId: string,\n    errors: string[] | Record<string, string | string[]>,\n    inputErrors?: string[] | Record<string, string | string[]>\n  ) => void\n  clearErrors: (formId: string) => void\n  submit: (formId: string) => void\n  reset: (formId: string, resetTo?: unknown) => void\n}\n\n/**\n * The Create a new instance of the FormKit plugin for Vue.\n *\n * @param app - A Vue application\n * @param config - FormKit Vue plugin configuration options\n *\n * @internal\n */\nfunction createPlugin(\n  app: App<any>,\n  options: FormKitOptions & Record<string, any>\n): FormKitVuePlugin {\n  app\n    .component(options.alias || 'FormKit', FormKit as any)\n    .component(options.schemaAlias || 'FormKitSchema', FormKitSchema)\n  return {\n    get: getNode,\n    setLocale: (locale: string) => {\n      if (options.config?.rootConfig) {\n        options.config.rootConfig.locale = locale\n      }\n    },\n    clearErrors,\n    setErrors,\n    submit: submitForm,\n    reset,\n  }\n}\n\n/**\n * The symbol key for accessing the FormKit node options.\n *\n * @public\n */\nexport const optionsSymbol: InjectionKey<FormKitOptions> =\n  Symbol.for('FormKitOptions')\n\n/**\n * The symbol key for accessing FormKit root configuration.\n *\n * @public\n */\nexport const configSymbol: InjectionKey<FormKitRootConfig> =\n  Symbol.for('FormKitConfig')\n\n/**\n * Create the FormKit plugin.\n *\n * @public\n */\nexport const plugin: Plugin = {\n  install(\n    app,\n    _options: FormKitOptions | ((...args: any[]) => FormKitOptions)\n  ): void {\n    /**\n     * Extend the default configuration options.\n     */\n    const options: FormKitOptions = Object.assign(\n      {\n        alias: 'FormKit',\n        schemaAlias: 'FormKitSchema',\n      },\n      typeof _options === 'function' ? _options() : _options\n    )\n    /**\n     * The root configuration options.\n     */\n    const rootConfig = createConfig(options.config || {})\n    /**\n     * We dont want to explicitly provide any \"config\" options, only a root\n     * config option — so here we override the existing config options.\n     */\n    options.config = { rootConfig }\n    /**\n     * Register the global $formkit plugin property.\n     */\n    app.config.globalProperties.$formkit = createPlugin(app, options)\n    /**\n     * Provide the config to the application for injection.\n     */\n    app.provide(optionsSymbol, options)\n    /**\n     * Provide the root config to the application.\n     */\n    app.provide(configSymbol, rootConfig)\n    /**\n     * Register the FormKit component globally.\n     */\n    if (typeof window !== 'undefined') {\n      globalThis.__FORMKIT_CONFIGS__ = (\n        globalThis.__FORMKIT_CONFIGS__ || []\n      ).concat([rootConfig])\n    }\n  },\n}\n","import {\n  FormKitTypeDefinition,\n  FormKitSchemaNode,\n  FormKitSectionsSchema,\n} from '@formkit/core'\nimport { cloneAny } from '@formkit/utils'\nimport { createSection, FormKitSection, useSchema } from '@formkit/inputs'\nimport { Component, markRaw } from 'vue'\n\nlet totalCreated = 1\n\n/**\n * Determine if the given object is a vue component.\n *\n * @param obj - Object or function\n * @returns\n * @public\n */\nfunction isComponent(obj: any): obj is Component {\n  return (\n    (typeof obj === 'function' && obj.length === 2) ||\n    (typeof obj === 'object' &&\n      !Array.isArray(obj) &&\n      !('$el' in obj) &&\n      !('$cmp' in obj) &&\n      !('if' in obj))\n  )\n}\n\n/**\n * Creates a new input from schema or a Vue component with the \"standard\"\n * FormKit features in place such as labels, help text, validation messages, and\n * class support.\n *\n * @param schemaOrComponent - The actual schema of the input or the component.\n * @param definitionOptions - Any options in the FormKitTypeDefinition you want\n * to define.\n *\n * @returns {@link @formkit/core#FormKitTypeDefinition | FormKitTypeDefinition}\n *\n * @public\n */\nexport function createInput<V = unknown>(\n  schemaOrComponent: FormKitSchemaNode | FormKitSection | Component,\n  definitionOptions: Partial<FormKitTypeDefinition<V>> = {},\n  sectionsSchema: FormKitSectionsSchema = {}\n): FormKitTypeDefinition<V> {\n  const definition: FormKitTypeDefinition<V> = {\n    type: 'input',\n    ...definitionOptions,\n  }\n  let schema: FormKitSection\n  if (isComponent(schemaOrComponent)) {\n    const cmpName = `SchemaComponent${totalCreated++}`\n    schema = createSection('input', () => ({\n      $cmp: cmpName,\n      props: {\n        context: '$node.context',\n      },\n    }))\n    definition.library = { [cmpName]: markRaw(schemaOrComponent) }\n  } else if (typeof schemaOrComponent === 'function') {\n    schema = schemaOrComponent\n  } else {\n    schema = createSection('input', () => cloneAny(schemaOrComponent))\n  }\n\n  // Use the default wrapping schema\n  definition.schema = useSchema(schema || 'Schema undefined', sectionsSchema)\n  if (!definition.schemaMemoKey) {\n    definition.schemaMemoKey = `${Math.random()}`\n  }\n  return definition\n}\n","import { DefaultConfigOptions } from '../index'\n\nexport function defineFormKitConfig(\n  config: DefaultConfigOptions | (() => DefaultConfigOptions)\n): () => DefaultConfigOptions {\n  return () => (typeof config === 'function' ? config() : config)\n}\n","import {\n  h,\n  defineComponent,\n  ref,\n  computed,\n  reactive,\n  onMounted,\n  KeepAlive,\n} from 'vue'\nimport { FormKitSchemaDefinition } from '@formkit/core'\nimport { FormKitSchema } from './index'\nimport { FormKitNode } from '@formkit/core'\nimport { getNode } from '@formkit/core'\nimport { FormKitSchemaNode } from 'packages/core/src'\n\nlet inputList: Record<string, string[]> = {}\nconst schemas: Record<string, FormKitSchemaDefinition[]> = {}\n\nconst classes = {\n  container: `\n    formkit-kitchen-sink \n    p-8\n  `,\n  tabs: `\n    formkit-tabs \n    mt-4 \n    mr-[min(350px,25vw)]\n  `,\n  tab: `\n    formkit-kitchen-sink-tab\n    inline-block\n    mb-4\n    -mr-px\n    cursor-pointer\n    px-4\n    py-2\n    border\n    border-neutral-200\n    text-neutral-800\n    data-[active]:bg-neutral-800\n    data-[active]:border-neutral-800\n    data-[active]:text-neutral-50\n    hover:bg-neutral-100\n    hover:text-neutral-900\n    dark:border-neutral-700\n    dark:text-neutral-50\n    dark:data-[active]:bg-neutral-100\n    dark:data-[active]:border-neutral-100\n    dark:data-[active]:text-neutral-800\n    dark:hover:bg-neutral-800\n    dark:hover:text-neutral-50\n  `,\n  filterContainer: `\n    formkit-filter-container\n    grid\n    grid-cols-[repeat(auto-fit,300px)]\n    mr-[min(350px,25vw)]\n    -mt-4\n    mb-8\n    px-4\n    pt-8\n    pb-4\n    border\n    relative\n    -translate-y-px\n    max-w-[1000px]\n    border-neutral-200\n    dark:border-neutral-700\n  `,\n  filterGroup: `\n    formkit-filter-group\n    mr-8\n    mb-8\n    [&_legend]:text-lg\n    [&_ul]:columns-2\n    [&_ul>li:first-child]:[column-span:all]\n    [&_ul>li:first-child]:mt-2\n    [&_ul>li:first-child]:mb-2\n    [&_ul>li:first-child]:pb-2\n    [&_ul>li:first-child]:border-b\n    [&_ul>li:first-child]:border-neutral-200\n    dark:[&_ul>li:first-child]:border-neutral-700\n  `,\n  formContainer: `\n    formkit-form-container\n    w-full\n    bg-white\n    rounded\n    border\n    border-neutral-100\n    shadow-lg\n    max-w-[800px]\n    p-[min(5vw,5rem)]\n    dark:bg-neutral-900\n    dark:border-neutral-800\n    dark:shadow-3xl\n    [&_form>h1]:text-2xl\n    [&_form>h1]:mb-4\n    [&_form>h1]:font-bold\n    [&_form>h1+p]:text-base\n    [&_form>h1+p]:mb-4\n    [&_form>h1+p]:-mt-2\n    [&_form_.double]:flex\n    [&_form_.double>*]:w-1/2\n    [&_form_.double>*:first-child]:mr-2\n    [&_form_.triple]:flex\n    [&_form_.triple>*]:w-1/3\n    [&_form_.triple>*:first-child]:mr-2\n    [&_form_.triple>*:last-child]:ml-2\n  `,\n  inputs: `formkit-inputs`,\n  specimen: `\n    formkit-specimen \n    flex \n    flex-col \n    p-2 \n    max-w-[75vw]\n  `,\n  inputSection: `\n    group/section\n    formkit-input-section \n    mr-[min(325px,25vw)]\n  `,\n  specimenGroup: `\n    formkit-specimen-group\n    grid\n    mb-16\n    grid-cols-[repeat(auto-fit,400px)]\n    group-data-[type=\"transferlist\"]/section:grid-cols-[repeat(auto-fit,650px)]\n    group-data-[type=\"multi-step\"]/section:grid-cols-[repeat(auto-fit,550px)]\n  `,\n  inputType: `\n    formkit-input-type\n    block\n    font-bold\n    text-neutral-900\n    border-b\n    border-neutral-100\n    text-3xl\n    mb-8\n    pb-2\n    capitalize\n    dark:border-neutral-800 \n    dark:text-neutral-50\n  `,\n}\n\n/**\n * Fetches the list of inputs from the remote schema repository\n */\nasync function fetchInputList() {\n  const response = await fetch(\n    'https://raw.githubusercontent.com/formkit/input-schemas/master/index.json'\n  )\n  const json = await response.json()\n  return json\n}\n\n/**\n * Fetches the list of inputs from the remote schema repository\n */\nasync function fetchInputSchema(input: string) {\n  try {\n    const response = await fetch(\n      `https://raw.githubusercontent.com/formkit/input-schemas/master/schemas/${input}.json`\n    )\n    const json = await response.json()\n    return json\n  } catch (error) {\n    console.error(error)\n  }\n}\n\n/**\n * Renders FormKit components fetched from a remote schema repository.\n * This is a kitchen sink component that is used for testing purposes.\n * It shows inputs in various states and configurations.\n *\n * @public\n */\nexport const FormKitKitchenSink = /* #__PURE__ */ defineComponent({\n  name: 'FormKitKitchenSink',\n  props: {\n    schemas: {\n      type: Array,\n      required: false,\n    },\n    pro: {\n      type: Boolean,\n      default: true,\n    },\n    addons: {\n      type: Boolean,\n      default: true,\n    },\n    forms: {\n      type: Boolean,\n      default: true,\n    },\n    navigation: {\n      type: Boolean,\n      default: true,\n    },\n  },\n  async setup(props) {\n    onMounted(() => {\n      const filterNode = getNode('filter-checkboxes')\n      data.filters = computed((): string[] => {\n        if (!filterNode?.context) return []\n        const filters = filterNode.context.value\n        const filterValues: string[] = []\n        Object.keys(filters).forEach((key) => {\n          filterValues.push(...filters[key])\n        })\n        return filterValues\n      }) as unknown as string[]\n    })\n\n    inputList = Object.keys(inputList).length\n      ? inputList\n      : await fetchInputList()\n    const promises = []\n    const activeTab = ref('')\n    const inputCheckboxes = computed(() => {\n      const inputGroups: Record<string, Record<string, string | string[]>> = {\n        core: { label: 'Inputs', name: 'core', inputs: inputList.core },\n      }\n      if (props.pro) {\n        inputGroups.pro = {\n          label: 'Pro Inputs',\n          name: 'pro',\n          inputs: inputList.pro,\n        }\n      }\n      if (props.addons) {\n        inputGroups.addons = {\n          label: 'Add-ons',\n          name: 'addons',\n          inputs: inputList.addons,\n        }\n      }\n      return inputGroups\n    })\n\n    if (!props.schemas) {\n      const coreInputPromises = inputList.core.map(async (schema: string) => {\n        const response = await fetchInputSchema(schema)\n        schemas[schema] = response\n      })\n      promises.push(...coreInputPromises)\n\n      if (props.forms) {\n        const formsPromises = inputList.forms.map(async (schema: string) => {\n          const schemaName = `form/${schema}`\n          const response = await fetchInputSchema(schemaName)\n          schemas[schemaName] = response\n        })\n        promises.push(...formsPromises)\n      }\n\n      if (props.pro) {\n        const proInputPromises = inputList.pro.map(async (schema: string) => {\n          const response = await fetchInputSchema(schema)\n          schemas[schema] = response\n        })\n        promises.push(...proInputPromises)\n      }\n\n      if (props.addons) {\n        const addonPromises = inputList.addons.map(async (schema: string) => {\n          const response = await fetchInputSchema(schema)\n          schemas[schema] = response\n        })\n        promises.push(...addonPromises)\n      }\n    } else {\n      const schemaPromises = props.schemas.map(async (schema: unknown) => {\n        const response = await fetchInputSchema(`${schema}`)\n        schemas[`${schema}`] = response\n      })\n      promises.push(...schemaPromises)\n    }\n\n    // a plugin required for the \"select all\" checkbox functionality\n    const selectAll = (node: FormKitNode) => {\n      let previousValue: string[] = []\n      let skip = false\n\n      if (node.props.type !== 'checkbox') return\n      node.on('created', () => {\n        // if the only checked item is the \"all\" checkbox, check all\n        const currentValue = node.value\n        if (\n          Array.isArray(currentValue) &&\n          currentValue.length === 1 &&\n          currentValue[0] === 'all'\n        ) {\n          node.input(\n            node.props.options.map((option: string | Record<string, any>) => {\n              if (typeof option !== 'string') return option.value\n              return option\n            })\n          )\n        }\n        previousValue = Array.isArray(node.value) ? node.value : []\n      })\n      node.on('commit', ({ payload }) => {\n        if (skip) {\n          skip = false\n          return\n        }\n        if (!Array.isArray(payload)) return\n\n        const previousValueHadAll = previousValue.includes('all')\n        const currentValueHasAll = payload.includes('all')\n\n        // if \"all\" was checked, check all\n        if (!previousValueHadAll && currentValueHasAll) {\n          const computedOptions = node.props.options.map(\n            (option: string | Record<string, any>) => {\n              if (typeof option !== 'string') return option.value\n              return option\n            }\n          )\n          node.input(computedOptions)\n          previousValue = computedOptions\n          return\n        }\n\n        // if \"all\" was unchecked, uncheck all\n        if (previousValueHadAll && !currentValueHasAll) {\n          node.input([])\n          previousValue = []\n          return\n        }\n\n        const valueMinusAll = payload.filter((value: string) => value !== 'all')\n        // uncheck \"all\" if we have less than all items checked\n        if (\n          valueMinusAll.length < node.props.options.length - 1 &&\n          currentValueHasAll\n        ) {\n          node.input(valueMinusAll)\n          previousValue = valueMinusAll\n          skip = true\n          return\n        }\n\n        // re-check \"all\" if we manually check all other items\n        if (\n          valueMinusAll.length === node.props.options.length - 1 &&\n          !currentValueHasAll\n        ) {\n          const computedOptions = node.props.options.map(\n            (option: string | Record<string, any>) => {\n              if (typeof option !== 'string') return option.value\n              return option\n            }\n          )\n          node.input(computedOptions)\n          previousValue = Array.isArray(node.value) ? node.value : []\n          return\n        }\n      })\n    }\n\n    // supporting schema functions for async input states\n    const data = reactive({\n      twClasses: classes,\n      basicOptions: Array.from({ length: 15 }, (_, i) => `Option ${i + 1}`),\n      asyncLoader: async () => {\n        // eslint-disable-next-line @typescript-eslint/no-empty-function\n        return await new Promise<void>(() => {})\n      },\n      paginatedLoader: async ({\n        page,\n        hasNextPage,\n      }: {\n        page: number\n        hasNextPage: () => void\n      }) => {\n        const base = (page - 1) * 10\n        hasNextPage()\n        return Array.from({ length: 10 }, (_, i) => `Option ${base + i + 1}`)\n      },\n      formSubmitHandler: async (data: any) => {\n        await new Promise((resolve) => setTimeout(resolve, 1000))\n        alert('Form submitted (fake) — check console for data object')\n        console.log('Form data:', data)\n      },\n      includes: (array: any[], value: any) => {\n        if (!Array.isArray(array)) return false\n        return array.includes(value)\n      },\n      checkboxPlugins: [selectAll],\n      filters: [] as string[],\n    })\n\n    await Promise.all(promises)\n\n    const inputKeys = Object.keys(schemas)\n\n    // create friendly labels for use in tabs\n    const formNames = inputKeys.map((key: string) => {\n      if (key.startsWith('form/')) {\n        switch (key) {\n          case 'form/tshirt':\n            return {\n              id: key,\n              name: 'Order Form',\n            }\n          default:\n            const name = key.replace('form/', '')\n            return {\n              id: key,\n              name: name.charAt(0).toUpperCase() + name.slice(1) + ' Form',\n            }\n        }\n      }\n      return {\n        id: key,\n        name: '',\n      }\n    })\n    const filteredFormNames = formNames.filter((form) => form.name !== '')\n\n    const forms = inputKeys.filter((schema: string) => {\n      return schema.startsWith('form/')\n    })\n    const inputs = inputKeys.filter(\n      (schema: string) => !schema.startsWith('form/')\n    )\n\n    const tabs: Record<string, string>[] = []\n    if (inputs.length) {\n      tabs.push({\n        id: 'kitchen-sink',\n        name: 'Kitchen Sink',\n      })\n    }\n    if (forms.length) {\n      tabs.push(...filteredFormNames.sort((a, b) => (a.name > b.name ? 1 : -1)))\n    }\n    if (tabs.length) {\n      activeTab.value = tabs[0].id\n    }\n\n    // collection of all inputs to be rendered in the \"kitchen sink\" tab\n    const kitchenSinkRenders = computed(() => {\n      inputs.sort()\n\n      const schemaDefinitions: FormKitSchemaDefinition = inputs.reduce(\n        (schemaDefinitions, inputName: string) => {\n          const schemaDefinition = schemas[inputName]\n          schemaDefinitions.push({\n            $el: 'div',\n            if: '$includes($filters, \"' + inputName + '\")',\n            attrs: {\n              key: inputName,\n              class: '$twClasses.inputSection',\n              'data-type': inputName,\n            },\n            children: [\n              {\n                $el: 'h2',\n                attrs: {\n                  class: '$twClasses.inputType',\n                },\n                children: inputName,\n              },\n              {\n                $el: 'div',\n                attrs: {\n                  class: '$twClasses.specimenGroup',\n                },\n                children: [\n                  ...((Array.isArray(schemaDefinition)\n                    ? schemaDefinition\n                    : [schemaDefinition]\n                  ).map((specimen) => {\n                    return {\n                      $el: 'div',\n                      attrs: {\n                        class: '$twClasses.specimen',\n                      },\n                      children: [specimen],\n                    }\n                  }) as FormKitSchemaNode[]),\n                ],\n              },\n            ],\n          })\n          return schemaDefinitions\n        },\n        [] as FormKitSchemaNode[]\n      )\n\n      return h(\n        KeepAlive,\n        {},\n        {\n          default: () => {\n            return activeTab.value === 'kitchen-sink'\n              ? h(FormKitSchema, { schema: schemaDefinitions, data: data })\n              : null\n          },\n        }\n      )\n    })\n\n    const formRenders = computed(() => {\n      return filteredFormNames\n        .map((form) => {\n          const schemaDefinition = schemas[form.id]\n          return h(\n            'div',\n            {\n              key: form.id,\n            },\n            activeTab.value === form.id\n              ? [\n                  h(\n                    'div',\n                    {\n                      class: classes.formContainer,\n                    },\n                    [\n                      h(FormKitSchema, {\n                        schema: schemaDefinition[0],\n                        data: data,\n                      }),\n                    ]\n                  ),\n                ]\n              : ''\n          )\n        })\n        .filter((form) => form.children)\n    })\n\n    const tabBar = computed(() => {\n      return h(\n        'div',\n        {\n          key: 'tab-bar',\n          class: classes.tabs,\n        },\n        tabs.map((tab) => {\n          return h(\n            'span',\n            {\n              class: classes.tab,\n              key: tab.id,\n              'data-tab': tab.id,\n              'data-active': activeTab.value === tab.id || undefined,\n              onClick: () => {\n                activeTab.value = tab.id\n              },\n            },\n            tab.name\n          )\n        })\n      )\n    })\n\n    const filterCheckboxes = computed(() => {\n      const createCheckboxSchema = (\n        inputGroup: Record<string, string | string[]>\n      ) => {\n        return {\n          $el: 'div',\n          attrs: {\n            class: '$twClasses.filterGroup',\n          },\n          children: [\n            {\n              $formkit: 'checkbox',\n              name: inputGroup.name,\n              label: inputGroup.label,\n              plugins: '$checkboxPlugins',\n              value: ['all'],\n              options: [\n                {\n                  label: 'All',\n                  value: 'all',\n                },\n                ...(Array.isArray(inputGroup.inputs) ? inputGroup.inputs : []),\n              ],\n            },\n          ],\n        }\n      }\n\n      // render each set of checkboxes\n      const filterSchema = h(FormKitSchema, {\n        key: 'filter-checkboxes',\n        data: data,\n        schema: {\n          $formkit: 'group',\n          id: 'filter-checkboxes',\n          children: [\n            {\n              $el: 'div',\n              attrs: {\n                class: '$twClasses.filterContainer',\n              },\n              children: Object.keys(inputCheckboxes.value).map((key) => {\n                const inputGroup = inputCheckboxes.value[key]\n                return createCheckboxSchema(inputGroup)\n              }),\n            },\n          ],\n        },\n      })\n\n      return h(\n        KeepAlive,\n        {},\n        {\n          default: () => {\n            if (\n              !(\n                tabs.find((tab) => tab.id === 'kitchen-sink') &&\n                activeTab.value === 'kitchen-sink'\n              )\n            ) {\n              return null\n            }\n            return filterSchema\n          },\n        }\n      )\n    })\n\n    return () => {\n      return h(\n        'div',\n        {\n          class: classes.container,\n        },\n        [\n          tabs.length > 1 ? tabBar.value : undefined,\n          filterCheckboxes.value,\n          ...formRenders.value,\n          kitchenSinkRenders.value,\n        ]\n      )\n    }\n  },\n})\n\nexport default FormKitKitchenSink\n","import {\n  defineComponent,\n  PropType,\n  computed,\n  inject,\n  watch,\n  h,\n  Component,\n} from 'vue'\nimport { createSection } from '@formkit/inputs'\nimport {\n  FormKitNode,\n  FormKitSchemaNode,\n  FormKitSchemaCondition,\n} from '@formkit/core'\nimport { parentSymbol } from './FormKit'\nimport FormKitSchema from './FormKitSchema'\nimport { undefine } from '@formkit/utils'\n\n/**\n * @internal\n */\nconst messages = createSection('messages', () => ({\n  $el: 'ul',\n  if: '$fns.length($messages)',\n}))\n\n/**\n * @internal\n */\nconst message = createSection('message', () => ({\n  $el: 'li',\n  for: ['message', '$messages'],\n  attrs: {\n    key: '$message.key',\n    id: `$id + '-' + $message.key`,\n    'data-message-type': '$message.type',\n  },\n}))\n\n/**\n * The actual schema to render for the messages.\n */\nconst definition = messages(message('$message.value'))\n\n/**\n * Renders the messages for a parent node, or any node explicitly passed to it.\n * @public\n */\nexport const FormKitMessages = /* #__PURE__ */ defineComponent({\n  props: {\n    node: {\n      type: Object as PropType<FormKitNode> | undefined,\n      required: false,\n    },\n    sectionsSchema: {\n      type: Object as PropType<\n        Record<string, Partial<FormKitSchemaNode> | FormKitSchemaCondition>\n      >,\n      default: {},\n    },\n    defaultPosition: {\n      type: [String, Boolean] as PropType<\n        'true' | 'false' | boolean | undefined\n      >,\n      default: false,\n    },\n    library: {\n      type: Object as PropType<Record<string, Component>>,\n      default: () => ({}),\n    },\n  },\n  setup(props, context) {\n    const node = computed<FormKitNode | undefined>(() => {\n      return props.node || inject(parentSymbol, undefined)\n    })\n    watch(\n      node,\n      () => {\n        if (node.value?.context && !undefine(props.defaultPosition)) {\n          node.value.context.defaultMessagePlacement = false\n        }\n      },\n      { immediate: true }\n    )\n\n    const schema = definition(props.sectionsSchema || {})\n    const data = computed(() => {\n      return {\n        messages: node.value?.context?.messages || {},\n        fns: node.value?.context?.fns || {},\n        classes: node.value?.context?.classes || {},\n      }\n    })\n    return () =>\n      node.value?.context\n        ? h(\n            FormKitSchema,\n            { schema, data: data.value, library: props.library },\n            { ...context.slots }\n          )\n        : null\n  },\n})\n","import { defineComponent, SetupContext } from 'vue'\nimport { FormKitOptions, createConfig } from '@formkit/core'\nimport { optionsSymbol, configSymbol } from './plugin'\nimport { provide, inject } from 'vue'\nimport { h } from 'vue'\nimport { Suspense } from 'vue'\nimport { getCurrentInstance } from 'vue'\nimport { ComponentInternalInstance } from 'vue'\nimport { VNode } from 'vue'\n\n/**\n * A composable to provide a given configuration to all children.\n * @param config - A FormKit configuration object or a function\n */\nexport function useConfig(\n  config?: FormKitOptions | ((...args: any[]) => FormKitOptions)\n) {\n  const options = Object.assign(\n    {\n      alias: 'FormKit',\n      schemaAlias: 'FormKitSchema',\n    },\n    typeof config === 'function' ? config() : config\n  )\n  /**\n   * The root configuration options.\n   */\n  const rootConfig = createConfig(options.config || {})\n  /**\n   * We dont want to explicitly provide any \"config\" options, only a root\n   * config option — so here we override the existing config options.\n   */\n  options.config = { rootConfig }\n  /**\n   * Provide the config to children.\n   */\n  provide(optionsSymbol, options)\n  /**\n   * Provide the root config to the children.\n   */\n  provide(configSymbol, rootConfig)\n  /**\n   * Register the FormKit component globally.\n   */\n  if (typeof window !== 'undefined') {\n    globalThis.__FORMKIT_CONFIGS__ = (\n      globalThis.__FORMKIT_CONFIGS__ || []\n    ).concat([rootConfig])\n  }\n}\n\nexport interface FormKitProviderProps {\n  config?: FormKitOptions | ((...args: any[]) => FormKitOptions)\n}\n\nexport interface ConfigLoaderProps {\n  defaultConfig?: boolean\n  configFile?: string\n}\n\n/**\n * The FormKitProvider component provides the FormKit config to the children.\n *\n * @public\n */\nexport const FormKitProvider = /* #__PURE__ */ defineComponent(\n  function FormKitProvider<\n    P extends FormKitProviderProps,\n    S extends { default: FormKitOptions }\n  >(props: P, { slots, attrs }: SetupContext<S>) {\n    const options: FormKitOptions = {}\n    if (props.config) {\n      useConfig(props.config)\n    }\n\n    return () =>\n      slots.default\n        ? slots.default(options).map((vnode) => {\n            return h(vnode, {\n              ...attrs,\n              ...vnode.props,\n            })\n          })\n        : null\n  },\n  { props: ['config'], name: 'FormKitProvider', inheritAttrs: false }\n)\n\n/**\n * The FormKitConfigLoader is an async component (meaning it needs a parent or\n * grandparent Suspense component to render) that loads the FormKit config and\n * provides it to the children.\n *\n * @internal\n */\nconst FormKitConfigLoader = /* #__PURE__ */ defineComponent(\n  async function FormKitConfigLoader(props: ConfigLoaderProps, context) {\n    let config = {}\n    if (props.configFile) {\n      const configFile = await import(\n        /*@__formkit.config.ts__*/ /* @vite-ignore */ /* webpackIgnore: true */ props.configFile\n      )\n      config = 'default' in configFile ? configFile.default : configFile\n    }\n    // Ensure this a factory function for runtimeConfig in nuxt.\n    if (typeof config === 'function') {\n      config = config()\n    }\n    /* @__default-config__ */\n    const useDefaultConfig = props.defaultConfig ?? true\n    if (useDefaultConfig) {\n      const { defaultConfig } = await import('./defaultConfig')\n      config = /* @__PURE__ */ defaultConfig(config)\n    }\n    /* @__default-config__ */\n    return () => h(FormKitProvider, { ...context.attrs, config }, context.slots)\n  },\n  {\n    props: ['defaultConfig', 'configFile'],\n    inheritAttrs: false,\n  }\n)\n\n/**\n * The FormKitLazyProvider component performs 2 HOC functions:\n *\n * 1. It checks if a FormKit config has already been provided, if it has it will\n *   render the children immediately.\n * 2. If a config has not been provided, it will render a Suspense component\n *    which will render the children once the config has been loaded by using\n *    the FormKitConfigLoader component.\n *\n * @public\n */\nexport const FormKitLazyProvider = /* #__PURE__ */ defineComponent(\n  function FormKitLazyProvider(\n    props: ConfigLoaderProps,\n    context: SetupContext<typeof Suspense>\n  ) {\n    const config = inject(optionsSymbol, null)\n    /* pass any attrs through */\n    const passthru = (vnode: VNode) => {\n      return h(vnode, {\n        ...context.attrs,\n        ...vnode.props,\n      })\n    }\n    if (config) {\n      // If there is already a config provided, render the children immediately.\n      return () =>\n        context.slots?.default ? context.slots.default().map(passthru) : null\n    }\n    const instance = getCurrentInstance() as ComponentInternalInstance & {\n      suspense?: boolean\n    }\n    if (instance.suspense) {\n      // If there is a suspense boundary already in place, we can render the\n      // config loader without another suspense boundary.\n      return () =>\n        h(FormKitConfigLoader, props, {\n          default: () =>\n            context.slots?.default\n              ? context.slots.default().map(passthru)\n              : null,\n        })\n    }\n    // If there is no suspense boundary, and no config, we render the suspense\n    // boundary and the config loader.\n    return () =>\n      h(Suspense, null, {\n        ...context.slots,\n        default: () =>\n          h(FormKitConfigLoader, { ...context.attrs, ...props }, context.slots),\n      })\n  },\n  {\n    props: ['defaultConfig', 'configFile'],\n    inheritAttrs: false,\n  }\n)\n","import { getNode, watchRegistry, stopWatch } from '@formkit/core'\nimport type {\n  FormKitFrameworkContext,\n  FormKitGroupValue,\n  FormKitNode,\n} from '@formkit/core'\nimport { parentSymbol } from '../FormKit'\nimport { ref, inject, onUnmounted } from 'vue'\nimport type { Ref } from 'vue'\n\n/**\n * Uses the FormKit context to access the current FormKit context. This must be\n * used in a component that is a child of the FormKit component.\n * @param effect - An optional effect callback to run when the context is available.\n */\nexport function useFormKitContext<T = FormKitGroupValue>(\n  effect?: (context: FormKitFrameworkContext<T>) => void\n): Ref<FormKitFrameworkContext<T> | undefined>\n/**\n * Allows access to a specific context by address.\n * @param address - An optional address of the context to access.\n * @param effect - An optional effect callback to run when the context is available.\n */\nexport function useFormKitContext<T = FormKitGroupValue>(\n  address?: string,\n  effect?: (context: FormKitFrameworkContext<T>) => void\n): Ref<FormKitFrameworkContext<T> | undefined>\nexport function useFormKitContext<T = FormKitGroupValue>(\n  addressOrEffect?: string | ((context: FormKitFrameworkContext<T>) => void),\n  optionalEffect?: (context: FormKitFrameworkContext<T>) => void\n): Ref<FormKitFrameworkContext<T> | undefined> {\n  const address =\n    typeof addressOrEffect === 'string' ? addressOrEffect : undefined\n  const effect =\n    typeof addressOrEffect === 'function' ? addressOrEffect : optionalEffect\n  const context = ref<FormKitFrameworkContext<T> | undefined>()\n  const parentNode = inject(parentSymbol, null)\n  if (false && !parentNode) {\n    console.warn(\n      'useFormKitContext must be used as a child of a FormKit component.'\n    )\n  }\n  if (parentNode) {\n    if (address) {\n      context.value = parentNode.at(address)?.context\n      const root = parentNode.at('$root')\n      if (root) {\n        const receipt = root.on('child.deep', () => {\n          const targetNode = parentNode.at(address)\n          if (targetNode && targetNode.context !== context.value) {\n            context.value = targetNode.context as FormKitFrameworkContext<T>\n            if (effect) effect(context.value)\n          }\n        })\n        onUnmounted(() => {\n          root.off(receipt)\n        })\n      }\n    } else {\n      context.value = parentNode?.context\n    }\n  }\n  if (context.value && effect) effect(context.value)\n  return context\n}\n\n/**\n * Allows global access to a specific context by id. The target node MUST have\n * an explicitly defined id.\n * @param id - The id of the node to access the context for.\n * @param effect - An effect callback to run when the context is available.\n */\nexport function useFormKitContextById<T = any>(\n  id: string,\n  effect?: (context: FormKitFrameworkContext<T>) => void\n): Ref<FormKitFrameworkContext<T> | undefined> {\n  const context = ref<FormKitFrameworkContext<T> | undefined>()\n  const targetNode = getNode<T>(id)\n  if (targetNode)\n    context.value = targetNode.context as FormKitFrameworkContext<T>\n  if (!targetNode) {\n    const receipt = watchRegistry(id, ({ payload: node }) => {\n      if (node) {\n        context.value = node.context as FormKitFrameworkContext<T>\n        stopWatch(receipt)\n        if (effect) effect(context.value)\n      }\n    })\n  }\n  if (context.value && effect) effect(context.value)\n  return context\n}\n\n/**\n * Fetches a node by id and returns a ref to the node. The node in question\n * must have an explicitly assigned id prop. If the node is not available, the\n * ref will be undefined until the node is available.\n * @param id - The id of the node to access.\n * @param effect - An optional effect callback to run when the node is available.\n * @returns\n */\nexport function useFormKitNodeById<T>(\n  id: string,\n  effect?: (node: FormKitNode<T>) => void\n): Ref<FormKitNode<T> | undefined> {\n  const nodeRef = ref<FormKitNode<T> | undefined>()\n  const targetNode = getNode<T>(id)\n  if (targetNode) nodeRef.value = targetNode\n  if (!targetNode) {\n    const receipt = watchRegistry(id, ({ payload: node }) => {\n      if (node) {\n        nodeRef.value = node\n        stopWatch(receipt)\n        if (effect) effect(node)\n      }\n    })\n  }\n  if (nodeRef.value && effect) effect(nodeRef.value)\n  return nodeRef\n}\n","import { defineComponent, PropType, computed, inject, h } from 'vue'\nimport { createSection } from '@formkit/inputs'\nimport { token } from '@formkit/utils'\nimport {\n  FormKitNode,\n  FormKitSchemaNode,\n  FormKitSchemaCondition,\n  FormKitFrameworkContext,\n} from '@formkit/core'\nimport { parentSymbol } from './FormKit'\nimport FormKitSchema from './FormKitSchema'\nimport { ref } from 'vue'\nimport { localize } from '@formkit/inputs'\nimport { nextTick } from 'vue'\n\nconst summary = createSection('summary', () => ({\n  $el: 'div',\n  attrs: {\n    'aria-live': 'polite',\n  },\n}))\n\nconst summaryInner = createSection('summaryInner', () => ({\n  $el: 'div',\n  if: '$summaries.length && $showSummaries',\n}))\n\n/**\n * @internal\n */\nconst messages = createSection('messages', () => ({\n  $el: 'ul',\n  if: '$summaries.length && $showSummaries',\n}))\n\n/**\n * @internal\n */\nconst message = createSection('message', () => ({\n  $el: 'li',\n  for: ['summary', '$summaries'],\n  attrs: {\n    key: '$summary.key',\n    'data-message-type': '$summary.type',\n  },\n}))\n\nconst summaryHeader = createSection('summaryHeader', () => ({\n  $el: 'h2',\n  attrs: {\n    id: '$id',\n  },\n}))\n\nconst messageLink = createSection('messageLink', () => ({\n  $el: 'a',\n  attrs: {\n    id: '$summary.key',\n    href: '$: \"#\" + $summary.id',\n    onClick: '$jumpLink',\n  },\n}))\n\n/**\n * The actual schema to render for the messages.\n */\nconst definition = summary(\n  summaryInner(\n    summaryHeader('$summaryHeader'),\n    messages(message(messageLink('$summary.message')))\n  )\n)\n\nexport interface FormKitSummaryMessage {\n  message: string\n  id: string\n  key: string\n  type: string\n}\n\n/**\n * Renders the messages for a parent node, or any node explicitly passed to it.\n * @public\n */\nexport const FormKitSummary = /* #__PURE__ */ defineComponent({\n  props: {\n    node: {\n      type: Object as PropType<FormKitNode> | undefined,\n      required: false,\n    },\n    forceShow: {\n      type: Boolean,\n      default: false,\n    },\n    sectionsSchema: {\n      type: Object as PropType<\n        Record<string, Partial<FormKitSchemaNode> | FormKitSchemaCondition>\n      >,\n      default: {},\n    },\n  },\n  emits: {\n    /* eslint-disable-next-line @typescript-eslint/no-unused-vars */\n    show: (_summaries: Array<FormKitSummaryMessage>) => true,\n  },\n  setup(props, context) {\n    const id = `summary-${token()}`\n    const node = computed<FormKitNode | undefined>(() => {\n      return props.node || inject(parentSymbol, undefined)\n    })\n\n    if (!node)\n      throw new Error(\n        'FormKitSummary must have a FormKit parent or use the node prop.'\n      )\n\n    const summaryContexts = ref<Array<FormKitFrameworkContext>>([])\n    const showSummaries = ref(false)\n    const summaries = computed((): Array<FormKitSummaryMessage> => {\n      const summarizedMessages: Array<FormKitSummaryMessage> = []\n      summaryContexts.value.forEach((context) => {\n        for (const idx in context.messages) {\n          const message = context.messages[idx]\n          if (typeof message.value !== 'string') continue\n          summarizedMessages.push({\n            message: message.value,\n            id: context.id,\n            key: `${context.id}-${message.key}`,\n            type: message.type,\n          })\n        }\n      })\n      return summarizedMessages\n    })\n\n    const addContexts = () => {\n      summaryContexts.value = []\n      node.value?.walk(\n        (child) => child.context && summaryContexts.value.push(child.context)\n      )\n    }\n\n    node.value?.on('submit-raw', async () => {\n      addContexts()\n      if (summaries.value.length === 0) return\n      context.emit('show', summaries.value)\n      showSummaries.value = true\n      await nextTick()\n      if (typeof window !== 'undefined') {\n        document.getElementById(id)?.scrollIntoView({ behavior: 'smooth' })\n        if (summaries.value[0]) {\n          document.getElementById(summaries.value[0].key)?.focus()\n        }\n      }\n    })\n    node.value?.on('child', addContexts)\n\n    function jumpLink(e: MouseEvent) {\n      if (e.target instanceof HTMLAnchorElement) {\n        e.preventDefault()\n        const id = e.target.getAttribute('href')?.substring(1)\n        if (id) {\n          document.getElementById(id)?.scrollIntoView({ behavior: 'smooth' })\n          document.getElementById(id)?.focus()\n        }\n      }\n    }\n\n    localize('summaryHeader', 'There were errors in your form.')(node.value!)\n\n    const schema = definition(props.sectionsSchema || {})\n\n    const data = computed(() => {\n      return {\n        id,\n        fns: node.value?.context?.fns || {},\n        classes: node.value?.context?.classes || {},\n        summaries: summaries.value,\n        showSummaries: props.forceShow || showSummaries.value,\n        summaryHeader: node.value?.context?.ui?.summaryHeader?.value || '',\n        jumpLink,\n      }\n    })\n    return () =>\n      node.value?.context\n        ? h(FormKitSchema, { schema, data: data.value }, { ...context.slots })\n        : null\n  },\n})\n","import type { FormKitRootConfig } from '@formkit/core'\n/**\n * The official FormKit/Vue integration. This package is responsible for\n * integrating Vue with FormKit core and other first-party packages.\n *\n *\n * @packageDocumentation\n */\n\ndeclare global {\n  // eslint-disable-next-line no-var\n  var __FORMKIT_CONFIGS__: FormKitRootConfig[]\n}\n\n/**\n * The useInput composable.\n */\nexport { useInput } from './composables/useInput'\n\n/**\n * Shorthand for creating inputs with standard FormKit features.\n */\nexport { createInput } from './composables/createInput'\n\n/**\n * The defineFormKitConfig composable.\n */\nexport { defineFormKitConfig } from './composables/defineFormKitConfig'\n\n/**\n * The plugin and plugin types.\n */\nexport * from './plugin'\n\n/**\n * The root FormKit component.\n */\nexport {\n  default as FormKit,\n  FormKitComponent,\n  FormKitSetupContext,\n  Slots,\n  parentSymbol,\n  componentSymbol,\n  getCurrentSchemaNode,\n} from './FormKit'\n\n/**\n * The FormKitRoot wrapper component used to provide context to FormKit\n * about whether a FormKit input is booting in a Document or ShadowRoot.\n */\nexport { FormKitRoot, rootSymbol } from './FormKitRoot'\n\n/**\n * The FormKitKitchenSink component.\n */\nexport { FormKitKitchenSink } from './FormKitKitchenSink'\n\n/**\n * The FormKitMessages component.\n * @public\n */\nexport { FormKitMessages } from './FormKitMessages'\n\n/**\n * The FormKitProvider component.\n * @public\n */\nexport {\n  FormKitProvider,\n  FormKitLazyProvider,\n  useConfig,\n} from './FormKitProvider'\n\n/**\n * Exports the useFormKitContext composable.\n */\nexport {\n  useFormKitContext,\n  useFormKitContextById,\n  useFormKitNodeById,\n} from './composables/useContext'\n\n/**\n * The FormKitSummary component.\n * @public\n */\nexport { FormKitSummary, FormKitSummaryMessage } from './FormKitSummary'\n\n/**\n * The FormKitSchema component.\n */\nexport {\n  FormKitSchema,\n  Renderable,\n  RenderableList,\n  RenderableSlot,\n  RenderableSlots,\n  FormKitComponentLibrary,\n  VirtualNode,\n} from './FormKitSchema'\n\n/**\n * The default configuration.\n */\nexport {\n  defaultConfig,\n  DefaultConfigOptions,\n  PluginConfigs,\n} from './defaultConfig'\n\n/**\n * The vue specific FormKit core plugin. This is generally required for all\n * vue based FormKit configurations.\n */\nexport { default as bindings } from './bindings'\n\n/**\n * A vue component for rendering icons from the FormKit icon registry\n */\nexport { FormKitIcon } from './FormKitIcon'\n\n/**\n * The counter reset for sequential identifiers.\n */\nexport { resetCount } from './utilities/resetCount'\n\n/**\n * Export the reset count explicitly\n */\nexport {\n  errorHandler,\n  setErrors,\n  clearErrors,\n  submitForm,\n  reset,\n} from '@formkit/core'\n\n/**\n * Export the changeLocale function explicitly.\n */\nexport { changeLocale } from '@formkit/i18n'\n\n/**\n * SSR support for cleanup operations relating to SSR.\n */\nexport { ssrComplete, onSSRComplete } from './composables/onSSRComplete'\n","import { h, ref, watch, defineComponent, inject, PropType } from 'vue'\nimport { optionsSymbol } from './plugin'\nimport { parentSymbol } from './FormKit'\nimport { FormKitPlugin } from '@formkit/core'\nimport { FormKitIconLoader, createIconHandler } from '@formkit/themes'\n\n/**\n * Renders an icon using the current IconLoader set at the root FormKit config\n *\n * @public\n */\nexport const FormKitIcon = /* #__PURE__ */ defineComponent({\n  name: 'FormKitIcon',\n  props: {\n    icon: {\n      type: String,\n      default: '',\n    },\n    iconLoader: {\n      type: Function as PropType<FormKitIconLoader>,\n      default: null,\n    },\n    iconLoaderUrl: {\n      type: Function as PropType<(iconName: string) => string>,\n      default: null,\n    },\n  },\n  setup(props) {\n    const icon = ref<undefined | string>(undefined)\n    const config = inject(optionsSymbol, {})\n    const parent = inject(parentSymbol, null)\n    let iconHandler: FormKitIconLoader | undefined = undefined\n\n    function loadIcon() {\n      if (!iconHandler || typeof iconHandler !== 'function') return\n      const iconOrPromise = iconHandler(props.icon)\n      if (iconOrPromise instanceof Promise) {\n        iconOrPromise.then((iconValue) => {\n          icon.value = iconValue\n        })\n      } else {\n        icon.value = iconOrPromise\n      }\n    }\n\n    if (props.iconLoader && typeof props.iconLoader === 'function') {\n      // if we have a locally supplied loader, then use it\n      iconHandler = createIconHandler(props.iconLoader)\n    } else if (parent && parent.props?.iconLoader) {\n      // otherwise try to inherit from a parent\n      iconHandler = createIconHandler(parent.props.iconLoader)\n    } else if (\n      props.iconLoaderUrl &&\n      typeof props.iconLoaderUrl === 'function'\n    ) {\n      iconHandler = createIconHandler(iconHandler, props.iconLoaderUrl)\n    } else {\n      // grab our iconHandler from the global config\n      const iconPlugin = config?.plugins?.find((plugin) => {\n        return (\n          typeof (plugin as FormKitPlugin & { iconHandler: FormKitIconLoader })\n            .iconHandler === 'function'\n        )\n      }) as (FormKitPlugin & { iconHandler: FormKitIconLoader }) | undefined\n      if (iconPlugin) {\n        iconHandler = iconPlugin.iconHandler\n      }\n    }\n\n    watch(\n      () => props.icon,\n      () => {\n        loadIcon()\n      },\n      { immediate: true }\n    )\n\n    return () => {\n      if (props.icon && icon.value) {\n        return h('span', {\n          class: 'formkit-icon',\n          innerHTML: icon.value,\n        })\n      }\n      return null\n    }\n  },\n})\n\nexport default FormKitIcon\n","/**\n * Reset any counters in the inputs package.\n */\nimport { resetCounts } from '@formkit/inputs'\nimport { resetCount as coreResetCount } from '@formkit/core'\n\nexport function resetCount() {\n  resetCounts()\n  coreResetCount()\n}\n"]}