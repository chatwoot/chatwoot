{"version":3,"file":"triggerMatching.js","sourceRoot":"","sources":["../../../../src/extensions/replay/triggerMatching.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n    SESSION_RECORDING_EVENT_TRIGGER_ACTIVATED_SESSION,\n    SESSION_RECORDING_URL_TRIGGER_ACTIVATED_SESSION,\n} from '../../constants'\nimport { PostHog } from '../../posthog-core'\nimport { FlagVariant, RemoteConfig, SessionRecordingUrlTrigger } from '../../types'\nimport { isNullish, isBoolean, isString, isObject } from '@posthog/core'\nimport { window } from '../../utils/globals'\n\nexport const DISABLED = 'disabled'\nexport const SAMPLED = 'sampled'\nexport const ACTIVE = 'active'\nexport const BUFFERING = 'buffering'\nexport const PAUSED = 'paused'\n\nconst TRIGGER = 'trigger'\nexport const TRIGGER_ACTIVATED = TRIGGER + '_activated'\nexport const TRIGGER_PENDING = TRIGGER + '_pending'\nexport const TRIGGER_DISABLED = TRIGGER + '_' + DISABLED\n\nexport interface RecordingTriggersStatus {\n    get receivedFlags(): boolean\n    get isRecordingEnabled(): false | true | undefined\n    get isSampled(): false | true | null\n    get urlTriggerMatching(): URLTriggerMatching\n    get eventTriggerMatching(): EventTriggerMatching\n    get linkedFlagMatching(): LinkedFlagMatching\n    get sessionId(): string\n}\n\nexport type TriggerType = 'url' | 'event'\n/* \ntriggers can have one of three statuses:\n * - trigger_activated: the trigger met conditions to start recording\n * - trigger_pending: the trigger is present, but the conditions are not yet met\n * - trigger_disabled: the trigger is not present\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst triggerStatuses = [TRIGGER_ACTIVATED, TRIGGER_PENDING, TRIGGER_DISABLED] as const\nexport type TriggerStatus = (typeof triggerStatuses)[number]\n\n/**\n * Session recording starts in buffering mode while waiting for \"flags response\".\n * Once the response is received, it might be disabled, active or sampled.\n * When \"sampled\" that means a sample rate is set, and the last time the session ID rotated\n * the sample rate determined this session should be sent to the server.\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst sessionRecordingStatuses = [DISABLED, SAMPLED, ACTIVE, BUFFERING, PAUSED] as const\nexport type SessionRecordingStatus = (typeof sessionRecordingStatuses)[number]\n\nfunction sessionRecordingUrlTriggerMatches(url: string, triggers: SessionRecordingUrlTrigger[]) {\n    return triggers.some((trigger) => {\n        switch (trigger.matching) {\n            case 'regex':\n                return new RegExp(trigger.url).test(url)\n            default:\n                return false\n        }\n    })\n}\n\nexport interface TriggerStatusMatching {\n    triggerStatus(sessionId: string): TriggerStatus\n    stop(): void\n}\nexport class OrTriggerMatching implements TriggerStatusMatching {\n    constructor(private readonly _matchers: TriggerStatusMatching[]) {}\n\n    triggerStatus(sessionId: string): TriggerStatus {\n        const statuses = this._matchers.map((m) => m.triggerStatus(sessionId))\n        if (statuses.includes(TRIGGER_ACTIVATED)) {\n            return TRIGGER_ACTIVATED\n        }\n        if (statuses.includes(TRIGGER_PENDING)) {\n            return TRIGGER_PENDING\n        }\n        return TRIGGER_DISABLED\n    }\n\n    stop(): void {\n        this._matchers.forEach((m) => m.stop())\n    }\n}\n\nexport class AndTriggerMatching implements TriggerStatusMatching {\n    constructor(private readonly _matchers: TriggerStatusMatching[]) {}\n\n    triggerStatus(sessionId: string): TriggerStatus {\n        const statuses = new Set<TriggerStatus>()\n        for (const matcher of this._matchers) {\n            statuses.add(matcher.triggerStatus(sessionId))\n        }\n\n        // trigger_disabled means no config\n        statuses.delete(TRIGGER_DISABLED)\n        switch (statuses.size) {\n            case 0:\n                return TRIGGER_DISABLED\n            case 1:\n                return Array.from(statuses)[0]\n            default:\n                return TRIGGER_PENDING\n        }\n    }\n\n    stop(): void {\n        this._matchers.forEach((m) => m.stop())\n    }\n}\n\nexport class PendingTriggerMatching implements TriggerStatusMatching {\n    triggerStatus(): TriggerStatus {\n        return TRIGGER_PENDING\n    }\n\n    stop(): void {\n        // no-op\n    }\n}\n\nexport class URLTriggerMatching implements TriggerStatusMatching {\n    _urlTriggers: SessionRecordingUrlTrigger[] = []\n    _urlBlocklist: SessionRecordingUrlTrigger[] = []\n\n    urlBlocked: boolean = false\n\n    constructor(private readonly _instance: PostHog) {}\n\n    onRemoteConfig(response: RemoteConfig) {\n        this._urlTriggers = response.sessionRecording?.urlTriggers || []\n        this._urlBlocklist = response.sessionRecording?.urlBlocklist || []\n    }\n\n    private _urlTriggerStatus(sessionId: string): TriggerStatus {\n        if (this._urlTriggers.length === 0) {\n            return TRIGGER_DISABLED\n        }\n\n        const currentTriggerSession = this._instance?.get_property(SESSION_RECORDING_URL_TRIGGER_ACTIVATED_SESSION)\n        return currentTriggerSession === sessionId ? TRIGGER_ACTIVATED : TRIGGER_PENDING\n    }\n\n    triggerStatus(sessionId: string): TriggerStatus {\n        const urlTriggerStatus = this._urlTriggerStatus(sessionId)\n        const eitherIsActivated = urlTriggerStatus === TRIGGER_ACTIVATED\n        const eitherIsPending = urlTriggerStatus === TRIGGER_PENDING\n\n        const result = eitherIsActivated ? TRIGGER_ACTIVATED : eitherIsPending ? TRIGGER_PENDING : TRIGGER_DISABLED\n        this._instance.register_for_session({\n            $sdk_debug_replay_url_trigger_status: result,\n        })\n        return result\n    }\n\n    checkUrlTriggerConditions(\n        onPause: () => void,\n        onResume: () => void,\n        onActivate: (triggerType: TriggerType) => void\n    ) {\n        if (typeof window === 'undefined' || !window.location.href) {\n            return\n        }\n\n        const url = window.location.href\n\n        const wasBlocked = this.urlBlocked\n        const isNowBlocked = sessionRecordingUrlTriggerMatches(url, this._urlBlocklist)\n\n        if (wasBlocked && isNowBlocked) {\n            // if the url is blocked and was already blocked, do nothing\n            return\n        } else if (isNowBlocked && !wasBlocked) {\n            onPause()\n        } else if (!isNowBlocked && wasBlocked) {\n            onResume()\n        }\n\n        if (sessionRecordingUrlTriggerMatches(url, this._urlTriggers)) {\n            onActivate('url')\n        }\n    }\n\n    stop(): void {\n        // no-op\n    }\n}\n\nexport class LinkedFlagMatching implements TriggerStatusMatching {\n    linkedFlag: string | FlagVariant | null = null\n    linkedFlagSeen: boolean = false\n    private _flaglistenerCleanup: () => void = () => {}\n    constructor(private readonly _instance: PostHog) {}\n\n    triggerStatus(): TriggerStatus {\n        let result = TRIGGER_PENDING\n        if (isNullish(this.linkedFlag)) {\n            result = TRIGGER_DISABLED\n        }\n        if (this.linkedFlagSeen) {\n            result = TRIGGER_ACTIVATED\n        }\n        this._instance.register_for_session({\n            $sdk_debug_replay_linked_flag_trigger_status: result,\n        })\n        return result\n    }\n\n    onRemoteConfig(response: RemoteConfig, onStarted: (flag: string, variant: string | null) => void) {\n        this.linkedFlag = response.sessionRecording?.linkedFlag || null\n\n        if (!isNullish(this.linkedFlag) && !this.linkedFlagSeen) {\n            const linkedFlag = isString(this.linkedFlag) ? this.linkedFlag : this.linkedFlag.flag\n            const linkedVariant = isString(this.linkedFlag) ? null : this.linkedFlag.variant\n            this._flaglistenerCleanup = this._instance.onFeatureFlags((_flags, variants) => {\n                const flagIsPresent = isObject(variants) && linkedFlag in variants\n                let linkedFlagMatches = false\n                if (flagIsPresent) {\n                    const variantForFlagKey = variants[linkedFlag]\n                    if (isBoolean(variantForFlagKey)) {\n                        linkedFlagMatches = variantForFlagKey === true\n                    } else if (linkedVariant) {\n                        linkedFlagMatches = variantForFlagKey === linkedVariant\n                    } else {\n                        // then this is a variant flag and we want to match any string\n                        linkedFlagMatches = !!variantForFlagKey\n                    }\n                }\n                this.linkedFlagSeen = linkedFlagMatches\n                if (linkedFlagMatches) {\n                    onStarted(linkedFlag, linkedVariant)\n                }\n            })\n        }\n    }\n\n    stop(): void {\n        this._flaglistenerCleanup()\n    }\n}\n\nexport class EventTriggerMatching implements TriggerStatusMatching {\n    _eventTriggers: string[] = []\n\n    constructor(private readonly _instance: PostHog) {}\n\n    onRemoteConfig(response: RemoteConfig) {\n        this._eventTriggers = response.sessionRecording?.eventTriggers || []\n    }\n\n    private _eventTriggerStatus(sessionId: string): TriggerStatus {\n        if (this._eventTriggers.length === 0) {\n            return TRIGGER_DISABLED\n        }\n\n        const currentTriggerSession = this._instance?.get_property(SESSION_RECORDING_EVENT_TRIGGER_ACTIVATED_SESSION)\n        return currentTriggerSession === sessionId ? TRIGGER_ACTIVATED : TRIGGER_PENDING\n    }\n\n    triggerStatus(sessionId: string): TriggerStatus {\n        const eventTriggerStatus = this._eventTriggerStatus(sessionId)\n        const result =\n            eventTriggerStatus === TRIGGER_ACTIVATED\n                ? TRIGGER_ACTIVATED\n                : eventTriggerStatus === TRIGGER_PENDING\n                  ? TRIGGER_PENDING\n                  : TRIGGER_DISABLED\n        this._instance.register_for_session({\n            $sdk_debug_replay_event_trigger_status: result,\n        })\n        return result\n    }\n\n    stop(): void {\n        // no-op\n    }\n}\n\n// we need a no-op matcher before we can lazy-load the other matches, since all matchers wait on remote config anyway\nexport function nullMatchSessionRecordingStatus(triggersStatus: RecordingTriggersStatus): SessionRecordingStatus {\n    if (!triggersStatus.isRecordingEnabled) {\n        return DISABLED\n    }\n\n    return BUFFERING\n}\n\nexport function anyMatchSessionRecordingStatus(triggersStatus: RecordingTriggersStatus): SessionRecordingStatus {\n    if (!triggersStatus.receivedFlags) {\n        return BUFFERING\n    }\n\n    if (!triggersStatus.isRecordingEnabled) {\n        return DISABLED\n    }\n\n    if (triggersStatus.urlTriggerMatching.urlBlocked) {\n        return PAUSED\n    }\n\n    const sampledActive = triggersStatus.isSampled === true\n    const triggerMatches = new OrTriggerMatching([\n        triggersStatus.eventTriggerMatching,\n        triggersStatus.urlTriggerMatching,\n        triggersStatus.linkedFlagMatching,\n    ]).triggerStatus(triggersStatus.sessionId)\n\n    if (sampledActive) {\n        return SAMPLED\n    }\n\n    if (triggerMatches === TRIGGER_ACTIVATED) {\n        return ACTIVE\n    }\n\n    if (triggerMatches === TRIGGER_PENDING) {\n        // even if sampled active is false, we should still be buffering\n        // since a pending trigger could override it\n        return BUFFERING\n    }\n\n    // if sampling is set and the session is already decided to not be sampled\n    // then we should never be active\n    if (triggersStatus.isSampled === false) {\n        return DISABLED\n    }\n\n    return ACTIVE\n}\n\nexport function allMatchSessionRecordingStatus(triggersStatus: RecordingTriggersStatus): SessionRecordingStatus {\n    if (!triggersStatus.receivedFlags) {\n        return BUFFERING\n    }\n\n    if (!triggersStatus.isRecordingEnabled) {\n        return DISABLED\n    }\n\n    if (triggersStatus.urlTriggerMatching.urlBlocked) {\n        return PAUSED\n    }\n\n    const andTriggerMatch = new AndTriggerMatching([\n        triggersStatus.eventTriggerMatching,\n        triggersStatus.urlTriggerMatching,\n        triggersStatus.linkedFlagMatching,\n    ])\n    const currentTriggerStatus = andTriggerMatch.triggerStatus(triggersStatus.sessionId)\n    const hasTriggersConfigured = currentTriggerStatus !== TRIGGER_DISABLED\n\n    const hasSamplingConfigured = isBoolean(triggersStatus.isSampled)\n\n    if (hasTriggersConfigured && currentTriggerStatus === TRIGGER_PENDING) {\n        return BUFFERING\n    }\n\n    if (hasTriggersConfigured && currentTriggerStatus === TRIGGER_DISABLED) {\n        return DISABLED\n    }\n\n    // sampling can't ever cause buffering, it's always determined right away or not configured\n    if (hasSamplingConfigured && !triggersStatus.isSampled) {\n        return DISABLED\n    }\n\n    // If sampling is configured and set to true, return sampled\n    if (triggersStatus.isSampled === true) {\n        return SAMPLED\n    }\n\n    return ACTIVE\n}\n"]}