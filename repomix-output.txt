This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: **/*.js, **/*.vue, **/*.svg, **/*.json
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
actions/
  contact_identify_action.rb
  contact_merge_action.rb
assets/
  stylesheets/
    administrate/
      base/
        _forms.scss
        _layout.scss
        _lists.scss
        _tables.scss
        _typography.scss
      components/
        _app-container.scss
        _attributes.scss
        _buttons.scss
        _cells.scss
        _field-unit.scss
        _flashes.scss
        _form-actions.scss
        _main-content.scss
        _pagination.scss
        _reports.scss
        _search.scss
      library/
        _clearfix.scss
        _data-label.scss
        _variables.scss
      reset/
        _normalize.scss
      utilities/
        _text-color.scss
        _variables.scss
      application.scss
      custom_styles.scss
builders/
  campaigns/
    campaign_conversation_builder.rb
  csat_surveys/
    response_builder.rb
  messages/
    facebook/
      message_builder.rb
    instagram/
      message_builder.rb
    messenger/
      message_builder.rb
    message_builder.rb
  v2/
    reports/
      conversations/
        base_report_builder.rb
        metric_builder.rb
        report_builder.rb
      timeseries/
        average_report_builder.rb
        base_timeseries_builder.rb
        count_report_builder.rb
      agent_summary_builder.rb
      base_summary_builder.rb
      bot_metrics_builder.rb
      inbox_summary_builder.rb
      team_summary_builder.rb
    report_builder.rb
  account_builder.rb
  agent_builder.rb
  contact_inbox_builder.rb
  contact_inbox_with_contact_builder.rb
  conversation_builder.rb
  notification_builder.rb
  notification_subscription_builder.rb
channels/
  application_cable/
    channel.rb
    connection.rb
  room_channel.rb
controllers/
  api/
    v1/
      accounts/
        actions/
          contact_merges_controller.rb
        channels/
          twilio_channels_controller.rb
        contacts/
          base_controller.rb
          contact_inboxes_controller.rb
          conversations_controller.rb
          labels_controller.rb
          notes_controller.rb
        conversations/
          assignments_controller.rb
          base_controller.rb
          direct_uploads_controller.rb
          draft_messages_controller.rb
          labels_controller.rb
          messages_controller.rb
          participants_controller.rb
        google/
          authorizations_controller.rb
        integrations/
          apps_controller.rb
          dyte_controller.rb
          hooks_controller.rb
          linear_controller.rb
          slack_controller.rb
        microsoft/
          authorizations_controller.rb
        twitter/
          authorizations_controller.rb
        agent_bots_controller.rb
        agents_controller.rb
        articles_controller.rb
        assignable_agents_controller.rb
        automation_rules_controller.rb
        base_controller.rb
        bulk_actions_controller.rb
        callbacks_controller.rb
        campaigns_controller.rb
        canned_responses_controller.rb
        categories_controller.rb
        contact_inboxes_controller.rb
        contacts_controller.rb
        conversations_controller.rb
        csat_survey_responses_controller.rb
        custom_attribute_definitions_controller.rb
        custom_filters_controller.rb
        dashboard_apps_controller.rb
        inbox_members_controller.rb
        inboxes_controller.rb
        labels_controller.rb
        macros_controller.rb
        notification_settings_controller.rb
        notifications_controller.rb
        portals_controller.rb
        search_controller.rb
        team_members_controller.rb
        teams_controller.rb
        upload_controller.rb
        webhooks_controller.rb
        working_hours_controller.rb
      integrations/
        webhooks_controller.rb
      widget/
        integrations/
          dyte_controller.rb
        base_controller.rb
        campaigns_controller.rb
        configs_controller.rb
        contacts_controller.rb
        conversations_controller.rb
        direct_uploads_controller.rb
        events_controller.rb
        inbox_members_controller.rb
        labels_controller.rb
        messages_controller.rb
      accounts_controller.rb
      notification_subscriptions_controller.rb
      profiles_controller.rb
      webhooks_controller.rb
    v2/
      accounts/
        live_reports_controller.rb
        reports_controller.rb
        summary_reports_controller.rb
      accounts_controller.rb
    base_controller.rb
  concerns/
    access_token_auth_helper.rb
    auth_helper.rb
    domain_helper.rb
    ensure_current_account_helper.rb
    google_concern.rb
    hmac_concern.rb
    label_concern.rb
    meta_token_verify_concern.rb
    microsoft_concern.rb
    request_exception_handler.rb
    switch_locale.rb
    twitter_concern.rb
    website_token_helper.rb
  devise_overrides/
    confirmations_controller.rb
    omniauth_callbacks_controller.rb
    passwords_controller.rb
    sessions_controller.rb
    token_validations_controller.rb
  google/
    callbacks_controller.rb
  installation/
    onboarding_controller.rb
  linear/
    callbacks_controller.rb
  microsoft/
    callbacks_controller.rb
  platform/
    api/
      v1/
        account_users_controller.rb
        accounts_controller.rb
        agent_bots_controller.rb
        users_controller.rb
  public/
    api/
      v1/
        inboxes/
          contacts_controller.rb
          conversations_controller.rb
          messages_controller.rb
        portals/
          articles_controller.rb
          base_controller.rb
          categories_controller.rb
        csat_survey_controller.rb
        inboxes_controller.rb
        portals_controller.rb
  super_admin/
    devise/
      sessions_controller.rb
    access_tokens_controller.rb
    account_users_controller.rb
    accounts_controller.rb
    agent_bots_controller.rb
    app_configs_controller.rb
    application_controller.rb
    dashboard_controller.rb
    installation_configs_controller.rb
    instance_statuses_controller.rb
    platform_apps_controller.rb
    settings_controller.rb
    users_controller.rb
  survey/
    responses_controller.rb
  twilio/
    callback_controller.rb
    delivery_status_controller.rb
  twitter/
    base_controller.rb
    callbacks_controller.rb
  webhooks/
    instagram_controller.rb
    line_controller.rb
    sms_controller.rb
    telegram_controller.rb
    whatsapp_controller.rb
  android_app_controller.rb
  api_controller.rb
  apple_app_controller.rb
  application_controller.rb
  dashboard_controller.rb
  microsoft_controller.rb
  oauth_callback_controller.rb
  platform_controller.rb
  public_controller.rb
  slack_uploads_controller.rb
  swagger_controller.rb
  widget_tests_controller.rb
  widgets_controller.rb
dashboards/
  access_token_dashboard.rb
  account_dashboard.rb
  account_user_dashboard.rb
  agent_bot_dashboard.rb
  installation_config_dashboard.rb
  platform_app_dashboard.rb
  user_dashboard.rb
dispatchers/
  async_dispatcher.rb
  base_dispatcher.rb
  dispatcher.rb
  sync_dispatcher.rb
drops/
  account_drop.rb
  base_drop.rb
  contact_drop.rb
  conversation_drop.rb
  inbox_drop.rb
  message_drop.rb
  user_drop.rb
fields/
  enterprise/
    account_features_field.rb
    account_limits_field.rb
  avatar_field.rb
  count_field.rb
  secret_field.rb
  serialized_field.rb
finders/
  conversation_finder.rb
  email_channel_finder.rb
  message_finder.rb
  notification_finder.rb
helpers/
  api/
    v1/
      widget/
        messages_helper.rb
      agents_helper.rb
      canned_responses_helper.rb
      conversations_helper.rb
      inboxes_helper.rb
    v2/
      accounts/
        heatmap_helper.rb
        reports_helper.rb
    base_helper.rb
  filters/
    filter_helper.rb
  linear/
    integration_helper.rb
  super_admin/
    account_features_helper.rb
  application_helper.rb
  billing_helper.rb
  cache_keys_helper.rb
  contact_helper.rb
  date_range_helper.rb
  email_helper.rb
  file_type_helper.rb
  frontend_urls_helper.rb
  home_helper.rb
  message_format_helper.rb
  portal_helper.rb
  report_helper.rb
  reporting_event_helper.rb
  timezone_helper.rb
  widget_helper.rb
javascript/
  dashboard/
    assets/
      scss/
        plugins/
          _dropdown.scss
          _multiselect.scss
        super_admin/
          index.scss
        views/
          settings/
            inbox.scss
            integrations.scss
        widgets/
          _base.scss
          _buttons.scss
          _conversation-view.scss
          _tabs.scss
          _woot-tables.scss
        _animations.scss
        _date-picker.scss
        _formulate.scss
        _helper-classes.scss
        _layout.scss
        _mixins.scss
        _rtl.scss
        _variables.scss
        _woot.scss
        app.scss
    components/
      specs/
        __snapshots__/
          SidemenuIcon.spec.js.snap
    routes/
      dashboard/
        settings/
          reports/
            components/
              specs/
                __snapshots__/
                  CSATMetrics.spec.js.snap
  design-system/
    histoire.scss
  portal/
    application.scss
  shared/
    assets/
      fonts/
        InterDisplay/
          inter-display.scss
        inter.scss
        widget_fonts.scss
      stylesheets/
        animations.scss
        border-radius.scss
        colors.scss
        font-size.scss
        font-weights.scss
        shadows.scss
        spacing.scss
        z-index.scss
    components/
      specs/
        __snapshots__/
          DateSeparator.spec.js.snap
          Spinner.spec.js.snap
  survey/
    assets/
      scss/
        woot.scss
  widget/
    assets/
      scss/
        views/
          _conversation.scss
        _buttons.scss
        _forms.scss
        _mixins.scss
        _reset.scss
        _utilities.scss
        _variables.scss
        woot.scss
  histoire.setup.ts
jobs/
  account/
    contacts_export_job.rb
    conversations_resolution_scheduler_job.rb
  agent_bots/
    csml_job.rb
    webhook_job.rb
  agents/
    destroy_job.rb
  avatar/
    avatar_from_gravatar_job.rb
    avatar_from_url_job.rb
  campaigns/
    trigger_oneoff_campaign_job.rb
  channels/
    whatsapp/
      templates_sync_job.rb
      templates_sync_scheduler_job.rb
  conversations/
    activity_message_job.rb
    reopen_snoozed_conversations_job.rb
    resolution_job.rb
    update_message_status_job.rb
    user_mention_job.rb
  inboxes/
    fetch_imap_email_inboxes_job.rb
    fetch_imap_emails_job.rb
    sync_widget_pre_chat_custom_fields_job.rb
    update_widget_pre_chat_custom_fields_job.rb
  internal/
    check_new_versions_job.rb
    process_stale_redis_keys_job.rb
    remove_stale_contact_inboxes_job.rb
    remove_stale_redis_keys_job.rb
    seed_account_job.rb
  labels/
    update_job.rb
  migration/
    add_search_indexes_job.rb
    conversation_batch_cache_label_job.rb
    conversation_cache_label_job.rb
    conversations_first_reply_scheduler_job.rb
    remove_message_notifications.rb
    remove_stale_notifications_job.rb
    update_first_response_time_in_reporting_events_job.rb
  notification/
    delete_notification_job.rb
    email_notification_job.rb
    push_notification_job.rb
    remove_duplicate_notification_job.rb
    remove_old_notification_job.rb
    reopen_snoozed_notifications_job.rb
  webhooks/
    facebook_delivery_job.rb
    facebook_events_job.rb
    instagram_events_job.rb
    line_events_job.rb
    sms_events_job.rb
    telegram_events_job.rb
    whatsapp_events_job.rb
  action_cable_broadcast_job.rb
  application_job.rb
  bulk_actions_job.rb
  contact_ip_lookup_job.rb
  data_import_job.rb
  delete_object_job.rb
  event_dispatcher_job.rb
  hook_job.rb
  macros_execution_job.rb
  mutex_application_job.rb
  send_on_slack_job.rb
  send_reply_job.rb
  slack_unfurl_job.rb
  trigger_scheduled_items_job.rb
  webhook_job.rb
listeners/
  action_cable_listener.rb
  agent_bot_listener.rb
  automation_rule_listener.rb
  base_listener.rb
  campaign_listener.rb
  csat_survey_listener.rb
  hook_listener.rb
  installation_webhook_listener.rb
  notification_listener.rb
  participation_listener.rb
  reporting_event_listener.rb
  webhook_listener.rb
mailboxes/
  imap/
    imap_mailbox.rb
  application_mailbox.rb
  default_mailbox.rb
  incoming_email_validity_helper.rb
  mailbox_helper.rb
  reply_mailbox.rb
  support_mailbox.rb
mailers/
  administrator_notifications/
    channel_notifications_mailer.rb
  agent_notifications/
    conversation_notifications_mailer.rb
  team_notifications/
    automation_notification_mailer.rb
  application_mailer.rb
  conversation_reply_mailer_helper.rb
  conversation_reply_mailer.rb
models/
  channel/
    api.rb
    email.rb
    facebook_page.rb
    line.rb
    sms.rb
    telegram.rb
    twilio_sms.rb
    twitter_profile.rb
    web_widget.rb
    whatsapp.rb
  concerns/
    access_tokenable.rb
    account_cache_revalidator.rb
    activity_message_handler.rb
    assignment_handler.rb
    auto_assignment_handler.rb
    availability_statusable.rb
    avatarable.rb
    cache_keys.rb
    channelable.rb
    content_attribute_validator.rb
    conversation_mute_helpers.rb
    featurable.rb
    json_schema_validator.rb
    label_activity_message_handler.rb
    labelable.rb
    liquidable.rb
    llm_formattable.rb
    message_filter_helpers.rb
    out_of_offisable.rb
    priority_activity_message_handler.rb
    pubsubable.rb
    push_data_helper.rb
    reauthorizable.rb
    reportable.rb
    sla_activity_message_handler.rb
    sort_handler.rb
    sso_authenticatable.rb
    team_activity_message_handler.rb
    user_attribute_helpers.rb
  integrations/
    app.rb
    hook.rb
  access_token.rb
  account_user.rb
  account.rb
  agent_bot_inbox.rb
  agent_bot.rb
  application_record.rb
  article.rb
  attachment.rb
  automation_rule.rb
  campaign.rb
  canned_response.rb
  category.rb
  contact_inbox.rb
  contact.rb
  conversation_participant.rb
  conversation.rb
  csat_survey_response.rb
  custom_attribute_definition.rb
  custom_filter.rb
  dashboard_app.rb
  data_import.rb
  email_template.rb
  folder.rb
  inbox_member.rb
  inbox.rb
  installation_config.rb
  integrations.rb
  jsonb_attributes_length_validator.rb
  kbase.rb
  label.rb
  macro.rb
  mention.rb
  message.rb
  note.rb
  notification_setting.rb
  notification_subscription.rb
  notification.rb
  platform_app_permissible.rb
  platform_app.rb
  portal_member.rb
  portal.rb
  related_category.rb
  reporting_event.rb
  super_admin.rb
  team_member.rb
  team.rb
  telegram_bot.rb
  user.rb
  webhook.rb
  working_hour.rb
policies/
  account_policy.rb
  agent_bot_policy.rb
  application_policy.rb
  article_policy.rb
  automation_rule_policy.rb
  campaign_policy.rb
  category_policy.rb
  contact_policy.rb
  conversation_policy.rb
  csat_survey_response_policy.rb
  custom_filter_policy.rb
  hook_policy.rb
  inbox_policy.rb
  label_policy.rb
  macro_policy.rb
  portal_policy.rb
  report_policy.rb
  team_member_policy.rb
  team_policy.rb
  user_policy.rb
  webhook_policy.rb
presenters/
  conversations/
    event_data_presenter.rb
  inbox/
    event_data_presenter.rb
  reports/
    time_format_presenter.rb
  agent_bot_presenter.rb
  html_parser.rb
  mail_presenter.rb
services/
  agent_bots/
    validate_bot_service.rb
  auto_assignment/
    agent_assignment_service.rb
    inbox_round_robin_service.rb
  automation_rules/
    action_service.rb
    condition_validation_service.rb
    conditions_filter_service.rb
  base/
    send_on_channel_service.rb
  contacts/
    contactable_inboxes_service.rb
    filter_service.rb
    sync_attributes.rb
  conversations/
    filter_service.rb
    typing_status_manager.rb
  data_import/
    contact_manager.rb
  email_templates/
    db_resolver_service.rb
  facebook/
    send_on_facebook_service.rb
  geocoder/
    setup_service.rb
  google/
    refresh_oauth_token_service.rb
  imap/
    base_fetch_email_service.rb
    fetch_email_service.rb
    google_fetch_email_service.rb
    microsoft_fetch_email_service.rb
  instagram/
    message_text.rb
    read_status_service.rb
    send_on_instagram_service.rb
    webhooks_base_service.rb
  internal/
    remove_stale_contact_inboxes_service.rb
    remove_stale_redis_keys_service.rb
  labels/
    update_service.rb
  line/
    incoming_message_service.rb
    send_on_line_service.rb
  llm_formatter/
    contact_llm_formatter.rb
    conversation_llm_formatter.rb
    default_llm_formatter.rb
    llm_text_formatter_service.rb
  macros/
    execution_service.rb
  message_templates/
    template/
      csat_survey.rb
      email_collect.rb
      greeting.rb
      out_of_office.rb
    hook_execution_service.rb
  messages/
    in_reply_to_message_builder.rb
    mention_service.rb
    new_message_notification_service.rb
  microsoft/
    refresh_oauth_token_service.rb
  notification/
    email_notification_service.rb
    fcm_service.rb
    push_notification_service.rb
  sms/
    delivery_status_service.rb
    incoming_message_service.rb
    oneoff_sms_campaign_service.rb
    send_on_sms_service.rb
  telegram/
    incoming_message_service.rb
    param_helpers.rb
    send_attachments_service.rb
    send_on_telegram_service.rb
    update_message_service.rb
  twilio/
    delivery_status_service.rb
    incoming_message_service.rb
    oneoff_sms_campaign_service.rb
    send_on_twilio_service.rb
    webhook_setup_service.rb
  twitter/
    direct_message_parser_service.rb
    send_on_twitter_service.rb
    tweet_parser_service.rb
    webhook_subscribe_service.rb
    webhooks_base_service.rb
  whatsapp/
    providers/
      base_service.rb
      whatsapp_360_dialog_service.rb
      whatsapp_cloud_service.rb
    incoming_message_base_service.rb
    incoming_message_service_helpers.rb
    incoming_message_service.rb
    incoming_message_whatsapp_cloud_service.rb
    send_on_whatsapp_service.rb
  widget/
    token_service.rb
  action_service.rb
  base_refresh_oauth_token_service.rb
  filter_service.rb
  ip_lookup_service.rb
  search_service.rb
views/
  android_app/
    assetlinks.json.erb
  api/
    v1/
      accounts/
        actions/
          contact_merges/
            create.json.jbuilder
        agent_bots/
          avatar.json.jbuilder
          create.json.jbuilder
          index.json.jbuilder
          show.json.jbuilder
          update.json.jbuilder
        agents/
          create.json.jbuilder
          index.json.jbuilder
          update.json.jbuilder
        articles/
          _article.json.jbuilder
          _associated_article.json.jbuilder
          create.json.jbuilder
          edit.json.jbuilder
          index.json.jbuilder
          show.json.jbuilder
          update.json.jbuilder
        assignable_agents/
          index.json.jbuilder
        automation_rules/
          partials/
            _automation_rule.json.jbuilder
          clone.json.jbuilder
          create.json.jbuilder
          index.json.jbuilder
          show.json.jbuilder
          update.json.jbuilder
        callbacks/
          facebook_pages.json.jbuilder
          reauthorize_page.json.jbuilder
          register_facebook_page.json.jbuilder
        campaigns/
          create.json.jbuilder
          index.json.jbuilder
          show.json.jbuilder
          update.json.jbuilder
        categories/
          _associated_category.json.jbuilder
          _category.json.jbuilder
          create.json.jbuilder
          index.json.jbuilder
          show.json.jbuilder
          update.json.jbuilder
        channels/
          twilio_channels/
            create.json.jbuilder
        contact_inboxes/
          filter.json.jbuilder
        contacts/
          contact_inboxes/
            create.json.jbuilder
          conversations/
            index.json.jbuilder
          labels/
            create.json.jbuilder
            index.json.jbuilder
          notes/
            create.json.jbuilder
            index.json.jbuilder
            show.json.jbuilder
            update.json.jbuilder
          active.json.jbuilder
          avatar.json.jbuilder
          contactable_inboxes.json.jbuilder
          create.json.jbuilder
          destroy_custom_attributes.json.jbuilder
          filter.json.jbuilder
          index.json.jbuilder
          search.json.jbuilder
          show.json.jbuilder
          update.json.jbuilder
        conversations/
          assignments/
            create.json.jbuilder
          labels/
            create.json.jbuilder
            index.json.jbuilder
          messages/
            create.json.jbuilder
            destroy.json.jbuilder
            index.json.jbuilder
            retry.json.jbuilder
          participants/
            create.json.jbuilder
            show.json.jbuilder
          attachments.json.jbuilder
          create.json.jbuilder
          custom_attributes.json.jbuilder
          filter.json.jbuilder
          index.json.jbuilder
          meta.json.jbuilder
          search.json.jbuilder
          show.json.jbuilder
          toggle_status.json.jbuilder
          unread.json.jbuilder
          update_last_seen.json.jbuilder
          update.json.jbuilder
        csat_survey_responses/
          download.csv.erb
          index.json.jbuilder
          metrics.json.jbuilder
        custom_attribute_definitions/
          create.json.jbuilder
          index.json.jbuilder
          show.json.jbuilder
          update.json.jbuilder
        custom_filters/
          create.json.jbuilder
          index.json.jbuilder
          show.json.jbuilder
          update.json.jbuilder
        dashboard_apps/
          create.json.jbuilder
          index.json.jbuilder
          show.json.jbuilder
          update.json.jbuilder
        inbox_members/
          create.json.jbuilder
          show.json.jbuilder
          update.json.jbuilder
        inboxes/
          agent_bot.json.jbuilder
          assignable_agents.json.jbuilder
          campaigns.json.jbuilder
          create.json.jbuilder
          index.json.jbuilder
          show.json.jbuilder
          update.json.jbuilder
        integrations/
          apps/
            index.json.jbuilder
            show.json.jbuilder
          hooks/
            create.json.jbuilder
            update.json.jbuilder
          linear/
            create.json.jbuilder
          slack/
            create.json.jbuilder
            list_all_channels.json.jbuilder
            update.json.jbuilder
        labels/
          create.json.jbuilder
          index.json.jbuilder
          show.json.jbuilder
          update.json.jbuilder
        macros/
          create.json.jbuilder
          index.json.jbuilder
          show.json.jbuilder
          update.json.jbuilder
        notification_settings/
          show.json.jbuilder
        notifications/
          index.json.jbuilder
        portals/
          _portal.json.jbuilder
          add_members.json.jbuilder
          create.json.jbuilder
          index.json.jbuilder
          show.json.jbuilder
          update.json.jbuilder
        search/
          _agent.json.jbuilder
          _contact.json.jbuilder
          _inbox.json.jbuilder
          _message.json.jbuilder
          contacts.json.jbuilder
          conversations.json.jbuilder
          index.json.jbuilder
          messages.json.jbuilder
        team_members/
          create.json.jbuilder
          index.json.jbuilder
        teams/
          create.json.jbuilder
          index.json.jbuilder
          show.json.jbuilder
          update.json.jbuilder
        webhooks/
          _webhook.json.jbuilder
          create.json.jbuilder
          index.json.jbuilder
          update.json.jbuilder
        create.json.jbuilder
        show.json.jbuilder
        update.json.jbuilder
      conversations/
        partials/
          _conversation.json.jbuilder
      models/
        _account.json.jbuilder
        _agent_bot.json.jbuilder
        _agent.json.jbuilder
        _app.json.jbuilder
        _campaign.json.jbuilder
        _contact_inbox.json.jbuilder
        _contact.json.jbuilder
        _conversation.json.jbuilder
        _csat_survey_response.json.jbuilder
        _custom_attribute_definition.json.jbuilder
        _custom_filter.json.jbuilder
        _dashboard_app.json.jbuilder
        _hook.json.jbuilder
        _inbox_slim.json.jbuilder
        _inbox.json.jbuilder
        _macro.json.jbuilder
        _message.json.jbuilder
        _note.json.jbuilder
        _portal_config.json.jbuilder
        _team.json.jbuilder
        _user.json.jbuilder
        _widget_message.json.jbuilder
      profiles/
        auto_offline.jbuilder
        availability.jbuilder
        avatar.json.jbuilder
        show.json.jbuilder
        update.json.jbuilder
      widget/
        campaigns/
          index.json.jbuilder
        configs/
          create.json.jbuilder
        contacts/
          set_user.json.jbuilder
          show.json.jbuilder
          update.json.jbuilder
        conversations/
          create.json.jbuilder
          index.json.jbuilder
        inbox_members/
          index.json.jbuilder
        messages/
          create.json.jbuilder
          index.json.jbuilder
          update.json.jbuilder
    v2/
      accounts/
        reports/
          agents.csv.erb
          conversation_traffic.erb
          inboxes.csv.erb
          labels.csv.erb
          teams.csv.erb
  apple_app/
    site_association.html.erb
  devise/
    mailer/
      confirmation_instructions.html.erb
      password_change.html.erb
      reset_password_instructions.html.erb
      unlock_instructions.html.erb
    _auth.json.jbuilder
    token.json.jbuilder
  fields/
    account_features_field/
      _form.html.erb
      _show.html.erb
    account_limits_field/
      _form.html.erb
      _index.html.erb
      _show.html.erb
    avatar_field/
      _index.html.erb
      _show.html.erb
    belongs_to/
      _form.html.erb
      _index.html.erb
      _show.html.erb
    belongs_to_search/
      _index.html.erb
    count_field/
      _index.html.erb
      _show.html.erb
    polymorphic/
      _form.html.erb
      _index.html.erb
      _show.html.erb
    secret_field/
      _index.html.erb
      _show.html.erb
    serialized_field/
      _form.html.erb
      _index.html.erb
      _show.html.erb
  icons/
    _check-mark.html.erb
    _chevron-down.html.erb
    _chevron-right.html.erb
    _globe.html.erb
    _monitor.html.erb
    _moon.html.erb
    _palette.html.erb
    _redirect.html.erb
    _sun.html.erb
    _user.html.erb
  installation/
    onboarding/
      index.html.erb
  layouts/
    mailer/
      base.liquid
    super_admin/
      application.html.erb
    portal.html.erb
    vueapp.html.erb
  mailers/
    administrator_notifications/
      channel_notifications_mailer/
        automation_rule_disabled.liquid
        contact_export_complete.liquid
        contact_import_complete.liquid
        contact_import_failed.liquid
        dialogflow_disconnect.liquid
        email_disconnect.liquid
        facebook_disconnect.liquid
        slack_disconnect.liquid
        whatsapp_disconnect.liquid
    agent_notifications/
      conversation_notifications_mailer/
        assigned_conversation_new_message.liquid
        conversation_assignment.liquid
        conversation_creation.liquid
        conversation_mention.liquid
        participating_conversation_new_message.liquid
        sla_missed_first_response.liquid
        sla_missed_next_response.liquid
        sla_missed_resolution.liquid
    conversation_reply_mailer/
      conversation_transcript.html.erb
      email_reply.html.erb
      reply_with_summary.html.erb
      reply_without_summary.html.erb
    team_notifications/
      automation_notification_mailer/
        conversation_creation.liquid
        conversation_updated.liquid
        message_created.liquid
  microsoft/
    identity_association.json.jbuilder
  platform/
    api/
      v1/
        accounts/
          create.json.jbuilder
          show.json.jbuilder
          update.json.jbuilder
        agent_bots/
          avatar.json.jbuilder
          create.json.jbuilder
          index.json.jbuilder
          show.json.jbuilder
          update.json.jbuilder
        models/
          _account.json.jbuilder
          _agent_bot.json.jbuilder
          _user.json.jbuilder
        users/
          create.json.jbuilder
          show.json.jbuilder
          update.json.jbuilder
  public/
    api/
      v1/
        csat_survey/
          show.json.jbuilder
          update.json.jbuilder
        inboxes/
          contacts/
            create.json.jbuilder
            show.json.jbuilder
            update.json.jbuilder
          conversations/
            create.json.jbuilder
            index.json.jbuilder
            show.json.jbuilder
            toggle_status.json.jbuilder
          messages/
            create.json.jbuilder
            index.json.jbuilder
            update.json.jbuilder
          show.json.jbuilder
        models/
          hc/
            _associated_article.json.jbuilder
            _author.json.jbuilder
            _portal.json.jbuilder
          _article.json.jbuilder
          _associated_category.json.jbuilder
          _category.json.jbuilder
          _contact.json.jbuilder
          _conversation.json.jbuilder
          _csat_survey.json.jbuilder
          _inbox.json.jbuilder
          _message.json.jbuilder
        portals/
          articles/
            _article_header.html.erb
            index.html.erb
            index.json.jbuilder
            show.html.erb
            show.json.jbuilder
          categories/
            _category-block.html.erb
            _category-hero.html.erb
            _hero.html.erb
            index.html.erb
            index.json.jbuilder
            show.html.erb
            show.json.jbuilder
          error/
            404.html.erb
          _article_count.html.erb
          _authors.html.erb
          _category-block.html.erb
          _featured_articles.html.erb
          _footer.html.erb
          _header.html.erb
          _hero.html.erb
          _thumbnail.html.erb
          _uncategorized-block.html.erb
          index.json.jbuilder
          show.html.erb
          show.json.jbuilder
          sitemap.xml.erb
  super_admin/
    accounts/
      _reset_cache.html.erb
      _seed_data.html.erb
      show.html.erb
    app_configs/
      show.html.erb
    application/
      _collection.html.erb
      _filters.html.erb
      _flashes.html.erb
      _icons.html.erb
      _javascript.html.erb
      _nav_item.html.erb
      _navigation.html.erb
      _search.html.erb
      _stylesheet.html.erb
      index.html.erb
      show.html.erb
    dashboard/
      index.html.erb
    devise/
      sessions/
        new.html.erb
    instance_statuses/
      show.html.erb
    settings/
      show.html.erb
    users/
      _collection.html.erb
      _impersonate.erb
      show.html.erb
  survey/
    responses/
      show.html.erb
  widget_tests/
    index.html.erb
  widgets/
    show.html.erb
workers/
  conversation_reply_email_worker.rb
  email_reply_worker.rb

================================================================
Files
================================================================

================
File: actions/contact_identify_action.rb
================
# retain_original_contact_name: false / true
# In case of setUser we want to update the name of the identified contact,
# which is the default behaviour
#
# But, In case of contact merge during prechat form contact update.
# We don't want to update the name of the identified original contact.

class ContactIdentifyAction
  pattr_initialize [:contact!, :params!, { retain_original_contact_name: false, discard_invalid_attrs: false }]

  def perform
    @attributes_to_update = [:identifier, :name, :email, :phone_number]

    ActiveRecord::Base.transaction do
      merge_if_existing_identified_contact
      merge_if_existing_email_contact
      merge_if_existing_phone_number_contact
      update_contact
    end
    @contact
  end

  private

  def account
    @account ||= @contact.account
  end

  def merge_if_existing_identified_contact
    return unless merge_contacts?(existing_identified_contact, :identifier)

    process_contact_merge(existing_identified_contact)
  end

  def merge_if_existing_email_contact
    return unless merge_contacts?(existing_email_contact, :email)

    process_contact_merge(existing_email_contact)
  end

  def merge_if_existing_phone_number_contact
    return unless merge_contacts?(existing_phone_number_contact, :phone_number)
    return unless mergable_phone_contact?

    process_contact_merge(existing_phone_number_contact)
  end

  def process_contact_merge(mergee_contact)
    @contact = merge_contact(mergee_contact, @contact)
    @attributes_to_update.delete(:name) if retain_original_contact_name
  end

  def existing_identified_contact
    return if params[:identifier].blank?

    @existing_identified_contact ||= account.contacts.find_by(identifier: params[:identifier])
  end

  def existing_email_contact
    return if params[:email].blank?

    @existing_email_contact ||= account.contacts.from_email(params[:email])
  end

  def existing_phone_number_contact
    return if params[:phone_number].blank?

    @existing_phone_number_contact ||= account.contacts.find_by(phone_number: params[:phone_number])
  end

  def merge_contacts?(existing_contact, key)
    return if existing_contact.blank?

    return true if params[:identifier].blank?

    # we want to prevent merging contacts with different identifiers
    if existing_contact.identifier.present? && existing_contact.identifier != params[:identifier]
      # we will remove attribute from update list
      @attributes_to_update.delete(key)
      return false
    end

    true
  end

  # case: contact 1: email: 1@test.com, phone: 123456789
  # params: email: 2@test.com, phone: 123456789
  # we don't want to overwrite 1@test.com since email parameter takes higer priority
  def mergable_phone_contact?
    return true if params[:email].blank?

    if existing_phone_number_contact.email.present? && existing_phone_number_contact.email != params[:email]
      @attributes_to_update.delete(:phone_number)
      return false
    end
    true
  end

  def update_contact
    @contact.attributes = params.slice(*@attributes_to_update).reject do |_k, v|
      v.blank?
    end.merge({ custom_attributes: custom_attributes, additional_attributes: additional_attributes })
    # blank identifier or email will throw unique index error
    # TODO: replace reject { |_k, v| v.blank? } with compact_blank when rails is upgraded
    @contact.discard_invalid_attrs if discard_invalid_attrs
    @contact.save!
    Avatar::AvatarFromUrlJob.perform_later(@contact, params[:avatar_url]) if params[:avatar_url].present? && !@contact.avatar.attached?
  end

  def merge_contact(base_contact, merge_contact)
    return base_contact if base_contact.id == merge_contact.id

    ContactMergeAction.new(
      account: account,
      base_contact: base_contact,
      mergee_contact: merge_contact
    ).perform
  end

  def custom_attributes
    return @contact.custom_attributes if params[:custom_attributes].blank?

    (@contact.custom_attributes || {}).deep_merge(params[:custom_attributes].stringify_keys)
  end

  def additional_attributes
    return @contact.additional_attributes if params[:additional_attributes].blank?

    (@contact.additional_attributes || {}).deep_merge(params[:additional_attributes].stringify_keys)
  end
end

================
File: actions/contact_merge_action.rb
================
class ContactMergeAction
  include Events::Types
  pattr_initialize [:account!, :base_contact!, :mergee_contact!]

  def perform
    # This case happens when an agent updates a contact email in dashboard,
    # while the contact also update his email via email collect box
    return @base_contact if base_contact.id == mergee_contact.id

    ActiveRecord::Base.transaction do
      validate_contacts
      merge_conversations
      merge_messages
      merge_contact_inboxes
      merge_contact_notes
      merge_and_remove_mergee_contact
    end
    @base_contact
  end

  private

  def validate_contacts
    return if belongs_to_account?(@base_contact) && belongs_to_account?(@mergee_contact)

    raise StandardError, 'contact does not belong to the account'
  end

  def belongs_to_account?(contact)
    @account.id == contact.account_id
  end

  def merge_conversations
    Conversation.where(contact_id: @mergee_contact.id).update(contact_id: @base_contact.id)
  end

  def merge_contact_notes
    Note.where(contact_id: @mergee_contact.id, account_id: @mergee_contact.account_id).update(contact_id: @base_contact.id)
  end

  def merge_messages
    Message.where(sender: @mergee_contact).update(sender: @base_contact)
  end

  def merge_contact_inboxes
    ContactInbox.where(contact_id: @mergee_contact.id).update(contact_id: @base_contact.id)
  end

  def merge_and_remove_mergee_contact
    mergable_attribute_keys = %w[identifier name email phone_number additional_attributes custom_attributes]
    base_contact_attributes = base_contact.attributes.slice(*mergable_attribute_keys).compact_blank
    mergee_contact_attributes = mergee_contact.attributes.slice(*mergable_attribute_keys).compact_blank

    # attributes in base contact are given preference
    merged_attributes = mergee_contact_attributes.deep_merge(base_contact_attributes)

    @mergee_contact.reload.destroy!
    Rails.configuration.dispatcher.dispatch(CONTACT_MERGED, Time.zone.now, contact: @base_contact,
                                                                           tokens: [@base_contact.contact_inboxes.filter_map(&:pubsub_token)])
    @base_contact.update!(merged_attributes)
  end
end

================
File: assets/stylesheets/administrate/base/_forms.scss
================
fieldset {
  background-color: transparent;
  border: 0;
  margin: 0;
  padding: 0;
}

legend {
  font-weight: $font-weight-medium;
  margin: 0;
  padding: 0;
}

label {
  display: block;
  font-weight: $font-weight-medium;
  margin: 0;
}

input,
select {
  display: block;
  font-family: $base-font-family;
  font-size: $base-font-size;
}

[type="color"],
[type="date"],
[type="datetime-local"],
[type="email"],
[type="month"],
[type="number"],
[type="password"],
[type="search"],
[type="tel"],
[type="text"],
[type="time"],
[type="url"],
[type="week"],
input:not([type]),
textarea {
  appearance: none;
  background-color: $white;
  border: $base-border;
  border-radius: $base-border-radius;
  font-family: $base-font-family;
  padding: 0.5em;
  transition: border-color $base-duration $base-timing;
  width: 100%;

  &:hover {
    border-color: mix($black, $base-border-color, 20%);
  }

  &:focus {
    border-color: $action-color;
    outline: none;
  }

  &:disabled {
    background-color: mix($black, $white, 5%);
    cursor: not-allowed;

    &:hover {
      border: $base-border;
    }
  }
}

textarea {
  resize: vertical;
}

[type="checkbox"],
[type="radio"] {
  display: inline;
  margin-right: $small-spacing / 2;
}

[type="file"] {
  width: 100%;
}

select {
  width: 100%;
}

[type="checkbox"],
[type="radio"],
[type="file"],
select {
  &:focus {
    outline: $focus-outline;
    outline-offset: $focus-outline-offset;
  }
}

================
File: assets/stylesheets/administrate/base/_layout.scss
================
html {
  background-color: $color-white;
  box-sizing: border-box;
  font-size: 16px;
  -webkit-font-smoothing: antialiased;
}

*,
*::before,
*::after {
  box-sizing: inherit;
}

figure {
  margin: 0;
}

img,
picture {
  margin: 0;
  max-width: 100%;
}

================
File: assets/stylesheets/administrate/base/_lists.scss
================
ul,
ol {
  list-style-type: none;
  margin: 0;
  padding: 0;
}

dl {
  margin-bottom: $small-spacing;

  dt {
    font-weight: $font-weight-medium;
    margin-top: $small-spacing;
  }

  dd {
    margin: 0;
  }
}

================
File: assets/stylesheets/administrate/base/_tables.scss
================
table {
  border-collapse: collapse;
  font-size: $font-size-default;
  text-align: left;
  width: 100%;

  a {
    color: inherit;
    text-decoration: none;
  }
}

tr {
  border-bottom: $base-border;

  th {
    font-weight: $font-weight-medium;

    &.cell-label--avatar-field {
      a {
        display: none;
      }
    }
  }
}

tbody tr {
  &:hover {
    background-color: $base-background-color;
    cursor: pointer;
  }

  &:focus {
    outline: $focus-outline;
    outline-offset: -($focus-outline-width);
  }

  td {
    &.cell-data--avatar-field {
      line-height: 1;
      text-align: center;

      img {
        border-radius: 50%;
        height: $space-large;
        max-height: $space-large;
        width: $space-large;
      }
    }
  }
}

td,
th {
  padding: $space-slab;
  vertical-align: middle;
}

td:first-child,
th:first-child {
  padding-left: 0;
}

td:last-child,
th:last-child {
  padding-right: 0;
}

td img {
  max-height: 2rem;
}

================
File: assets/stylesheets/administrate/base/_typography.scss
================
body {
  color: $base-font-color;
  font-family: $base-font-family;
  font-size: $base-font-size;
  line-height: $base-line-height;
}

h1,
h2,
h3,
h4,
h5,
h6 {
  font-family: $heading-font-family;
  font-size: $base-font-size;
  line-height: $heading-line-height;
  margin: 0;
}

p {
  margin: 0 0 $small-spacing;
}

a {
  color: $action-color;
  transition: color $base-duration $base-timing;

  &:hover {
    color: mix($black, $action-color, 25%);
  }

  &:focus {
    outline: $focus-outline;
    outline-offset: $focus-outline-offset;
  }
}

hr {
  border-bottom: $base-border;
  border-left: 0;
  border-right: 0;
  border-top: 0;
  margin: $base-spacing 0;
}

================
File: assets/stylesheets/administrate/components/_app-container.scss
================
.app-container {
  align-items: stretch;
  display: flex;
  margin-left: auto;
  margin-right: auto;
  max-width: 100rem;
  min-height: 100vh;
}

================
File: assets/stylesheets/administrate/components/_attributes.scss
================
.attribute-label {
  @include data-label;
  clear: left;
  float: left;
  margin-bottom: $base-spacing;
  margin-top: 0.25em;
  text-align: left;
  width: calc(16% - 1rem);
}

.preserve-whitespace {
  white-space: pre-wrap;
  word-wrap: break-word;
}

.attribute-data {
  float: left;
  margin-bottom: $base-spacing;
  margin-left: 1.25rem;
  width: calc(84% - 0.625rem);
}

.attribute--nested {
  border: $base-border;
  padding: $small-spacing;
}

================
File: assets/stylesheets/administrate/components/_buttons.scss
================
button:not(.reset-base),
input[type='button']:not(.reset-base),
input[type='reset']:not(.reset-base),
input[type='submit']:not(.reset-base),
.button:not(.reset-base) {
  appearance: none;
  background-color: $color-woot;
  border: 0;
  border-radius: $base-border-radius;
  color: $white;
  cursor: pointer;
  display: inline-block;
  font-size: $font-size-small;
  -webkit-font-smoothing: antialiased;
  font-weight: $font-weight-medium;
  line-height: 1;
  padding: $space-one $space-two;
  text-decoration: none;
  transition: background-color $base-duration $base-timing;
  user-select: none;
  vertical-align: middle;
  white-space: nowrap;

  &:hover {
    background-color: mix($black, $color-woot, 20%);
    color: $white;
  }

  &:focus {
    outline: $focus-outline;
    outline-offset: $focus-outline-offset;
  }

  &:disabled {
    cursor: not-allowed;
    opacity: 0.5;

    &:hover {
      background-color: $color-woot;
    }
  }
}

.button--alt {
  background-color: transparent;
  border: $base-border;
  border-color: $blue;
  color: $blue;
  margin-bottom: $base-spacing;
}

================
File: assets/stylesheets/administrate/components/_cells.scss
================
.cell-label {
  &:hover {
    a {
      color: $action-color;
    }

    svg {
      fill: $action-color;
      transform: rotate(180deg);
    }
  }

  a {
    color: inherit;
    display: inline-block;
    transition: color $base-duration $base-timing;
    width: 100%;
  }
}

.cell-label--asc,
.cell-label--desc {
  font-weight: $font-weight-medium;
}

.cell-label__sort-indicator {
  float: right;
  margin-left: 5px;

  svg {
    fill: $hint-grey;
    height: 13px;
    transition: transform $base-duration $base-timing;
    width: 13px;
  }
}

.cell-label__sort-indicator--desc {
  transform: rotate(180deg);
}

.cell-data--number,
.cell-label--number {
  text-align: right;
}

.cell-data__secret-field {
  align-items: center;
  display: flex;

  span {
    flex: 1;
  }

  button {
    margin-left: 5px;

    svg {
      fill: currentColor;
    }
  }
}

================
File: assets/stylesheets/administrate/components/_field-unit.scss
================
.field-unit {
  @include administrate-clearfix;
  align-items: center;
  display: flex;
  margin-bottom: $base-spacing;
  position: relative;
  width: 100%;
}

.field-unit__label {
  float: left;
  margin-left: 0.625rem;
  text-align: right;
  width: calc(15% - 0.625rem);
}

.field-unit__field {
  float: left;
  margin-left: 1.25rem;
  max-width: 31.15rem;
  width: 100%;
}

.field-unit--nested {
  border: $base-border;
  margin-left: 7.5%;
  max-width: 37.5rem;
  padding: $small-spacing;
  width: 100%;

  .field-unit__field {
    width: 100%;
  }

  .field-unit__label {
    width: 10rem;
  }
}

.field-unit--required {
  label::after {
    color: $red;
    content: ' *';
  }
}

.attribute-data--avatar-field {
  height: $space-larger;
  width: $space-larger;

  img {
    border-radius: 50%;
  }
}

================
File: assets/stylesheets/administrate/components/_flashes.scss
================
$base-spacing: 1.5em !default;
$flashes: (
  "alert": #fff6bf,
  "error": #fbe3e4,
  "notice": #e5edf8,
  "success": #e6efc2,
) !default;

@each $flash-type, $color in $flashes {
  .flash-#{$flash-type} {
    background-color: $color;
    color: mix($black, $color, 60%);
    display: block;
    margin-bottom: $base-spacing / 2;
    padding: $base-spacing / 2;
    text-align: center;

    a {
      color: mix($black, $color, 70%);
      text-decoration: underline;

      &:focus,
      &:hover {
        color: mix($black, $color, 90%);
      }
    }
  }
}

================
File: assets/stylesheets/administrate/components/_form-actions.scss
================
.form-actions {
  margin-left: calc(15% + 1.25rem);
}

================
File: assets/stylesheets/administrate/components/_main-content.scss
================
.main-content {
  font-size: $font-size-default;
  left: 21rem;
  position: absolute;
  right: 0;
  top: 0;
}

.main-content__body {
  font-size: $font-size-small;
  padding: $space-two;

  table {
    font-size: $font-size-small;
  }

  form {
    margin-top: $space-two;
  }
}

.main-content__header {
  align-items: center;
  background-color: $color-white;
  border-bottom: 1px solid $color-border;
  display: flex;
  min-height: 3.5rem;
  padding: $space-small $space-normal;
}

.main-content__page-title {
  font-size: $font-size-medium;
  font-weight: $font-weight-medium;
  margin-right: auto;
}

================
File: assets/stylesheets/administrate/components/_pagination.scss
================
.pagination {
  font-size: $font-size-default;
  margin-top: $base-spacing;
  padding-left: $base-spacing;
  padding-right: $base-spacing;
  text-align: center;

  .first,
  .prev,
  .page,
  .next,
  .last {
    margin: $small-spacing;
  }

  .current {
    font-weight: $font-weight-medium;
  }
}

================
File: assets/stylesheets/administrate/components/_reports.scss
================
.report--list {
  display: flex;
  padding: 0 $space-two $space-larger;
}

.report-card {
  flex: 1;
  font-size: $font-size-small;
  text-align: center;

  .metric {
    font-size: $font-size-bigger;
    font-weight: 200;
  }
}

================
File: assets/stylesheets/administrate/components/_search.scss
================
.search {
  margin-left: auto;
  margin-right: 1.25rem;
  max-width: 27.5rem;
  position: relative;
  width: 100%;
}

.search__input {
  background: $grey-1;
  padding-left: $space-normal * 2.5;
  padding-right: $space-normal * 2.5;
}

.search__eyeglass-icon {
  fill: $grey-7;
  height: $space-normal;
  left: $space-normal;
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  width: $space-normal;
}

.search__clear-link {
  height: $space-normal;
  position: absolute;
  right: $space-normal * 0.75;
  top: 50%;
  transform: translateY(-50%);
  width: $space-normal;
}

.search__clear-icon {
  fill: $grey-5;
  height: $space-normal;
  position: absolute;
  transition: fill $base-duration $base-timing;
  width: $space-normal;

  &:hover {
    fill: $action-color;
  }
}

================
File: assets/stylesheets/administrate/library/_clearfix.scss
================
@mixin administrate-clearfix {
  &::after {
    clear: both;
    content: '';
    display: block;
  }
}

================
File: assets/stylesheets/administrate/library/_data-label.scss
================
@mixin data-label {
  color: $hint-grey;
  font-size: 0.8em;
  font-weight: 400;
  letter-spacing: 0.0357em;
  position: relative;
  text-transform: uppercase;
}

================
File: assets/stylesheets/administrate/library/_variables.scss
================
// Typography
$base-font-family: Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto",
  "Oxygen", "Ubuntu", "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue",
  sans-serif !default;
$heading-font-family: $base-font-family !default;

$base-font-size: 16px !default;

$base-line-height: 1.5 !default;
$heading-line-height: 1.2 !default;

// Other Sizes
$base-border-radius: 4px !default;
$base-spacing: $base-line-height * 1em !default;
$small-spacing: $base-spacing / 2 !default;

// Colors
$white: #fff !default;
$black: #000 !default;

$blue: #1f93ff !default;
$red: #ff382d !default;
$light-yellow: #ffc532 !default;
$light-green: #44ce4b !default;

$grey-0: #f6f7f7 !default;
$grey-1: #f0f4f5 !default;
$grey-2: #cfd8dc !default;
$grey-5: #adb5bd !default;
$grey-7: #293f54 !default;

$hint-grey: #7b808c !default;

// Font Colors
$base-font-color: $grey-7 !default;
$action-color: $blue !default;

// Background Colors
$base-background-color: $grey-0 !default;

// Focus
$focus-outline-color: transparentize($action-color, 0.4);
$focus-outline-width: 3px;
$focus-outline: $focus-outline-width solid $focus-outline-color;
$focus-outline-offset: 1px;

// Flash Colors
$flash-colors: (
  alert: $light-yellow,
  error: $red,
  notice: mix($white, $blue, 50%),
  success: $light-green
);

// Border
$base-border-color: $grey-1 !default;
$base-border: 1px solid $base-border-color !default;

// Transitions
$base-duration: 250ms !default;
$base-timing: ease-in-out !default;

================
File: assets/stylesheets/administrate/reset/_normalize.scss
================
/*! normalize.css v7.0.0 | MIT License | github.com/necolas/normalize.css */

/* Document
   ========================================================================== */

/**
 * 1. Correct the line height in all browsers.
 * 2. Prevent adjustments of font size after orientation changes in
 *    IE on Windows Phone and in iOS.
 */

html {
  line-height: 1.15; /* 1 */
  -ms-text-size-adjust: 100%; /* 2 */
  -webkit-text-size-adjust: 100%; /* 2 */
  -moz-osx-font-smoothing: grayscale;
}

/* Sections
   ========================================================================== */

/**
 * Remove the margin in all browsers (opinionated).
 */

body {
  margin: 0;
}

/**
 * Add the correct display in IE 9-.
 */

article,
aside,
footer,
header,
nav,
section {
  display: block;
}

/**
 * Correct the font size and margin on `h1` elements within `section` and
 * `article` contexts in Chrome, Firefox, and Safari.
 */

h1 {
  font-size: 2em;
  margin: 0.67em 0;
}

/* Grouping content
   ========================================================================== */

/**
 * Add the correct display in IE 9-.
 * 1. Add the correct display in IE.
 */

figcaption,
figure,
main { /* 1 */
  display: block;
}

/**
 * Add the correct margin in IE 8.
 */

figure {
  margin: 1em 40px;
}

/**
 * 1. Add the correct box sizing in Firefox.
 * 2. Show the overflow in Edge and IE.
 */

hr {
  box-sizing: content-box; /* 1 */
  height: 0; /* 1 */
  overflow: visible; /* 2 */
}

/**
 * 1. Correct the inheritance and scaling of font size in all browsers.
 * 2. Correct the odd `em` font sizing in all browsers.
 */

pre {
  font-family: monospace, monospace; /* 1 */
  font-size: 1em; /* 2 */
}

/* Text-level semantics
   ========================================================================== */

/**
 * 1. Remove the gray background on active links in IE 10.
 * 2. Remove gaps in links underline in iOS 8+ and Safari 8+.
 */

a {
  background-color: transparent; /* 1 */
  -webkit-text-decoration-skip: objects; /* 2 */
}

/**
 * 1. Remove the bottom border in Chrome 57- and Firefox 39-.
 * 2. Add the correct text decoration in Chrome, Edge, IE, Opera, and Safari.
 */

abbr[title] {
  border-bottom: none; /* 1 */
  text-decoration: underline; /* 2 */
  text-decoration: underline dotted; /* 2 */
}

/**
 * Prevent the duplicate application of `bolder` by the next rule in Safari 6.
 */

b,
strong {
  font-weight: inherit;
}

/**
 * Add the correct font weight in Chrome, Edge, and Safari.
 */

b,
strong {
  font-weight: bolder;
}

/**
 * 1. Correct the inheritance and scaling of font size in all browsers.
 * 2. Correct the odd `em` font sizing in all browsers.
 */

code,
kbd,
samp {
  font-family: monospace, monospace; /* 1 */
  font-size: 1em; /* 2 */
}

/**
 * Add the correct font style in Android 4.3-.
 */

dfn {
  font-style: italic;
}

/**
 * Add the correct background and color in IE 9-.
 */

mark {
  background-color: #ff0;
  color: #000;
}

/**
 * Add the correct font size in all browsers.
 */

small {
  font-size: 80%;
}

/**
 * Prevent `sub` and `sup` elements from affecting the line height in
 * all browsers.
 */

sub,
sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}

sub {
  bottom: -0.25em;
}

sup {
  top: -0.5em;
}

/* Embedded content
   ========================================================================== */

/**
 * Add the correct display in IE 9-.
 */

audio,
video {
  display: inline-block;
}

/**
 * Add the correct display in iOS 4-7.
 */

audio:not([controls]) {
  display: none;
  height: 0;
}

/**
 * Remove the border on images inside links in IE 10-.
 */

img {
  border-style: none;
}

/**
 * Hide the overflow in IE.
 */

svg:not(:root) {
  overflow: hidden;
}

/* Forms
   ========================================================================== */

/**
 * 1. Change the font styles in all browsers (opinionated).
 * 2. Remove the margin in Firefox and Safari.
 */

button,
input,
optgroup,
select,
textarea {
  font-family: sans-serif; /* 1 */
  font-size: 100%; /* 1 */
  line-height: 1.15; /* 1 */
  margin: 0; /* 2 */
}

/**
 * Show the overflow in IE.
 * 1. Show the overflow in Edge.
 */

button,
input { /* 1 */
  overflow: visible;
}

/**
 * Remove the inheritance of text transform in Edge, Firefox, and IE.
 * 1. Remove the inheritance of text transform in Firefox.
 */

button,
select { /* 1 */
  text-transform: none;
}

/**
 * 1. Prevent a WebKit bug where (2) destroys native `audio` and `video`
 *    controls in Android 4.
 * 2. Correct the inability to style clickable types in iOS and Safari.
 */

button,
html [type="button"], /* 1 */
[type="reset"],
[type="submit"] {
  -webkit-appearance: button; /* 2 */
}

/**
 * Remove the inner border and padding in Firefox.
 */

button::-moz-focus-inner,
[type="button"]::-moz-focus-inner,
[type="reset"]::-moz-focus-inner,
[type="submit"]::-moz-focus-inner {
  border-style: none;
  padding: 0;
}

/**
 * Restore the focus styles unset by the previous rule.
 */

button:-moz-focusring,
[type="button"]:-moz-focusring,
[type="reset"]:-moz-focusring,
[type="submit"]:-moz-focusring {
  outline: 1px dotted ButtonText;
}

/**
 * Correct the padding in Firefox.
 */

fieldset {
  padding: 0.35em 0.75em 0.625em;
}

/**
 * 1. Correct the text wrapping in Edge and IE.
 * 2. Correct the color inheritance from `fieldset` elements in IE.
 * 3. Remove the padding so developers are not caught out when they zero out
 *    `fieldset` elements in all browsers.
 */

legend {
  box-sizing: border-box; /* 1 */
  color: inherit; /* 2 */
  display: table; /* 1 */
  max-width: 100%; /* 1 */
  padding: 0; /* 3 */
  white-space: normal; /* 1 */
}

/**
 * 1. Add the correct display in IE 9-.
 * 2. Add the correct vertical alignment in Chrome, Firefox, and Opera.
 */

progress {
  display: inline-block; /* 1 */
  vertical-align: baseline; /* 2 */
}

/**
 * Remove the default vertical scrollbar in IE.
 */

textarea {
  overflow: auto;
}

/**
 * 1. Add the correct box sizing in IE 10-.
 * 2. Remove the padding in IE 10-.
 */

[type="checkbox"],
[type="radio"] {
  box-sizing: border-box; /* 1 */
  padding: 0; /* 2 */
}

/**
 * Correct the cursor style of increment and decrement buttons in Chrome.
 */

[type="number"]::-webkit-inner-spin-button,
[type="number"]::-webkit-outer-spin-button {
  height: auto;
}

/**
 * 1. Correct the odd appearance in Chrome and Safari.
 * 2. Correct the outline style in Safari.
 */

[type="search"] {
  -webkit-appearance: textfield; /* 1 */
  outline-offset: -2px; /* 2 */
}

/**
 * Remove the inner padding and cancel buttons in Chrome and Safari on macOS.
 */

[type="search"]::-webkit-search-cancel-button,
[type="search"]::-webkit-search-decoration {
  -webkit-appearance: none;
}

/**
 * 1. Correct the inability to style clickable types in iOS and Safari.
 * 2. Change font properties to `inherit` in Safari.
 */

::-webkit-file-upload-button {
  -webkit-appearance: button; /* 1 */
  font: inherit; /* 2 */
}

/* Interactive
   ========================================================================== */

/*
 * Add the correct display in IE 9-.
 * 1. Add the correct display in Edge, IE, and Firefox.
 */

details, /* 1 */
menu {
  display: block;
}

/*
 * Add the correct display in all browsers.
 */

summary {
  display: list-item;
}

/* Scripting
   ========================================================================== */

/**
 * Add the correct display in IE 9-.
 */

canvas {
  display: inline-block;
}

/**
 * Add the correct display in IE.
 */

template {
  display: none;
}

/* Hidden
   ========================================================================== */

/**
 * Add the correct display in IE 10-.
 */

[hidden] {
  display: none;
}

================
File: assets/stylesheets/administrate/utilities/_text-color.scss
================
.text-color-red {
  color: $alert-color;
}

================
File: assets/stylesheets/administrate/utilities/_variables.scss
================
// Font sizes
$font-size-nano: 0.5rem;
$font-size-micro: 0.675rem;
$font-size-mini: 0.75rem;
$font-size-small: 0.875rem;
$font-size-default: 1rem;
$font-size-medium: 1.125rem;
$font-size-large: 1.375rem;
$font-size-big: 1.5rem;
$font-size-bigger: 1.75rem;
$font-size-mega: 2.125rem;
$font-size-giga: 2.5rem;

// spaces
$zero: 0;
$space-micro: 0.125rem;
$space-smaller: 0.25rem;
$space-small: 0.5rem;
$space-one: 0.675rem;
$space-slab: 0.75rem;
$space-normal: 1rem;
$space-two: 1.25rem;
$space-medium: 1.5rem;
$space-large: 2rem;
$space-larger: 3rem;
$space-jumbo: 4rem;
$space-mega: 6.25rem;

// font-weight
$font-weight-feather: 100;
$font-weight-light: 300;
$font-weight-normal: 400;
$font-weight-medium: 500;
$font-weight-bold: 600;
$font-weight-black: 700;

//Navbar
$nav-bar-width: 23rem;
$header-height: 5.6rem;

$woot-logo-padding: $space-large $space-two;

// Colors
$color-woot: #1f93ff;
$color-gray: #6e6f73;
$color-light-gray: #747677;
$color-border: #e0e6ed;
$color-border-light: #f0f4f5;
$color-background: #f4f6fb;
$color-border-dark: #cad0d4;
$color-background-light: #f9fafc;
$color-white: #fff;
$color-body: #3c4858;
$color-heading: #1f2d3d;
$color-extra-light-blue: #f5f7f9;

$primary-color: $color-woot;
$secondary-color: #5d7592;
$success-color: #44ce4b;
$warning-color: #ffc532;
$alert-color: #ff382d;

$masked-bg: rgba(0, 0, 0, .4);

// Color-palettes

$color-primary-light: #c7e3ff;
$color-primary-dark: darken($color-woot, 20%);

// Thumbnail
$thumbnail-radius: 4rem;

// chat-header
$conv-header-height: 4rem;

// Inbox List

$inbox-thumb-size: 4.8rem;


// Snackbar default
$woot-snackbar-bg: #323232;
$woot-snackbar-button: #ffeb3b;

$swift-ease-out-duration: .4s !default;
$swift-ease-out-timing-function: cubic-bezier(.25, .8, .25, 1) !default;
$swift-ease-out: all $swift-ease-out-duration $swift-ease-out-timing-function !default;

// Transitions
$transition-ease-in: all 0.250s ease-in;

================
File: assets/stylesheets/administrate/application.scss
================
@charset 'utf-8';

@import 'reset/normalize';

@import 'utilities/variables';
@import 'utilities/text-color';

@import 'selectize';

@import 'library/clearfix';
@import 'library/data-label';
@import 'library/variables';

@import 'base/forms';
@import 'base/layout';
@import 'base/lists';
@import 'base/tables';
@import 'base/typography';

@import 'components/app-container';
@import 'components/attributes';
@import 'components/buttons';
@import 'components/cells';
@import 'components/field-unit';
@import 'components/flashes';
@import 'components/form-actions';
@import 'components/main-content';
@import 'components/pagination';
@import 'components/search';
@import 'components/reports';

@import 'custom_styles';

================
File: assets/stylesheets/administrate/custom_styles.scss
================
// custom styles for the dashboard

.feature-cell {
  background: $color-extra-light-blue;
  border-radius: 10px;
  float: left;
  margin-left: 8px;
  margin-top: 6px;
  padding: 4px 12px;

  .icon-container {
    margin-right: 2px;
  }

  .value-container {
    margin-left: 6px;
  }
}


.feature-container {
  max-width: 100rem;
}

================
File: builders/campaigns/campaign_conversation_builder.rb
================
class Campaigns::CampaignConversationBuilder
  pattr_initialize [:contact_inbox_id!, :campaign_display_id!, :conversation_additional_attributes, :custom_attributes]

  def perform
    @contact_inbox = ContactInbox.find(@contact_inbox_id)
    @campaign = @contact_inbox.inbox.campaigns.find_by!(display_id: campaign_display_id)

    ActiveRecord::Base.transaction do
      @contact_inbox.lock!

      # We won't send campaigns if a conversation is already present
      raise 'Conversation alread present' if @contact_inbox.reload.conversations.present?

      @conversation = ::Conversation.create!(conversation_params)
      Messages::MessageBuilder.new(@campaign.sender, @conversation, message_params).perform
    end
    @conversation
  rescue StandardError => e
    Rails.logger.info(e.message)
    nil
  end

  private

  def message_params
    ActionController::Parameters.new({
                                       content: @campaign.message,
                                       campaign_id: @campaign.id
                                     })
  end

  def conversation_params
    {
      account_id: @campaign.account_id,
      inbox_id: @contact_inbox.inbox_id,
      contact_id: @contact_inbox.contact_id,
      contact_inbox_id: @contact_inbox.id,
      campaign_id: @campaign.id,
      additional_attributes: conversation_additional_attributes,
      custom_attributes: custom_attributes || {}
    }
  end
end

================
File: builders/csat_surveys/response_builder.rb
================
class CsatSurveys::ResponseBuilder
  pattr_initialize [:message]

  def perform
    raise 'Invalid Message' unless message.input_csat?

    conversation = message.conversation
    rating = message.content_attributes.dig('submitted_values', 'csat_survey_response', 'rating')
    feedback_message = message.content_attributes.dig('submitted_values', 'csat_survey_response', 'feedback_message')

    return if rating.blank?

    process_csat_response(conversation, rating, feedback_message)
  end

  private

  def process_csat_response(conversation, rating, feedback_message)
    csat_survey_response = message.csat_survey_response || CsatSurveyResponse.new(
      message_id: message.id, account_id: message.account_id, conversation_id: message.conversation_id,
      contact_id: conversation.contact_id, assigned_agent: conversation.assignee
    )
    csat_survey_response.rating = rating
    csat_survey_response.feedback_message = feedback_message
    csat_survey_response.save!
    csat_survey_response
  end
end

================
File: builders/messages/facebook/message_builder.rb
================
# This class creates both outgoing messages from chatwoot and echo outgoing messages based on the flag `outgoing_echo`
# Assumptions
# 1. Incase of an outgoing message which is echo, source_id will NOT be nil,
#    based on this we are showing "not sent from chatwoot" message in frontend
#    Hence there is no need to set user_id in message for outgoing echo messages.

class Messages::Facebook::MessageBuilder < Messages::Messenger::MessageBuilder
  attr_reader :response

  def initialize(response, inbox, outgoing_echo: false)
    super()
    @response = response
    @inbox = inbox
    @outgoing_echo = outgoing_echo
    @sender_id = (@outgoing_echo ? @response.recipient_id : @response.sender_id)
    @message_type = (@outgoing_echo ? :outgoing : :incoming)
    @attachments = (@response.attachments || [])
  end

  def perform
    # This channel might require reauthorization, may be owner might have changed the fb password
    return if @inbox.channel.reauthorization_required?

    ActiveRecord::Base.transaction do
      build_contact_inbox
      build_message
    end
  rescue Koala::Facebook::AuthenticationError => e
    Rails.logger.warn("Facebook authentication error for inbox: #{@inbox.id} with error: #{e.message}")
    Rails.logger.error e
    @inbox.channel.authorization_error!
  rescue StandardError => e
    ChatwootExceptionTracker.new(e, account: @inbox.account).capture_exception
    true
  end

  private

  def build_contact_inbox
    @contact_inbox = ::ContactInboxWithContactBuilder.new(
      source_id: @sender_id,
      inbox: @inbox,
      contact_attributes: contact_params
    ).perform
  end

  def build_message
    @message = conversation.messages.create!(message_params)

    @attachments.each do |attachment|
      process_attachment(attachment)
    end
  end

  def conversation
    @conversation ||= set_conversation_based_on_inbox_config
  end

  def set_conversation_based_on_inbox_config
    if @inbox.lock_to_single_conversation
      Conversation.where(conversation_params).order(created_at: :desc).first || build_conversation
    else
      find_or_build_for_multiple_conversations
    end
  end

  def find_or_build_for_multiple_conversations
    # If lock to single conversation is disabled, we will create a new conversation if previous conversation is resolved
    last_conversation = Conversation.where(conversation_params).where.not(status: :resolved).order(created_at: :desc).first
    return build_conversation if last_conversation.nil?

    last_conversation
  end

  def build_conversation
    Conversation.create!(conversation_params.merge(
                           contact_inbox_id: @contact_inbox.id
                         ))
  end

  def location_params(attachment)
    lat = attachment['payload']['coordinates']['lat']
    long = attachment['payload']['coordinates']['long']
    {
      external_url: attachment['url'],
      coordinates_lat: lat,
      coordinates_long: long,
      fallback_title: attachment['title']
    }
  end

  def fallback_params(attachment)
    {
      fallback_title: attachment['title'],
      external_url: attachment['url']
    }
  end

  def conversation_params
    {
      account_id: @inbox.account_id,
      inbox_id: @inbox.id,
      contact_id: @contact_inbox.contact_id
    }
  end

  def message_params
    {
      account_id: conversation.account_id,
      inbox_id: conversation.inbox_id,
      message_type: @message_type,
      content: response.content,
      source_id: response.identifier,
      content_attributes: {
        in_reply_to_external_id: response.in_reply_to_external_id
      },
      sender: @outgoing_echo ? nil : @contact_inbox.contact
    }
  end

  def process_contact_params_result(result)
    {
      name: "#{result['first_name'] || 'John'} #{result['last_name'] || 'Doe'}",
      account_id: @inbox.account_id,
      avatar_url: result['profile_pic']
    }
  end

  # rubocop:disable Metrics/AbcSize
  # rubocop:disable Metrics/MethodLength
  def contact_params
    begin
      k = Koala::Facebook::API.new(@inbox.channel.page_access_token) if @inbox.facebook?
      result = k.get_object(@sender_id) || {}
    rescue Koala::Facebook::AuthenticationError => e
      Rails.logger.warn("Facebook authentication error for inbox: #{@inbox.id} with error: #{e.message}")
      Rails.logger.error e
      @inbox.channel.authorization_error!
      raise
    rescue Koala::Facebook::ClientError => e
      result = {}
      # OAuthException, code: 100, error_subcode: 2018218, message: (#100) No profile available for this user
      # We don't need to capture this error as we don't care about contact params in case of echo messages
      if e.message.include?('2018218')
        Rails.logger.warn e
      else
        ChatwootExceptionTracker.new(e, account: @inbox.account).capture_exception unless @outgoing_echo
      end
    rescue StandardError => e
      result = {}
      ChatwootExceptionTracker.new(e, account: @inbox.account).capture_exception
    end
    process_contact_params_result(result)
  end
  # rubocop:enable Metrics/AbcSize
  # rubocop:enable Metrics/MethodLength
end

================
File: builders/messages/instagram/message_builder.rb
================
# This class creates both outgoing messages from chatwoot and echo outgoing messages based on the flag `outgoing_echo`
# Assumptions
# 1. Incase of an outgoing message which is echo, source_id will NOT be nil,
#    based on this we are showing "not sent from chatwoot" message in frontend
#    Hence there is no need to set user_id in message for outgoing echo messages.

class Messages::Instagram::MessageBuilder < Messages::Messenger::MessageBuilder
  attr_reader :messaging

  def initialize(messaging, inbox, outgoing_echo: false)
    super()
    @messaging = messaging
    @inbox = inbox
    @outgoing_echo = outgoing_echo
  end

  def perform
    return if @inbox.channel.reauthorization_required?

    ActiveRecord::Base.transaction do
      build_message
    end
  rescue Koala::Facebook::AuthenticationError => e
    Rails.logger.warn("Instagram authentication error for inbox: #{@inbox.id} with error: #{e.message}")
    Rails.logger.error e
    @inbox.channel.authorization_error!
    raise
  rescue StandardError => e
    ChatwootExceptionTracker.new(e, account: @inbox.account).capture_exception
    true
  end

  private

  def attachments
    @messaging[:message][:attachments] || {}
  end

  def message_type
    @outgoing_echo ? :outgoing : :incoming
  end

  def message_identifier
    message[:mid]
  end

  def message_source_id
    @outgoing_echo ? recipient_id : sender_id
  end

  def message_is_unsupported?
    message[:is_unsupported].present? && @messaging[:message][:is_unsupported] == true
  end

  def sender_id
    @messaging[:sender][:id]
  end

  def recipient_id
    @messaging[:recipient][:id]
  end

  def message
    @messaging[:message]
  end

  def contact
    @contact ||= @inbox.contact_inboxes.find_by(source_id: message_source_id)&.contact
  end

  def conversation
    @conversation ||= set_conversation_based_on_inbox_config
  end

  def instagram_direct_message_conversation
    Conversation.where(conversation_params)
                .where("additional_attributes ->> 'type' = 'instagram_direct_message'")
  end

  def set_conversation_based_on_inbox_config
    if @inbox.lock_to_single_conversation
      instagram_direct_message_conversation.order(created_at: :desc).first || build_conversation
    else
      find_or_build_for_multiple_conversations
    end
  end

  def find_or_build_for_multiple_conversations
    last_conversation = instagram_direct_message_conversation.where.not(status: :resolved).order(created_at: :desc).first

    return build_conversation if last_conversation.nil?

    last_conversation
  end

  def message_content
    @messaging[:message][:text]
  end

  def story_reply_attributes
    message[:reply_to][:story] if message[:reply_to].present? && message[:reply_to][:story].present?
  end

  def message_reply_attributes
    message[:reply_to][:mid] if message[:reply_to].present? && message[:reply_to][:mid].present?
  end

  def build_message
    return if @outgoing_echo && already_sent_from_chatwoot?
    return if message_content.blank? && all_unsupported_files?

    @message = conversation.messages.create!(message_params)
    save_story_id

    attachments.each do |attachment|
      process_attachment(attachment)
    end
  end

  def save_story_id
    return if story_reply_attributes.blank?

    @message.save_story_info(story_reply_attributes)
  end

  def build_conversation
    @contact_inbox ||= contact.contact_inboxes.find_by!(source_id: message_source_id)

    Conversation.create!(conversation_params.merge(
                           contact_inbox_id: @contact_inbox.id,
                           additional_attributes: { type: 'instagram_direct_message' }
                         ))
  end

  def conversation_params
    {
      account_id: @inbox.account_id,
      inbox_id: @inbox.id,
      contact_id: contact.id
    }
  end

  def message_params
    params = {
      account_id: conversation.account_id,
      inbox_id: conversation.inbox_id,
      message_type: message_type,
      source_id: message_identifier,
      content: message_content,
      sender: @outgoing_echo ? nil : contact,
      content_attributes: {
        in_reply_to_external_id: message_reply_attributes
      }
    }

    params[:content_attributes][:is_unsupported] = true if message_is_unsupported?
    params
  end

  def already_sent_from_chatwoot?
    cw_message = conversation.messages.where(
      source_id: @messaging[:message][:mid]
    ).first

    cw_message.present?
  end

  def all_unsupported_files?
    return if attachments.empty?

    attachments_type = attachments.pluck(:type).uniq.first
    unsupported_file_type?(attachments_type)
  end

  ### Sample response
  # {
  #   "object": "instagram",
  #   "entry": [
  #     {
  #       "id": "<IGID>",// ig id of the business
  #       "time": 1569262486134,
  #       "messaging": [
  #         {
  #           "sender": {
  #             "id": "<IGSID>"
  #           },
  #           "recipient": {
  #             "id": "<IGID>"
  #           },
  #           "timestamp": 1569262485349,
  #           "message": {
  #             "mid": "<MESSAGE_ID>",
  #             "text": "<MESSAGE_CONTENT>"
  #           }
  #         }
  #       ]
  #     }
  #   ],
  # }
end

================
File: builders/messages/messenger/message_builder.rb
================
class Messages::Messenger::MessageBuilder
  include ::FileTypeHelper

  def process_attachment(attachment)
    # This check handles very rare case if there are multiple files to attach with only one usupported file
    return if unsupported_file_type?(attachment['type'])

    attachment_obj = @message.attachments.new(attachment_params(attachment).except(:remote_file_url))
    attachment_obj.save!
    attach_file(attachment_obj, attachment_params(attachment)[:remote_file_url]) if attachment_params(attachment)[:remote_file_url]
    fetch_story_link(attachment_obj) if attachment_obj.file_type == 'story_mention'
    update_attachment_file_type(attachment_obj)
  end

  def attach_file(attachment, file_url)
    attachment_file = Down.download(
      file_url
    )
    attachment.file.attach(
      io: attachment_file,
      filename: attachment_file.original_filename,
      content_type: attachment_file.content_type
    )
  end

  def attachment_params(attachment)
    file_type = attachment['type'].to_sym
    params = { file_type: file_type, account_id: @message.account_id }

    if [:image, :file, :audio, :video, :share, :story_mention, :ig_reel].include? file_type
      params.merge!(file_type_params(attachment))
    elsif file_type == :location
      params.merge!(location_params(attachment))
    elsif file_type == :fallback
      params.merge!(fallback_params(attachment))
    end

    params
  end

  def file_type_params(attachment)
    {
      external_url: attachment['payload']['url'],
      remote_file_url: attachment['payload']['url']
    }
  end

  def update_attachment_file_type(attachment)
    return if @message.reload.attachments.blank?
    return unless attachment.file_type == 'share' || attachment.file_type == 'story_mention'

    attachment.file_type = file_type(attachment.file&.content_type)
    attachment.save!
  end

  def fetch_story_link(attachment)
    message = attachment.message
    result = get_story_object_from_source_id(message.source_id)

    return if result.blank?

    story_id = result['story']['mention']['id']
    story_sender = result['from']['username']
    message.content_attributes[:story_sender] = story_sender
    message.content_attributes[:story_id] = story_id
    message.content_attributes[:image_type] = 'story_mention'
    message.content = I18n.t('conversations.messages.instagram_story_content', story_sender: story_sender)
    message.save!
  end

  def get_story_object_from_source_id(source_id)
    k = Koala::Facebook::API.new(@inbox.channel.page_access_token) if @inbox.facebook?
    k.get_object(source_id, fields: %w[story from]) || {}
  rescue Koala::Facebook::AuthenticationError
    @inbox.channel.authorization_error!
    raise
  rescue Koala::Facebook::ClientError => e
    # The exception occurs when we are trying fetch the deleted story or blocked story.
    @message.attachments.destroy_all
    @message.update(content: I18n.t('conversations.messages.instagram_deleted_story_content'))
    Rails.logger.error e
    {}
  rescue StandardError => e
    ChatwootExceptionTracker.new(e, account: @inbox.account).capture_exception
    {}
  end

  private

  def unsupported_file_type?(attachment_type)
    [:template, :unsupported_type].include? attachment_type.to_sym
  end
end

================
File: builders/messages/message_builder.rb
================
class Messages::MessageBuilder
  include ::FileTypeHelper
  attr_reader :message

  def initialize(user, conversation, params)
    @params = params
    @private = params[:private] || false
    @conversation = conversation
    @user = user
    @message_type = params[:message_type] || 'outgoing'
    @attachments = params[:attachments]
    @automation_rule = content_attributes&.dig(:automation_rule_id)
    return unless params.instance_of?(ActionController::Parameters)

    @in_reply_to = content_attributes&.dig(:in_reply_to)
    @items = content_attributes&.dig(:items)
  end

  def perform
    @message = @conversation.messages.build(message_params)
    process_attachments
    process_emails
    @message.save!
    @message
  end

  private

  # Extracts content attributes from the given params.
  # - Converts ActionController::Parameters to a regular hash if needed.
  # - Attempts to parse a JSON string if content is a string.
  # - Returns an empty hash if content is not present, if there's a parsing error, or if it's an unexpected type.
  def content_attributes
    params = convert_to_hash(@params)
    content_attributes = params.fetch(:content_attributes, {})

    return parse_json(content_attributes) if content_attributes.is_a?(String)
    return content_attributes if content_attributes.is_a?(Hash)

    {}
  end

  # Converts the given object to a hash.
  # If it's an instance of ActionController::Parameters, converts it to an unsafe hash.
  # Otherwise, returns the object as-is.
  def convert_to_hash(obj)
    return obj.to_unsafe_h if obj.instance_of?(ActionController::Parameters)

    obj
  end

  # Attempts to parse a string as JSON.
  # If successful, returns the parsed hash with symbolized names.
  # If unsuccessful, returns nil.
  def parse_json(content)
    JSON.parse(content, symbolize_names: true)
  rescue JSON::ParserError
    {}
  end

  def process_attachments
    return if @attachments.blank?

    @attachments.each do |uploaded_attachment|
      attachment = @message.attachments.build(
        account_id: @message.account_id,
        file: uploaded_attachment
      )

      attachment.file_type = if uploaded_attachment.is_a?(String)
                               file_type_by_signed_id(
                                 uploaded_attachment
                               )
                             else
                               file_type(uploaded_attachment&.content_type)
                             end
    end
  end

  def process_emails
    return unless @conversation.inbox&.inbox_type == 'Email'

    cc_emails = process_email_string(@params[:cc_emails])
    bcc_emails = process_email_string(@params[:bcc_emails])
    to_emails = process_email_string(@params[:to_emails])

    all_email_addresses = cc_emails + bcc_emails + to_emails
    validate_email_addresses(all_email_addresses)

    @message.content_attributes[:cc_emails] = cc_emails
    @message.content_attributes[:bcc_emails] = bcc_emails
    @message.content_attributes[:to_emails] = to_emails
  end

  def process_email_string(email_string)
    return [] if email_string.blank?

    email_string.gsub(/\s+/, '').split(',')
  end

  def validate_email_addresses(all_emails)
    all_emails&.each do |email|
      raise StandardError, 'Invalid email address' unless email.match?(URI::MailTo::EMAIL_REGEXP)
    end
  end

  def message_type
    if @conversation.inbox.channel_type != 'Channel::Api' && @message_type == 'incoming'
      raise StandardError, 'Incoming messages are only allowed in Api inboxes'
    end

    @message_type
  end

  def sender
    message_type == 'outgoing' ? (message_sender || @user) : @conversation.contact
  end

  def external_created_at
    @params[:external_created_at].present? ? { external_created_at: @params[:external_created_at] } : {}
  end

  def automation_rule_id
    @automation_rule.present? ? { content_attributes: { automation_rule_id: @automation_rule } } : {}
  end

  def campaign_id
    @params[:campaign_id].present? ? { additional_attributes: { campaign_id: @params[:campaign_id] } } : {}
  end

  def template_params
    @params[:template_params].present? ? { additional_attributes: { template_params: JSON.parse(@params[:template_params].to_json) } } : {}
  end

  def message_sender
    return if @params[:sender_type] != 'AgentBot'

    AgentBot.where(account_id: [nil, @conversation.account.id]).find_by(id: @params[:sender_id])
  end

  def message_params
    {
      account_id: @conversation.account_id,
      inbox_id: @conversation.inbox_id,
      message_type: message_type,
      content: @params[:content],
      private: @private,
      sender: sender,
      content_type: @params[:content_type],
      items: @items,
      in_reply_to: @in_reply_to,
      echo_id: @params[:echo_id],
      source_id: @params[:source_id]
    }.merge(external_created_at).merge(automation_rule_id).merge(campaign_id).merge(template_params)
  end
end

================
File: builders/v2/reports/conversations/base_report_builder.rb
================
class V2::Reports::Conversations::BaseReportBuilder
  pattr_initialize :account, :params

  private

  AVG_METRICS = %w[avg_first_response_time avg_resolution_time reply_time].freeze
  COUNT_METRICS = %w[
    conversations_count
    incoming_messages_count
    outgoing_messages_count
    resolutions_count
    bot_resolutions_count
    bot_handoffs_count
  ].freeze

  def builder_class(metric)
    case metric
    when *AVG_METRICS
      V2::Reports::Timeseries::AverageReportBuilder
    when *COUNT_METRICS
      V2::Reports::Timeseries::CountReportBuilder
    end
  end

  def log_invalid_metric
    Rails.logger.error "ReportBuilder: Invalid metric - #{params[:metric]}"

    {}
  end
end

================
File: builders/v2/reports/conversations/metric_builder.rb
================
class V2::Reports::Conversations::MetricBuilder < V2::Reports::Conversations::BaseReportBuilder
  def summary
    {
      conversations_count: count('conversations_count'),
      incoming_messages_count: count('incoming_messages_count'),
      outgoing_messages_count: count('outgoing_messages_count'),
      avg_first_response_time: count('avg_first_response_time'),
      avg_resolution_time: count('avg_resolution_time'),
      resolutions_count: count('resolutions_count'),
      reply_time: count('reply_time')
    }
  end

  def bot_summary
    {
      bot_resolutions_count: count('bot_resolutions_count'),
      bot_handoffs_count: count('bot_handoffs_count')
    }
  end

  private

  def count(metric)
    builder_class(metric).new(account, builder_params(metric)).aggregate_value
  end

  def builder_params(metric)
    params.merge({ metric: metric })
  end
end

================
File: builders/v2/reports/conversations/report_builder.rb
================
class V2::Reports::Conversations::ReportBuilder < V2::Reports::Conversations::BaseReportBuilder
  def timeseries
    perform_action(:timeseries)
  end

  def aggregate_value
    perform_action(:aggregate_value)
  end

  private

  def perform_action(method_name)
    return builder.new(account, params).public_send(method_name) if builder.present?

    log_invalid_metric
  end

  def builder
    builder_class(params[:metric])
  end
end

================
File: builders/v2/reports/timeseries/average_report_builder.rb
================
class V2::Reports::Timeseries::AverageReportBuilder < V2::Reports::Timeseries::BaseTimeseriesBuilder
  def timeseries
    grouped_average_time = reporting_events.average(average_value_key)
    grouped_event_count = reporting_events.count
    grouped_average_time.each_with_object([]) do |element, arr|
      event_date, average_time = element
      arr << {
        value: average_time,
        timestamp: event_date.in_time_zone(timezone).to_i,
        count: grouped_event_count[event_date]
      }
    end
  end

  def aggregate_value
    object_scope.average(average_value_key)
  end

  private

  def event_name
    metric_to_event_name = {
      avg_first_response_time: :first_response,
      avg_resolution_time: :conversation_resolved,
      reply_time: :reply_time
    }
    metric_to_event_name[params[:metric].to_sym]
  end

  def object_scope
    scope.reporting_events.where(name: event_name, created_at: range, account_id: account.id)
  end

  def reporting_events
    @grouped_values = object_scope.group_by_period(
      group_by,
      :created_at,
      default_value: 0,
      range: range,
      permit: %w[day week month year hour],
      time_zone: timezone
    )
  end

  def average_value_key
    @average_value_key ||= params[:business_hours].present? ? :value_in_business_hours : :value
  end
end

================
File: builders/v2/reports/timeseries/base_timeseries_builder.rb
================
class V2::Reports::Timeseries::BaseTimeseriesBuilder
  include TimezoneHelper
  include DateRangeHelper
  DEFAULT_GROUP_BY = 'day'.freeze

  pattr_initialize :account, :params

  def scope
    case params[:type].to_sym
    when :account
      account
    when :inbox
      inbox
    when :agent
      user
    when :label
      label
    when :team
      team
    end
  end

  def inbox
    @inbox ||= account.inboxes.find(params[:id])
  end

  def user
    @user ||= account.users.find(params[:id])
  end

  def label
    @label ||= account.labels.find(params[:id])
  end

  def team
    @team ||= account.teams.find(params[:id])
  end

  def group_by
    @group_by ||= %w[day week month year hour].include?(params[:group_by]) ? params[:group_by] : DEFAULT_GROUP_BY
  end

  def timezone
    @timezone ||= timezone_name_from_offset(params[:timezone_offset])
  end
end

================
File: builders/v2/reports/timeseries/count_report_builder.rb
================
class V2::Reports::Timeseries::CountReportBuilder < V2::Reports::Timeseries::BaseTimeseriesBuilder
  def timeseries
    grouped_count.each_with_object([]) do |element, arr|
      event_date, event_count = element

      # The `event_date` is in Date format (without time), such as "Wed, 15 May 2024".
      # We need a timestamp for the start of the day. However, we can't use `event_date.to_time.to_i`
      # because it converts the date to 12:00 AM server timezone.
      # The desired output should be 12:00 AM in the specified timezone.
      arr << { value: event_count, timestamp: event_date.in_time_zone(timezone).to_i }
    end
  end

  def aggregate_value
    object_scope.count
  end

  private

  def metric
    @metric ||= params[:metric]
  end

  def object_scope
    send("scope_for_#{metric}")
  end

  def scope_for_conversations_count
    scope.conversations.where(account_id: account.id, created_at: range)
  end

  def scope_for_incoming_messages_count
    scope.messages.where(account_id: account.id, created_at: range).incoming.unscope(:order)
  end

  def scope_for_outgoing_messages_count
    scope.messages.where(account_id: account.id, created_at: range).outgoing.unscope(:order)
  end

  def scope_for_resolutions_count
    scope.reporting_events.joins(:conversation).select(:conversation_id).where(
      name: :conversation_resolved,
      conversations: { status: :resolved }, created_at: range
    ).distinct
  end

  def scope_for_bot_resolutions_count
    scope.reporting_events.joins(:conversation).select(:conversation_id).where(
      name: :conversation_bot_resolved,
      conversations: { status: :resolved }, created_at: range
    ).distinct
  end

  def scope_for_bot_handoffs_count
    scope.reporting_events.joins(:conversation).select(:conversation_id).where(
      name: :conversation_bot_handoff,
      created_at: range
    ).distinct
  end

  def grouped_count
    @grouped_values = object_scope.group_by_period(
      group_by,
      :created_at,
      default_value: 0,
      range: range,
      permit: %w[day week month year hour],
      time_zone: timezone
    ).count
  end
end

================
File: builders/v2/reports/agent_summary_builder.rb
================
class V2::Reports::AgentSummaryBuilder < V2::Reports::BaseSummaryBuilder
  pattr_initialize [:account!, :params!]

  def build
    load_data
    prepare_report
  end

  private

  attr_reader :conversations_count, :resolved_count,
              :avg_resolution_time, :avg_first_response_time, :avg_reply_time

  def fetch_conversations_count
    account.conversations.where(created_at: range).group('assignee_id').count
  end

  def prepare_report
    account.account_users.map do |account_user|
      build_agent_stats(account_user)
    end
  end

  def build_agent_stats(account_user)
    user_id = account_user.user_id
    {
      id: user_id,
      conversations_count: conversations_count[user_id] || 0,
      resolved_conversations_count: resolved_count[user_id] || 0,
      avg_resolution_time: avg_resolution_time[user_id],
      avg_first_response_time: avg_first_response_time[user_id],
      avg_reply_time: avg_reply_time[user_id]
    }
  end

  def group_by_key
    :user_id
  end
end

================
File: builders/v2/reports/base_summary_builder.rb
================
class V2::Reports::BaseSummaryBuilder
  include DateRangeHelper

  def build
    load_data
    prepare_report
  end

  private

  def load_data
    @conversations_count = fetch_conversations_count
    @resolved_count = fetch_resolved_count
    @avg_resolution_time = fetch_average_time('conversation_resolved')
    @avg_first_response_time = fetch_average_time('first_response')
    @avg_reply_time = fetch_average_time('reply_time')
  end

  def reporting_events
    @reporting_events ||= account.reporting_events.where(created_at: range)
  end

  def fetch_conversations_count
    # Override this method
  end

  def fetch_average_time(event_name)
    get_grouped_average(reporting_events.where(name: event_name))
  end

  def fetch_resolved_count
    reporting_events.where(name: 'conversation_resolved').group(group_by_key).count
  end

  def group_by_key
    # Override this method
  end

  def prepare_report
    # Override this method
  end

  def get_grouped_average(events)
    events.group(group_by_key).average(average_value_key)
  end

  def average_value_key
    ActiveModel::Type::Boolean.new.cast(params[:business_hours]).present? ? :value_in_business_hours : :value
  end
end

================
File: builders/v2/reports/bot_metrics_builder.rb
================
class V2::Reports::BotMetricsBuilder
  include DateRangeHelper
  attr_reader :account, :params

  def initialize(account, params)
    @account = account
    @params = params
  end

  def metrics
    {
      conversation_count: bot_conversations.count,
      message_count: bot_messages.count,
      resolution_rate: bot_resolution_rate.to_i,
      handoff_rate: bot_handoff_rate.to_i
    }
  end

  private

  def bot_activated_inbox_ids
    @bot_activated_inbox_ids ||= account.inboxes.filter(&:active_bot?).map(&:id)
  end

  def bot_conversations
    @bot_conversations ||= account.conversations.where(inbox_id: bot_activated_inbox_ids).where(created_at: range)
  end

  def bot_messages
    @bot_messages ||= account.messages.outgoing.where(conversation_id: bot_conversations.ids).where(created_at: range)
  end

  def bot_resolutions_count
    account.reporting_events.joins(:conversation).select(:conversation_id).where(account_id: account.id, name: :conversation_bot_resolved,
                                                                                 created_at: range).distinct.count
  end

  def bot_handoffs_count
    account.reporting_events.joins(:conversation).select(:conversation_id).where(account_id: account.id, name: :conversation_bot_handoff,
                                                                                 created_at: range).distinct.count
  end

  def bot_resolution_rate
    return 0 if bot_conversations.count.zero?

    bot_resolutions_count.to_f / bot_conversations.count * 100
  end

  def bot_handoff_rate
    return 0 if bot_conversations.count.zero?

    bot_handoffs_count.to_f / bot_conversations.count * 100
  end
end

================
File: builders/v2/reports/inbox_summary_builder.rb
================
class V2::Reports::InboxSummaryBuilder < V2::Reports::BaseSummaryBuilder
  pattr_initialize [:account!, :params!]

  def build
    load_data
    prepare_report
  end

  private

  attr_reader :conversations_count, :resolved_count,
              :avg_resolution_time, :avg_first_response_time, :avg_reply_time

  def load_data
    @conversations_count = fetch_conversations_count
    @resolved_count = fetch_resolved_count
    @avg_resolution_time = fetch_average_time('conversation_resolved')
    @avg_first_response_time = fetch_average_time('first_response')
    @avg_reply_time = fetch_average_time('reply_time')
  end

  def fetch_conversations_count
    account.conversations.where(created_at: range).group(group_by_key).count
  end

  def prepare_report
    account.inboxes.map do |inbox|
      build_inbox_stats(inbox)
    end
  end

  def build_inbox_stats(inbox)
    {
      id: inbox.id,
      conversations_count: conversations_count[inbox.id] || 0,
      resolved_conversations_count: resolved_count[inbox.id] || 0,
      avg_resolution_time: avg_resolution_time[inbox.id],
      avg_first_response_time: avg_first_response_time[inbox.id],
      avg_reply_time: avg_reply_time[inbox.id]
    }
  end

  def group_by_key
    :inbox_id
  end

  def average_value_key
    ActiveModel::Type::Boolean.new.cast(params[:business_hours]) ? :value_in_business_hours : :value
  end
end

================
File: builders/v2/reports/team_summary_builder.rb
================
class V2::Reports::TeamSummaryBuilder < V2::Reports::BaseSummaryBuilder
  pattr_initialize [:account!, :params!]

  private

  attr_reader :conversations_count, :resolved_count,
              :avg_resolution_time, :avg_first_response_time, :avg_reply_time

  def fetch_conversations_count
    account.conversations.where(created_at: range).group(:team_id).count
  end

  def reporting_events
    @reporting_events ||= account.reporting_events.where(created_at: range).joins(:conversation)
  end

  def prepare_report
    account.teams.map do |team|
      build_team_stats(team)
    end
  end

  def build_team_stats(team)
    {
      id: team.id,
      conversations_count: conversations_count[team.id] || 0,
      resolved_conversations_count: resolved_count[team.id] || 0,
      avg_resolution_time: avg_resolution_time[team.id],
      avg_first_response_time: avg_first_response_time[team.id],
      avg_reply_time: avg_reply_time[team.id]
    }
  end

  def group_by_key
    'conversations.team_id'
  end
end

================
File: builders/v2/report_builder.rb
================
class V2::ReportBuilder
  include DateRangeHelper
  include ReportHelper
  attr_reader :account, :params

  DEFAULT_GROUP_BY = 'day'.freeze
  AGENT_RESULTS_PER_PAGE = 25

  def initialize(account, params)
    @account = account
    @params = params

    timezone_offset = (params[:timezone_offset] || 0).to_f
    @timezone = ActiveSupport::TimeZone[timezone_offset]&.name
  end

  def timeseries
    return send(params[:metric]) if metric_valid?

    Rails.logger.error "ReportBuilder: Invalid metric - #{params[:metric]}"
    {}
  end

  # For backward compatible with old report
  def build
    if %w[avg_first_response_time avg_resolution_time reply_time].include?(params[:metric])
      timeseries.each_with_object([]) do |p, arr|
        arr << { value: p[1], timestamp: p[0].in_time_zone(@timezone).to_i, count: @grouped_values.count[p[0]] }
      end
    else
      timeseries.each_with_object([]) do |p, arr|
        arr << { value: p[1], timestamp: p[0].in_time_zone(@timezone).to_i }
      end
    end
  end

  def summary
    {
      conversations_count: conversations.count,
      incoming_messages_count: incoming_messages.count,
      outgoing_messages_count: outgoing_messages.count,
      avg_first_response_time: avg_first_response_time_summary,
      avg_resolution_time: avg_resolution_time_summary,
      resolutions_count: resolutions.count,
      reply_time: reply_time_summary
    }
  end

  def short_summary
    {
      conversations_count: conversations.count,
      avg_first_response_time: avg_first_response_time_summary,
      avg_resolution_time: avg_resolution_time_summary
    }
  end

  def bot_summary
    {
      bot_resolutions_count: bot_resolutions.count,
      bot_handoffs_count: bot_handoffs.count
    }
  end

  def conversation_metrics
    if params[:type].equal?(:account)
      live_conversations
    else
      agent_metrics.sort_by { |hash| hash[:metric][:open] }.reverse
    end
  end

  private

  def metric_valid?
    %w[conversations_count
       incoming_messages_count
       outgoing_messages_count
       avg_first_response_time
       avg_resolution_time reply_time
       resolutions_count
       bot_resolutions_count
       bot_handoffs_count
       reply_time].include?(params[:metric])
  end

  def inbox
    @inbox ||= account.inboxes.find(params[:id])
  end

  def user
    @user ||= account.users.find(params[:id])
  end

  def label
    @label ||= account.labels.find(params[:id])
  end

  def team
    @team ||= account.teams.find(params[:id])
  end

  def get_grouped_values(object_scope)
    @grouped_values = object_scope.group_by_period(
      params[:group_by] || DEFAULT_GROUP_BY,
      :created_at,
      default_value: 0,
      range: range,
      permit: %w[day week month year hour],
      time_zone: @timezone
    )
  end

  def agent_metrics
    account_users = @account.account_users.page(params[:page]).per(AGENT_RESULTS_PER_PAGE)
    account_users.each_with_object([]) do |account_user, arr|
      @user = account_user.user
      arr << {
        id: @user.id,
        name: @user.name,
        email: @user.email,
        thumbnail: @user.avatar_url,
        availability: account_user.availability_status,
        metric: live_conversations
      }
    end
  end

  def live_conversations
    @open_conversations = scope.conversations.where(account_id: @account.id).open
    metric = {
      open: @open_conversations.count,
      unattended: @open_conversations.unattended.count
    }
    metric[:unassigned] = @open_conversations.unassigned.count if params[:type].equal?(:account)
    metric[:pending] = @open_conversations.pending.count if params[:type].equal?(:account)
    metric
  end
end

================
File: builders/account_builder.rb
================
# frozen_string_literal: true

class AccountBuilder
  include CustomExceptions::Account
  pattr_initialize [:account_name, :email!, :confirmed, :user, :user_full_name, :user_password, :super_admin, :locale]

  def perform
    if @user.nil?
      validate_email
      validate_user
    end
    ActiveRecord::Base.transaction do
      @account = create_account
      @user = create_and_link_user
    end
    [@user, @account]
  rescue StandardError => e
    Rails.logger.debug e.inspect
    raise e
  end

  private

  def user_full_name
    # the empty string ensures that not-null constraint is not violated
    @user_full_name || ''
  end

  def account_name
    # the empty string ensures that not-null constraint is not violated
    @account_name || ''
  end

  def validate_email
    raise InvalidEmail.new({ domain_blocked: domain_blocked }) if domain_blocked?

    address = ValidEmail2::Address.new(@email)
    if address.valid? && !address.disposable?
      true
    else
      raise InvalidEmail.new({ valid: address.valid?, disposable: address.disposable? })
    end
  end

  def validate_user
    if User.exists?(email: @email)
      raise UserExists.new(email: @email)
    else
      true
    end
  end

  def create_account
    @account = Account.create!(name: account_name, locale: I18n.locale)
    Current.account = @account
  end

  def create_and_link_user
    if @user.present? || create_user
      link_user_to_account(@user, @account)
      @user
    else
      raise UserErrors.new(errors: @user.errors)
    end
  end

  def link_user_to_account(user, account)
    AccountUser.create!(
      account_id: account.id,
      user_id: user.id,
      role: AccountUser.roles['administrator']
    )
  end

  def create_user
    @user = User.new(email: @email,
                     password: user_password,
                     password_confirmation: user_password,
                     name: user_full_name)
    @user.type = 'SuperAdmin' if @super_admin
    @user.confirm if @confirmed
    @user.save!
  end

  def domain_blocked?
    domain = @email.split('@').last

    blocked_domains.each do |blocked_domain|
      return true if domain.match?(blocked_domain)
    end

    false
  end

  def blocked_domains
    domains = GlobalConfigService.load('BLOCKED_EMAIL_DOMAINS', '')
    return [] if domains.blank?

    domains.split("\n").map(&:strip)
  end
end

================
File: builders/agent_builder.rb
================
# The AgentBuilder class is responsible for creating a new agent.
# It initializes with necessary attributes and provides a perform method
# to create a user and account user in a transaction.
class AgentBuilder
  # Initializes an AgentBuilder with necessary attributes.
  # @param email [String] the email of the user.
  # @param name [String] the name of the user.
  # @param role [String] the role of the user, defaults to 'agent' if not provided.
  # @param inviter [User] the user who is inviting the agent (Current.user in most cases).
  # @param availability [String] the availability status of the user, defaults to 'offline' if not provided.
  # @param auto_offline [Boolean] the auto offline status of the user.
  pattr_initialize [:email, { name: '' }, :inviter, :account, { role: :agent }, { availability: :offline }, { auto_offline: false }]

  # Creates a user and account user in a transaction.
  # @return [User] the created user.
  def perform
    ActiveRecord::Base.transaction do
      @user = find_or_create_user
      create_account_user
    end
    @user
  end

  private

  # Finds a user by email or creates a new one with a temporary password.
  # @return [User] the found or created user.
  def find_or_create_user
    user = User.from_email(email)
    return user if user

    temp_password = "1!aA#{SecureRandom.alphanumeric(12)}"
    User.create!(email: email, name: name, password: temp_password, password_confirmation: temp_password)
  end

  # Checks if the user needs confirmation.
  # @return [Boolean] true if the user is persisted and not confirmed, false otherwise.
  def user_needs_confirmation?
    @user.persisted? && !@user.confirmed?
  end

  # Creates an account user linking the user to the current account.
  def create_account_user
    AccountUser.create!({
      account_id: account.id,
      user_id: @user.id,
      inviter_id: inviter.id
    }.merge({
      role: role,
      availability: availability,
      auto_offline: auto_offline
    }.compact))
  end
end

================
File: builders/contact_inbox_builder.rb
================
# This Builder will create a contact inbox with specified attributes. If the contact inbox already exists, it will be returned.
# For Specific Channels like whatsapp, email etc . it smartly generated appropriate the source id when none is provided.

class ContactInboxBuilder
  pattr_initialize [:contact, :inbox, :source_id, { hmac_verified: false }]

  def perform
    @source_id ||= generate_source_id
    create_contact_inbox if source_id.present?
  end

  private

  def generate_source_id
    case @inbox.channel_type
    when 'Channel::TwilioSms'
      twilio_source_id
    when 'Channel::Whatsapp'
      wa_source_id
    when 'Channel::Email'
      email_source_id
    when 'Channel::Sms'
      phone_source_id
    when 'Channel::Api', 'Channel::WebWidget'
      SecureRandom.uuid
    else
      raise "Unsupported operation for this channel: #{@inbox.channel_type}"
    end
  end

  def email_source_id
    raise ActionController::ParameterMissing, 'contact email' unless @contact.email

    @contact.email
  end

  def phone_source_id
    raise ActionController::ParameterMissing, 'contact phone number' unless @contact.phone_number

    @contact.phone_number
  end

  def wa_source_id
    raise ActionController::ParameterMissing, 'contact phone number' unless @contact.phone_number

    # whatsapp doesn't want the + in e164 format
    @contact.phone_number.delete('+').to_s
  end

  def twilio_source_id
    raise ActionController::ParameterMissing, 'contact phone number' unless @contact.phone_number

    case @inbox.channel.medium
    when 'sms'
      @contact.phone_number
    when 'whatsapp'
      "whatsapp:#{@contact.phone_number}"
    end
  end

  def create_contact_inbox
    ::ContactInbox.create_with(hmac_verified: hmac_verified || false).find_or_create_by!(
      contact_id: @contact.id,
      inbox_id: @inbox.id,
      source_id: @source_id
    )
  end
end

================
File: builders/contact_inbox_with_contact_builder.rb
================
# This Builder will create a contact and contact inbox with specified attributes.
# If an existing identified contact exisits, it will be returned.
# for contact inbox logic it uses the contact inbox builder

class ContactInboxWithContactBuilder
  pattr_initialize [:inbox!, :contact_attributes!, :source_id, :hmac_verified]

  def perform
    find_or_create_contact_and_contact_inbox
  # in case of race conditions where contact is created by another thread
  # we will try to find the contact and create a contact inbox
  rescue ActiveRecord::RecordNotUnique
    find_or_create_contact_and_contact_inbox
  end

  def find_or_create_contact_and_contact_inbox
    @contact_inbox = inbox.contact_inboxes.find_by(source_id: source_id) if source_id.present?
    return @contact_inbox if @contact_inbox

    ActiveRecord::Base.transaction(requires_new: true) do
      build_contact_with_contact_inbox
    end
    update_contact_avatar(@contact) unless @contact.avatar.attached?
    @contact_inbox
  end

  private

  def build_contact_with_contact_inbox
    @contact = find_contact || create_contact
    @contact_inbox = create_contact_inbox
  end

  def account
    @account ||= inbox.account
  end

  def create_contact_inbox
    ContactInboxBuilder.new(
      contact: @contact,
      inbox: @inbox,
      source_id: @source_id,
      hmac_verified: hmac_verified
    ).perform
  end

  def update_contact_avatar(contact)
    ::Avatar::AvatarFromUrlJob.perform_later(contact, contact_attributes[:avatar_url]) if contact_attributes[:avatar_url]
  end

  def create_contact
    account.contacts.create!(
      name: contact_attributes[:name] || ::Haikunator.haikunate(1000),
      phone_number: contact_attributes[:phone_number],
      email: contact_attributes[:email],
      identifier: contact_attributes[:identifier],
      additional_attributes: contact_attributes[:additional_attributes],
      custom_attributes: contact_attributes[:custom_attributes]
    )
  end

  def find_contact
    contact = find_contact_by_identifier(contact_attributes[:identifier])
    contact ||= find_contact_by_email(contact_attributes[:email])
    contact ||= find_contact_by_phone_number(contact_attributes[:phone_number])
    contact
  end

  def find_contact_by_identifier(identifier)
    return if identifier.blank?

    account.contacts.find_by(identifier: identifier)
  end

  def find_contact_by_email(email)
    return if email.blank?

    account.contacts.from_email(email)
  end

  def find_contact_by_phone_number(phone_number)
    return if phone_number.blank?

    account.contacts.find_by(phone_number: phone_number)
  end
end

================
File: builders/conversation_builder.rb
================
class ConversationBuilder
  pattr_initialize [:params!, :contact_inbox!]

  def perform
    look_up_exising_conversation || create_new_conversation
  end

  private

  def look_up_exising_conversation
    return unless @contact_inbox.inbox.lock_to_single_conversation?

    @contact_inbox.conversations.last
  end

  def create_new_conversation
    ::Conversation.create!(conversation_params)
  end

  def conversation_params
    additional_attributes = params[:additional_attributes]&.permit! || {}
    custom_attributes = params[:custom_attributes]&.permit! || {}
    status = params[:status].present? ? { status: params[:status] } : {}

    # TODO: temporary fallback for the old bot status in conversation, we will remove after couple of releases
    # commenting this out to see if there are any errors, if not we can remove this in subsequent releases
    # status = { status: 'pending' } if status[:status] == 'bot'
    {
      account_id: @contact_inbox.inbox.account_id,
      inbox_id: @contact_inbox.inbox_id,
      contact_id: @contact_inbox.contact_id,
      contact_inbox_id: @contact_inbox.id,
      additional_attributes: additional_attributes,
      custom_attributes: custom_attributes,
      snoozed_until: params[:snoozed_until],
      assignee_id: params[:assignee_id],
      team_id: params[:team_id]
    }.merge(status)
  end
end

================
File: builders/notification_builder.rb
================
class NotificationBuilder
  pattr_initialize [:notification_type!, :user!, :account!, :primary_actor!, :secondary_actor]

  def perform
    build_notification
  end

  private

  def current_user
    Current.user
  end

  def user_subscribed_to_notification?
    notification_setting = user.notification_settings.find_by(account_id: account.id)
    # added for the case where an assignee might be removed from the account but remains in conversation
    return false if notification_setting.blank?

    return true if notification_setting.public_send("email_#{notification_type}?")
    return true if notification_setting.public_send("push_#{notification_type}?")

    false
  end

  def build_notification
    # Create conversation_creation notification only if user is subscribed to it
    return if notification_type == 'conversation_creation' && !user_subscribed_to_notification?
    # skip notifications for blocked conversations except for user mentions
    return if primary_actor.contact.blocked? && notification_type != 'conversation_mention'

    user.notifications.create!(
      notification_type: notification_type,
      account: account,
      primary_actor: primary_actor,
      # secondary_actor is secondary_actor if present, else current_user
      secondary_actor: secondary_actor || current_user
    )
  end
end

================
File: builders/notification_subscription_builder.rb
================
class NotificationSubscriptionBuilder
  pattr_initialize [:params, :user!]

  def perform
    # if multiple accounts were used to login in same browser
    move_subscription_to_user if identifier_subscription && identifier_subscription.user_id != user.id
    identifier_subscription.blank? ? build_identifier_subscription : update_identifier_subscription
    identifier_subscription
  end

  private

  def identifier
    @identifier ||= params[:subscription_attributes][:endpoint] if params[:subscription_type] == 'browser_push'
    @identifier ||= params[:subscription_attributes][:device_id] if params[:subscription_type] == 'fcm'
    @identifier
  end

  def identifier_subscription
    @identifier_subscription ||= NotificationSubscription.find_by(identifier: identifier)
  end

  def move_subscription_to_user
    @identifier_subscription.update(user_id: user.id)
  end

  def build_identifier_subscription
    @identifier_subscription = user.notification_subscriptions.create!(params.merge(identifier: identifier))
  end

  def update_identifier_subscription
    identifier_subscription.update(params.merge(identifier: identifier))
  end
end

================
File: channels/application_cable/channel.rb
================
class ApplicationCable::Channel < ActionCable::Channel::Base
end

================
File: channels/application_cable/connection.rb
================
class ApplicationCable::Connection < ActionCable::Connection::Base
end

================
File: channels/room_channel.rb
================
class RoomChannel < ApplicationCable::Channel
  def subscribed
    # TODO: should we only do ensure stream  if current account is present?
    # for now going ahead with guard clauses in update_subscription and broadcast_presence

    ensure_stream
    current_user
    current_account
    update_subscription
    broadcast_presence
  end

  def update_presence
    update_subscription
    broadcast_presence
  end

  private

  def broadcast_presence
    return if @current_account.blank?

    data = { account_id: @current_account.id, users: ::OnlineStatusTracker.get_available_users(@current_account.id) }
    data[:contacts] = ::OnlineStatusTracker.get_available_contacts(@current_account.id) if @current_user.is_a? User
    ActionCable.server.broadcast(@pubsub_token, { event: 'presence.update', data: data })
  end

  def ensure_stream
    @pubsub_token = params[:pubsub_token]
    stream_from @pubsub_token
  end

  def update_subscription
    return if @current_account.blank?

    ::OnlineStatusTracker.update_presence(@current_account.id, @current_user.class.name, @current_user.id)
  end

  def current_user
    @current_user ||= if params[:user_id].blank?
                        ContactInbox.find_by!(pubsub_token: @pubsub_token).contact
                      else
                        User.find_by!(pubsub_token: @pubsub_token, id: params[:user_id])
                      end
  end

  def current_account
    return if current_user.blank?

    @current_account ||= if @current_user.is_a? Contact
                           @current_user.account
                         else
                           @current_user.accounts.find(params[:account_id])
                         end
  end
end

================
File: controllers/api/v1/accounts/actions/contact_merges_controller.rb
================
class Api::V1::Accounts::Actions::ContactMergesController < Api::V1::Accounts::BaseController
  before_action :set_base_contact, only: [:create]
  before_action :set_mergee_contact, only: [:create]

  def create
    contact_merge_action = ContactMergeAction.new(
      account: Current.account,
      base_contact: @base_contact,
      mergee_contact: @mergee_contact
    )
    contact_merge_action.perform
  end

  private

  def set_base_contact
    @base_contact = contacts.find(params[:base_contact_id])
  end

  def set_mergee_contact
    @mergee_contact = contacts.find(params[:mergee_contact_id])
  end

  def contacts
    @contacts ||= Current.account.contacts
  end
end

================
File: controllers/api/v1/accounts/channels/twilio_channels_controller.rb
================
class Api::V1::Accounts::Channels::TwilioChannelsController < Api::V1::Accounts::BaseController
  before_action :authorize_request

  def create
    process_create
  rescue StandardError => e
    render_could_not_create_error(e.message)
  end

  private

  def authorize_request
    authorize ::Inbox
  end

  def process_create
    ActiveRecord::Base.transaction do
      authenticate_twilio
      build_inbox
      setup_webhooks if @twilio_channel.sms?
    end
  end

  def authenticate_twilio
    client = if permitted_params[:api_key_sid].present?
               Twilio::REST::Client.new(permitted_params[:api_key_sid], permitted_params[:auth_token], permitted_params[:account_sid])
             else
               Twilio::REST::Client.new(permitted_params[:account_sid], permitted_params[:auth_token])
             end
    client.messages.list(limit: 1)
  end

  def setup_webhooks
    ::Twilio::WebhookSetupService.new(inbox: @inbox).perform
  end

  def phone_number
    return if permitted_params[:phone_number].blank?

    medium == 'sms' ? permitted_params[:phone_number] : "whatsapp:#{permitted_params[:phone_number]}"
  end

  def medium
    permitted_params[:medium]
  end

  def build_inbox
    @twilio_channel = Current.account.twilio_sms.create!(
      account_sid: permitted_params[:account_sid],
      auth_token: permitted_params[:auth_token],
      api_key_sid: permitted_params[:api_key_sid],
      messaging_service_sid: permitted_params[:messaging_service_sid].presence,
      phone_number: phone_number,
      medium: medium
    )
    @inbox = Current.account.inboxes.create!(
      name: permitted_params[:name],
      channel: @twilio_channel
    )
  end

  def permitted_params
    params.require(:twilio_channel).permit(
      :account_id, :messaging_service_sid, :phone_number, :account_sid, :auth_token, :name, :medium, :api_key_sid
    )
  end
end

================
File: controllers/api/v1/accounts/contacts/base_controller.rb
================
class Api::V1::Accounts::Contacts::BaseController < Api::V1::Accounts::BaseController
  before_action :ensure_contact

  private

  def ensure_contact
    @contact = Current.account.contacts.find(params[:contact_id])
  end
end

================
File: controllers/api/v1/accounts/contacts/contact_inboxes_controller.rb
================
class Api::V1::Accounts::Contacts::ContactInboxesController < Api::V1::Accounts::Contacts::BaseController
  include HmacConcern
  before_action :ensure_inbox, only: [:create]

  def create
    @contact_inbox = ContactInboxBuilder.new(
      contact: @contact,
      inbox: @inbox,
      source_id: params[:source_id],
      hmac_verified: hmac_verified?
    ).perform
  end

  private

  def ensure_inbox
    @inbox = Current.account.inboxes.find(params[:inbox_id])
    authorize @inbox, :show?
  end
end

================
File: controllers/api/v1/accounts/contacts/conversations_controller.rb
================
class Api::V1::Accounts::Contacts::ConversationsController < Api::V1::Accounts::Contacts::BaseController
  def index
    @conversations = Current.account.conversations.includes(
      :assignee, :contact, :inbox, :taggings
    ).where(inbox_id: inbox_ids, contact_id: @contact.id).order(last_activity_at: :desc).limit(20)
  end

  private

  def inbox_ids
    if Current.user.administrator? || Current.user.agent?
      Current.user.assigned_inboxes.pluck(:id)
    else
      []
    end
  end
end

================
File: controllers/api/v1/accounts/contacts/labels_controller.rb
================
class Api::V1::Accounts::Contacts::LabelsController < Api::V1::Accounts::Contacts::BaseController
  include LabelConcern

  private

  def model
    @model ||= @contact
  end

  def permitted_params
    params.permit(labels: [])
  end
end

================
File: controllers/api/v1/accounts/contacts/notes_controller.rb
================
class Api::V1::Accounts::Contacts::NotesController < Api::V1::Accounts::Contacts::BaseController
  before_action :note, except: [:index, :create]

  def index
    @notes = @contact.notes.latest.includes(:user)
  end

  def show; end

  def create
    @note = @contact.notes.create!(note_params)
  end

  def update
    @note.update(note_params)
  end

  def destroy
    @note.destroy!
    head :ok
  end

  private

  def note
    @note ||= @contact.notes.find(params[:id])
  end

  def note_params
    params.require(:note).permit(:content).merge({ contact_id: @contact.id, user_id: Current.user.id })
  end
end

================
File: controllers/api/v1/accounts/conversations/assignments_controller.rb
================
class Api::V1::Accounts::Conversations::AssignmentsController < Api::V1::Accounts::Conversations::BaseController
  # assigns agent/team to a conversation
  def create
    if params.key?(:assignee_id)
      set_agent
    elsif params.key?(:team_id)
      set_team
    else
      render json: nil
    end
  end

  private

  def set_agent
    @agent = Current.account.users.find_by(id: params[:assignee_id])
    @conversation.assignee = @agent
    @conversation.save!
    render_agent
  end

  def render_agent
    if @agent.nil?
      render json: nil
    else
      render partial: 'api/v1/models/agent', formats: [:json], locals: { resource: @agent }
    end
  end

  def set_team
    @team = Current.account.teams.find_by(id: params[:team_id])
    @conversation.update!(team: @team)
    render json: @team
  end
end

================
File: controllers/api/v1/accounts/conversations/base_controller.rb
================
class Api::V1::Accounts::Conversations::BaseController < Api::V1::Accounts::BaseController
  before_action :conversation

  private

  def conversation
    @conversation ||= Current.account.conversations.find_by!(display_id: params[:conversation_id])
    authorize @conversation.inbox, :show?
  end
end

================
File: controllers/api/v1/accounts/conversations/direct_uploads_controller.rb
================
class Api::V1::Accounts::Conversations::DirectUploadsController < ActiveStorage::DirectUploadsController
  include EnsureCurrentAccountHelper
  before_action :current_account
  before_action :conversation

  def create
    return if @conversation.nil? || @current_account.nil?

    super
  end

  private

  def conversation
    @conversation ||= Current.account.conversations.find_by(display_id: params[:conversation_id])
  end
end

================
File: controllers/api/v1/accounts/conversations/draft_messages_controller.rb
================
class Api::V1::Accounts::Conversations::DraftMessagesController < Api::V1::Accounts::Conversations::BaseController
  def show
    render json: { has_draft: false } and return unless Redis::Alfred.exists?(draft_redis_key)

    draft_message = Redis::Alfred.get(draft_redis_key)
    render json: { has_draft: true, message: draft_message }
  end

  def update
    Redis::Alfred.set(draft_redis_key, draft_message_params)
    head :ok
  end

  def destroy
    Redis::Alfred.delete(draft_redis_key)
    head :ok
  end

  private

  def draft_redis_key
    format(Redis::Alfred::CONVERSATION_DRAFT_MESSAGE, id: @conversation.id)
  end

  def draft_message_params
    params.dig(:draft_message, :message) || ''
  end
end

================
File: controllers/api/v1/accounts/conversations/labels_controller.rb
================
class Api::V1::Accounts::Conversations::LabelsController < Api::V1::Accounts::Conversations::BaseController
  include LabelConcern

  private

  def model
    @model ||= @conversation
  end

  def permitted_params
    params.permit(:conversation_id, labels: [])
  end
end

================
File: controllers/api/v1/accounts/conversations/messages_controller.rb
================
class Api::V1::Accounts::Conversations::MessagesController < Api::V1::Accounts::Conversations::BaseController
  def index
    @messages = message_finder.perform
  end

  def create
    user = Current.user || @resource
    mb = Messages::MessageBuilder.new(user, @conversation, params)
    @message = mb.perform
  rescue StandardError => e
    render_could_not_create_error(e.message)
  end

  def destroy
    ActiveRecord::Base.transaction do
      message.update!(content: I18n.t('conversations.messages.deleted'), content_type: :text, content_attributes: { deleted: true })
      message.attachments.destroy_all
    end
  end

  def retry
    return if message.blank?

    message.update!(status: :sent, content_attributes: {})
    ::SendReplyJob.perform_later(message.id)
  rescue StandardError => e
    render_could_not_create_error(e.message)
  end

  def translate
    return head :ok if already_translated_content_available?

    translated_content = Integrations::GoogleTranslate::ProcessorService.new(
      message: message,
      target_language: permitted_params[:target_language]
    ).perform

    if translated_content.present?
      translations = {}
      translations[permitted_params[:target_language]] = translated_content
      translations = message.translations.merge!(translations) if message.translations.present?
      message.update!(translations: translations)
    end

    render json: { content: translated_content }
  end

  private

  def message
    @message ||= @conversation.messages.find(permitted_params[:id])
  end

  def message_finder
    @message_finder ||= MessageFinder.new(@conversation, params)
  end

  def permitted_params
    params.permit(:id, :target_language)
  end

  def already_translated_content_available?
    message.translations.present? && message.translations[permitted_params[:target_language]].present?
  end
end

================
File: controllers/api/v1/accounts/conversations/participants_controller.rb
================
class Api::V1::Accounts::Conversations::ParticipantsController < Api::V1::Accounts::Conversations::BaseController
  def show
    @participants = @conversation.conversation_participants
  end

  def create
    ActiveRecord::Base.transaction do
      @participants = participants_to_be_added_ids.map { |user_id| @conversation.conversation_participants.find_or_create_by(user_id: user_id) }
    end
  end

  def update
    ActiveRecord::Base.transaction do
      participants_to_be_added_ids.each { |user_id| @conversation.conversation_participants.find_or_create_by(user_id: user_id) }
      participants_to_be_removed_ids.each { |user_id| @conversation.conversation_participants.find_by(user_id: user_id)&.destroy }
    end
    @participants = @conversation.conversation_participants
    render action: 'show'
  end

  def destroy
    ActiveRecord::Base.transaction do
      params[:user_ids].map { |user_id| @conversation.conversation_participants.find_by(user_id: user_id)&.destroy }
    end
    head :ok
  end

  private

  def participants_to_be_added_ids
    params[:user_ids] - current_participant_ids
  end

  def participants_to_be_removed_ids
    current_participant_ids - params[:user_ids]
  end

  def current_participant_ids
    @current_participant_ids ||= @conversation.conversation_participants.pluck(:user_id)
  end
end

================
File: controllers/api/v1/accounts/google/authorizations_controller.rb
================
class Api::V1::Accounts::Google::AuthorizationsController < Api::V1::Accounts::BaseController
  include GoogleConcern
  before_action :check_authorization

  def create
    email = params[:authorization][:email]
    redirect_url = google_client.auth_code.authorize_url(
      {
        redirect_uri: "#{base_url}/google/callback",
        scope: 'email profile https://mail.google.com/',
        response_type: 'code',
        prompt: 'consent', # the oauth flow does not return a refresh token, this is supposed to fix it
        access_type: 'offline', # the default is 'online'
        client_id: GlobalConfigService.load('GOOGLE_OAUTH_CLIENT_ID', nil)
      }
    )

    if redirect_url
      cache_key = "google::#{email.downcase}"
      ::Redis::Alfred.setex(cache_key, Current.account.id, 5.minutes)
      render json: { success: true, url: redirect_url }
    else
      render json: { success: false }, status: :unprocessable_entity
    end
  end

  private

  def check_authorization
    raise Pundit::NotAuthorizedError unless Current.account_user.administrator?
  end
end

================
File: controllers/api/v1/accounts/integrations/apps_controller.rb
================
class Api::V1::Accounts::Integrations::AppsController < Api::V1::Accounts::BaseController
  before_action :check_admin_authorization?, except: [:index, :show]
  before_action :fetch_apps, only: [:index]
  before_action :fetch_app, only: [:show]

  def index; end

  def show; end

  private

  def fetch_apps
    @apps = Integrations::App.all.select { |app| app.active?(Current.account) }
  end

  def fetch_app
    @app = Integrations::App.find(id: params[:id])
  end
end

================
File: controllers/api/v1/accounts/integrations/dyte_controller.rb
================
class Api::V1::Accounts::Integrations::DyteController < Api::V1::Accounts::BaseController
  before_action :fetch_conversation, only: [:create_a_meeting]
  before_action :fetch_message, only: [:add_participant_to_meeting]
  before_action :authorize_request

  def create_a_meeting
    render_response(dyte_processor_service.create_a_meeting(Current.user))
  end

  def add_participant_to_meeting
    if @message.content_type != 'integrations'
      return render json: {
        error: I18n.t('errors.dyte.invalid_message_type')
      }, status: :unprocessable_entity
    end

    render_response(
      dyte_processor_service.add_participant_to_meeting(@message.content_attributes['data']['meeting_id'], Current.user)
    )
  end

  private

  def authorize_request
    authorize @conversation.inbox, :show?
  end

  def render_response(response)
    render json: response, status: response[:error].blank? ? :ok : :unprocessable_entity
  end

  def dyte_processor_service
    Integrations::Dyte::ProcessorService.new(account: Current.account, conversation: @conversation)
  end

  def permitted_params
    params.permit(:conversation_id, :message_id)
  end

  def fetch_conversation
    @conversation = Current.account.conversations.find_by!(display_id: permitted_params[:conversation_id])
  end

  def fetch_message
    @message = Current.account.messages.find(permitted_params[:message_id])
    @conversation = @message.conversation
  end
end

================
File: controllers/api/v1/accounts/integrations/hooks_controller.rb
================
class Api::V1::Accounts::Integrations::HooksController < Api::V1::Accounts::BaseController
  before_action :fetch_hook, except: [:create]
  before_action :check_authorization

  def create
    @hook = Current.account.hooks.create!(permitted_params)
  end

  def update
    @hook.update!(permitted_params.slice(:status, :settings))
  end

  def process_event
    response = @hook.process_event(params[:event])

    # for cases like an invalid event, or when conversation does not have enough messages
    # for a label suggestion, the response is nil
    if response.nil?
      render json: { message: nil }
    elsif response[:error]
      render json: { error: response[:error] }, status: :unprocessable_entity
    else
      render json: { message: response[:message] }
    end
  end

  def destroy
    @hook.destroy!
    head :ok
  end

  private

  def fetch_hook
    @hook = Current.account.hooks.find(params[:id])
  end

  def check_authorization
    authorize(:hook)
  end

  def permitted_params
    params.require(:hook).permit(:app_id, :inbox_id, :status, settings: {})
  end
end

================
File: controllers/api/v1/accounts/integrations/linear_controller.rb
================
class Api::V1::Accounts::Integrations::LinearController < Api::V1::Accounts::BaseController
  before_action :fetch_conversation, only: [:link_issue, :linked_issues]
  before_action :fetch_hook, only: [:destroy]

  def destroy
    @hook.destroy!
    head :ok
  end

  def teams
    teams = linear_processor_service.teams
    if teams[:error]
      render json: { error: teams[:error] }, status: :unprocessable_entity
    else
      render json: teams[:data], status: :ok
    end
  end

  def team_entities
    team_id = permitted_params[:team_id]
    team_entities = linear_processor_service.team_entities(team_id)
    if team_entities[:error]
      render json: { error: team_entities[:error] }, status: :unprocessable_entity
    else
      render json: team_entities[:data], status: :ok
    end
  end

  def create_issue
    issue = linear_processor_service.create_issue(permitted_params)
    if issue[:error]
      render json: { error: issue[:error] }, status: :unprocessable_entity
    else
      render json: issue[:data], status: :ok
    end
  end

  def link_issue
    issue_id = permitted_params[:issue_id]
    title = permitted_params[:title]
    issue = linear_processor_service.link_issue(conversation_link, issue_id, title)
    if issue[:error]
      render json: { error: issue[:error] }, status: :unprocessable_entity
    else
      render json: issue[:data], status: :ok
    end
  end

  def unlink_issue
    link_id = permitted_params[:link_id]
    issue = linear_processor_service.unlink_issue(link_id)

    if issue[:error]
      render json: { error: issue[:error] }, status: :unprocessable_entity
    else
      render json: issue[:data], status: :ok
    end
  end

  def linked_issues
    issues = linear_processor_service.linked_issues(conversation_link)

    if issues[:error]
      render json: { error: issues[:error] }, status: :unprocessable_entity
    else
      render json: issues[:data], status: :ok
    end
  end

  def search_issue
    render json: { error: 'Specify search string with parameter q' }, status: :unprocessable_entity if params[:q].blank? && return

    term = params[:q]
    issues = linear_processor_service.search_issue(term)
    if issues[:error]
      render json: { error: issues[:error] }, status: :unprocessable_entity
    else
      render json: issues[:data], status: :ok
    end
  end

  private

  def conversation_link
    "#{ENV.fetch('FRONTEND_URL', nil)}/app/accounts/#{Current.account.id}/conversations/#{@conversation.display_id}"
  end

  def fetch_conversation
    @conversation = Current.account.conversations.find_by!(display_id: permitted_params[:conversation_id])
  end

  def linear_processor_service
    Integrations::Linear::ProcessorService.new(account: Current.account)
  end

  def permitted_params
    params.permit(:team_id, :project_id, :conversation_id, :issue_id, :link_id, :title, :description, :assignee_id, :priority, label_ids: [])
  end

  def fetch_hook
    @hook = Integrations::Hook.where(account: Current.account).find_by(app_id: 'linear')
  end
end

================
File: controllers/api/v1/accounts/integrations/slack_controller.rb
================
class Api::V1::Accounts::Integrations::SlackController < Api::V1::Accounts::BaseController
  before_action :check_admin_authorization?
  before_action :fetch_hook, only: [:update, :destroy, :list_all_channels]

  def list_all_channels
    @channels = channel_builder.fetch_channels
  end

  def create
    hook_builder = Integrations::Slack::HookBuilder.new(
      account: Current.account,
      code: params[:code],
      inbox_id: params[:inbox_id]
    )
    @hook = hook_builder.perform
  end

  def update
    @hook = channel_builder.update(permitted_params[:reference_id])
    render json: { error: I18n.t('errors.slack.invalid_channel_id') }, status: :unprocessable_entity if @hook.blank?
  end

  def destroy
    @hook.destroy!
    head :ok
  end

  private

  def fetch_hook
    @hook = Integrations::Hook.where(account: Current.account).find_by(app_id: 'slack')
  end

  def channel_builder
    Integrations::Slack::ChannelBuilder.new(hook: @hook)
  end

  def permitted_params
    params.permit(:reference_id)
  end
end

================
File: controllers/api/v1/accounts/microsoft/authorizations_controller.rb
================
class Api::V1::Accounts::Microsoft::AuthorizationsController < Api::V1::Accounts::BaseController
  include MicrosoftConcern
  before_action :check_authorization

  def create
    email = params[:authorization][:email]
    redirect_url = microsoft_client.auth_code.authorize_url(
      {
        redirect_uri: "#{base_url}/microsoft/callback",
        scope: 'offline_access https://outlook.office.com/IMAP.AccessAsUser.All https://outlook.office.com/SMTP.Send openid profile',
        prompt: 'consent'
      }
    )
    if redirect_url
      cache_key = "microsoft::#{email.downcase}"
      ::Redis::Alfred.setex(cache_key, Current.account.id, 5.minutes)
      render json: { success: true, url: redirect_url }
    else
      render json: { success: false }, status: :unprocessable_entity
    end
  end

  private

  def check_authorization
    raise Pundit::NotAuthorizedError unless Current.account_user.administrator?
  end
end

================
File: controllers/api/v1/accounts/twitter/authorizations_controller.rb
================
class Api::V1::Accounts::Twitter::AuthorizationsController < Api::V1::Accounts::BaseController
  include TwitterConcern

  before_action :check_authorization

  def create
    @response = twitter_client.request_oauth_token(url: twitter_callback_url)
    if @response.status == '200'
      ::Redis::Alfred.setex(oauth_token, Current.account.id)
      render json: { success: true, url: oauth_authorize_endpoint(oauth_token) }
    else
      render json: { success: false }, status: :unprocessable_entity
    end
  end

  private

  def oauth_token
    parsed_body['oauth_token']
  end

  def oauth_authorize_endpoint(oauth_token)
    "#{twitter_api_base_url}/oauth/authorize?oauth_token=#{oauth_token}"
  end

  def check_authorization
    raise Pundit::NotAuthorizedError unless Current.account_user.administrator?
  end
end

================
File: controllers/api/v1/accounts/agent_bots_controller.rb
================
class Api::V1::Accounts::AgentBotsController < Api::V1::Accounts::BaseController
  before_action :current_account
  before_action :check_authorization
  before_action :agent_bot, except: [:index, :create]

  def index
    @agent_bots = AgentBot.where(account_id: [nil, Current.account.id])
  end

  def show; end

  def create
    @agent_bot = Current.account.agent_bots.create!(permitted_params.except(:avatar_url))
    process_avatar_from_url
  end

  def update
    @agent_bot.update!(permitted_params.except(:avatar_url))
    process_avatar_from_url
  end

  def avatar
    @agent_bot.avatar.purge if @agent_bot.avatar.attached?
    @agent_bot
  end

  def destroy
    @agent_bot.destroy!
    head :ok
  end

  private

  def agent_bot
    @agent_bot = AgentBot.where(account_id: [nil, Current.account.id]).find(params[:id]) if params[:action] == 'show'
    @agent_bot ||= Current.account.agent_bots.find(params[:id])
  end

  def permitted_params
    params.permit(:name, :description, :outgoing_url, :avatar, :avatar_url, :bot_type, bot_config: [:csml_content])
  end

  def process_avatar_from_url
    ::Avatar::AvatarFromUrlJob.perform_later(@agent_bot, params[:avatar_url]) if params[:avatar_url].present?
  end
end

================
File: controllers/api/v1/accounts/agents_controller.rb
================
class Api::V1::Accounts::AgentsController < Api::V1::Accounts::BaseController
  before_action :fetch_agent, except: [:create, :index, :bulk_create]
  before_action :check_authorization
  before_action :validate_limit, only: [:create]
  before_action :validate_limit_for_bulk_create, only: [:bulk_create]

  def index
    @agents = agents
  end

  def create
    builder = AgentBuilder.new(
      email: new_agent_params['email'],
      name: new_agent_params['name'],
      role: new_agent_params['role'],
      availability: new_agent_params['availability'],
      auto_offline: new_agent_params['auto_offline'],
      inviter: current_user,
      account: Current.account
    )

    @agent = builder.perform
  end

  def update
    @agent.update!(agent_params.slice(:name).compact)
    @agent.current_account_user.update!(agent_params.slice(*account_user_attributes).compact)
  end

  def destroy
    @agent.current_account_user.destroy!
    delete_user_record(@agent)
    head :ok
  end

  def bulk_create
    emails = params[:emails]

    emails.each do |email|
      builder = AgentBuilder.new(
        email: email,
        name: email.split('@').first,
        inviter: current_user,
        account: Current.account
      )
      begin
        builder.perform
      rescue ActiveRecord::RecordInvalid => e
        Rails.logger.info "[Agent#bulk_create] ignoring email #{email}, errors: #{e.record.errors}"
      end
    end

    # This endpoint is used to bulk create agents during onboarding
    # onboarding_step key in present in Current account custom attributes, since this is a one time operation
    Current.account.custom_attributes.delete('onboarding_step')
    Current.account.save!
    head :ok
  end

  private

  def check_authorization
    super(User)
  end

  def fetch_agent
    @agent = agents.find(params[:id])
  end

  def account_user_attributes
    [:role, :availability, :auto_offline]
  end

  def allowed_agent_params
    [:name, :email, :name, :role, :availability, :auto_offline]
  end

  def agent_params
    params.require(:agent).permit(allowed_agent_params)
  end

  def new_agent_params
    params.require(:agent).permit(:email, :name, :role, :availability, :auto_offline)
  end

  def agents
    @agents ||= Current.account.users.order_by_full_name.includes(:account_users, { avatar_attachment: [:blob] })
  end

  def validate_limit_for_bulk_create
    limit_available = params[:emails].count <= available_agent_count

    render_payment_required('Account limit exceeded. Please purchase more licenses') unless limit_available
  end

  def validate_limit
    render_payment_required('Account limit exceeded. Please purchase more licenses') unless can_add_agent?
  end

  def available_agent_count
    Current.account.usage_limits[:agents] - agents.count
  end

  def can_add_agent?
    available_agent_count.positive?
  end

  def delete_user_record(agent)
    DeleteObjectJob.perform_later(agent) if agent.reload.account_users.blank?
  end
end

Api::V1::Accounts::AgentsController.prepend_mod_with('Api::V1::Accounts::AgentsController')

================
File: controllers/api/v1/accounts/articles_controller.rb
================
class Api::V1::Accounts::ArticlesController < Api::V1::Accounts::BaseController
  before_action :portal
  before_action :check_authorization
  before_action :fetch_article, except: [:index, :create, :reorder]
  before_action :set_current_page, only: [:index]

  def index
    @portal_articles = @portal.articles

    set_article_count

    @articles = @articles.search(list_params)

    @articles = if list_params[:category_slug].present?
                  @articles.order_by_position.page(@current_page)
                else
                  @articles.order_by_updated_at.page(@current_page)
                end
  end

  def show; end
  def edit; end

  def create
    @article = @portal.articles.create!(article_params)
    @article.associate_root_article(article_params[:associated_article_id])
    @article.draft!
    render json: { error: @article.errors.messages }, status: :unprocessable_entity and return unless @article.valid?
  end

  def update
    @article.update!(article_params) if params[:article].present?
    render json: { error: @article.errors.messages }, status: :unprocessable_entity and return unless @article.valid?
  end

  def destroy
    @article.destroy!
    head :ok
  end

  def reorder
    Article.update_positions(params[:positions_hash])
    head :ok
  end

  private

  def set_article_count
    # Search the params without status and author_id, use this to
    # compute mine count published draft etc
    base_search_params = list_params.except(:status, :author_id)
    @articles = @portal_articles.search(base_search_params)

    @articles_count = @articles.count
    @mine_articles_count = @articles.search_by_author(Current.user.id).count
    @published_articles_count = @articles.published.count
    @draft_articles_count = @articles.draft.count
    @archived_articles_count = @articles.archived.count
  end

  def fetch_article
    @article = @portal.articles.find(params[:id])
  end

  def portal
    @portal ||= Current.account.portals.find_by!(slug: params[:portal_id])
  end

  def article_params
    params.require(:article).permit(
      :title, :slug, :position, :content, :description, :position, :category_id, :author_id, :associated_article_id, :status,
      :locale, meta: [:title,
                      :description,
                      { tags: [] }]
    )
  end

  def list_params
    params.permit(:locale, :query, :page, :category_slug, :status, :author_id)
  end

  def set_current_page
    @current_page = params[:page] || 1
  end
end

================
File: controllers/api/v1/accounts/assignable_agents_controller.rb
================
class Api::V1::Accounts::AssignableAgentsController < Api::V1::Accounts::BaseController
  before_action :fetch_inboxes

  def index
    agent_ids = @inboxes.map do |inbox|
      authorize inbox, :show?
      member_ids = inbox.members.pluck(:user_id)
      member_ids
    end
    agent_ids = agent_ids.inject(:&)
    agents = Current.account.users.where(id: agent_ids)
    @assignable_agents = (agents + Current.account.administrators).uniq
  end

  private

  def fetch_inboxes
    @inboxes = Current.account.inboxes.find(permitted_params[:inbox_ids])
  end

  def permitted_params
    params.permit(inbox_ids: [])
  end
end

================
File: controllers/api/v1/accounts/automation_rules_controller.rb
================
class Api::V1::Accounts::AutomationRulesController < Api::V1::Accounts::BaseController
  before_action :check_authorization
  before_action :fetch_automation_rule, only: [:show, :update, :destroy, :clone]

  def index
    @automation_rules = Current.account.automation_rules
  end

  def show; end

  def create
    @automation_rule = Current.account.automation_rules.new(automation_rules_permit)
    @automation_rule.actions = params[:actions]
    @automation_rule.conditions = params[:conditions]

    render json: { error: @automation_rule.errors.messages }, status: :unprocessable_entity and return unless @automation_rule.valid?

    @automation_rule.save!
    process_attachments
    @automation_rule
  end

  def update
    ActiveRecord::Base.transaction do
      automation_rule_update
      process_attachments

    rescue StandardError => e
      Rails.logger.error e
      render json: { error: @automation_rule.errors.messages }.to_json, status: :unprocessable_entity
    end
  end

  def destroy
    @automation_rule.destroy!
    head :ok
  end

  def clone
    automation_rule = Current.account.automation_rules.find_by(id: params[:automation_rule_id])
    new_rule = automation_rule.dup
    new_rule.save!
    @automation_rule = new_rule
  end

  def process_attachments
    actions = @automation_rule.actions.filter_map { |k, _v| k if k['action_name'] == 'send_attachment' }
    return if actions.blank?

    actions.each do |action|
      blob_id = action['action_params']
      blob = ActiveStorage::Blob.find_by(id: blob_id)
      @automation_rule.files.attach(blob)
    end
  end

  private

  def automation_rule_update
    @automation_rule.update!(automation_rules_permit)
    @automation_rule.actions = params[:actions] if params[:actions]
    @automation_rule.conditions = params[:conditions] if params[:conditions]
    @automation_rule.save!
  end

  def automation_rules_permit
    params.permit(
      :name, :description, :event_name, :account_id, :active,
      conditions: [:attribute_key, :filter_operator, :query_operator, :custom_attribute_type, { values: [] }],
      actions: [:action_name, { action_params: [] }]
    )
  end

  def fetch_automation_rule
    @automation_rule = Current.account.automation_rules.find_by(id: params[:id])
  end
end

================
File: controllers/api/v1/accounts/base_controller.rb
================
class Api::V1::Accounts::BaseController < Api::BaseController
  include SwitchLocale
  include EnsureCurrentAccountHelper
  before_action :current_account
  around_action :switch_locale_using_account_locale
end

================
File: controllers/api/v1/accounts/bulk_actions_controller.rb
================
class Api::V1::Accounts::BulkActionsController < Api::V1::Accounts::BaseController
  before_action :type_matches?

  def create
    if type_matches?
      ::BulkActionsJob.perform_later(
        account: @current_account,
        user: current_user,
        params: permitted_params
      )
      head :ok
    else
      render json: { success: false }, status: :unprocessable_entity
    end
  end

  private

  def type_matches?
    ['Conversation'].include?(params[:type])
  end

  def permitted_params
    params.permit(:type, :snoozed_until, ids: [], fields: [:status, :assignee_id, :team_id], labels: [add: [], remove: []])
  end
end

================
File: controllers/api/v1/accounts/callbacks_controller.rb
================
class Api::V1::Accounts::CallbacksController < Api::V1::Accounts::BaseController
  before_action :inbox, only: [:reauthorize_page]

  def register_facebook_page
    user_access_token = params[:user_access_token]
    page_access_token = params[:page_access_token]
    page_id = params[:page_id]
    inbox_name = params[:inbox_name]
    ActiveRecord::Base.transaction do
      facebook_channel = Current.account.facebook_pages.create!(
        page_id: page_id, user_access_token: user_access_token,
        page_access_token: page_access_token
      )
      @facebook_inbox = Current.account.inboxes.create!(name: inbox_name, channel: facebook_channel)
      set_instagram_id(page_access_token, facebook_channel)
      set_avatar(@facebook_inbox, page_id)
    end
  rescue StandardError => e
    ChatwootExceptionTracker.new(e).capture_exception
    Rails.logger.error "Error in register_facebook_page: #{e.message}"
    # Additional log statements
    log_additional_info
  end

  def log_additional_info
    Rails.logger.debug do
      "user_access_token: #{params[:user_access_token]} , page_access_token: #{params[:page_access_token]} ,
      page_id: #{params[:page_id]}, inbox_name: #{params[:inbox_name]}"
    end
  end

  def facebook_pages
    @page_details = mark_already_existing_facebook_pages(fb_object.get_connections('me', 'accounts'))
  end

  def set_instagram_id(page_access_token, facebook_channel)
    fb_object = Koala::Facebook::API.new(page_access_token)
    response = fb_object.get_connections('me', '', { fields: 'instagram_business_account' })
    return if response['instagram_business_account'].blank?

    instagram_id = response['instagram_business_account']['id']
    facebook_channel.update(instagram_id: instagram_id)
  rescue StandardError => e
    Rails.logger.error "Error in set_instagram_id: #{e.message}"
  end

  # get params[:inbox_id], current_account. params[:omniauth_token]
  def reauthorize_page
    if @inbox&.facebook?
      fb_page_id = @inbox.channel.page_id
      page_details = fb_object.get_connections('me', 'accounts')

      if (page_detail = (page_details || []).detect { |page| fb_page_id == page['id'] })
        update_fb_page(fb_page_id, page_detail['access_token'])
        render and return
      end
    end

    head :unprocessable_entity
  end

  private

  def inbox
    @inbox = Current.account.inboxes.find_by(id: params[:inbox_id])
  end

  def update_fb_page(fb_page_id, access_token)
    fb_page = get_fb_page(fb_page_id)
    ActiveRecord::Base.transaction do
      fb_page&.update!(user_access_token: @user_access_token, page_access_token: access_token)
      set_instagram_id(access_token, fb_page)
      fb_page&.reauthorized!
    rescue StandardError => e
      ChatwootExceptionTracker.new(e).capture_exception
      Rails.logger.error "Error in update_fb_page: #{e.message}"
    end
  end

  def get_fb_page(fb_page_id)
    Current.account.facebook_pages.find_by(page_id: fb_page_id)
  end

  def fb_object
    @user_access_token = long_lived_token(params[:omniauth_token])
    Koala::Facebook::API.new(@user_access_token)
  end

  def long_lived_token(omniauth_token)
    koala = Koala::Facebook::OAuth.new(GlobalConfigService.load('FB_APP_ID', ''), GlobalConfigService.load('FB_APP_SECRET', ''))
    koala.exchange_access_token_info(omniauth_token)['access_token']
  rescue StandardError => e
    Rails.logger.error "Error in long_lived_token: #{e.message}"
  end

  def mark_already_existing_facebook_pages(data)
    return [] if data.empty?

    data.inject([]) do |result, page_detail|
      page_detail[:exists] = Current.account.facebook_pages.exists?(page_id: page_detail['id'])
      result << page_detail
    end
  end

  def set_avatar(facebook_inbox, page_id)
    avatar_url = "https://graph.facebook.com/#{page_id}/picture?type=large"
    Avatar::AvatarFromUrlJob.perform_later(facebook_inbox, avatar_url)
  end
end

================
File: controllers/api/v1/accounts/campaigns_controller.rb
================
class Api::V1::Accounts::CampaignsController < Api::V1::Accounts::BaseController
  before_action :campaign, except: [:index, :create]
  before_action :check_authorization

  def index
    @campaigns = Current.account.campaigns
  end

  def show; end

  def create
    @campaign = Current.account.campaigns.create!(campaign_params)
  end

  def update
    @campaign.update!(campaign_params)
  end

  def destroy
    @campaign.destroy!
    head :ok
  end

  private

  def campaign
    @campaign ||= Current.account.campaigns.find_by(display_id: params[:id])
  end

  def campaign_params
    params.require(:campaign).permit(:title, :description, :message, :enabled, :trigger_only_during_business_hours, :inbox_id, :sender_id,
                                     :scheduled_at, audience: [:type, :id], trigger_rules: {})
  end
end

================
File: controllers/api/v1/accounts/canned_responses_controller.rb
================
class Api::V1::Accounts::CannedResponsesController < Api::V1::Accounts::BaseController
  before_action :fetch_canned_response, only: [:update, :destroy]

  def index
    render json: canned_responses
  end

  def create
    @canned_response = Current.account.canned_responses.new(canned_response_params)
    @canned_response.save!
    render json: @canned_response
  end

  def update
    @canned_response.update!(canned_response_params)
    render json: @canned_response
  end

  def destroy
    @canned_response.destroy!
    head :ok
  end

  private

  def fetch_canned_response
    @canned_response = Current.account.canned_responses.find(params[:id])
  end

  def canned_response_params
    params.require(:canned_response).permit(:short_code, :content)
  end

  def canned_responses
    if params[:search]
      Current.account.canned_responses
             .where('short_code ILIKE :search OR content ILIKE :search', search: "%#{params[:search]}%")
             .order_by_search(params[:search])

    else
      Current.account.canned_responses
    end
  end
end

================
File: controllers/api/v1/accounts/categories_controller.rb
================
class Api::V1::Accounts::CategoriesController < Api::V1::Accounts::BaseController
  before_action :portal
  before_action :check_authorization
  before_action :fetch_category, except: [:index, :create]
  before_action :set_current_page, only: [:index]

  def index
    @current_locale = params[:locale]
    @categories = @portal.categories.search(params)
  end

  def show; end

  def create
    @category = @portal.categories.create!(category_params)
    @category.related_categories << related_categories_records
    render json: { error: @category.errors.messages }, status: :unprocessable_entity and return unless @category.valid?

    @category.save!
  end

  def update
    @category.update!(category_params)
    @category.related_categories = related_categories_records if related_categories_records.any?
    render json: { error: @category.errors.messages }, status: :unprocessable_entity and return unless @category.valid?

    @category.save!
  end

  def destroy
    @category.destroy!
    head :ok
  end

  private

  def fetch_category
    @category = @portal.categories.find(params[:id])
  end

  def portal
    @portal ||= Current.account.portals.find_by(slug: params[:portal_id])
  end

  def related_categories_records
    @portal.categories.where(id: params[:category][:related_category_ids])
  end

  def category_params
    params.require(:category).permit(
      :name, :description, :position, :slug, :locale, :icon, :parent_category_id, :associated_category_id
    )
  end

  def set_current_page
    @current_page = params[:page] || 1
  end
end

================
File: controllers/api/v1/accounts/contact_inboxes_controller.rb
================
class Api::V1::Accounts::ContactInboxesController < Api::V1::Accounts::BaseController
  before_action :ensure_inbox

  def filter
    contact_inbox = @inbox.contact_inboxes.where(inbox_id: permitted_params[:inbox_id], source_id: permitted_params[:source_id])
    return head :not_found if contact_inbox.empty?

    @contact = contact_inbox.first.contact
  end

  private

  def ensure_inbox
    @inbox = Current.account.inboxes.find(permitted_params[:inbox_id])
    authorize @inbox, :show?
  end

  def permitted_params
    params.permit(:inbox_id, :source_id)
  end
end

================
File: controllers/api/v1/accounts/contacts_controller.rb
================
class Api::V1::Accounts::ContactsController < Api::V1::Accounts::BaseController
  include Sift
  sort_on :email, type: :string
  sort_on :name, internal_name: :order_on_name, type: :scope, scope_params: [:direction]
  sort_on :phone_number, type: :string
  sort_on :last_activity_at, internal_name: :order_on_last_activity_at, type: :scope, scope_params: [:direction]
  sort_on :created_at, internal_name: :order_on_created_at, type: :scope, scope_params: [:direction]
  sort_on :company, internal_name: :order_on_company_name, type: :scope, scope_params: [:direction]
  sort_on :city, internal_name: :order_on_city, type: :scope, scope_params: [:direction]
  sort_on :country, internal_name: :order_on_country_name, type: :scope, scope_params: [:direction]

  RESULTS_PER_PAGE = 15

  before_action :check_authorization
  before_action :set_current_page, only: [:index, :active, :search, :filter]
  before_action :fetch_contact, only: [:show, :update, :destroy, :avatar, :contactable_inboxes, :destroy_custom_attributes]
  before_action :set_include_contact_inboxes, only: [:index, :search, :filter, :show, :update]

  def index
    @contacts_count = resolved_contacts.count
    @contacts = fetch_contacts(resolved_contacts)
  end

  def search
    render json: { error: 'Specify search string with parameter q' }, status: :unprocessable_entity if params[:q].blank? && return

    contacts = resolved_contacts.where(
      'name ILIKE :search OR email ILIKE :search OR phone_number ILIKE :search OR contacts.identifier LIKE :search
        OR contacts.additional_attributes->>\'company_name\' ILIKE :search',
      search: "%#{params[:q].strip}%"
    )
    @contacts_count = contacts.count
    @contacts = fetch_contacts(contacts)
  end

  def import
    render json: { error: I18n.t('errors.contacts.import.failed') }, status: :unprocessable_entity and return if params[:import_file].blank?

    ActiveRecord::Base.transaction do
      import = Current.account.data_imports.create!(data_type: 'contacts')
      import.import_file.attach(params[:import_file])
    end

    head :ok
  end

  def export
    column_names = params['column_names']
    filter_params = { :payload => params.permit!['payload'], :label => params.permit!['label'] }
    Account::ContactsExportJob.perform_later(Current.account.id, Current.user.id, column_names, filter_params)
    head :ok, message: I18n.t('errors.contacts.export.success')
  end

  # returns online contacts
  def active
    contacts = Current.account.contacts.where(id: ::OnlineStatusTracker
                  .get_available_contact_ids(Current.account.id))
    @contacts_count = contacts.count
    @contacts = contacts.page(@current_page)
  end

  def show; end

  def filter
    result = ::Contacts::FilterService.new(Current.account, Current.user, params.permit!).perform
    contacts = result[:contacts]
    @contacts_count = result[:count]
    @contacts = fetch_contacts(contacts)
  rescue CustomExceptions::CustomFilter::InvalidAttribute,
         CustomExceptions::CustomFilter::InvalidOperator,
         CustomExceptions::CustomFilter::InvalidQueryOperator,
         CustomExceptions::CustomFilter::InvalidValue => e
    render_could_not_create_error(e.message)
  end

  def contactable_inboxes
    @all_contactable_inboxes = Contacts::ContactableInboxesService.new(contact: @contact).get
    @contactable_inboxes = @all_contactable_inboxes.select { |contactable_inbox| policy(contactable_inbox[:inbox]).show? }
  end

  # TODO : refactor this method into dedicated contacts/custom_attributes controller class and routes
  def destroy_custom_attributes
    @contact.custom_attributes = @contact.custom_attributes.excluding(params[:custom_attributes])
    @contact.save!
  end

  def create
    ActiveRecord::Base.transaction do
      @contact = Current.account.contacts.new(permitted_params.except(:avatar_url))
      @contact.save!
      @contact_inbox = build_contact_inbox
      process_avatar_from_url
    end
  end

  def update
    @contact.assign_attributes(contact_update_params)
    @contact.save!
    process_avatar_from_url
  end

  def destroy
    if ::OnlineStatusTracker.get_presence(
      @contact.account.id, 'Contact', @contact.id
    )
      return render_error({ message: I18n.t('contacts.online.delete', contact_name: @contact.name.capitalize) },
                          :unprocessable_entity)
    end

    @contact.destroy!
    head :ok
  end

  def avatar
    @contact.avatar.purge if @contact.avatar.attached?
    @contact
  end

  private

  # TODO: Move this to a finder class
  def resolved_contacts
    return @resolved_contacts if @resolved_contacts

    @resolved_contacts = Current.account.contacts.resolved_contacts

    @resolved_contacts = @resolved_contacts.tagged_with(params[:labels], any: true) if params[:labels].present?
    @resolved_contacts
  end

  def set_current_page
    @current_page = params[:page] || 1
  end

  def fetch_contacts(contacts)
    contacts_with_avatar = filtrate(contacts)
                           .includes([{ avatar_attachment: [:blob] }])
                           .page(@current_page).per(RESULTS_PER_PAGE)

    return contacts_with_avatar.includes([{ contact_inboxes: [:inbox] }]) if @include_contact_inboxes

    contacts_with_avatar
  end

  def build_contact_inbox
    return if params[:inbox_id].blank?

    inbox = Current.account.inboxes.find(params[:inbox_id])
    ContactInboxBuilder.new(
      contact: @contact,
      inbox: inbox,
      source_id: params[:source_id]
    ).perform
  end

  def permitted_params
    params.permit(:name, :identifier, :email, :phone_number, :avatar, :blocked, :avatar_url, additional_attributes: {}, custom_attributes: {})
  end

  def contact_custom_attributes
    return @contact.custom_attributes.merge(permitted_params[:custom_attributes]) if permitted_params[:custom_attributes]

    @contact.custom_attributes
  end

  def contact_update_params
    # we want the merged custom attributes not the original one
    permitted_params.except(:custom_attributes, :avatar_url).merge({ custom_attributes: contact_custom_attributes })
  end

  def set_include_contact_inboxes
    @include_contact_inboxes = if params[:include_contact_inboxes].present?
                                 params[:include_contact_inboxes] == 'true'
                               else
                                 true
                               end
  end

  def fetch_contact
    @contact = Current.account.contacts.includes(contact_inboxes: [:inbox]).find(params[:id])
  end

  def process_avatar_from_url
    ::Avatar::AvatarFromUrlJob.perform_later(@contact, params[:avatar_url]) if params[:avatar_url].present?
  end

  def render_error(error, error_status)
    render json: error, status: error_status
  end
end

================
File: controllers/api/v1/accounts/conversations_controller.rb
================
class Api::V1::Accounts::ConversationsController < Api::V1::Accounts::BaseController
  include Events::Types
  include DateRangeHelper
  include HmacConcern

  before_action :conversation, except: [:index, :meta, :search, :create, :filter]
  before_action :inbox, :contact, :contact_inbox, only: [:create]

  ATTACHMENT_RESULTS_PER_PAGE = 100

  def index
    result = conversation_finder.perform
    @conversations = result[:conversations]
    @conversations_count = result[:count]
  end

  def meta
    result = conversation_finder.perform
    @conversations_count = result[:count]
  end

  def search
    result = conversation_finder.perform
    @conversations = result[:conversations]
    @conversations_count = result[:count]
  end

  def attachments
    @attachments_count = @conversation.attachments.count
    @attachments = @conversation.attachments
                                .includes(:message)
                                .order(created_at: :desc)
                                .page(attachment_params[:page])
                                .per(ATTACHMENT_RESULTS_PER_PAGE)
  end

  def show; end

  def create
    ActiveRecord::Base.transaction do
      @conversation = ConversationBuilder.new(params: params, contact_inbox: @contact_inbox).perform
      Messages::MessageBuilder.new(Current.user, @conversation, params[:message]).perform if params[:message].present?
    end
  end

  def update
    @conversation.update!(permitted_update_params)
  end

  def filter
    result = ::Conversations::FilterService.new(params.permit!, current_user).perform
    @conversations = result[:conversations]
    @conversations_count = result[:count]
  rescue CustomExceptions::CustomFilter::InvalidAttribute,
         CustomExceptions::CustomFilter::InvalidOperator,
         CustomExceptions::CustomFilter::InvalidQueryOperator,
         CustomExceptions::CustomFilter::InvalidValue => e
    render_could_not_create_error(e.message)
  end

  def mute
    @conversation.mute!
    head :ok
  end

  def unmute
    @conversation.unmute!
    head :ok
  end

  def transcript
    render json: { error: 'email param missing' }, status: :unprocessable_entity and return if params[:email].blank?

    ConversationReplyMailer.with(account: @conversation.account).conversation_transcript(@conversation, params[:email])&.deliver_later
    head :ok
  end

  def toggle_status
    # FIXME: move this logic into a service object
    if pending_to_open_by_bot?
      @conversation.bot_handoff!
    elsif params[:status].present?
      set_conversation_status
      @status = @conversation.save!
    else
      @status = @conversation.toggle_status
    end
    assign_conversation if should_assign_conversation?
  end

  def pending_to_open_by_bot?
    return false unless Current.user.is_a?(AgentBot)

    @conversation.status == 'pending' && params[:status] == 'open'
  end

  def should_assign_conversation?
    @conversation.status == 'open' && Current.user.is_a?(User) && Current.user&.agent?
  end

  def toggle_priority
    @conversation.toggle_priority(params[:priority])
    head :ok
  end

  def toggle_typing_status
    typing_status_manager = ::Conversations::TypingStatusManager.new(@conversation, current_user, params)
    typing_status_manager.toggle_typing_status
    head :ok
  end

  def update_last_seen
    update_last_seen_on_conversation(DateTime.now.utc, assignee?)
  end

  def unread
    last_incoming_message = @conversation.messages.incoming.last
    last_seen_at = last_incoming_message.created_at - 1.second if last_incoming_message.present?
    update_last_seen_on_conversation(last_seen_at, true)
  end

  def custom_attributes
    @conversation.custom_attributes = params.permit(custom_attributes: {})[:custom_attributes]
    @conversation.save!
  end

  private

  def permitted_update_params
    # TODO: Move the other conversation attributes to this method and remove specific endpoints for each attribute
    params.permit(:priority)
  end

  def attachment_params
    params.permit(:page)
  end

  def update_last_seen_on_conversation(last_seen_at, update_assignee)
    # rubocop:disable Rails/SkipsModelValidations
    @conversation.update_column(:agent_last_seen_at, last_seen_at)
    @conversation.update_column(:assignee_last_seen_at, last_seen_at) if update_assignee.present?
    # rubocop:enable Rails/SkipsModelValidations
  end

  def set_conversation_status
    @conversation.status = params[:status]
    @conversation.snoozed_until = parse_date_time(params[:snoozed_until].to_s) if params[:snoozed_until]
  end

  def assign_conversation
    @conversation.assignee = current_user
    @conversation.save!
  end

  def conversation
    @conversation ||= Current.account.conversations.find_by!(display_id: params[:id])
    authorize @conversation.inbox, :show?
  end

  def inbox
    return if params[:inbox_id].blank?

    @inbox = Current.account.inboxes.find(params[:inbox_id])
    authorize @inbox, :show?
  end

  def contact
    return if params[:contact_id].blank?

    @contact = Current.account.contacts.find(params[:contact_id])
  end

  def contact_inbox
    @contact_inbox = build_contact_inbox

    # fallback for the old case where we do look up only using source id
    # In future we need to change this and make sure we do look up on combination of inbox_id and source_id
    # and deprecate the support of passing only source_id as the param
    @contact_inbox ||= ::ContactInbox.find_by!(source_id: params[:source_id])
    authorize @contact_inbox.inbox, :show?
  rescue ActiveRecord::RecordNotUnique
    render json: { error: 'source_id should be unique' }, status: :unprocessable_entity
  end

  def build_contact_inbox
    return if @inbox.blank? || @contact.blank?

    ContactInboxBuilder.new(
      contact: @contact,
      inbox: @inbox,
      source_id: params[:source_id],
      hmac_verified: hmac_verified?
    ).perform
  end

  def conversation_finder
    @conversation_finder ||= ConversationFinder.new(Current.user, params)
  end

  def assignee?
    @conversation.assignee_id? && Current.user == @conversation.assignee
  end
end

Api::V1::Accounts::ConversationsController.prepend_mod_with('Api::V1::Accounts::ConversationsController')

================
File: controllers/api/v1/accounts/csat_survey_responses_controller.rb
================
class Api::V1::Accounts::CsatSurveyResponsesController < Api::V1::Accounts::BaseController
  include Sift
  include DateRangeHelper

  RESULTS_PER_PAGE = 25

  before_action :check_authorization
  before_action :set_csat_survey_responses, only: [:index, :metrics, :download]
  before_action :set_current_page, only: [:index]
  before_action :set_current_page_surveys, only: [:index]
  before_action :set_total_sent_messages_count, only: [:metrics]

  sort_on :created_at, type: :datetime

  def index; end

  def metrics
    @total_count = @csat_survey_responses.count
    @ratings_count = @csat_survey_responses.group(:rating).count
  end

  def download
    response.headers['Content-Type'] = 'text/csv'
    response.headers['Content-Disposition'] = 'attachment; filename=csat_report.csv'
    render layout: false, template: 'api/v1/accounts/csat_survey_responses/download', formats: [:csv]
  end

  private

  def set_total_sent_messages_count
    @csat_messages = Current.account.messages.input_csat
    @csat_messages = @csat_messages.where(created_at: range) if range.present?
    @total_sent_messages_count = @csat_messages.count
  end

  def set_csat_survey_responses
    base_query = Current.account.csat_survey_responses.includes([:conversation, :assigned_agent, :contact])
    @csat_survey_responses = filtrate(base_query).filter_by_created_at(range)
                                                 .filter_by_assigned_agent_id(params[:user_ids])
                                                 .filter_by_inbox_id(params[:inbox_id])
                                                 .filter_by_team_id(params[:team_id])
                                                 .filter_by_rating(params[:rating])
  end

  def set_current_page_surveys
    @csat_survey_responses = @csat_survey_responses.page(@current_page).per(RESULTS_PER_PAGE)
  end

  def set_current_page
    @current_page = params[:page] || 1
  end
end

================
File: controllers/api/v1/accounts/custom_attribute_definitions_controller.rb
================
class Api::V1::Accounts::CustomAttributeDefinitionsController < Api::V1::Accounts::BaseController
  before_action :fetch_custom_attributes_definitions, except: [:create]
  before_action :fetch_custom_attribute_definition, only: [:show, :update, :destroy]
  DEFAULT_ATTRIBUTE_MODEL = 'conversation_attribute'.freeze

  def index; end

  def show; end

  def create
    @custom_attribute_definition = Current.account.custom_attribute_definitions.create!(
      permitted_payload
    )
  end

  def update
    @custom_attribute_definition.update!(permitted_payload)
  end

  def destroy
    @custom_attribute_definition.destroy!
    head :no_content
  end

  private

  def fetch_custom_attributes_definitions
    @custom_attribute_definitions = Current.account.custom_attribute_definitions.with_attribute_model(permitted_params[:attribute_model])
  end

  def fetch_custom_attribute_definition
    @custom_attribute_definition = Current.account.custom_attribute_definitions.find(permitted_params[:id])
  end

  def permitted_payload
    params.require(:custom_attribute_definition).permit(
      :attribute_display_name,
      :attribute_description,
      :attribute_display_type,
      :attribute_key,
      :attribute_model,
      :regex_pattern,
      :regex_cue,
      attribute_values: []
    )
  end

  def permitted_params
    params.permit(:id, :filter_type, :attribute_model)
  end
end

================
File: controllers/api/v1/accounts/custom_filters_controller.rb
================
class Api::V1::Accounts::CustomFiltersController < Api::V1::Accounts::BaseController
  before_action :check_authorization
  before_action :fetch_custom_filters, except: [:create]
  before_action :fetch_custom_filter, only: [:show, :update, :destroy]
  DEFAULT_FILTER_TYPE = 'conversation'.freeze

  def index; end

  def show; end

  def create
    @custom_filter = current_user.custom_filters.create!(
      permitted_payload.merge(account_id: Current.account.id)
    )
    render json: { error: @custom_filter.errors.messages }, status: :unprocessable_entity and return unless @custom_filter.valid?
  end

  def update
    @custom_filter.update!(permitted_payload)
  end

  def destroy
    @custom_filter.destroy!
    head :no_content
  end

  private

  def fetch_custom_filters
    @custom_filters = current_user.custom_filters.where(
      account_id: Current.account.id,
      filter_type: permitted_params[:filter_type] || DEFAULT_FILTER_TYPE
    )
  end

  def fetch_custom_filter
    @custom_filter = @custom_filters.find(permitted_params[:id])
  end

  def permitted_payload
    params.require(:custom_filter).permit(
      :name,
      :filter_type,
      query: {}
    )
  end

  def permitted_params
    params.permit(:id, :filter_type)
  end
end

================
File: controllers/api/v1/accounts/dashboard_apps_controller.rb
================
class Api::V1::Accounts::DashboardAppsController < Api::V1::Accounts::BaseController
  before_action :fetch_dashboard_apps, except: [:create]
  before_action :fetch_dashboard_app, only: [:show, :update, :destroy]

  def index; end

  def show; end

  def create
    @dashboard_app = Current.account.dashboard_apps.create!(
      permitted_payload.merge(user_id: Current.user.id)
    )
  end

  def update
    @dashboard_app.update!(permitted_payload)
  end

  def destroy
    @dashboard_app.destroy!
    head :no_content
  end

  private

  def fetch_dashboard_apps
    @dashboard_apps = Current.account.dashboard_apps
  end

  def fetch_dashboard_app
    @dashboard_app = @dashboard_apps.find(permitted_params[:id])
  end

  def permitted_payload
    params.require(:dashboard_app).permit(
      :title,
      content: [:url, :type]
    )
  end

  def permitted_params
    params.permit(:id)
  end
end

================
File: controllers/api/v1/accounts/inbox_members_controller.rb
================
class Api::V1::Accounts::InboxMembersController < Api::V1::Accounts::BaseController
  before_action :fetch_inbox
  before_action :current_agents_ids, only: [:create, :update]

  def show
    authorize @inbox, :show?
    fetch_updated_agents
  end

  def create
    authorize @inbox, :create?
    ActiveRecord::Base.transaction do
      @inbox.add_members(agents_to_be_added_ids)
    end
    fetch_updated_agents
  end

  def update
    authorize @inbox, :update?
    update_agents_list
    fetch_updated_agents
  end

  def destroy
    authorize @inbox, :destroy?
    ActiveRecord::Base.transaction do
      @inbox.remove_members(params[:user_ids])
    end
    head :ok
  end

  private

  def fetch_updated_agents
    @agents = Current.account.users.where(id: @inbox.members.select(:user_id))
  end

  def update_agents_list
    # get all the user_ids which the inbox currently has as members.
    # get the list of  user_ids from params
    # the missing ones are the agents which are to be deleted from the inbox
    # the new ones are the agents which are to be added to the inbox
    ActiveRecord::Base.transaction do
      @inbox.add_members(agents_to_be_added_ids)
      @inbox.remove_members(agents_to_be_removed_ids)
    end
  end

  def agents_to_be_added_ids
    params[:user_ids] - @current_agents_ids
  end

  def agents_to_be_removed_ids
    @current_agents_ids - params[:user_ids]
  end

  def current_agents_ids
    @current_agents_ids = @inbox.members.pluck(:id)
  end

  def fetch_inbox
    @inbox = Current.account.inboxes.find(params[:inbox_id])
  end
end

================
File: controllers/api/v1/accounts/inboxes_controller.rb
================
class Api::V1::Accounts::InboxesController < Api::V1::Accounts::BaseController
  include Api::V1::InboxesHelper
  before_action :fetch_inbox, except: [:index, :create]
  before_action :fetch_agent_bot, only: [:set_agent_bot]
  before_action :validate_limit, only: [:create]
  # we are already handling the authorization in fetch inbox
  before_action :check_authorization, except: [:show]

  def index
    @inboxes = policy_scope(Current.account.inboxes.order_by_name.includes(:channel, { avatar_attachment: [:blob] }))
  end

  def show; end

  # Deprecated: This API will be removed in 2.7.0
  def assignable_agents
    @assignable_agents = @inbox.assignable_agents
  end

  def campaigns
    @campaigns = @inbox.campaigns
  end

  def avatar
    @inbox.avatar.attachment.destroy! if @inbox.avatar.attached?
    head :ok
  end

  def create
    ActiveRecord::Base.transaction do
      channel = create_channel
      @inbox = Current.account.inboxes.build(
        {
          name: inbox_name(channel),
          channel: channel
        }.merge(
          permitted_params.except(:channel)
        )
      )
      @inbox.save!
    end
  end

  def update
    @inbox.update!(permitted_params.except(:channel))
    update_inbox_working_hours
    update_channel if channel_update_required?
  end

  def agent_bot
    @agent_bot = @inbox.agent_bot
  end

  def set_agent_bot
    if @agent_bot
      agent_bot_inbox = @inbox.agent_bot_inbox || AgentBotInbox.new(inbox: @inbox)
      agent_bot_inbox.agent_bot = @agent_bot
      agent_bot_inbox.save!
    elsif @inbox.agent_bot_inbox.present?
      @inbox.agent_bot_inbox.destroy!
    end
    head :ok
  end

  def destroy
    ::DeleteObjectJob.perform_later(@inbox, Current.user, request.ip) if @inbox.present?
    render status: :ok, json: { message: I18n.t('messages.inbox_deletetion_response') }
  end

  private

  def fetch_inbox
    @inbox = Current.account.inboxes.find(params[:id])
    authorize @inbox, :show?
  end

  def fetch_agent_bot
    @agent_bot = AgentBot.find(params[:agent_bot]) if params[:agent_bot]
  end

  def create_channel
    return unless %w[web_widget api email line telegram whatsapp sms].include?(permitted_params[:channel][:type])

    account_channels_method.create!(permitted_params(channel_type_from_params::EDITABLE_ATTRS)[:channel].except(:type))
  end

  def update_inbox_working_hours
    @inbox.update_working_hours(params.permit(working_hours: Inbox::OFFISABLE_ATTRS)[:working_hours]) if params[:working_hours]
  end

  def update_channel
    channel_attributes = get_channel_attributes(@inbox.channel_type)
    return if permitted_params(channel_attributes)[:channel].blank?

    validate_and_update_email_channel(channel_attributes) if @inbox.inbox_type == 'Email'

    reauthorize_and_update_channel(channel_attributes)
    update_channel_feature_flags
  end

  def channel_update_required?
    permitted_params(get_channel_attributes(@inbox.channel_type))[:channel].present?
  end

  def validate_and_update_email_channel(channel_attributes)
    validate_email_channel(channel_attributes)
  rescue StandardError => e
    render json: { message: e }, status: :unprocessable_entity and return
  end

  def reauthorize_and_update_channel(channel_attributes)
    @inbox.channel.reauthorized! if @inbox.channel.respond_to?(:reauthorized!)
    @inbox.channel.update!(permitted_params(channel_attributes)[:channel])
  end

  def update_channel_feature_flags
    return unless @inbox.web_widget?
    return unless permitted_params(Channel::WebWidget::EDITABLE_ATTRS)[:channel].key? :selected_feature_flags

    @inbox.channel.selected_feature_flags = permitted_params(Channel::WebWidget::EDITABLE_ATTRS)[:channel][:selected_feature_flags]
    @inbox.channel.save!
  end

  def inbox_attributes
    [:name, :avatar, :greeting_enabled, :greeting_message, :enable_email_collect, :csat_survey_enabled,
     :enable_auto_assignment, :working_hours_enabled, :out_of_office_message, :timezone, :allow_messages_after_resolved,
     :lock_to_single_conversation, :portal_id, :sender_name_type, :business_name]
  end

  def permitted_params(channel_attributes = [])
    # We will remove this line after fixing https://linear.app/chatwoot/issue/CW-1567/null-value-passed-as-null-string-to-backend
    params.each { |k, v| params[k] = params[k] == 'null' ? nil : v }

    params.permit(
      *inbox_attributes,
      channel: [:type, *channel_attributes]
    )
  end

  def channel_type_from_params
    {
      'web_widget' => Channel::WebWidget,
      'api' => Channel::Api,
      'email' => Channel::Email,
      'line' => Channel::Line,
      'telegram' => Channel::Telegram,
      'whatsapp' => Channel::Whatsapp,
      'sms' => Channel::Sms
    }[permitted_params[:channel][:type]]
  end

  def get_channel_attributes(channel_type)
    if channel_type.constantize.const_defined?(:EDITABLE_ATTRS)
      channel_type.constantize::EDITABLE_ATTRS.presence
    else
      []
    end
  end
end

Api::V1::Accounts::InboxesController.prepend_mod_with('Api::V1::Accounts::InboxesController')

================
File: controllers/api/v1/accounts/labels_controller.rb
================
class Api::V1::Accounts::LabelsController < Api::V1::Accounts::BaseController
  before_action :current_account
  before_action :fetch_label, except: [:index, :create]
  before_action :check_authorization

  def index
    @labels = policy_scope(Current.account.labels)
  end

  def show; end

  def create
    @label = Current.account.labels.create!(permitted_params)
  end

  def update
    @label.update!(permitted_params)
  end

  def destroy
    @label.destroy!
    head :ok
  end

  private

  def fetch_label
    @label = Current.account.labels.find(params[:id])
  end

  def permitted_params
    params.require(:label).permit(:title, :description, :color, :show_on_sidebar)
  end
end

================
File: controllers/api/v1/accounts/macros_controller.rb
================
class Api::V1::Accounts::MacrosController < Api::V1::Accounts::BaseController
  before_action :fetch_macro, only: [:show, :update, :destroy, :execute]
  before_action :check_authorization, only: [:show, :update, :destroy, :execute]

  def index
    @macros = Macro.with_visibility(current_user, params)
  end

  def show
    head :not_found if @macro.nil?
  end

  def create
    @macro = Current.account.macros.new(macros_with_user.merge(created_by_id: current_user.id))
    @macro.set_visibility(current_user, permitted_params)
    @macro.actions = params[:actions]

    render json: { error: @macro.errors.messages }, status: :unprocessable_entity and return unless @macro.valid?

    @macro.save!
    process_attachments
    @macro
  end

  def update
    ActiveRecord::Base.transaction do
      @macro.update!(macros_with_user)
      @macro.set_visibility(current_user, permitted_params)
      process_attachments
      @macro.save!
    rescue StandardError => e
      Rails.logger.error e
      render json: { error: @macro.errors.messages }.to_json, status: :unprocessable_entity
    end
  end

  def destroy
    @macro.destroy!
    head :ok
  end

  def execute
    ::MacrosExecutionJob.perform_later(@macro, conversation_ids: params[:conversation_ids], user: Current.user)

    head :ok
  end

  private

  def process_attachments
    actions = @macro.actions.filter_map { |k, _v| k if k['action_name'] == 'send_attachment' }
    return if actions.blank?

    actions.each do |action|
      blob_id = action['action_params']
      blob = ActiveStorage::Blob.find_by(id: blob_id)
      @macro.files.attach(blob)
    end
  end

  def permitted_params
    params.permit(
      :name, :account_id, :visibility,
      actions: [:action_name, { action_params: [] }]
    )
  end

  def macros_with_user
    permitted_params.merge(updated_by_id: current_user.id)
  end

  def fetch_macro
    @macro = Current.account.macros.find_by(id: params[:id])
  end

  def check_authorization
    authorize(@macro) if @macro.present?
  end
end

================
File: controllers/api/v1/accounts/notification_settings_controller.rb
================
class Api::V1::Accounts::NotificationSettingsController < Api::V1::Accounts::BaseController
  before_action :set_user, :load_notification_setting

  def show; end

  def update
    update_flags
    @notification_setting.save!
    render action: 'show'
  end

  private

  def set_user
    @user = current_user
  end

  def load_notification_setting
    @notification_setting = @user.notification_settings.find_by(account_id: Current.account.id)
  end

  def notification_setting_params
    params.require(:notification_settings).permit(selected_email_flags: [], selected_push_flags: [])
  end

  def update_flags
    @notification_setting.selected_email_flags = notification_setting_params[:selected_email_flags]
    @notification_setting.selected_push_flags = notification_setting_params[:selected_push_flags]
  end
end

================
File: controllers/api/v1/accounts/notifications_controller.rb
================
class Api::V1::Accounts::NotificationsController < Api::V1::Accounts::BaseController
  RESULTS_PER_PAGE = 15
  include DateRangeHelper

  before_action :fetch_notification, only: [:update, :destroy, :snooze, :unread]
  before_action :set_primary_actor, only: [:read_all]
  before_action :set_current_page, only: [:index]

  def index
    @notifications = notification_finder.notifications
    @unread_count = notification_finder.unread_count
    @count = notification_finder.count
  end

  def read_all
    # rubocop:disable Rails/SkipsModelValidations
    if @primary_actor
      current_user.notifications.where(account_id: current_account.id, primary_actor: @primary_actor, read_at: nil)
                  .update_all(read_at: DateTime.now.utc)
    else
      current_user.notifications.where(account_id: current_account.id, read_at: nil).update_all(read_at: DateTime.now.utc)
    end
    # rubocop:enable Rails/SkipsModelValidations
    head :ok
  end

  def update
    @notification.update(read_at: DateTime.now.utc)
    render json: @notification
  end

  def unread
    @notification.update(read_at: nil)
    render json: @notification
  end

  def destroy
    @notification.destroy
    head :ok
  end

  def destroy_all
    if params[:type] == 'read'
      ::Notification::DeleteNotificationJob.perform_later(Current.user, type: :read)
    else
      ::Notification::DeleteNotificationJob.perform_later(Current.user, type: :all)
    end
    head :ok
  end

  def unread_count
    @unread_count = notification_finder.unread_count
    render json: @unread_count
  end

  def snooze
    updated_meta = (@notification.meta || {}).merge('last_snoozed_at' => nil)
    @notification.update(snoozed_until: parse_date_time(params[:snoozed_until].to_s), meta: updated_meta) if params[:snoozed_until]
    render json: @notification
  end

  private

  def set_primary_actor
    return unless params[:primary_actor_type]
    return unless Notification::PRIMARY_ACTORS.include?(params[:primary_actor_type])

    @primary_actor = params[:primary_actor_type].safe_constantize.find_by(id: params[:primary_actor_id])
  end

  def fetch_notification
    @notification = current_user.notifications.find(params[:id])
  end

  def set_current_page
    @current_page = params[:page] || 1
  end

  def notification_finder
    @notification_finder ||= NotificationFinder.new(Current.user, Current.account, params)
  end
end

================
File: controllers/api/v1/accounts/portals_controller.rb
================
class Api::V1::Accounts::PortalsController < Api::V1::Accounts::BaseController
  include ::FileTypeHelper

  before_action :fetch_portal, except: [:index, :create]
  before_action :check_authorization
  before_action :set_current_page, only: [:index]

  def index
    @portals = Current.account.portals
  end

  def add_members
    agents = Current.account.agents.where(id: portal_member_params[:member_ids])
    @portal.members << agents
  end

  def show
    @all_articles = @portal.articles
    @articles = @all_articles.search(locale: params[:locale])
  end

  def create
    @portal = Current.account.portals.build(portal_params.merge(live_chat_widget_params))
    @portal.custom_domain = parsed_custom_domain
    @portal.save!
    process_attached_logo
  end

  def update
    ActiveRecord::Base.transaction do
      @portal.update!(portal_params.merge(live_chat_widget_params)) if params[:portal].present?
      # @portal.custom_domain = parsed_custom_domain
      process_attached_logo if params[:blob_id].present?
    rescue StandardError => e
      Rails.logger.error e
      render json: { error: @portal.errors.messages }.to_json, status: :unprocessable_entity
    end
  end

  def destroy
    @portal.destroy!
    head :ok
  end

  def archive
    @portal.update(archive: true)
    head :ok
  end

  def logo
    @portal.logo.purge if @portal.logo.attached?
    head :ok
  end

  def process_attached_logo
    blob_id = params[:blob_id]
    blob = ActiveStorage::Blob.find_by(id: blob_id)
    @portal.logo.attach(blob)
  end

  private

  def fetch_portal
    @portal = Current.account.portals.find_by(slug: permitted_params[:id])
  end

  def permitted_params
    params.permit(:id)
  end

  def portal_params
    params.require(:portal).permit(
      :account_id, :color, :custom_domain, :header_text, :homepage_link,
      :name, :page_title, :slug, :archived, { config: [:default_locale, { allowed_locales: [] }] }
    )
  end

  def live_chat_widget_params
    permitted_params = params.permit(:inbox_id)
    return {} if permitted_params[:inbox_id].blank?

    inbox = Inbox.find(permitted_params[:inbox_id])
    return {} unless inbox.web_widget?

    { channel_web_widget_id: inbox.channel.id }
  end

  def portal_member_params
    params.require(:portal).permit(:account_id, member_ids: [])
  end

  def set_current_page
    @current_page = params[:page] || 1
  end

  def parsed_custom_domain
    domain = URI.parse(@portal.custom_domain)
    domain.is_a?(URI::HTTP) ? domain.host : @portal.custom_domain
  end
end

================
File: controllers/api/v1/accounts/search_controller.rb
================
class Api::V1::Accounts::SearchController < Api::V1::Accounts::BaseController
  def index
    @result = search('all')
  end

  def conversations
    @result = search('Conversation')
  end

  def contacts
    @result = search('Contact')
  end

  def messages
    @result = search('Message')
  end

  private

  def search(search_type)
    SearchService.new(
      current_user: Current.user,
      current_account: Current.account,
      search_type: search_type,
      params: params
    ).perform
  end
end

================
File: controllers/api/v1/accounts/team_members_controller.rb
================
class Api::V1::Accounts::TeamMembersController < Api::V1::Accounts::BaseController
  before_action :fetch_team
  before_action :check_authorization
  before_action :validate_member_id_params, only: [:create, :update, :destroy]

  def index
    @team_members = @team.team_members.map(&:user)
  end

  def create
    ActiveRecord::Base.transaction do
      @team_members = @team.add_members(members_to_be_added_ids)
    end
  end

  def update
    ActiveRecord::Base.transaction do
      @team.add_members(members_to_be_added_ids)
      @team.remove_members(members_to_be_removed_ids)
    end
    @team_members = @team.members
    render action: 'create'
  end

  def destroy
    ActiveRecord::Base.transaction do
      @team.remove_members(params[:user_ids])
    end
    head :ok
  end

  private

  def members_to_be_added_ids
    params[:user_ids] - current_members_ids
  end

  def members_to_be_removed_ids
    current_members_ids - params[:user_ids]
  end

  def current_members_ids
    @current_members_ids ||= @team.members.pluck(:id)
  end

  def fetch_team
    @team = Current.account.teams.find(params[:team_id])
  end

  def validate_member_id_params
    invalid_ids = params[:user_ids].map(&:to_i) - @team.account.user_ids

    render json: { error: 'Invalid User IDs' }, status: :unauthorized and return if invalid_ids.present?
  end
end

================
File: controllers/api/v1/accounts/teams_controller.rb
================
class Api::V1::Accounts::TeamsController < Api::V1::Accounts::BaseController
  before_action :fetch_team, only: [:show, :update, :destroy]
  before_action :check_authorization

  def index
    @teams = Current.account.teams
  end

  def show; end

  def create
    @team = Current.account.teams.new(team_params)
    @team.save!
  end

  def update
    @team.update!(team_params)
  end

  def destroy
    @team.destroy!
    head :ok
  end

  private

  def fetch_team
    @team = Current.account.teams.find(params[:id])
  end

  def team_params
    params.require(:team).permit(:name, :description, :allow_auto_assign)
  end
end

================
File: controllers/api/v1/accounts/upload_controller.rb
================
class Api::V1::Accounts::UploadController < Api::V1::Accounts::BaseController
  def create
    result = if params[:attachment].present?
               create_from_file
             elsif params[:external_url].present?
               create_from_url
             else
               render_error('No file or URL provided', :unprocessable_entity)
             end

    render_success(result) if result.is_a?(ActiveStorage::Blob)
  end

  private

  def create_from_file
    attachment = params[:attachment]
    create_and_save_blob(attachment.tempfile, attachment.original_filename, attachment.content_type)
  end

  def create_from_url
    uri = parse_uri(params[:external_url])
    return if performed?

    fetch_and_process_file_from_uri(uri)
  end

  def parse_uri(url)
    uri = URI.parse(url)
    validate_uri(uri)
    uri
  rescue URI::InvalidURIError, SocketError
    render_error('Invalid URL provided', :unprocessable_entity)
    nil
  end

  def validate_uri(uri)
    raise URI::InvalidURIError unless uri.is_a?(URI::HTTP) || uri.is_a?(URI::HTTPS)
  end

  def fetch_and_process_file_from_uri(uri)
    uri.open do |file|
      create_and_save_blob(file, File.basename(uri.path), file.content_type)
    end
  rescue OpenURI::HTTPError => e
    render_error("Failed to fetch file from URL: #{e.message}", :unprocessable_entity)
  rescue SocketError
    render_error('Invalid URL provided', :unprocessable_entity)
  rescue StandardError
    render_error('An unexpected error occurred', :internal_server_error)
  end

  def create_and_save_blob(io, filename, content_type)
    ActiveStorage::Blob.create_and_upload!(
      io: io,
      filename: filename,
      content_type: content_type
    )
  end

  def render_success(file_blob)
    render json: { file_url: url_for(file_blob), blob_key: file_blob.key, blob_id: file_blob.id }
  end

  def render_error(message, status)
    render json: { error: message }, status: status
  end
end

================
File: controllers/api/v1/accounts/webhooks_controller.rb
================
class Api::V1::Accounts::WebhooksController < Api::V1::Accounts::BaseController
  before_action :check_authorization
  before_action :fetch_webhook, only: [:update, :destroy]

  def index
    @webhooks = Current.account.webhooks
  end

  def create
    @webhook = Current.account.webhooks.new(webhook_params)
    @webhook.save!
  end

  def update
    @webhook.update!(webhook_params)
  end

  def destroy
    @webhook.destroy!
    head :ok
  end

  private

  def webhook_params
    params.require(:webhook).permit(:inbox_id, :url, subscriptions: [])
  end

  def fetch_webhook
    @webhook = Current.account.webhooks.find(params[:id])
  end
end

================
File: controllers/api/v1/accounts/working_hours_controller.rb
================
class Api::V1::Accounts::WorkingHoursController < Api::V1::Accounts::BaseController
  before_action :check_authorization
  before_action :fetch_webhook, only: [:update]

  def update
    @working_hour.update!(working_hour_params)
  end

  private

  def working_hour_params
    params.require(:working_hour).permit(:inbox_id, :open_hour, :open_minutes, :close_hour, :close_minutes, :closed_all_day)
  end

  def fetch_working_hour
    @working_hour = Current.account.working_hours.find(params[:id])
  end
end

================
File: controllers/api/v1/integrations/webhooks_controller.rb
================
class Api::V1::Integrations::WebhooksController < ApplicationController
  def create
    builder = Integrations::Slack::IncomingMessageBuilder.new(permitted_params)
    response = builder.perform
    render json: response
  end

  private

  # TODO: This is a temporary solution to permit all params for slack unfurling job.
  # We should only permit the params that we use. Handle all the params based on events and send it to the respective services.
  def permitted_params
    params.permit!
  end
end

================
File: controllers/api/v1/widget/integrations/dyte_controller.rb
================
class Api::V1::Widget::Integrations::DyteController < Api::V1::Widget::BaseController
  before_action :set_message

  def add_participant_to_meeting
    if @message.content_type != 'integrations'
      return render json: {
        error: I18n.t('errors.dyte.invalid_message_type')
      }, status: :unprocessable_entity
    end

    response = dyte_processor_service.add_participant_to_meeting(
      @message.content_attributes['data']['meeting_id'],
      @conversation.contact
    )
    render_response(response)
  end

  private

  def render_response(response)
    render json: response, status: response[:error].blank? ? :ok : :unprocessable_entity
  end

  def dyte_processor_service
    Integrations::Dyte::ProcessorService.new(account: @web_widget.inbox.account, conversation: @conversation)
  end

  def set_message
    @message = @web_widget.inbox.messages.find(permitted_params[:message_id])
    @conversation = @message.conversation
  end

  def permitted_params
    params.permit(:website_token, :message_id)
  end
end

================
File: controllers/api/v1/widget/base_controller.rb
================
class Api::V1::Widget::BaseController < ApplicationController
  include SwitchLocale
  include WebsiteTokenHelper

  before_action :set_web_widget
  before_action :set_contact

  private

  def conversations
    if @contact_inbox.hmac_verified?
      verified_contact_inbox_ids = @contact.contact_inboxes.where(inbox_id: auth_token_params[:inbox_id], hmac_verified: true).map(&:id)
      @conversations = @contact.conversations.where(contact_inbox_id: verified_contact_inbox_ids)
    else
      @conversations = @contact_inbox.conversations.where(inbox_id: auth_token_params[:inbox_id])
    end
  end

  def conversation
    @conversation ||= conversations.last
  end

  def create_conversation
    ::Conversation.create!(conversation_params)
  end

  def inbox
    @inbox ||= ::Inbox.find_by(id: auth_token_params[:inbox_id])
  end

  def conversation_params
    # FIXME: typo referrer in additional attributes, will probably require a migration.
    {
      account_id: inbox.account_id,
      inbox_id: inbox.id,
      contact_id: @contact.id,
      contact_inbox_id: @contact_inbox.id,
      additional_attributes: {
        browser_language: browser.accept_language&.first&.code,
        browser: browser_params,
        initiated_at: timestamp_params,
        referer: permitted_params[:message][:referer_url]
      },
      custom_attributes: permitted_params[:custom_attributes].presence || {}
    }
  end

  def contact_email
    permitted_params.dig(:contact, :email)&.downcase
  end

  def contact_name
    return if @contact.email.present? || @contact.phone_number.present? || @contact.identifier.present?

    permitted_params.dig(:contact, :name) || (contact_email.split('@')[0] if contact_email.present?)
  end

  def contact_phone_number
    permitted_params.dig(:contact, :phone_number)
  end

  def browser_params
    {
      browser_name: browser.name,
      browser_version: browser.full_version,
      device_name: browser.device.name,
      platform_name: browser.platform.name,
      platform_version: browser.platform.version
    }
  end

  def timestamp_params
    { timestamp: permitted_params[:message][:timestamp] }
  end

  def message_params
    {
      account_id: conversation.account_id,
      sender: @contact,
      content: permitted_params[:message][:content],
      inbox_id: conversation.inbox_id,
      content_attributes: {
        in_reply_to: permitted_params[:message][:reply_to]
      },
      echo_id: permitted_params[:message][:echo_id],
      message_type: :incoming
    }
  end
end

================
File: controllers/api/v1/widget/campaigns_controller.rb
================
class Api::V1::Widget::CampaignsController < Api::V1::Widget::BaseController
  skip_before_action :set_contact

  def index
    @campaigns = @web_widget.inbox.campaigns.where(enabled: true)
  end
end

================
File: controllers/api/v1/widget/configs_controller.rb
================
class Api::V1::Widget::ConfigsController < Api::V1::Widget::BaseController
  before_action :set_global_config

  def create
    build_contact
    set_token
  end

  private

  def set_global_config
    @global_config = GlobalConfig.get('LOGO_THUMBNAIL', 'BRAND_NAME', 'WIDGET_BRAND_URL')
  end

  def set_contact
    @contact_inbox = @web_widget.inbox.contact_inboxes.find_by(
      source_id: auth_token_params[:source_id]
    )
    @contact = @contact_inbox&.contact
  end

  def build_contact
    return if @contact.present?

    @contact_inbox = @web_widget.create_contact_inbox(additional_attributes)
    @contact = @contact_inbox.contact
  end

  def set_token
    payload = { source_id: @contact_inbox.source_id, inbox_id: @web_widget.inbox.id }
    @token = ::Widget::TokenService.new(payload: payload).generate_token
  end

  def additional_attributes
    if @web_widget.inbox.account.feature_enabled?('ip_lookup')
      { created_at_ip: request.remote_ip }
    else
      {}
    end
  end
end

================
File: controllers/api/v1/widget/contacts_controller.rb
================
class Api::V1::Widget::ContactsController < Api::V1::Widget::BaseController
  include WidgetHelper

  before_action :validate_hmac, only: [:set_user]

  def show; end

  def update
    identify_contact(@contact)
  end

  def set_user
    contact = nil

    if a_different_contact?
      @contact_inbox, @widget_auth_token = build_contact_inbox_with_token(@web_widget)
      contact = @contact_inbox.contact
    else
      contact = @contact
    end

    @contact_inbox.update(hmac_verified: true) if should_verify_hmac? && valid_hmac?

    identify_contact(contact)
  end

  # TODO : clean up this with proper routes delete contacts/custom_attributes
  def destroy_custom_attributes
    @contact.custom_attributes = @contact.custom_attributes.excluding(params[:custom_attributes])
    @contact.save!
    render json: @contact
  end

  private

  def identify_contact(contact)
    contact_identify_action = ContactIdentifyAction.new(
      contact: contact,
      params: permitted_params.to_h.deep_symbolize_keys,
      discard_invalid_attrs: true
    )
    @contact = contact_identify_action.perform
  end

  def a_different_contact?
    @contact.identifier.present? && @contact.identifier != permitted_params[:identifier]
  end

  def validate_hmac
    return unless should_verify_hmac?

    render json: { error: 'HMAC failed: Invalid Identifier Hash Provided' }, status: :unauthorized unless valid_hmac?
  end

  def should_verify_hmac?
    return false if params[:identifier_hash].blank? && !@web_widget.hmac_mandatory

    # Taking an extra caution that the hmac is triggered whenever identifier is present
    return false if params[:custom_attributes].present? && params[:identifier].blank?

    true
  end

  def valid_hmac?
    params[:identifier_hash] == OpenSSL::HMAC.hexdigest(
      'sha256',
      @web_widget.hmac_token,
      params[:identifier].to_s
    )
  end

  def permitted_params
    params.permit(:website_token, :identifier, :identifier_hash, :email, :name, :avatar_url, :phone_number, custom_attributes: {},
                                                                                                            additional_attributes: {})
  end
end

================
File: controllers/api/v1/widget/conversations_controller.rb
================
class Api::V1::Widget::ConversationsController < Api::V1::Widget::BaseController
  include Events::Types
  before_action :render_not_found_if_empty, only: [:toggle_typing, :toggle_status, :set_custom_attributes, :destroy_custom_attributes]

  def index
    @conversation = conversation
  end

  def create
    ActiveRecord::Base.transaction do
      process_update_contact
      @conversation = create_conversation
      conversation.messages.create!(message_params)
      # TODO: Temporary fix for message type cast issue, since message_type is returning as string instead of integer
      conversation.reload
    end
  end

  def process_update_contact
    @contact = ContactIdentifyAction.new(
      contact: @contact,
      params: { email: contact_email, phone_number: contact_phone_number, name: contact_name },
      retain_original_contact_name: true,
      discard_invalid_attrs: true
    ).perform
  end

  def update_last_seen
    head :ok && return if conversation.nil?

    conversation.contact_last_seen_at = DateTime.now.utc
    conversation.save!
    ::Conversations::UpdateMessageStatusJob.perform_later(conversation.id, conversation.contact_last_seen_at)
    head :ok
  end

  def transcript
    if conversation.present? && conversation.contact.present? && conversation.contact.email.present?
      ConversationReplyMailer.with(account: conversation.account).conversation_transcript(
        conversation,
        conversation.contact.email
      )&.deliver_later
    end
    head :ok
  end

  def toggle_typing
    case permitted_params[:typing_status]
    when 'on'
      trigger_typing_event(CONVERSATION_TYPING_ON)
    when 'off'
      trigger_typing_event(CONVERSATION_TYPING_OFF)
    end

    head :ok
  end

  def toggle_status
    return head :forbidden unless @web_widget.end_conversation?

    unless conversation.resolved?
      conversation.status = :resolved
      conversation.save!
    end
    head :ok
  end

  def set_custom_attributes
    conversation.update!(custom_attributes: permitted_params[:custom_attributes])
  end

  def destroy_custom_attributes
    conversation.custom_attributes = conversation.custom_attributes.excluding(params[:custom_attribute])
    conversation.save!
    render json: conversation
  end

  private

  def trigger_typing_event(event)
    Rails.configuration.dispatcher.dispatch(event, Time.zone.now, conversation: conversation, user: @contact)
  end

  def render_not_found_if_empty
    return head :not_found if conversation.nil?
  end

  def permitted_params
    params.permit(:id, :typing_status, :website_token, :email, contact: [:name, :email, :phone_number],
                                                               message: [:content, :referer_url, :timestamp, :echo_id],
                                                               custom_attributes: {})
  end
end

================
File: controllers/api/v1/widget/direct_uploads_controller.rb
================
class Api::V1::Widget::DirectUploadsController < ActiveStorage::DirectUploadsController
  include WebsiteTokenHelper
  before_action :set_web_widget
  before_action :set_contact

  def create
    return if @contact.nil? || @current_account.nil?

    super
  end
end

================
File: controllers/api/v1/widget/events_controller.rb
================
class Api::V1::Widget::EventsController < Api::V1::Widget::BaseController
  include Events::Types

  def create
    Rails.configuration.dispatcher.dispatch(permitted_params[:name], Time.zone.now, contact_inbox: @contact_inbox,
                                                                                    event_info: permitted_params[:event_info].to_h.merge(event_info))
    head :no_content
  end

  private

  def event_info
    {
      widget_language: params[:locale],
      browser_language: browser.accept_language.first&.code,
      browser: browser_params
    }
  end

  def permitted_params
    params.permit(:name, :website_token, event_info: {})
  end
end

================
File: controllers/api/v1/widget/inbox_members_controller.rb
================
class Api::V1::Widget::InboxMembersController < Api::V1::Widget::BaseController
  skip_before_action :set_contact

  def index
    @inbox_members = @web_widget.inbox.inbox_members.includes(:user)
  end
end

================
File: controllers/api/v1/widget/labels_controller.rb
================
class Api::V1::Widget::LabelsController < Api::V1::Widget::BaseController
  def create
    if conversation.present? && label_defined_in_account?
      conversation.label_list.add(permitted_params[:label])
      conversation.save!
    end

    head :no_content
  end

  def destroy
    if conversation.present?
      conversation.label_list.remove(permitted_params[:id])
      conversation.save!
    end

    head :no_content
  end

  private

  def label_defined_in_account?
    label = @current_account.labels&.find_by(title: permitted_params[:label])
    label.present?
  end

  def permitted_params
    params.permit(:id, :label, :website_token)
  end
end

================
File: controllers/api/v1/widget/messages_controller.rb
================
class Api::V1::Widget::MessagesController < Api::V1::Widget::BaseController
  before_action :set_conversation, only: [:create]
  before_action :set_message, only: [:update]

  def index
    @messages = conversation.nil? ? [] : message_finder.perform
  end

  def create
    @message = conversation.messages.new(message_params)
    build_attachment
    @message.save!
  end

  def update
    if @message.content_type == 'input_email'
      @message.update!(submitted_email: contact_email)
      ContactIdentifyAction.new(
        contact: @contact,
        params: { email: contact_email, name: contact_name },
        retain_original_contact_name: true
      ).perform
    else
      @message.update!(message_update_params[:message])
    end
  rescue StandardError => e
    render json: { error: @contact.errors, message: e.message }.to_json, status: :internal_server_error
  end

  private

  def build_attachment
    return if params[:message][:attachments].blank?

    params[:message][:attachments].each do |uploaded_attachment|
      attachment = @message.attachments.new(
        account_id: @message.account_id,
        file: uploaded_attachment
      )

      attachment.file_type = helpers.file_type(uploaded_attachment&.content_type) if uploaded_attachment.is_a?(ActionDispatch::Http::UploadedFile)
    end
  end

  def set_conversation
    @conversation = create_conversation if conversation.nil?
  end

  def message_finder_params
    {
      filter_internal_messages: true,
      before: permitted_params[:before],
      after: permitted_params[:after]
    }
  end

  def message_finder
    @message_finder ||= MessageFinder.new(conversation, message_finder_params)
  end

  def message_update_params
    params.permit(message: [{ submitted_values: [:name, :title, :value, { csat_survey_response: [:feedback_message, :rating] }] }])
  end

  def permitted_params
    # timestamp parameter is used in create conversation method
    params.permit(:id, :before, :after, :website_token, contact: [:name, :email], message: [:content, :referer_url, :timestamp, :echo_id, :reply_to])
  end

  def set_message
    @message = @web_widget.inbox.messages.find(permitted_params[:id])
  end
end

================
File: controllers/api/v1/accounts_controller.rb
================
class Api::V1::AccountsController < Api::BaseController
  include AuthHelper
  include CacheKeysHelper

  skip_before_action :authenticate_user!, :set_current_user, :handle_with_exception,
                     only: [:create], raise: false
  before_action :check_signup_enabled, only: [:create]
  before_action :ensure_account_name, only: [:create]
  before_action :validate_captcha, only: [:create]
  before_action :fetch_account, except: [:create]
  before_action :check_authorization, except: [:create]

  rescue_from CustomExceptions::Account::InvalidEmail,
              CustomExceptions::Account::InvalidParams,
              CustomExceptions::Account::UserExists,
              CustomExceptions::Account::UserErrors,
              with: :render_error_response

  def show
    @latest_chatwoot_version = ::Redis::Alfred.get(::Redis::Alfred::LATEST_CHATWOOT_VERSION)
    render 'api/v1/accounts/show', format: :json
  end

  def create
    @user, @account = AccountBuilder.new(
      account_name: account_params[:account_name],
      user_full_name: account_params[:user_full_name],
      email: account_params[:email],
      user_password: account_params[:password],
      locale: account_params[:locale],
      user: current_user
    ).perform
    if @user
      send_auth_headers(@user)
      render 'api/v1/accounts/create', format: :json, locals: { resource: @user }
    else
      render_error_response(CustomExceptions::Account::SignupFailed.new({}))
    end
  end

  def cache_keys
    expires_in 10.seconds, public: false, stale_while_revalidate: 5.minutes
    render json: { cache_keys: cache_keys_for_account }, status: :ok
  end

  def update
    @account.assign_attributes(account_params.slice(:name, :locale, :domain, :support_email, :auto_resolve_duration))
    @account.custom_attributes.merge!(custom_attributes_params)
    @account.custom_attributes['onboarding_step'] = 'invite_team' if @account.custom_attributes['onboarding_step'] == 'account_update'
    @account.save!
  end

  def update_active_at
    @current_account_user.active_at = Time.now.utc
    @current_account_user.save!
    head :ok
  end

  private

  def ensure_account_name
    # ensure that account_name and user_full_name is present
    # this is becuase the account builder and the models validations are not triggered
    # this change is to align the behaviour with the v2 accounts controller
    # since these values are not required directly there
    return if account_params[:account_name].present?
    return if account_params[:user_full_name].present?

    raise CustomExceptions::Account::InvalidParams.new({})
  end

  def cache_keys_for_account
    {
      label: fetch_value_for_key(params[:id], Label.name.underscore),
      inbox: fetch_value_for_key(params[:id], Inbox.name.underscore),
      team: fetch_value_for_key(params[:id], Team.name.underscore)
    }
  end

  def fetch_account
    @account = current_user.accounts.find(params[:id])
    @current_account_user = @account.account_users.find_by(user_id: current_user.id)
  end

  def account_params
    params.permit(:account_name, :email, :name, :password, :locale, :domain, :support_email, :auto_resolve_duration, :user_full_name)
  end

  def custom_attributes_params
    params.permit(:industry, :company_size, :timezone)
  end

  def check_signup_enabled
    raise ActionController::RoutingError, 'Not Found' if GlobalConfigService.load('ENABLE_ACCOUNT_SIGNUP', 'false') == 'false'
  end

  def validate_captcha
    raise ActionController::InvalidAuthenticityToken, 'Invalid Captcha' unless ChatwootCaptcha.new(params[:h_captcha_client_response]).valid?
  end

  def pundit_user
    {
      user: current_user,
      account: @account,
      account_user: @current_account_user
    }
  end
end

================
File: controllers/api/v1/notification_subscriptions_controller.rb
================
class Api::V1::NotificationSubscriptionsController < Api::BaseController
  before_action :set_user

  def create
    notification_subscription = NotificationSubscriptionBuilder.new(user: @user, params: notification_subscription_params).perform

    render json: notification_subscription
  end

  def destroy
    notification_subscription = NotificationSubscription.where(["subscription_attributes->>'push_token' = ?", params[:push_token]]).first
    notification_subscription.destroy! if notification_subscription.present?
    head :ok
  end

  private

  def set_user
    @user = current_user
  end

  def notification_subscription_params
    params.require(:notification_subscription).permit(:subscription_type, subscription_attributes: {})
  end
end

================
File: controllers/api/v1/profiles_controller.rb
================
class Api::V1::ProfilesController < Api::BaseController
  before_action :set_user

  def show; end

  def update
    if password_params[:password].present?
      render_could_not_create_error('Invalid current password') and return unless @user.valid_password?(password_params[:current_password])

      @user.update!(password_params.except(:current_password))
    end

    @user.assign_attributes(profile_params)
    @user.custom_attributes.merge!(custom_attributes_params)
    @user.save!
  end

  def avatar
    @user.avatar.attachment.destroy! if @user.avatar.attached?
    @user.reload
  end

  def auto_offline
    @user.account_users.find_by!(account_id: auto_offline_params[:account_id]).update!(auto_offline: auto_offline_params[:auto_offline] || false)
  end

  def availability
    @user.account_users.find_by!(account_id: availability_params[:account_id]).update!(availability: availability_params[:availability])
  end

  def set_active_account
    @user.account_users.find_by(account_id: profile_params[:account_id]).update(active_at: Time.now.utc)
    head :ok
  end

  def resend_confirmation
    @user.send_confirmation_instructions unless @user.confirmed?
    head :ok
  end

  private

  def set_user
    @user = current_user
  end

  def availability_params
    params.require(:profile).permit(:account_id, :availability)
  end

  def auto_offline_params
    params.require(:profile).permit(:account_id, :auto_offline)
  end

  def profile_params
    params.require(:profile).permit(
      :email,
      :name,
      :display_name,
      :avatar,
      :message_signature,
      :account_id,
      ui_settings: {}
    )
  end

  def custom_attributes_params
    params.require(:profile).permit(:phone_number)
  end

  def password_params
    params.require(:profile).permit(
      :current_password,
      :password,
      :password_confirmation
    )
  end
end

================
File: controllers/api/v1/webhooks_controller.rb
================
class Api::V1::WebhooksController < ApplicationController
  skip_before_action :authenticate_user!, raise: false
  skip_before_action :set_current_user

  def twitter_crc
    render json: { response_token: "sha256=#{twitter_client.generate_crc(params[:crc_token])}" }
  end

  def twitter_events
    twitter_consumer.consume
    head :ok
  rescue StandardError => e
    ChatwootExceptionTracker.new(e).capture_exception
    head :ok
  end

  private

  def twitter_client
    Twitty::Facade.new do |config|
      config.consumer_secret = ENV.fetch('TWITTER_CONSUMER_SECRET', nil)
    end
  end

  def twitter_consumer
    @twitter_consumer ||= ::Webhooks::Twitter.new(params)
  end
end

================
File: controllers/api/v2/accounts/live_reports_controller.rb
================
class Api::V2::Accounts::LiveReportsController < Api::V1::Accounts::BaseController
  before_action :load_conversations, only: [:conversation_metrics, :grouped_conversation_metrics]
  before_action :set_group_scope, only: [:grouped_conversation_metrics]

  before_action :check_authorization

  def conversation_metrics
    render json: {
      open: @conversations.open.count,
      unattended: @conversations.open.unattended.count,
      unassigned: @conversations.open.unassigned.count,
      pending: @conversations.pending.count
    }
  end

  def grouped_conversation_metrics
    count_by_group = @conversations.open.group(@group_scope).count
    unattended_by_group = @conversations.open.unattended.group(@group_scope).count
    unassigned_by_group = @conversations.open.unassigned.group(@group_scope).count

    group_metrics = count_by_group.map do |group_id, count|
      metric = {
        open: count,
        unattended: unattended_by_group[group_id] || 0,
        unassigned: unassigned_by_group[group_id] || 0
      }
      metric[@group_scope] = group_id
      metric
    end

    render json: group_metrics
  end

  private

  def check_authorization
    authorize :report, :view?
  end

  def set_group_scope
    render json: { error: 'invalid group_by' }, status: :unprocessable_entity and return unless %w[
      team_id
      assignee_id
    ].include?(permitted_params[:group_by])

    @group_scope = permitted_params[:group_by]
  end

  def team
    return unless permitted_params[:team_id]

    @team ||= Current.account.teams.find(permitted_params[:team_id])
  end

  def load_conversations
    scope = Current.account.conversations
    scope = scope.where(team_id: team.id) if team.present?
    @conversations = scope
  end

  def permitted_params
    params.permit(:team_id, :group_by)
  end
end

================
File: controllers/api/v2/accounts/reports_controller.rb
================
class Api::V2::Accounts::ReportsController < Api::V1::Accounts::BaseController
  include Api::V2::Accounts::ReportsHelper
  include Api::V2::Accounts::HeatmapHelper

  before_action :check_authorization

  def index
    builder = V2::Reports::Conversations::ReportBuilder.new(Current.account, report_params)
    data = builder.timeseries
    render json: data
  end

  def summary
    render json: build_summary(:summary)
  end

  def bot_summary
    render json: build_summary(:bot_summary)
  end

  def agents
    @report_data = generate_agents_report
    generate_csv('agents_report', 'api/v2/accounts/reports/agents')
  end

  def inboxes
    @report_data = generate_inboxes_report
    generate_csv('inboxes_report', 'api/v2/accounts/reports/inboxes')
  end

  def labels
    @report_data = generate_labels_report
    generate_csv('labels_report', 'api/v2/accounts/reports/labels')
  end

  def teams
    @report_data = generate_teams_report
    generate_csv('teams_report', 'api/v2/accounts/reports/teams')
  end

  def conversation_traffic
    @report_data = generate_conversations_heatmap_report
    timezone_offset = (params[:timezone_offset] || 0).to_f
    @timezone = ActiveSupport::TimeZone[timezone_offset]

    generate_csv('conversation_traffic_reports', 'api/v2/accounts/reports/conversation_traffic')
  end

  def conversations
    return head :unprocessable_entity if params[:type].blank?

    render json: conversation_metrics
  end

  def bot_metrics
    bot_metrics = V2::Reports::BotMetricsBuilder.new(Current.account, params).metrics
    render json: bot_metrics
  end

  private

  def generate_csv(filename, template)
    response.headers['Content-Type'] = 'text/csv'
    response.headers['Content-Disposition'] = "attachment; filename=#{filename}.csv"
    render layout: false, template: template, formats: [:csv]
  end

  def check_authorization
    return if Current.account_user.administrator?

    raise Pundit::NotAuthorizedError
  end

  def common_params
    {
      type: params[:type].to_sym,
      id: params[:id],
      group_by: params[:group_by],
      business_hours: ActiveModel::Type::Boolean.new.cast(params[:business_hours])
    }
  end

  def current_summary_params
    common_params.merge({
                          since: range[:current][:since],
                          until: range[:current][:until],
                          timezone_offset: params[:timezone_offset]
                        })
  end

  def previous_summary_params
    common_params.merge({
                          since: range[:previous][:since],
                          until: range[:previous][:until],
                          timezone_offset: params[:timezone_offset]
                        })
  end

  def report_params
    common_params.merge({
                          metric: params[:metric],
                          since: params[:since],
                          until: params[:until],
                          timezone_offset: params[:timezone_offset]
                        })
  end

  def conversation_params
    {
      type: params[:type].to_sym,
      user_id: params[:user_id],
      page: params[:page].presence || 1
    }
  end

  def range
    {
      current: {
        since: params[:since],
        until: params[:until]
      },
      previous: {
        since: (params[:since].to_i - (params[:until].to_i - params[:since].to_i)).to_s,
        until: params[:since]
      }
    }
  end

  def build_summary(method)
    builder = V2::Reports::Conversations::MetricBuilder
    current_summary = builder.new(Current.account, current_summary_params).send(method)
    previous_summary = builder.new(Current.account, previous_summary_params).send(method)
    current_summary.merge(previous: previous_summary)
  end

  def conversation_metrics
    V2::ReportBuilder.new(Current.account, conversation_params).conversation_metrics
  end
end

Api::V2::Accounts::ReportsController.prepend_mod_with('Api::V2::Accounts::ReportsController')

================
File: controllers/api/v2/accounts/summary_reports_controller.rb
================
class Api::V2::Accounts::SummaryReportsController < Api::V1::Accounts::BaseController
  before_action :check_authorization
  before_action :prepare_builder_params, only: [:agent, :team, :inbox]

  def agent
    render_report_with(V2::Reports::AgentSummaryBuilder)
  end

  def team
    render_report_with(V2::Reports::TeamSummaryBuilder)
  end

  def inbox
    render_report_with(V2::Reports::InboxSummaryBuilder)
  end

  private

  def check_authorization
    authorize :report, :view?
  end

  def prepare_builder_params
    @builder_params = {
      since: permitted_params[:since],
      until: permitted_params[:until],
      business_hours: ActiveModel::Type::Boolean.new.cast(permitted_params[:business_hours])
    }
  end

  def render_report_with(builder_class)
    builder = builder_class.new(account: Current.account, params: @builder_params)
    render json: builder.build
  end

  def permitted_params
    params.permit(:since, :until, :business_hours)
  end
end

================
File: controllers/api/v2/accounts_controller.rb
================
class Api::V2::AccountsController < Api::BaseController
  include AuthHelper

  skip_before_action :authenticate_user!, :set_current_user, :handle_with_exception,
                     only: [:create], raise: false
  before_action :check_signup_enabled, only: [:create]
  before_action :validate_captcha, only: [:create]
  before_action :fetch_account, except: [:create]
  before_action :check_authorization, except: [:create]

  rescue_from CustomExceptions::Account::InvalidEmail,
              CustomExceptions::Account::UserExists,
              CustomExceptions::Account::UserErrors,
              with: :render_error_response

  def create
    @user, @account = AccountBuilder.new(
      email: account_params[:email],
      user_password: account_params[:password],
      locale: account_params[:locale],
      user: current_user
    ).perform

    fetch_account_and_user_info
    update_account_info if @account.present?

    if @user
      send_auth_headers(@user)
      render 'api/v1/accounts/create', format: :json, locals: { resource: @user }
    else
      render_error_response(CustomExceptions::Account::SignupFailed.new({}))
    end
  end

  private

  def account_attributes
    {
      custom_attributes: @account.custom_attributes.merge({ 'onboarding_step' => 'profile_update' })
    }
  end

  def update_account_info
    @account.update!(
      account_attributes
    )
  end

  def fetch_account_and_user_info; end

  def fetch_account
    @account = current_user.accounts.find(params[:id])
    @current_account_user = @account.account_users.find_by(user_id: current_user.id)
  end

  def account_params
    params.permit(:account_name, :email, :name, :password, :locale, :domain, :support_email, :auto_resolve_duration, :user_full_name)
  end

  def check_signup_enabled
    raise ActionController::RoutingError, 'Not Found' if GlobalConfigService.load('ENABLE_ACCOUNT_SIGNUP', 'false') == 'false'
  end

  def validate_captcha
    raise ActionController::InvalidAuthenticityToken, 'Invalid Captcha' unless ChatwootCaptcha.new(params[:h_captcha_client_response]).valid?
  end
end

Api::V2::AccountsController.prepend_mod_with('Api::V2::AccountsController')

================
File: controllers/api/base_controller.rb
================
class Api::BaseController < ApplicationController
  include AccessTokenAuthHelper
  respond_to :json
  before_action :authenticate_access_token!, if: :authenticate_by_access_token?
  before_action :validate_bot_access_token!, if: :authenticate_by_access_token?
  before_action :authenticate_user!, unless: :authenticate_by_access_token?

  private

  def authenticate_by_access_token?
    request.headers[:api_access_token].present? || request.headers[:HTTP_API_ACCESS_TOKEN].present?
  end

  def check_authorization(model = nil)
    model ||= controller_name.classify.constantize

    authorize(model)
  end

  def check_admin_authorization?
    raise Pundit::NotAuthorizedError unless Current.account_user.administrator?
  end
end

================
File: controllers/concerns/access_token_auth_helper.rb
================
module AccessTokenAuthHelper
  BOT_ACCESSIBLE_ENDPOINTS = {
    'api/v1/accounts/conversations' => %w[toggle_status toggle_priority create update],
    'api/v1/accounts/conversations/messages' => ['create'],
    'api/v1/accounts/conversations/assignments' => ['create']
  }.freeze

  def ensure_access_token
    token = request.headers[:api_access_token] || request.headers[:HTTP_API_ACCESS_TOKEN]
    @access_token = AccessToken.find_by(token: token) if token.present?
  end

  def authenticate_access_token!
    ensure_access_token
    render_unauthorized('Invalid Access Token') && return if @access_token.blank?

    @resource = @access_token.owner
    Current.user = @resource if allowed_current_user_type?(@resource)
  end

  def allowed_current_user_type?(resource)
    return true if resource.is_a?(User)
    return true if resource.is_a?(AgentBot)

    false
  end

  def validate_bot_access_token!
    return if Current.user.is_a?(User)
    return if agent_bot_accessible?

    render_unauthorized('Access to this endpoint is not authorized for bots')
  end

  def agent_bot_accessible?
    BOT_ACCESSIBLE_ENDPOINTS.fetch(params[:controller], []).include?(params[:action])
  end
end

================
File: controllers/concerns/auth_helper.rb
================
module AuthHelper
  def send_auth_headers(user)
    data = user.create_new_auth_token
    response.headers[DeviseTokenAuth.headers_names[:'access-token']] = data['access-token']
    response.headers[DeviseTokenAuth.headers_names[:'token-type']]   = 'Bearer'
    response.headers[DeviseTokenAuth.headers_names[:client]]       = data['client']
    response.headers[DeviseTokenAuth.headers_names[:expiry]]       = data['expiry']
    response.headers[DeviseTokenAuth.headers_names[:uid]]          = data['uid']
  end
end

================
File: controllers/concerns/domain_helper.rb
================
module DomainHelper
  def self.chatwoot_domain?(domain = request.host)
    [URI.parse(ENV.fetch('FRONTEND_URL', '')).host, URI.parse(ENV.fetch('HELPCENTER_URL', '')).host].include?(domain)
  end
end

================
File: controllers/concerns/ensure_current_account_helper.rb
================
module EnsureCurrentAccountHelper
  private

  def current_account
    @current_account ||= ensure_current_account
    Current.account = @current_account
  end

  def ensure_current_account
    account = Account.find(params[:account_id])
    render_unauthorized('Account is suspended') and return unless account.active?

    if current_user
      account_accessible_for_user?(account)
    elsif @resource.is_a?(AgentBot)
      account_accessible_for_bot?(account)
    end
    account
  end

  def account_accessible_for_user?(account)
    @current_account_user = account.account_users.find_by(user_id: current_user.id)
    Current.account_user = @current_account_user
    render_unauthorized('You are not authorized to access this account') unless @current_account_user
  end

  def account_accessible_for_bot?(account)
    render_unauthorized('Bot is not authorized to access this account') unless @resource.agent_bot_inboxes.find_by(account_id: account.id)
  end
end

================
File: controllers/concerns/google_concern.rb
================
module GoogleConcern
  extend ActiveSupport::Concern

  def google_client
    app_id = GlobalConfigService.load('GOOGLE_OAUTH_CLIENT_ID', nil)
    app_secret = GlobalConfigService.load('GOOGLE_OAUTH_CLIENT_SECRET', nil)

    ::OAuth2::Client.new(app_id, app_secret, {
                           site: 'https://oauth2.googleapis.com',
                           authorize_url: 'https://accounts.google.com/o/oauth2/auth',
                           token_url: 'https://accounts.google.com/o/oauth2/token'
                         })
  end

  private

  def base_url
    ENV.fetch('FRONTEND_URL', 'http://localhost:3000')
  end
end

================
File: controllers/concerns/hmac_concern.rb
================
module HmacConcern
  def hmac_verified?
    ActiveModel::Type::Boolean.new.cast(params[:hmac_verified]).present?
  end
end

================
File: controllers/concerns/label_concern.rb
================
module LabelConcern
  def create
    model.update_labels(permitted_params[:labels])
    @labels = model.label_list
  end

  def index
    @labels = model.label_list
  end
end

================
File: controllers/concerns/meta_token_verify_concern.rb
================
# services from Meta (Prev: Facebook) needs a token verification step for webhook subscriptions,
# This concern handles the token verification step.

module MetaTokenVerifyConcern
  def verify
    service = is_a?(Webhooks::WhatsappController) ? 'whatsapp' : 'instagram'
    if valid_token?(params['hub.verify_token'])
      Rails.logger.info("#{service.capitalize} webhook verified")
      render json: params['hub.challenge']
    else
      render status: :unauthorized, json: { error: 'Error; wrong verify token' }
    end
  end

  private

  def valid_token?(_token)
    raise 'Overwrite this method your controller'
  end
end

================
File: controllers/concerns/microsoft_concern.rb
================
module MicrosoftConcern
  extend ActiveSupport::Concern

  def microsoft_client
    app_id = GlobalConfigService.load('AZURE_APP_ID', nil)
    app_secret = GlobalConfigService.load('AZURE_APP_SECRET', nil)

    ::OAuth2::Client.new(app_id, app_secret,
                         {
                           site: 'https://login.microsoftonline.com',
                           authorize_url: 'https://login.microsoftonline.com/common/oauth2/v2.0/authorize',
                           token_url: 'https://login.microsoftonline.com/common/oauth2/v2.0/token'
                         })
  end

  private

  def base_url
    ENV.fetch('FRONTEND_URL', 'http://localhost:3000')
  end
end

================
File: controllers/concerns/request_exception_handler.rb
================
module RequestExceptionHandler
  extend ActiveSupport::Concern

  included do
    rescue_from ActiveRecord::RecordInvalid, with: :render_record_invalid
  end

  private

  def handle_with_exception
    yield
  rescue ActiveRecord::RecordNotFound => e
    log_handled_error(e)
    render_not_found_error('Resource could not be found')
  rescue Pundit::NotAuthorizedError => e
    log_handled_error(e)
    render_unauthorized('You are not authorized to do this action')
  rescue ActionController::ParameterMissing => e
    log_handled_error(e)
    render_could_not_create_error(e.message)
  ensure
    # to address the thread variable leak issues in Puma/Thin webserver
    Current.reset
  end

  def render_unauthorized(message)
    render json: { error: message }, status: :unauthorized
  end

  def render_not_found_error(message)
    render json: { error: message }, status: :not_found
  end

  def render_could_not_create_error(message)
    render json: { error: message }, status: :unprocessable_entity
  end

  def render_payment_required(message)
    render json: { error: message }, status: :payment_required
  end

  def render_internal_server_error(message)
    render json: { error: message }, status: :internal_server_error
  end

  def render_record_invalid(exception)
    log_handled_error(exception)
    render json: {
      message: exception.record.errors.full_messages.join(', '),
      attributes: exception.record.errors.attribute_names
    }, status: :unprocessable_entity
  end

  def render_error_response(exception)
    log_handled_error(exception)
    render json: exception.to_hash, status: exception.http_status
  end

  def log_handled_error(exception)
    logger.info("Handled error: #{exception.inspect}")
  end
end

================
File: controllers/concerns/switch_locale.rb
================
module SwitchLocale
  extend ActiveSupport::Concern

  private

  def switch_locale(&)
    # priority is for locale set in query string (mostly for widget/from js sdk)
    locale ||= params[:locale]

    locale ||= locale_from_custom_domain
    # if locale is not set in account, let's use DEFAULT_LOCALE env variable
    locale ||= ENV.fetch('DEFAULT_LOCALE', nil)
    set_locale(locale, &)
  end

  def switch_locale_using_account_locale(&)
    locale = locale_from_account(@current_account)
    set_locale(locale, &)
  end

  # If the request is coming from a custom domain, it should be for a helpcenter portal
  # We will use the portal locale in such cases
  def locale_from_custom_domain(&)
    return if params[:locale]

    domain = request.host
    return if DomainHelper.chatwoot_domain?(domain)

    @portal = Portal.find_by(custom_domain: domain)
    return unless @portal

    @portal.default_locale
  end

  def set_locale(locale, &)
    safe_locale = validate_and_get_locale(locale)
    # Ensure locale won't bleed into other requests
    # https://guides.rubyonrails.org/i18n.html#managing-the-locale-across-requests
    I18n.with_locale(safe_locale, &)
  end

  def validate_and_get_locale(locale)
    return I18n.default_locale.to_s if locale.blank?

    available_locales = I18n.available_locales.map(&:to_s)
    locale_without_variant = locale.split('_')[0]

    if available_locales.include?(locale)
      locale
    elsif available_locales.include?(locale_without_variant)
      locale_without_variant
    else
      I18n.default_locale.to_s
    end
  end

  def locale_from_account(account)
    return unless account

    account.locale
  end
end

================
File: controllers/concerns/twitter_concern.rb
================
module TwitterConcern
  extend ActiveSupport::Concern

  private

  def parsed_body
    @parsed_body ||= Rack::Utils.parse_nested_query(@response.raw_response.body)
  end

  def host
    ENV.fetch('FRONTEND_URL', '')
  end

  def twitter_client
    Twitty::Facade.new do |config|
      config.consumer_key = ENV.fetch('TWITTER_CONSUMER_KEY', nil)
      config.consumer_secret = ENV.fetch('TWITTER_CONSUMER_SECRET', nil)
      config.base_url = twitter_api_base_url
      config.environment = ENV.fetch('TWITTER_ENVIRONMENT', '')
    end
  end

  def twitter_api_base_url
    'https://api.twitter.com'
  end
end

================
File: controllers/concerns/website_token_helper.rb
================
module WebsiteTokenHelper
  def auth_token_params
    @auth_token_params ||= ::Widget::TokenService.new(token: request.headers['X-Auth-Token']).decode_token
  end

  def set_web_widget
    @web_widget = ::Channel::WebWidget.find_by!(website_token: permitted_params[:website_token])
    @current_account = @web_widget.inbox.account

    render json: { error: 'Account is suspended' }, status: :unauthorized unless @current_account.active?
  end

  def set_contact
    @contact_inbox = @web_widget.inbox.contact_inboxes.find_by(
      source_id: auth_token_params[:source_id]
    )
    @contact = @contact_inbox&.contact
    raise ActiveRecord::RecordNotFound unless @contact

    Current.contact = @contact
  end

  def permitted_params
    params.permit(:website_token)
  end
end

================
File: controllers/devise_overrides/confirmations_controller.rb
================
class DeviseOverrides::ConfirmationsController < Devise::ConfirmationsController
  include AuthHelper
  skip_before_action :require_no_authentication, raise: false
  skip_before_action :authenticate_user!, raise: false

  def create
    @confirmable = User.find_by(confirmation_token: params[:confirmation_token])
    render_confirmation_success and return if @confirmable&.confirm

    render_confirmation_error
  end

  private

  def render_confirmation_success
    send_auth_headers(@confirmable)
    render partial: 'devise/auth', formats: [:json], locals: { resource: @confirmable }
  end

  def render_confirmation_error
    if @confirmable.blank?
      render json: { message: 'Invalid token', redirect_url: '/' }, status: :unprocessable_entity
    elsif @confirmable.confirmed_at
      render json: { message: 'Already confirmed', redirect_url: '/' }, status: :unprocessable_entity
    else
      render json: { message: 'Failure', redirect_url: '/' }, status: :unprocessable_entity
    end
  end

  def create_reset_token_link(user)
    token = user.send(:set_reset_password_token)
    "/app/auth/password/edit?config=default&redirect_url=&reset_password_token=#{token}"
  end
end

================
File: controllers/devise_overrides/omniauth_callbacks_controller.rb
================
class DeviseOverrides::OmniauthCallbacksController < DeviseTokenAuth::OmniauthCallbacksController
  include EmailHelper

  def omniauth_success
    get_resource_from_auth_hash

    @resource.present? ? sign_in_user : sign_up_user
  end

  private

  def sign_in_user
    @resource.skip_confirmation! if confirmable_enabled?

    # once the resource is found and verified
    # we can just send them to the login page again with the SSO params
    # that will log them in
    encoded_email = ERB::Util.url_encode(@resource.email)
    redirect_to login_page_url(email: encoded_email, sso_auth_token: @resource.generate_sso_auth_token)
  end

  def sign_up_user
    return redirect_to login_page_url(error: 'no-account-found') unless account_signup_allowed?
    return redirect_to login_page_url(error: 'business-account-only') unless validate_business_account?

    create_account_for_user
    token = @resource.send(:set_reset_password_token)
    frontend_url = ENV.fetch('FRONTEND_URL', nil)
    redirect_to "#{frontend_url}/app/auth/password/edit?config=default&reset_password_token=#{token}"
  end

  def login_page_url(error: nil, email: nil, sso_auth_token: nil)
    frontend_url = ENV.fetch('FRONTEND_URL', nil)
    params = { email: email, sso_auth_token: sso_auth_token }.compact
    params[:error] = error if error.present?

    "#{frontend_url}/app/login?#{params.to_query}"
  end

  def account_signup_allowed?
    # set it to true by default, this is the behaviour across the app
    GlobalConfigService.load('ENABLE_ACCOUNT_SIGNUP', 'false') != 'false'
  end

  def resource_class(_mapping = nil)
    User
  end

  def get_resource_from_auth_hash # rubocop:disable Naming/AccessorMethodName
    # find the user with their email instead of UID and token
    @resource = resource_class.where(
      email: auth_hash['info']['email']
    ).first
  end

  def validate_business_account?
    # return true if the user is a business account, false if it is a gmail account
    auth_hash['info']['email'].exclude?('@gmail.com')
  end

  def create_account_for_user
    @resource, @account = AccountBuilder.new(
      account_name: extract_domain_without_tld(auth_hash['info']['email']),
      user_full_name: auth_hash['info']['name'],
      email: auth_hash['info']['email'],
      locale: I18n.locale,
      confirmed: auth_hash['info']['email_verified']
    ).perform
    Avatar::AvatarFromUrlJob.perform_later(@resource, auth_hash['info']['image'])
  end

  def default_devise_mapping
    'user'
  end
end

================
File: controllers/devise_overrides/passwords_controller.rb
================
class DeviseOverrides::PasswordsController < Devise::PasswordsController
  include AuthHelper

  skip_before_action :require_no_authentication, raise: false
  skip_before_action :authenticate_user!, raise: false

  def create
    @user = User.from_email(params[:email])
    if @user
      @user.send_reset_password_instructions
      build_response(I18n.t('messages.reset_password_success'), 200)
    else
      build_response(I18n.t('messages.reset_password_failure'), 404)
    end
  end

  def update
    # params: reset_password_token, password, password_confirmation
    original_token = params[:reset_password_token]
    reset_password_token = Devise.token_generator.digest(self, :reset_password_token, original_token)
    @recoverable = User.find_by(reset_password_token: reset_password_token)
    if @recoverable && reset_password_and_confirmation(@recoverable)
      send_auth_headers(@recoverable)
      render partial: 'devise/auth', formats: [:json], locals: { resource: @recoverable }
    else
      render json: { message: 'Invalid token', redirect_url: '/' }, status: :unprocessable_entity
    end
  end

  private

  def reset_password_and_confirmation(recoverable)
    recoverable.confirm unless recoverable.confirmed? # confirm if user resets password without confirming anytime before
    recoverable.reset_password(params[:password], params[:password_confirmation])
    recoverable.reset_password_token = nil
    recoverable.confirmation_token = nil
    recoverable.reset_password_sent_at = nil
    recoverable.save!
  end

  def build_response(message, status)
    render json: {
      message: message
    }, status: status
  end
end

================
File: controllers/devise_overrides/sessions_controller.rb
================
class DeviseOverrides::SessionsController < DeviseTokenAuth::SessionsController
  # Prevent session parameter from being passed
  # Unpermitted parameter: session
  wrap_parameters format: []
  before_action :process_sso_auth_token, only: [:create]

  def new
    redirect_to login_page_url(error: 'access-denied')
  end

  def create
    # Authenticate user via the temporary sso auth token
    if params[:sso_auth_token].present? && @resource.present?
      authenticate_resource_with_sso_token
      yield @resource if block_given?
      render_create_success
    else
      super
    end
  end

  def render_create_success
    render partial: 'devise/auth', formats: [:json], locals: { resource: @resource }
  end

  private

  def login_page_url(error: nil)
    frontend_url = ENV.fetch('FRONTEND_URL', nil)

    "#{frontend_url}/app/login?error=#{error}"
  end

  def authenticate_resource_with_sso_token
    @token = @resource.create_token
    @resource.save!

    sign_in(:user, @resource, store: false, bypass: false)
    # invalidate the token after the user is signed in
    @resource.invalidate_sso_auth_token(params[:sso_auth_token])
  end

  def process_sso_auth_token
    return if params[:email].blank?

    user = User.from_email(params[:email])
    @resource = user if user&.valid_sso_auth_token?(params[:sso_auth_token])
  end
end

DeviseOverrides::SessionsController.prepend_mod_with('DeviseOverrides::SessionsController')

================
File: controllers/devise_overrides/token_validations_controller.rb
================
class DeviseOverrides::TokenValidationsController < DeviseTokenAuth::TokenValidationsController
  def validate_token
    # @resource will have been set by set_user_by_token concern
    if @resource
      render 'devise/token', formats: [:json]
    else
      render_validate_token_error
    end
  end
end

================
File: controllers/google/callbacks_controller.rb
================
class Google::CallbacksController < OauthCallbackController
  include GoogleConcern

  def find_channel_by_email
    # find by imap_login first, and then by email
    # this ensures the legacy users can migrate correctly even if inbox email address doesn't match
    imap_channel = Channel::Email.find_by(imap_login: users_data['email'], account: account)
    return imap_channel if imap_channel

    Channel::Email.find_by(email: users_data['email'], account: account)
  end

  private

  def provider_name
    'google'
  end

  def imap_address
    'imap.gmail.com'
  end

  def oauth_client
    # from GoogleConcern
    google_client
  end
end

================
File: controllers/installation/onboarding_controller.rb
================
class Installation::OnboardingController < ApplicationController
  before_action :ensure_installation_onboarding

  def index; end

  def create
    begin
      AccountBuilder.new(
        account_name: onboarding_params.dig(:user, :company),
        user_full_name: onboarding_params.dig(:user, :name),
        email: onboarding_params.dig(:user, :email),
        user_password: params.dig(:user, :password),
        super_admin: true,
        confirmed: true
      ).perform
    rescue StandardError => e
      redirect_to '/', flash: { error: e.message } and return
    end
    finish_onboarding
    redirect_to '/'
  end

  private

  def onboarding_params
    params.permit(:subscribe_to_updates, user: [:name, :company, :email])
  end

  def finish_onboarding
    ::Redis::Alfred.delete(::Redis::Alfred::CHATWOOT_INSTALLATION_ONBOARDING)
    return if onboarding_params[:subscribe_to_updates].blank?

    ChatwootHub.register_instance(
      onboarding_params.dig(:user, :company),
      onboarding_params.dig(:user, :name),
      onboarding_params.dig(:user, :email)
    )
  end

  def ensure_installation_onboarding
    redirect_to '/' unless ::Redis::Alfred.get(::Redis::Alfred::CHATWOOT_INSTALLATION_ONBOARDING)
  end
end

================
File: controllers/linear/callbacks_controller.rb
================
class Linear::CallbacksController < ApplicationController
  include Linear::IntegrationHelper

  def show
    @response = oauth_client.auth_code.get_token(
      params[:code],
      redirect_uri: "#{base_url}/linear/callback"
    )

    handle_response
  rescue StandardError => e
    Rails.logger.error("Linear callback error: #{e.message}")
    redirect_to linear_redirect_uri
  end

  private

  def oauth_client
    app_id = GlobalConfigService.load('LINEAR_CLIENT_ID', nil)
    app_secret = GlobalConfigService.load('LINEAR_CLIENT_SECRET', nil)

    OAuth2::Client.new(
      app_id,
      app_secret,
      {
        site: 'https://api.linear.app',
        token_url: '/oauth/token',
        authorize_url: '/oauth/authorize'
      }
    )
  end

  def handle_response
    hook = account.hooks.new(
      access_token: parsed_body['access_token'],
      status: 'enabled',
      app_id: 'linear',
      settings: {
        token_type: parsed_body['token_type'],
        expires_in: parsed_body['expires_in'],
        scope: parsed_body['scope']
      }
    )
    # You may wonder why we're not handling the refresh token update, since the token will expire only after 10 years, https://github.com/linear/linear/issues/251
    hook.save!
    redirect_to linear_redirect_uri
  rescue StandardError => e
    Rails.logger.error("Linear callback error: #{e.message}")
    redirect_to linear_redirect_uri
  end

  def account
    @account ||= Account.find(account_id)
  end

  def account_id
    return unless params[:state]

    verify_linear_token(params[:state])
  end

  def linear_redirect_uri
    "#{ENV.fetch('FRONTEND_URL', nil)}/app/accounts/#{account.id}/settings/integrations/linear"
  end

  def parsed_body
    @parsed_body ||= @response.response.parsed
  end

  def base_url
    ENV.fetch('FRONTEND_URL', 'http://localhost:3000')
  end
end

================
File: controllers/microsoft/callbacks_controller.rb
================
class Microsoft::CallbacksController < OauthCallbackController
  include MicrosoftConcern

  private

  def oauth_client
    microsoft_client
  end

  def provider_name
    'microsoft'
  end

  def imap_address
    'outlook.office365.com'
  end
end

================
File: controllers/platform/api/v1/account_users_controller.rb
================
class Platform::Api::V1::AccountUsersController < PlatformController
  before_action :set_resource
  before_action :validate_platform_app_permissible

  def index
    render json: @resource.account_users
  end

  def create
    @account_user = @resource.account_users.find_or_initialize_by(user_id: account_user_params[:user_id])
    @account_user.update!(account_user_params)
    render json: @account_user
  end

  def destroy
    @resource.account_users.find_by(user_id: account_user_params[:user_id])&.destroy!
    head :ok
  end

  private

  def set_resource
    @resource = Account.find(params[:account_id])
  end

  def account_user_params
    params.permit(:user_id, :role)
  end
end

================
File: controllers/platform/api/v1/accounts_controller.rb
================
class Platform::Api::V1::AccountsController < PlatformController
  def show; end

  def create
    @resource = Account.create!(account_params)
    update_resource_features
    @resource.save!
    @platform_app.platform_app_permissibles.find_or_create_by(permissible: @resource)
  end

  def update
    @resource.assign_attributes(account_params)
    update_resource_features
    @resource.save!
  end

  def destroy
    DeleteObjectJob.perform_later(@resource)
    head :ok
  end

  private

  def set_resource
    @resource = Account.find(params[:id])
  end

  def account_params
    permitted_params.except(:features)
  end

  def update_resource_features
    return if permitted_params[:features].blank?

    permitted_params[:features].each do |key, value|
      value.present? ? @resource.enable_features(key) : @resource.disable_features(key)
    end
  end

  def permitted_params
    params.permit(:name, :locale, :domain, :support_email, :status, features: {}, limits: {}, custom_attributes: {})
  end
end

================
File: controllers/platform/api/v1/agent_bots_controller.rb
================
class Platform::Api::V1::AgentBotsController < PlatformController
  before_action :set_resource, except: [:index, :create]
  before_action :validate_platform_app_permissible, except: [:index, :create]

  def index
    @resources = @platform_app.platform_app_permissibles.where(permissible_type: 'AgentBot').all
  end

  def show; end

  def create
    @resource = AgentBot.new(agent_bot_params.except(:avatar_url))
    @resource.save!
    process_avatar_from_url
    @platform_app.platform_app_permissibles.find_or_create_by(permissible: @resource)
  end

  def update
    @resource.update!(agent_bot_params.except(:avatar_url))
    process_avatar_from_url
  end

  def destroy
    @resource.destroy!
    head :ok
  end

  def avatar
    @resource.avatar.purge if @resource.avatar.attached?
    @resource
  end

  private

  def set_resource
    @resource = AgentBot.find(params[:id])
  end

  def agent_bot_params
    params.permit(:name, :description, :account_id, :outgoing_url, :avatar, :avatar_url)
  end

  def process_avatar_from_url
    ::Avatar::AvatarFromUrlJob.perform_later(@resource, params[:avatar_url]) if params[:avatar_url].present?
  end
end

================
File: controllers/platform/api/v1/users_controller.rb
================
class Platform::Api::V1::UsersController < PlatformController
  # ref: https://stackoverflow.com/a/45190318/939299
  # set resource is called for other actions already in platform controller
  # we want to add login to that chain as well
  before_action(only: [:login]) { set_resource }
  before_action(only: [:login]) { validate_platform_app_permissible }

  def show; end

  def create
    @resource = (User.from_email(user_params[:email]) || User.new(user_params))
    @resource.skip_confirmation!
    @resource.save!
    @platform_app.platform_app_permissibles.find_or_create_by!(permissible: @resource)
  end

  def login
    render json: { url: @resource.generate_sso_link }
  end

  def update
    @resource.assign_attributes(user_update_params)

    # We are using devise's reconfirmable flow for changing emails
    # But in case of platform APIs we don't want user to go through this extra step
    @resource.skip_reconfirmation! if user_update_params[:email].present?
    @resource.save!
  end

  def destroy
    DeleteObjectJob.perform_later(@resource)
    head :ok
  end

  private

  def user_custom_attributes
    return @resource.custom_attributes.merge(user_params[:custom_attributes]) if user_params[:custom_attributes]

    @resource.custom_attributes
  end

  def user_update_params
    # we want the merged custom attributes not the original one
    user_params.except(:custom_attributes).merge({ custom_attributes: user_custom_attributes })
  end

  def set_resource
    @resource = User.find(params[:id])
  end

  def user_params
    params.permit(:name, :display_name, :email, :password, custom_attributes: {})
  end
end

================
File: controllers/public/api/v1/inboxes/contacts_controller.rb
================
class Public::Api::V1::Inboxes::ContactsController < Public::Api::V1::InboxesController
  before_action :contact_inbox, except: [:create]
  before_action :process_hmac

  def show; end

  def create
    source_id = params[:source_id] || SecureRandom.uuid
    @contact_inbox = ::ContactInboxWithContactBuilder.new(
      source_id: source_id,
      inbox: @inbox_channel.inbox,
      contact_attributes: permitted_params.except(:identifier_hash)
    ).perform
  end

  def update
    contact_identify_action = ContactIdentifyAction.new(
      contact: @contact_inbox.contact,
      params: permitted_params.to_h.deep_symbolize_keys.except(:identifier)
    )
    render json: contact_identify_action.perform
  end

  private

  def contact_inbox
    @contact_inbox = @inbox_channel.inbox.contact_inboxes.find_by!(source_id: params[:id])
  end

  def process_hmac
    return if params[:identifier_hash].blank? && !@inbox_channel.hmac_mandatory
    raise StandardError, 'HMAC failed: Invalid Identifier Hash Provided' unless valid_hmac?

    @contact_inbox.update(hmac_verified: true) if @contact_inbox.present?
  end

  def valid_hmac?
    params[:identifier_hash] == OpenSSL::HMAC.hexdigest(
      'sha256',
      @inbox_channel.hmac_token,
      params[:identifier].to_s
    )
  end

  def permitted_params
    params.permit(:identifier, :identifier_hash, :email, :name, :avatar_url, :phone_number, custom_attributes: {})
  end
end

================
File: controllers/public/api/v1/inboxes/conversations_controller.rb
================
class Public::Api::V1::Inboxes::ConversationsController < Public::Api::V1::InboxesController
  include Events::Types
  before_action :set_conversation, only: [:toggle_typing, :update_last_seen, :show, :toggle_status]

  def index
    @conversations = @contact_inbox.hmac_verified? ? @contact.conversations : @contact_inbox.conversations
  end

  def show; end

  def create
    @conversation = create_conversation
  end

  def toggle_status
    # Check if the conversation is already resolved to prevent redundant operations
    return if @conversation.resolved?

    # Assign the conversation's contact as the resolver
    # This step attributes the resolution action to the contact involved in the conversation
    # If this assignment is not made, the system implicitly becomes the resolver by default
    Current.contact = @conversation.contact

    # Update the conversation's status to 'resolved' to reflect its closure
    @conversation.status = :resolved
    @conversation.save!
  end

  def toggle_typing
    case params[:typing_status]
    when 'on'
      trigger_typing_event(CONVERSATION_TYPING_ON)
    when 'off'
      trigger_typing_event(CONVERSATION_TYPING_OFF)
    end
    head :ok
  end

  def update_last_seen
    @conversation.contact_last_seen_at = DateTime.now.utc
    @conversation.save!
    ::Conversations::UpdateMessageStatusJob.perform_later(@conversation.id, @conversation.contact_last_seen_at)
    head :ok
  end

  private

  def set_conversation
    @conversation = if @contact_inbox.hmac_verified?
                      @contact_inbox.contact.conversations.find_by!(display_id: params[:id])
                    else
                      @contact_inbox.conversations.find_by!(display_id: params[:id])
                    end
  end

  def create_conversation
    ConversationBuilder.new(params: conversation_params, contact_inbox: @contact_inbox).perform
  end

  def trigger_typing_event(event)
    Rails.configuration.dispatcher.dispatch(event, Time.zone.now, conversation: @conversation, user: @conversation.contact)
  end

  def conversation_params
    params.permit(custom_attributes: {})
  end
end

================
File: controllers/public/api/v1/inboxes/messages_controller.rb
================
class Public::Api::V1::Inboxes::MessagesController < Public::Api::V1::InboxesController
  before_action :set_message, only: [:update]

  def index
    @messages = @conversation.nil? ? [] : message_finder.perform
  end

  def create
    @message = @conversation.messages.new(message_params)
    build_attachment
    @message.save!
  end

  def update
    render json: { error: 'You cannot update the CSAT survey after 14 days' }, status: :unprocessable_entity and return if check_csat_locked

    @message.update!(message_update_params)
  rescue StandardError => e
    render json: { error: @contact.errors, message: e.message }.to_json, status: :internal_server_error
  end

  private

  def build_attachment
    return if params[:attachments].blank?

    params[:attachments].each do |uploaded_attachment|
      @message.attachments.new(
        account_id: @message.account_id,
        file_type: helpers.file_type(uploaded_attachment&.content_type),
        file: uploaded_attachment
      )
    end
  end

  def message_finder_params
    {
      filter_internal_messages: true,
      before: params[:before]
    }
  end

  def message_finder
    @message_finder ||= MessageFinder.new(@conversation, message_finder_params)
  end

  def message_update_params
    params.permit(submitted_values: [:name, :title, :value, { csat_survey_response: [:feedback_message, :rating] }])
  end

  def permitted_params
    params.permit(:content, :echo_id)
  end

  def set_message
    @message = @conversation.messages.find(params[:id])
  end

  def message_params
    {
      account_id: @conversation.account_id,
      sender: @contact_inbox.contact,
      content: permitted_params[:content],
      inbox_id: @conversation.inbox_id,
      echo_id: permitted_params[:echo_id],
      message_type: :incoming
    }
  end

  def check_csat_locked
    (Time.zone.now.to_date - @message.created_at.to_date).to_i > 14 and @message.content_type == 'input_csat'
  end
end

================
File: controllers/public/api/v1/portals/articles_controller.rb
================
class Public::Api::V1::Portals::ArticlesController < Public::Api::V1::Portals::BaseController
  before_action :ensure_custom_domain_request, only: [:show, :index]
  before_action :portal
  before_action :set_category, except: [:index, :show]
  before_action :set_article, only: [:show]
  layout 'portal'

  def index
    @articles = @portal.articles.published
    @articles_count = @articles.count
    search_articles
    order_by_sort_param
    @articles = @articles.page(list_params[:page]) if list_params[:page].present?
  end

  def show; end

  private

  def search_articles
    @articles = @articles.search(list_params) if list_params.present?
  end

  def order_by_sort_param
    @articles = if list_params[:sort].present? && list_params[:sort] == 'views'
                  @articles.order_by_views
                else
                  @articles.order_by_position
                end
  end

  def set_article
    @article = @portal.articles.find_by(slug: permitted_params[:article_slug])
    @article.increment_view_count if @article.published?
    @parsed_content = render_article_content(@article.content)
  end

  def set_category
    return if permitted_params[:category_slug].blank?

    @category = @portal.categories.find_by!(
      slug: permitted_params[:category_slug],
      locale: permitted_params[:locale]
    )
  end

  def list_params
    params.permit(:query, :locale, :sort, :status, :page)
  end

  def permitted_params
    params.permit(:slug, :category_slug, :locale, :id, :article_slug)
  end

  def render_article_content(content)
    ChatwootMarkdownRenderer.new(content).render_article
  end
end

Public::Api::V1::Portals::ArticlesController.prepend_mod_with('Public::Api::V1::Portals::ArticlesController')

================
File: controllers/public/api/v1/portals/base_controller.rb
================
class Public::Api::V1::Portals::BaseController < PublicController
  include SwitchLocale

  before_action :show_plain_layout
  before_action :set_color_scheme
  before_action :set_global_config
  around_action :set_locale
  after_action :allow_iframe_requests

  private

  def show_plain_layout
    @is_plain_layout_enabled = params[:show_plain_layout] == 'true'
  end

  def set_color_scheme
    @theme_from_params = params[:theme] if %w[dark light].include?(params[:theme])
  end

  def portal
    @portal ||= Portal.find_by!(slug: params[:slug], archived: false)
  end

  def set_locale(&)
    switch_locale_with_portal(&) if params[:locale].present?
    switch_locale_with_article(&) if params[:article_slug].present?

    yield
  end

  def switch_locale_with_portal(&)
    @locale = validate_and_get_locale(params[:locale])

    I18n.with_locale(@locale, &)
  end

  def switch_locale_with_article(&)
    article = Article.find_by(slug: params[:article_slug])
    Rails.logger.info "Article: not found for slug: #{params[:article_slug]}"
    render_404 && return if article.blank?

    article_locale = if article.category.present?
                       article.category.locale
                     else
                       article.portal.default_locale
                     end
    @locale = validate_and_get_locale(article_locale)
    I18n.with_locale(@locale, &)
  end

  def allow_iframe_requests
    response.headers.delete('X-Frame-Options') if @is_plain_layout_enabled
  end

  def render_404
    portal
    render 'public/api/v1/portals/error/404', status: :not_found
  end

  def set_global_config
    @global_config = GlobalConfig.get('LOGO_THUMBNAIL', 'BRAND_NAME', 'BRAND_URL')
  end
end

================
File: controllers/public/api/v1/portals/categories_controller.rb
================
class Public::Api::V1::Portals::CategoriesController < Public::Api::V1::Portals::BaseController
  before_action :ensure_custom_domain_request, only: [:show, :index]
  before_action :portal
  before_action :set_category, only: [:show]
  layout 'portal'

  def index
    @categories = @portal.categories.order(position: :asc)
  end

  def show; end

  private

  def set_category
    @category = @portal.categories.find_by(locale: params[:locale], slug: params[:category_slug])

    Rails.logger.info "Category: not found for slug: #{params[:category_slug]}"
    render_404 && return if @category.blank?
  end
end

================
File: controllers/public/api/v1/csat_survey_controller.rb
================
class Public::Api::V1::CsatSurveyController < PublicController
  before_action :set_conversation
  before_action :set_message

  def show; end

  def update
    render json: { error: 'You cannot update the CSAT survey after 14 days' }, status: :unprocessable_entity and return if check_csat_locked

    @message.update!(message_update_params[:message])
  end

  private

  def set_conversation
    return if params[:id].blank?

    @conversation = Conversation.find_by!(uuid: params[:id])
  end

  def set_message
    @message = @conversation.messages.find_by!(content_type: 'input_csat')
  end

  def message_update_params
    params.permit(message: [{ submitted_values: [:name, :title, :value, { csat_survey_response: [:feedback_message, :rating] }] }])
  end

  def check_csat_locked
    (Time.zone.now.to_date - @message.created_at.to_date).to_i > 14
  end
end

================
File: controllers/public/api/v1/inboxes_controller.rb
================
class Public::Api::V1::InboxesController < PublicController
  before_action :set_inbox_channel
  before_action :set_contact_inbox
  before_action :set_conversation

  def show
    @inbox_channel = ::Channel::Api.find_by!(identifier: params[:id])
  end

  private

  def set_inbox_channel
    return if params[:inbox_id].blank?

    @inbox_channel = ::Channel::Api.find_by!(identifier: params[:inbox_id])
  end

  def set_contact_inbox
    return if params[:contact_id].blank?

    @contact_inbox = @inbox_channel.inbox.contact_inboxes.find_by!(source_id: params[:contact_id])
  end

  def set_conversation
    return if params[:conversation_id].blank?

    @conversation = @contact_inbox.contact.conversations.find_by!(display_id: params[:conversation_id])
  end
end

================
File: controllers/public/api/v1/portals_controller.rb
================
class Public::Api::V1::PortalsController < Public::Api::V1::Portals::BaseController
  before_action :ensure_custom_domain_request, only: [:show]
  before_action :portal
  before_action :redirect_to_portal_with_locale, only: [:show]
  layout 'portal'

  def show; end

  def sitemap
    @help_center_url = @portal.custom_domain || ChatwootApp.help_center_root
    # if help_center_url does not contain a protocol, prepend it with https
    @help_center_url = "https://#{@help_center_url}" unless @help_center_url.include?('://')
  end

  private

  def portal
    @portal ||= Portal.find_by!(slug: params[:slug], archived: false)
    @locale = params[:locale] || @portal.default_locale
  end

  def redirect_to_portal_with_locale
    return if params[:locale].present?

    redirect_to "/hc/#{@portal.slug}/#{@portal.default_locale}"
  end
end

================
File: controllers/super_admin/devise/sessions_controller.rb
================
# frozen_string_literal: true

class SuperAdmin::Devise::SessionsController < Devise::SessionsController
  def new
    self.resource = resource_class.new(sign_in_params)
  end

  def create
    redirect_to(super_admin_session_path, flash: { error: @error_message }) && return unless valid_credentials?

    sign_in(:super_admin, @super_admin)
    flash.discard
    redirect_to super_admin_users_path
  end

  def destroy
    sign_out
    flash.discard
    redirect_to '/'
  end

  private

  def valid_credentials?
    @super_admin = SuperAdmin.find_by!(email: params[:super_admin][:email])
    raise StandardError, 'Invalid Password' unless @super_admin.valid_password?(params[:super_admin][:password])

    true
  rescue StandardError => e
    Rails.logger.error e.message
    @error_message = 'Invalid credentials. Please try again.'
    false
  end
end

================
File: controllers/super_admin/access_tokens_controller.rb
================
class SuperAdmin::AccessTokensController < SuperAdmin::ApplicationController
  # Overwrite any of the RESTful controller actions to implement custom behavior
  # For example, you may want to send an email after a foo is updated.
  #
  # def update
  #   super
  #   send_foo_updated_email(requested_resource)
  # end

  # Override this method to specify custom lookup behavior.
  # This will be used to set the resource for the `show`, `edit`, and `update`
  # actions.
  #
  # def find_resource(param)
  #   Foo.find_by!(slug: param)
  # end

  # The result of this lookup will be available as `requested_resource`

  # Override this if you have certain roles that require a subset
  # this will be used to set the records shown on the `index` action.
  #
  # def scoped_resource
  #   if current_user.super_admin?
  #     resource_class
  #   else
  #     resource_class.with_less_stuff
  #   end
  # end

  # Override `resource_params` if you want to transform the submitted
  # data before it's persisted. For example, the following would turn all
  # empty values into nil values. It uses other APIs such as `resource_class`
  # and `dashboard`:
  #
  # def resource_params
  #   params.require(resource_class.model_name.param_key).
  #     permit(dashboard.permitted_attributes).
  #     transform_values { |value| value == "" ? nil : value }
  # end

  # See https://administrate-prototype.herokuapp.com/customizing_controller_actions
  # for more information
end

================
File: controllers/super_admin/account_users_controller.rb
================
class SuperAdmin::AccountUsersController < SuperAdmin::ApplicationController
  # Overwrite any of the RESTful controller actions to implement custom behavior
  # For example, you may want to send an email after a foo is updated.
  #
  def create
    resource = resource_class.new(resource_params)
    authorize_resource(resource)

    notice =  resource.save ? translate_with_resource('create.success') : resource.errors.full_messages.first
    redirect_back(fallback_location: [namespace, resource.account], notice: notice)
  end

  def destroy
    if requested_resource.destroy
      flash[:notice] = translate_with_resource('destroy.success')
    else
      flash[:error] = requested_resource.errors.full_messages.join('<br/>')
    end
    redirect_back(fallback_location: [namespace, requested_resource.account])
  end

  # Override this method to specify custom lookup behavior.
  # This will be used to set the resource for the `show`, `edit`, and `update`
  # actions.
  #
  # def find_resource(param)
  #   Foo.find_by!(slug: param)
  # end

  # The result of this lookup will be available as `requested_resource`

  # Override this if you have certain roles that require a subset
  # this will be used to set the records shown on the `index` action.
  #
  # def scoped_resource
  #   if current_user.super_admin?
  #     resource_class
  #   else
  #     resource_class.with_less_stuff
  #   end
  # end

  # Override `resource_params` if you want to transform the submitted
  # data before it's persisted. For example, the following would turn all
  # empty values into nil values. It uses other APIs such as `resource_class`
  # and `dashboard`:
  #
  # def resource_params
  #   params.require(resource_class.model_name.param_key).
  #     permit(dashboard.permitted_attributes).
  #     transform_values { |value| value == "" ? nil : value }
  # end

  # See https://administrate-prototype.herokuapp.com/customizing_controller_actions
  # for more information
end

================
File: controllers/super_admin/accounts_controller.rb
================
class SuperAdmin::AccountsController < SuperAdmin::ApplicationController
  # Overwrite any of the RESTful controller actions to implement custom behavior
  # For example, you may want to send an email after a foo is updated.
  #
  # def update
  #   super
  #   send_foo_updated_email(requested_resource)
  # end

  # Override this method to specify custom lookup behavior.
  # This will be used to set the resource for the `show`, `edit`, and `update`
  # actions.
  #
  # def find_resource(param)
  #   Foo.find_by!(slug: param)
  # end

  # The result of this lookup will be available as `requested_resource`

  # Override this if you have certain roles that require a subset
  # this will be used to set the records shown on the `index` action.
  #
  # def scoped_resource
  #   if current_user.super_admin?
  #     resource_class
  #   else
  #     resource_class.with_less_stuff
  #   end
  # end

  # Override `resource_params` if you want to transform the submitted
  # data before it's persisted. For example, the following would turn all
  # empty values into nil values. It uses other APIs such as `resource_class`
  # and `dashboard`:
  #
  def resource_params
    permitted_params = super
    permitted_params[:limits] = permitted_params[:limits].to_h.compact
    permitted_params[:selected_feature_flags] = params[:enabled_features].keys.map(&:to_sym) if params[:enabled_features].present?
    permitted_params
  end

  # See https://administrate-prototype.herokuapp.com/customizing_controller_actions
  # for more information

  def seed
    Internal::SeedAccountJob.perform_later(requested_resource)
    # rubocop:disable Rails/I18nLocaleTexts
    redirect_back(fallback_location: [namespace, requested_resource], notice: 'Account seeding triggered')
    # rubocop:enable Rails/I18nLocaleTexts
  end

  def reset_cache
    requested_resource.reset_cache_keys
    # rubocop:disable Rails/I18nLocaleTexts
    redirect_back(fallback_location: [namespace, requested_resource], notice: 'Cache keys cleared')
    # rubocop:enable Rails/I18nLocaleTexts
  end

  def destroy
    account = Account.find(params[:id])

    DeleteObjectJob.perform_later(account) if account.present?
    # rubocop:disable Rails/I18nLocaleTexts
    redirect_back(fallback_location: [namespace, requested_resource], notice: 'Account deletion is in progress.')
    # rubocop:enable Rails/I18nLocaleTexts
  end
end

================
File: controllers/super_admin/agent_bots_controller.rb
================
class SuperAdmin::AgentBotsController < SuperAdmin::ApplicationController
  # Overwrite any of the RESTful controller actions to implement custom behavior
  # For example, you may want to send an email after a foo is updated.
  #
  # def update
  #   super
  #   send_foo_updated_email(requested_resource)
  # end

  # Override this method to specify custom lookup behavior.
  # This will be used to set the resource for the `show`, `edit`, and `update`
  # actions.
  #
  # def find_resource(param)
  #   Foo.find_by!(slug: param)
  # end

  # The result of this lookup will be available as `requested_resource`

  # Override this if you have certain roles that require a subset
  # this will be used to set the records shown on the `index` action.
  #
  # def scoped_resource
  #   if current_user.super_admin?
  #     resource_class
  #   else
  #     resource_class.with_less_stuff
  #   end
  # end

  # Override `resource_params` if you want to transform the submitted
  # data before it's persisted. For example, the following would turn all
  # empty values into nil values. It uses other APIs such as `resource_class`
  # and `dashboard`:
  #
  # def resource_params
  #   params.require(resource_class.model_name.param_key).
  #     permit(dashboard.permitted_attributes).
  #     transform_values { |value| value == "" ? nil : value }
  # end

  # See https://administrate-prototype.herokuapp.com/customizing_controller_actions
  # for more information

  def destroy_avatar
    avatar = requested_resource.avatar
    avatar.purge
    redirect_back(fallback_location: super_admin_agent_bots_path)
  end

  def scoped_resource
    resource_class.with_attached_avatar
  end
end

================
File: controllers/super_admin/app_configs_controller.rb
================
class SuperAdmin::AppConfigsController < SuperAdmin::ApplicationController
  before_action :set_config
  before_action :allowed_configs
  def show
    # ref: https://github.com/rubocop/rubocop/issues/7767
    # rubocop:disable Style/HashTransformValues
    @app_config = InstallationConfig.where(name: @allowed_configs)
                                    .pluck(:name, :serialized_value)
                                    .map { |name, serialized_value| [name, serialized_value['value']] }
                                    .to_h
    # rubocop:enable Style/HashTransformValues
    @installation_configs = ConfigLoader.new.general_configs.each_with_object({}) do |config_hash, result|
      result[config_hash['name']] = config_hash.except('name')
    end
  end

  def create
    params['app_config'].each do |key, value|
      next unless @allowed_configs.include?(key)

      i = InstallationConfig.where(name: key).first_or_create(value: value, locked: false)
      i.value = value
      i.save!
    end
    redirect_to super_admin_settings_path, notice: "App Configs - #{@config.titleize} updated successfully"
  end

  private

  def set_config
    @config = params[:config] || 'general'
  end

  def allowed_configs
    @allowed_configs = case @config
                       when 'facebook'
                         %w[FB_APP_ID FB_VERIFY_TOKEN FB_APP_SECRET IG_VERIFY_TOKEN FACEBOOK_API_VERSION ENABLE_MESSENGER_CHANNEL_HUMAN_AGENT]
                       when 'microsoft'
                         %w[AZURE_APP_ID AZURE_APP_SECRET]
                       when 'email'
                         ['MAILER_INBOUND_EMAIL_DOMAIN']
                       when 'linear'
                         %w[LINEAR_CLIENT_ID LINEAR_CLIENT_SECRET]
                       else
                         %w[ENABLE_ACCOUNT_SIGNUP FIREBASE_PROJECT_ID FIREBASE_CREDENTIALS]
                       end
  end
end

SuperAdmin::AppConfigsController.prepend_mod_with('SuperAdmin::AppConfigsController')

================
File: controllers/super_admin/application_controller.rb
================
# All Administrate controllers inherit from this
# `Administrate::ApplicationController`, making it the ideal place to put
# authentication logic or other before_actions.
#
# If you want to add pagination or other controller-level concerns,
# you're free to overwrite the RESTful controller actions.
class SuperAdmin::ApplicationController < Administrate::ApplicationController
  include ActionView::Helpers::TagHelper
  include ActionView::Context

  helper_method :render_vue_component
  # authenticiation done via devise : SuperAdmin Model
  before_action :authenticate_super_admin!

  # Override this value to specify the number of elements to display at a time
  # on index pages. Defaults to 20.
  # def records_per_page
  #   params[:per_page] || 20
  # end

  def order
    @order ||= Administrate::Order.new(
      params.fetch(resource_name, {}).fetch(:order, 'id'),
      params.fetch(resource_name, {}).fetch(:direction, 'desc')
    )
  end

  private

  def render_vue_component(component_name, props = {})
    html_options = {
      id: 'app',
      data: {
        component_name: component_name,
        props: props.to_json
      }
    }
    content_tag(:div, '', html_options)
  end

  def invalid_action_perfomed
    # rubocop:disable Rails/I18nLocaleTexts
    flash[:error] = 'Invalid action performed'
    # rubocop:enable Rails/I18nLocaleTexts
    redirect_back(fallback_location: root_path)
  end
end

================
File: controllers/super_admin/dashboard_controller.rb
================
class SuperAdmin::DashboardController < SuperAdmin::ApplicationController
  include ActionView::Helpers::NumberHelper

  def index
    @data = Conversation.unscoped.group_by_day(:created_at, range: 30.days.ago..2.seconds.ago).count.to_a
    @accounts_count = number_with_delimiter(Account.count)
    @users_count = number_with_delimiter(User.count)
    @inboxes_count = number_with_delimiter(Inbox.count)
    @conversations_count = number_with_delimiter(Conversation.count)
  end
end

================
File: controllers/super_admin/installation_configs_controller.rb
================
class SuperAdmin::InstallationConfigsController < SuperAdmin::ApplicationController
  rescue_from ActiveRecord::RecordNotUnique, :with => :invalid_action_perfomed
  # Overwrite any of the RESTful controller actions to implement custom behavior
  # For example, you may want to send an email after a foo is updated.
  #
  # def update
  #   super
  #   send_foo_updated_email(requested_resource)
  # end

  # Override this method to specify custom lookup behavior.
  # This will be used to set the resource for the `show`, `edit`, and `update`
  # actions.
  #
  # def find_resource(param)
  #   Foo.find_by!(slug: param)
  # end

  # The result of this lookup will be available as `requested_resource`

  # Override this if you have certain roles that require a subset
  # this will be used to set the records shown on the `index` action.
  #
  def scoped_resource
    resource_class.editable
  end

  # Override `resource_params` if you want to transform the submitted
  # data before it's persisted. For example, the following would turn all
  # empty values into nil values. It uses other APIs such as `resource_class`
  # and `dashboard`:
  #
  # def resource_params
  #   params.require(resource_class.model_name.param_key).
  #     permit(dashboard.permitted_attributes).
  #     transform_values { |value| value == "" ? nil : value }
  # end

  def resource_params
    params.require(:installation_config)
          .permit(:name, :value)
          .transform_values { |value| value == '' ? nil : value }.merge(locked: false)
  end

  # See https://administrate-prototype.herokuapp.com/customizing_controller_actions
  # for more information
end

================
File: controllers/super_admin/instance_statuses_controller.rb
================
class SuperAdmin::InstanceStatusesController < SuperAdmin::ApplicationController
  def show
    @metrics = {}
    chatwoot_version
    sha
    postgres_status
    redis_metrics
    chatwoot_edition
    instance_meta
  end

  def chatwoot_edition
    @metrics['Chatwoot edition'] = if ChatwootApp.enterprise?
                                     'Enterprise'
                                   elsif ChatwootApp.custom?
                                     'Custom'
                                   else
                                     'Community'
                                   end
  end

  def instance_meta
    @metrics['Database Migrations'] = ActiveRecord::Base.connection.migration_context.needs_migration? ? 'pending' : 'completed'
  end

  def chatwoot_version
    @metrics['Chatwoot version'] = Chatwoot.config[:version]
  end

  def sha
    @metrics['Git SHA'] = GIT_HASH
  end

  def postgres_status
    @metrics['Postgres alive'] = if ActiveRecord::Base.connection.active?
                                   'true'
                                 else
                                   'false'
                                 end
  end

  def redis_metrics
    r = Redis.new(Redis::Config.app)
    if r.ping == 'PONG'
      redis_server = r.info
      @metrics['Redis alive'] = 'true'
      @metrics['Redis version'] = redis_server['redis_version']
      @metrics['Redis number of connected clients'] = redis_server['connected_clients']
      @metrics["Redis 'maxclients' setting"] = redis_server['maxclients']
      @metrics['Redis memory used'] = redis_server['used_memory_human']
      @metrics['Redis memory peak'] = redis_server['used_memory_peak_human']
      @metrics['Redis total memory available'] = redis_server['total_system_memory_human']
      @metrics["Redis 'maxmemory' setting"] = redis_server['maxmemory']
      @metrics["Redis 'maxmemory_policy' setting"] = redis_server['maxmemory_policy']
    end
  rescue Redis::CannotConnectError
    @metrics['Redis alive'] = false
  end
end

================
File: controllers/super_admin/platform_apps_controller.rb
================
class SuperAdmin::PlatformAppsController < SuperAdmin::ApplicationController
  # Overwrite any of the RESTful controller actions to implement custom behavior
  # For example, you may want to send an email after a foo is updated.
  #
  # def update
  #   super
  #   send_foo_updated_email(requested_resource)
  # end

  # Override this method to specify custom lookup behavior.
  # This will be used to set the resource for the `show`, `edit`, and `update`
  # actions.
  #
  # def find_resource(param)
  #   Foo.find_by!(slug: param)
  # end

  # The result of this lookup will be available as `requested_resource`

  # Override this if you have certain roles that require a subset
  # this will be used to set the records shown on the `index` action.
  #
  # def scoped_resource
  #   if current_user.super_admin?
  #     resource_class
  #   else
  #     resource_class.with_less_stuff
  #   end
  # end

  # Override `resource_params` if you want to transform the submitted
  # data before it's persisted. For example, the following would turn all
  # empty values into nil values. It uses other APIs such as `resource_class`
  # and `dashboard`:
  #
  # def resource_params
  #   params.require(resource_class.model_name.param_key).
  #     permit(dashboard.permitted_attributes).
  #     transform_values { |value| value == "" ? nil : value }
  # end

  # See https://administrate-prototype.herokuapp.com/customizing_controller_actions
  # for more information
end

================
File: controllers/super_admin/settings_controller.rb
================
class SuperAdmin::SettingsController < SuperAdmin::ApplicationController
  def show; end

  def refresh
    Internal::CheckNewVersionsJob.perform_now
    # rubocop:disable Rails/I18nLocaleTexts
    redirect_to super_admin_settings_path, notice: 'Instance status refreshed'
    # rubocop:enable Rails/I18nLocaleTexts
  end
end

================
File: controllers/super_admin/users_controller.rb
================
class SuperAdmin::UsersController < SuperAdmin::ApplicationController
  # Overwrite any of the RESTful controller actions to implement custom behavior
  # For example, you may want to send an email after a foo is updated.

  def create
    resource = resource_class.new(resource_params)
    authorize_resource(resource)

    if resource.save
      redirect_to super_admin_user_path(resource), notice: translate_with_resource('create.success')
    else
      notice = resource.errors.full_messages.first
      redirect_to new_super_admin_user_path, notice: notice
    end
  end
  #
  # def update
  #   super
  #   send_foo_updated_email(requested_resource)
  # end

  # Override this method to specify custom lookup behavior.
  # This will be used to set the resource for the `show`, `edit`, and `update`
  # actions.
  #
  # def find_resource(param)
  #   Foo.find_by!(slug: param)
  # end

  # The result of this lookup will be available as `requested_resource`

  # Override this if you have certain roles that require a subset
  # this will be used to set the records shown on the `index` action.
  #
  # def scoped_resource
  #   if current_user.super_admin?
  #     resource_class
  #   else
  #     resource_class.with_less_stuff
  #   end
  # end

  # Override `resource_params` if you want to transform the submitted
  # data before it's persisted. For example, the following would turn all
  # empty values into nil values. It uses other APIs such as `resource_class`
  # and `dashboard`:
  #

  def destroy_avatar
    avatar = requested_resource.avatar
    avatar.purge
    redirect_back(fallback_location: super_admin_users_path)
  end

  def scoped_resource
    resource_class.with_attached_avatar
  end

  def resource_params
    permitted_params = super
    permitted_params.delete(:password) if permitted_params[:password].blank?
    permitted_params
  end

  # See https://administrate-prototype.herokuapp.com/customizing_controller_actions
  # for more information
  def find_resource(param)
    super.becomes(User)
  end
end

================
File: controllers/survey/responses_controller.rb
================
class Survey::ResponsesController < ActionController::Base
  before_action :set_global_config
  def show; end

  private

  def set_global_config
    @global_config = GlobalConfig.get('LOGO_THUMBNAIL', 'BRAND_NAME', 'WIDGET_BRAND_URL')
  end
end

================
File: controllers/twilio/callback_controller.rb
================
class Twilio::CallbackController < ApplicationController
  def create
    ::Twilio::IncomingMessageService.new(params: permitted_params).perform

    head :no_content
  end

  private

  def permitted_params # rubocop:disable Metrics/MethodLength
    params.permit(
      :ApiVersion,
      :SmsSid,
      :From,
      :ToState,
      :ToZip,
      :AccountSid,
      :MessageSid,
      :FromCountry,
      :ToCity,
      :FromCity,
      :To,
      :FromZip,
      :Body,
      :ToCountry,
      :FromState,
      :MediaUrl0,
      :MediaContentType0,
      :MessagingServiceSid
    )
  end
end

================
File: controllers/twilio/delivery_status_controller.rb
================
class Twilio::DeliveryStatusController < ApplicationController
  def create
    ::Twilio::DeliveryStatusService.new(params: permitted_params).perform

    head :no_content
  end

  private

  def permitted_params
    params.permit(
      :AccountSid,
      :From,
      :MessageSid,
      :MessagingServiceSid,
      :MessageStatus,
      :ErrorCode,
      :ErrorMessage
    )
  end
end

================
File: controllers/twitter/base_controller.rb
================
class Twitter::BaseController < ApplicationController
  include TwitterConcern
end

================
File: controllers/twitter/callbacks_controller.rb
================
class Twitter::CallbacksController < Twitter::BaseController
  include TwitterConcern

  def show
    return redirect_to twitter_app_redirect_url if permitted_params[:denied]

    @response = ensure_access_token
    return redirect_to twitter_app_redirect_url if @response.status != '200'

    ActiveRecord::Base.transaction do
      inbox = create_inbox
      ::Redis::Alfred.delete(permitted_params[:oauth_token])
      ::Twitter::WebhookSubscribeService.new(inbox_id: inbox.id).perform
      redirect_to app_twitter_inbox_agents_url(account_id: account.id, inbox_id: inbox.id)
    end
  rescue StandardError => e
    ChatwootExceptionTracker.new(e).capture_exception
    redirect_to twitter_app_redirect_url
  end

  private

  def parsed_body
    @parsed_body ||= Rack::Utils.parse_nested_query(@response.raw_response.body)
  end

  def account_id
    ::Redis::Alfred.get(permitted_params[:oauth_token])
  end

  def account
    @account ||= Account.find(account_id)
  end

  def twitter_app_redirect_url
    app_new_twitter_inbox_url(account_id: account.id)
  end

  def ensure_access_token
    twitter_client.access_token(
      oauth_token: permitted_params[:oauth_token],
      oauth_verifier: permitted_params[:oauth_verifier]
    )
  end

  def create_inbox
    twitter_profile = account.twitter_profiles.create!(
      twitter_access_token: parsed_body['oauth_token'],
      twitter_access_token_secret: parsed_body['oauth_token_secret'],
      profile_id: parsed_body['user_id']
    )
    inbox = account.inboxes.create!(
      name: parsed_body['screen_name'],
      channel: twitter_profile
    )
    save_profile_image(inbox)
    inbox
  end

  def save_profile_image(inbox)
    response = twitter_client.user_show(screen_name: inbox.name)

    return unless response.status.to_i == 200

    parsed_user_profile = response.body

    ::Avatar::AvatarFromUrlJob.perform_later(inbox, parsed_user_profile['profile_image_url_https'])
  end

  def permitted_params
    params.permit(:oauth_token, :oauth_verifier, :denied)
  end
end

================
File: controllers/webhooks/instagram_controller.rb
================
class Webhooks::InstagramController < ActionController::API
  include MetaTokenVerifyConcern

  def events
    Rails.logger.info('Instagram webhook received events')
    if params['object'].casecmp('instagram').zero?
      ::Webhooks::InstagramEventsJob.perform_later(params.to_unsafe_hash[:entry])
      render json: :ok
    else
      Rails.logger.warn("Message is not received from the instagram webhook event: #{params['object']}")
      head :unprocessable_entity
    end
  end

  private

  def valid_token?(token)
    token == GlobalConfigService.load('IG_VERIFY_TOKEN', '')
  end
end

================
File: controllers/webhooks/line_controller.rb
================
class Webhooks::LineController < ActionController::API
  def process_payload
    Webhooks::LineEventsJob.perform_later(params: params.to_unsafe_hash, signature: request.headers['x-line-signature'], post_body: request.raw_post)
    head :ok
  end
end

================
File: controllers/webhooks/sms_controller.rb
================
class Webhooks::SmsController < ActionController::API
  def process_payload
    Webhooks::SmsEventsJob.perform_later(params['_json']&.first&.to_unsafe_hash)
    head :ok
  end
end

================
File: controllers/webhooks/telegram_controller.rb
================
class Webhooks::TelegramController < ActionController::API
  def process_payload
    Webhooks::TelegramEventsJob.perform_later(params.to_unsafe_hash)
    head :ok
  end
end

================
File: controllers/webhooks/whatsapp_controller.rb
================
class Webhooks::WhatsappController < ActionController::API
  include MetaTokenVerifyConcern

  def process_payload
    Webhooks::WhatsappEventsJob.perform_later(params.to_unsafe_hash)
    head :ok
  end

  private

  def valid_token?(token)
    channel = Channel::Whatsapp.find_by(phone_number: params[:phone_number])
    whatsapp_webhook_verify_token = channel.provider_config['webhook_verify_token'] if channel.present?
    token == whatsapp_webhook_verify_token if whatsapp_webhook_verify_token.present?
  end
end

================
File: controllers/android_app_controller.rb
================
class AndroidAppController < ApplicationController
  def assetlinks
    render layout: false
  end
end

================
File: controllers/api_controller.rb
================
class ApiController < ApplicationController
  skip_before_action :set_current_user, only: [:index]

  def index
    render json: { version: Chatwoot.config[:version],
                   timestamp: Time.now.utc.to_fs(:db),
                   queue_services: redis_status,
                   data_services: postgres_status }
  end

  private

  def redis_status
    r = Redis.new(Redis::Config.app)
    return 'ok' if r.ping
  rescue Redis::CannotConnectError
    'failing'
  end

  def postgres_status
    ActiveRecord::Base.connection.active? ? 'ok' : 'failing'
  rescue ActiveRecord::ConnectionNotEstablished
    'failing'
  end
end

================
File: controllers/apple_app_controller.rb
================
class AppleAppController < ApplicationController
  def site_association
    site_association_json = render_to_string action: 'site_association', layout: false
    send_data site_association_json, filename: 'apple-app-site-association', type: 'application/json'
  end
end

================
File: controllers/application_controller.rb
================
class ApplicationController < ActionController::Base
  include DeviseTokenAuth::Concerns::SetUserByToken
  include RequestExceptionHandler
  include Pundit::Authorization
  include SwitchLocale

  skip_before_action :verify_authenticity_token

  before_action :set_current_user, unless: :devise_controller?
  around_action :switch_locale
  around_action :handle_with_exception, unless: :devise_controller?

  private

  def set_current_user
    @user ||= current_user
    Current.user = @user
  end

  def pundit_user
    {
      user: Current.user,
      account: Current.account,
      account_user: Current.account_user
    }
  end
end
ApplicationController.include_mod_with('Concerns::ApplicationControllerConcern')

================
File: controllers/dashboard_controller.rb
================
class DashboardController < ActionController::Base
  include SwitchLocale

  before_action :set_application_pack
  before_action :set_global_config
  before_action :set_dashboard_scripts
  around_action :switch_locale
  before_action :ensure_installation_onboarding, only: [:index]
  before_action :render_hc_if_custom_domain, only: [:index]
  before_action :ensure_html_format
  layout 'vueapp'

  def index; end

  private

  def ensure_html_format
    head :not_acceptable unless request.format.html?
  end

  def set_global_config
    @global_config = GlobalConfig.get(
      'LOGO', 'LOGO_DARK', 'LOGO_THUMBNAIL',
      'INSTALLATION_NAME',
      'WIDGET_BRAND_URL', 'TERMS_URL',
      'BRAND_URL', 'BRAND_NAME',
      'PRIVACY_URL',
      'DISPLAY_MANIFEST',
      'CREATE_NEW_ACCOUNT_FROM_DASHBOARD',
      'CHATWOOT_INBOX_TOKEN',
      'API_CHANNEL_NAME',
      'API_CHANNEL_THUMBNAIL',
      'ANALYTICS_TOKEN',
      'DIRECT_UPLOADS_ENABLED',
      'HCAPTCHA_SITE_KEY',
      'LOGOUT_REDIRECT_LINK',
      'DISABLE_USER_PROFILE_UPDATE',
      'DEPLOYMENT_ENV',
      'CSML_EDITOR_HOST', 'INSTALLATION_PRICING_PLAN'
    ).merge(app_config)
  end

  def set_dashboard_scripts
    @dashboard_scripts = sensitive_path? ? nil : GlobalConfig.get_value('DASHBOARD_SCRIPTS')
  end

  def ensure_installation_onboarding
    redirect_to '/installation/onboarding' if ::Redis::Alfred.get(::Redis::Alfred::CHATWOOT_INSTALLATION_ONBOARDING)
  end

  def render_hc_if_custom_domain
    domain = request.host
    return if domain == URI.parse(ENV.fetch('FRONTEND_URL', '')).host

    @portal = Portal.find_by(custom_domain: domain)
    return unless @portal

    @locale = @portal.default_locale
    render 'public/api/v1/portals/show', layout: 'portal', portal: @portal and return
  end

  def app_config
    {
      APP_VERSION: Chatwoot.config[:version],
      VAPID_PUBLIC_KEY: VapidService.public_key,
      ENABLE_ACCOUNT_SIGNUP: GlobalConfigService.load('ENABLE_ACCOUNT_SIGNUP', 'false'),
      FB_APP_ID: GlobalConfigService.load('FB_APP_ID', ''),
      FACEBOOK_API_VERSION: GlobalConfigService.load('FACEBOOK_API_VERSION', 'v17.0'),
      IS_ENTERPRISE: ChatwootApp.enterprise?,
      AZURE_APP_ID: GlobalConfigService.load('AZURE_APP_ID', ''),
      GIT_SHA: GIT_HASH
    }
  end

  def set_application_pack
    @application_pack = if request.path.include?('/auth') || request.path.include?('/login')
                          'v3app'
                        else
                          'dashboard'
                        end
  end

  def sensitive_path?
    # dont load dashboard scripts on sensitive paths like password reset
    sensitive_paths = [edit_user_password_path].freeze

    # remove app prefix
    current_path = request.path.gsub(%r{^/app}, '')

    sensitive_paths.include?(current_path)
  end
end

================
File: controllers/microsoft_controller.rb
================
class MicrosoftController < ApplicationController
  after_action :set_version_header

  def identity_association
    microsoft_indentity
  end

  private

  def set_version_header
    response.headers['Content-Length'] = { associatedApplications: [{ applicationId: @identity_json }] }.to_json.length
  end

  def microsoft_indentity
    @identity_json = GlobalConfigService.load('AZURE_APP_ID', nil)
  end
end

================
File: controllers/oauth_callback_controller.rb
================
class OauthCallbackController < ApplicationController
  def show
    @response = oauth_client.auth_code.get_token(
      oauth_code,
      redirect_uri: "#{base_url}/#{provider_name}/callback"
    )

    handle_response
    ::Redis::Alfred.delete(cache_key)
  rescue StandardError => e
    ChatwootExceptionTracker.new(e).capture_exception
    redirect_to '/'
  end

  private

  def handle_response
    inbox, already_exists = find_or_create_inbox

    if already_exists
      redirect_to app_email_inbox_settings_url(account_id: account.id, inbox_id: inbox.id)
    else
      redirect_to app_email_inbox_agents_url(account_id: account.id, inbox_id: inbox.id)
    end
  end

  def find_or_create_inbox
    channel_email = find_channel_by_email
    # we need this value to know where to redirect on sucessful processing of the callback
    channel_exists = channel_email.present?

    channel_email ||= create_channel_with_inbox
    update_channel(channel_email)

    # reauthorize channel, this code path only triggers when microsoft auth is successful
    # reauthorized will also update cache keys for the associated inbox
    channel_email.reauthorized!

    [channel_email.inbox, channel_exists]
  end

  def find_channel_by_email
    Channel::Email.find_by(email: users_data['email'], account: account)
  end

  def update_channel(channel_email)
    channel_email.update!({
                            imap_login: users_data['email'], imap_address: imap_address,
                            imap_port: '993', imap_enabled: true,
                            provider: provider_name,
                            provider_config: {
                              access_token: parsed_body['access_token'],
                              refresh_token: parsed_body['refresh_token'],
                              expires_on: (Time.current.utc + 1.hour).to_s
                            }
                          })
  end

  def provider_name
    raise NotImplementedError
  end

  def oauth_client
    raise NotImplementedError
  end

  def cache_key
    "#{provider_name}::#{users_data['email'].downcase}"
  end

  def create_channel_with_inbox
    ActiveRecord::Base.transaction do
      channel_email = Channel::Email.create!(email: users_data['email'], account: account)
      account.inboxes.create!(
        account: account,
        channel: channel_email,
        name: users_data['name'] || fallback_name
      )
      channel_email
    end
  end

  def users_data
    decoded_token = JWT.decode parsed_body[:id_token], nil, false
    decoded_token[0]
  end

  def account_id
    ::Redis::Alfred.get(cache_key)
  end

  def account
    @account ||= Account.find(account_id)
  end

  # Fallback name, for when name field is missing from users_data
  def fallback_name
    users_data['email'].split('@').first.parameterize.titleize
  end

  def oauth_code
    params[:code]
  end

  def base_url
    ENV.fetch('FRONTEND_URL', 'http://localhost:3000')
  end

  def parsed_body
    @parsed_body ||= @response.response.parsed
  end
end

================
File: controllers/platform_controller.rb
================
class PlatformController < ActionController::API
  include RequestExceptionHandler

  before_action :ensure_access_token
  before_action :set_platform_app
  before_action :set_resource, only: [:update, :show, :destroy]
  before_action :validate_platform_app_permissible, only: [:update, :show, :destroy]

  def show; end

  def update; end

  def destroy; end

  private

  def ensure_access_token
    token = request.headers[:api_access_token] || request.headers[:HTTP_API_ACCESS_TOKEN]
    @access_token = AccessToken.find_by(token: token) if token.present?
  end

  def set_platform_app
    @platform_app = @access_token.owner if @access_token && @access_token.owner.is_a?(PlatformApp)
    render json: { error: 'Invalid access_token' }, status: :unauthorized if @platform_app.blank?
  end

  def set_resource
    # set @resource in your controller
    raise 'Overwrite this method your controller'
  end

  def validate_platform_app_permissible
    return if @platform_app.platform_app_permissibles.find_by(permissible: @resource)

    render json: { error: 'Non permissible resource' }, status: :unauthorized
  end
end

================
File: controllers/public_controller.rb
================
# TODO: we should switch to ActionController::API for the base classes
# One of the specs is failing when I tried doing that, lets revisit in future
class PublicController < ActionController::Base
  include RequestExceptionHandler
  skip_before_action :verify_authenticity_token

  private

  def ensure_custom_domain_request
    domain = request.host
    return if DomainHelper.chatwoot_domain?(domain)

    @portal = ::Portal.find_by(custom_domain: domain)
    return if @portal.present?

    render json: {
      error: "Domain: #{domain} is not registered with us. \
      Please send us an email at support@chatwoot.com with the custom domain name and account API key"
    }, status: :unauthorized and return
  end
end

================
File: controllers/slack_uploads_controller.rb
================
class SlackUploadsController < ApplicationController
  include Rails.application.routes.url_helpers
  before_action :set_blob, only: [:show]

  def show
    if @blob
      redirect_to blob_url
    else
      redirect_to avatar_url
    end
  end

  private

  def set_blob
    @blob = ActiveStorage::Blob.find_by(key: params[:blob_key])
  end

  def blob_url
    url_for(@blob.representation(resize_to_fill: [250, nil]))
  end

  def avatar_url
    base_url = ENV.fetch('FRONTEND_URL', nil)
    "#{base_url}/integrations/slack/#{params[:sender_type]}.png"
  end
end

================
File: controllers/swagger_controller.rb
================
class SwaggerController < ApplicationController
  def respond
    if Rails.env.development? || Rails.env.test?
      render inline: Rails.root.join('swagger', derived_path).read
    else
      head :not_found
    end
  end

  private

  def derived_path
    params[:path] ||= 'index.html'
    path = Rack::Utils.clean_path_info(params[:path])
    path << ".#{Rack::Utils.clean_path_info(params[:format])}" unless path.ends_with?(params[:format].to_s)
    path
  end
end

================
File: controllers/widget_tests_controller.rb
================
class WidgetTestsController < ActionController::Base
  before_action :ensure_web_widget
  before_action :ensure_widget_position
  before_action :ensure_widget_type
  before_action :ensure_widget_style
  before_action :ensure_dark_mode

  def index
    render
  end

  private

  def ensure_widget_style
    @widget_style = params[:widget_style] || 'standard'
  end

  def ensure_dark_mode
    @dark_mode = params[:dark_mode] || 'light'
  end

  def ensure_widget_position
    @widget_position = params[:position] || 'left'
  end

  def ensure_widget_type
    @widget_type = params[:type] || 'expanded_bubble'
  end

  def inbox_id
    @inbox_id ||= params[:inbox_id] || Channel::WebWidget.first.inbox.id
  end

  def ensure_web_widget
    @inbox = Inbox.find(inbox_id)
    @web_widget = @inbox.channel
  end
end

================
File: controllers/widgets_controller.rb
================
# TODO : Delete this and associated spec once 'api/widget/config' end point is merged
class WidgetsController < ActionController::Base
  include WidgetHelper

  before_action :set_global_config
  before_action :set_web_widget
  before_action :ensure_account_is_active
  before_action :ensure_location_is_supported
  before_action :set_token
  before_action :set_contact
  before_action :build_contact
  after_action :allow_iframe_requests

  private

  def set_global_config
    @global_config = GlobalConfig.get('LOGO_THUMBNAIL', 'BRAND_NAME', 'WIDGET_BRAND_URL', 'DIRECT_UPLOADS_ENABLED')
  end

  def set_web_widget
    @web_widget = ::Channel::WebWidget.find_by!(website_token: permitted_params[:website_token])
  rescue ActiveRecord::RecordNotFound
    Rails.logger.error('web widget does not exist')
    render json: { error: 'web widget does not exist' }, status: :not_found
  end

  def set_token
    @token = permitted_params[:cw_conversation]
    @auth_token_params = if @token.present?
                           ::Widget::TokenService.new(token: @token).decode_token
                         else
                           {}
                         end
  end

  def set_contact
    return if @auth_token_params[:source_id].nil?

    @contact_inbox = ::ContactInbox.find_by(
      inbox_id: @web_widget.inbox.id,
      source_id: @auth_token_params[:source_id]
    )

    @contact = @contact_inbox&.contact
  end

  def build_contact
    return if @contact.present?

    @contact_inbox, @token = build_contact_inbox_with_token(@web_widget, additional_attributes)
    @contact = @contact_inbox.contact
  end

  def ensure_account_is_active
    render json: { error: 'Account is suspended' }, status: :unauthorized unless @web_widget.inbox.account.active?
  end

  def ensure_location_is_supported; end

  def additional_attributes
    if @web_widget.inbox.account.feature_enabled?('ip_lookup')
      { created_at_ip: request.remote_ip }
    else
      {}
    end
  end

  def permitted_params
    params.permit(:website_token, :cw_conversation)
  end

  def allow_iframe_requests
    response.headers.delete('X-Frame-Options')
  end
end

WidgetsController.prepend_mod_with('WidgetsController')

================
File: dashboards/access_token_dashboard.rb
================
require 'administrate/base_dashboard'

class AccessTokenDashboard < Administrate::BaseDashboard
  # ATTRIBUTE_TYPES
  # a hash that describes the type of each of the model's fields.
  #
  # Each different type represents an Administrate::Field object,
  # which determines how the attribute is displayed
  # on pages throughout the dashboard.
  ATTRIBUTE_TYPES = {
    owner: Field::Polymorphic,
    id: Field::Number,
    token: SecretField,
    created_at: Field::DateTime,
    updated_at: Field::DateTime
  }.freeze

  # COLLECTION_ATTRIBUTES
  # an array of attributes that will be displayed on the model's index page.
  #
  # By default, it's limited to four items to reduce clutter on index pages.
  # Feel free to add, remove, or rearrange items.
  COLLECTION_ATTRIBUTES = %i[
    owner
    id
    token
    created_at
  ].freeze

  # SHOW_PAGE_ATTRIBUTES
  # an array of attributes that will be displayed on the model's show page.
  SHOW_PAGE_ATTRIBUTES = %i[
    token
  ].freeze

  # FORM_ATTRIBUTES
  # an array of attributes that will be displayed
  # on the model's form (`new` and `edit`) pages.
  FORM_ATTRIBUTES = %i[
    owner
    token
  ].freeze

  # COLLECTION_FILTERS
  # a hash that defines filters that can be used while searching via the search
  # field of the dashboard.
  #
  # For example to add an option to search for open resources by typing "open:"
  # in the search field:
  #
  #   COLLECTION_FILTERS = {
  #     open: ->(resources) { resources.where(open: true) }
  #   }.freeze
  COLLECTION_FILTERS = {
    user: ->(resources) { resources.where(owner_type: 'User') },
    agent_bot: ->(resources) { resources.where(owner_type: 'AgentBot') },
    platform_app: ->(resources) { resources.where(owner_type: 'PlatformApp') }
  }.freeze

  # Overwrite this method to customize how access tokens are displayed
  # across all pages of the admin dashboard.
  #
  # def display_resource(access_token)
  #   "AccessToken ##{access_token.id}"
  # end
end

================
File: dashboards/account_dashboard.rb
================
require 'administrate/base_dashboard'

class AccountDashboard < Administrate::BaseDashboard
  # ATTRIBUTE_TYPES
  # a hash that describes the type of each of the model's fields.
  #
  # Each different type represents an Administrate::Field object,
  # which determines how the attribute is displayed
  # on pages throughout the dashboard.

  enterprise_attribute_types = if ChatwootApp.enterprise?
                                 {
                                   limits: Enterprise::AccountLimitsField,
                                   all_features: Enterprise::AccountFeaturesField
                                 }
                               else
                                 {}
                               end

  ATTRIBUTE_TYPES = {
    id: Field::Number.with_options(searchable: true),
    name: Field::String.with_options(searchable: true),
    created_at: Field::DateTime,
    updated_at: Field::DateTime,
    users: CountField,
    conversations: CountField,
    locale: Field::Select.with_options(collection: LANGUAGES_CONFIG.map { |_x, y| y[:iso_639_1_code] }),
    status: Field::Select.with_options(collection: [%w[Active active], %w[Suspended suspended]]),
    account_users: Field::HasMany,
    custom_attributes: Field::String
  }.merge(enterprise_attribute_types).freeze

  # COLLECTION_ATTRIBUTES
  # an array of attributes that will be displayed on the model's index page.
  #
  # By default, it's limited to four items to reduce clutter on index pages.
  # Feel free to add, remove, or rearrange items.
  COLLECTION_ATTRIBUTES = %i[
    id
    name
    locale
    users
    conversations
    status
  ].freeze

  # SHOW_PAGE_ATTRIBUTES
  # an array of attributes that will be displayed on the model's show page.
  enterprise_show_page_attributes = ChatwootApp.enterprise? ? %i[custom_attributes limits all_features] : []
  SHOW_PAGE_ATTRIBUTES = (%i[
    id
    name
    created_at
    updated_at
    locale
    status
    conversations
    account_users
  ] + enterprise_show_page_attributes).freeze

  # FORM_ATTRIBUTES
  # an array of attributes that will be displayed
  # on the model's form (`new` and `edit`) pages.
  enterprise_form_attributes = ChatwootApp.enterprise? ? %i[limits all_features] : []
  FORM_ATTRIBUTES = (%i[
    name
    locale
    status
  ] + enterprise_form_attributes).freeze

  # COLLECTION_FILTERS
  # a hash that defines filters that can be used while searching via the search
  # field of the dashboard.
  #
  # For example to add an option to search for open resources by typing "open:"
  # in the search field:
  #
  #   COLLECTION_FILTERS = {
  #     open: ->(resources) { resources.where(open: true) }
  #   }.freeze
  COLLECTION_FILTERS = {
    active: ->(resources) { resources.where(status: :active) },
    suspended: ->(resources) { resources.where(status: :suspended) },
    recent: ->(resources) { resources.where('created_at > ?', 30.days.ago) }
  }.freeze

  # Overwrite this method to customize how accounts are displayed
  # across all pages of the admin dashboard.
  #
  def display_resource(account)
    "##{account.id} #{account.name}"
  end

  # We do not use the action parameter but we still need to define it
  # to prevent an error from being raised (wrong number of arguments)
  # Reference: https://github.com/thoughtbot/administrate/pull/2356/files#diff-4e220b661b88f9a19ac527c50d6f1577ef6ab7b0bed2bfdf048e22e6bfa74a05R204
  def permitted_attributes(action)
    super + [limits: {}]
  end
end

================
File: dashboards/account_user_dashboard.rb
================
require 'administrate/base_dashboard'

class AccountUserDashboard < Administrate::BaseDashboard
  # ATTRIBUTE_TYPES
  # a hash that describes the type of each of the model's fields.
  #
  # Each different type represents an Administrate::Field object,
  # which determines how the attribute is displayed
  # on pages throughout the dashboard.
  ATTRIBUTE_TYPES = {
    account: Field::BelongsToSearch.with_options(class_name: 'Account', searchable: true, searchable_field: [:name, :id], order: 'id DESC'),
    user: Field::BelongsToSearch.with_options(class_name: 'User', searchable: true, searchable_field: [:name, :email, :id], order: 'id DESC'),
    inviter: Field::BelongsToSearch.with_options(class_name: 'User', searchable: true, searchable_field: [:name, :email, :id], order: 'id DESC'),
    id: Field::Number,
    role: Field::Select.with_options(collection: AccountUser.roles.keys),
    created_at: Field::DateTime,
    updated_at: Field::DateTime
  }.freeze

  # COLLECTION_ATTRIBUTES
  # an array of attributes that will be displayed on the model's index page.
  #
  # By default, it's limited to four items to reduce clutter on index pages.
  # Feel free to add, remove, or rearrange items.
  COLLECTION_ATTRIBUTES = %i[
    account
    user
    inviter
    role
  ].freeze

  # SHOW_PAGE_ATTRIBUTES
  # an array of attributes that will be displayed on the model's show page.
  SHOW_PAGE_ATTRIBUTES = %i[
    account
    user
    inviter
    id
    role
    created_at
    updated_at
  ].freeze

  # FORM_ATTRIBUTES
  # an array of attributes that will be displayed
  # on the model's form (`new` and `edit`) pages.
  FORM_ATTRIBUTES = %i[
    account
    user
    role
  ].freeze

  # COLLECTION_FILTERS
  # a hash that defines filters that can be used while searching via the search
  # field of the dashboard.
  #
  # For example to add an option to search for open resources by typing "open:"
  # in the search field:
  #
  #   COLLECTION_FILTERS = {
  #     open: ->(resources) { resources.where(open: true) }
  #   }.freeze
  COLLECTION_FILTERS = {}.freeze

  # Overwrite this method to customize how account users are displayed
  # across all pages of the admin dashboard.
  #
  def display_resource(account_user)
    "AccountUser ##{account_user.id}"
  end
end

================
File: dashboards/agent_bot_dashboard.rb
================
require 'administrate/base_dashboard'

class AgentBotDashboard < Administrate::BaseDashboard
  # ATTRIBUTE_TYPES
  # a hash that describes the type of each of the model's fields.
  #
  # Each different type represents an Administrate::Field object,
  # which determines how the attribute is displayed
  # on pages throughout the dashboard.
  ATTRIBUTE_TYPES = {
    access_token: Field::HasOne,
    avatar_url: AvatarField,
    avatar: Field::ActiveStorage.with_options(
      destroy_url: proc do |_namespace, _resource, attachment|
        [:avatar_super_admin_agent_bot, { attachment_id: attachment.id }]
      end
    ),
    id: Field::Number,
    name: Field::String,
    account: Field::BelongsTo.with_options(searchable: true, searchable_field: 'name', order: 'id DESC'),
    description: Field::String,
    outgoing_url: Field::String,
    created_at: Field::DateTime,
    updated_at: Field::DateTime
  }.freeze

  # COLLECTION_ATTRIBUTES
  # an array of attributes that will be displayed on the model's index page.
  #
  # By default, it's limited to four items to reduce clutter on index pages.
  # Feel free to add, remove, or rearrange items.
  COLLECTION_ATTRIBUTES = %i[
    id
    avatar_url
    account
    name
    outgoing_url
  ].freeze

  # SHOW_PAGE_ATTRIBUTES
  # an array of attributes that will be displayed on the model's show page.
  SHOW_PAGE_ATTRIBUTES = %i[
    id
    avatar_url
    account
    name
    description
    outgoing_url
    access_token
  ].freeze

  # FORM_ATTRIBUTES
  # an array of attributes that will be displayed
  # on the model's form (`new` and `edit`) pages.
  FORM_ATTRIBUTES = %i[
    name
    avatar
    account
    description
    outgoing_url
  ].freeze

  # COLLECTION_FILTERS
  # a hash that defines filters that can be used while searching via the search
  # field of the dashboard.
  #
  # For example to add an option to search for open resources by typing "open:"
  # in the search field:
  #
  #   COLLECTION_FILTERS = {
  #     open: ->(resources) { resources.where(open: true) }
  #   }.freeze
  COLLECTION_FILTERS = {}.freeze

  # Overwrite this method to customize how agent bots are displayed
  # across all pages of the admin dashboard.
  #
  # def display_resource(agent_bot)
  #   "AgentBot ##{agent_bot.id}"
  # end
end

================
File: dashboards/installation_config_dashboard.rb
================
require 'administrate/base_dashboard'

class InstallationConfigDashboard < Administrate::BaseDashboard
  # ATTRIBUTE_TYPES
  # a hash that describes the type of each of the model's fields.
  #
  # Each different type represents an Administrate::Field object,
  # which determines how the attribute is displayed
  # on pages throughout the dashboard.
  ATTRIBUTE_TYPES = {
    id: Field::Number,
    name: Field::String,
    value: SerializedField,
    created_at: Field::DateTime,
    updated_at: Field::DateTime
  }.freeze

  # COLLECTION_ATTRIBUTES
  # an array of attributes that will be displayed on the model's index page.
  #
  # By default, it's limited to four items to reduce clutter on index pages.
  # Feel free to add, remove, or rearrange items.
  COLLECTION_ATTRIBUTES = %i[
    id
    name
    value
    created_at
  ].freeze

  # SHOW_PAGE_ATTRIBUTES
  # an array of attributes that will be displayed on the model's show page.
  SHOW_PAGE_ATTRIBUTES = %i[
    id
    name
    value
    created_at
    updated_at
  ].freeze

  # FORM_ATTRIBUTES
  # an array of attributes that will be displayed
  # on the model's form (`new` and `edit`) pages.
  FORM_ATTRIBUTES = %i[
    name
    value
  ].freeze

  # COLLECTION_FILTERS
  # a hash that defines filters that can be used while searching via the search
  # field of the dashboard.
  #
  # For example to add an option to search for open resources by typing "open:"
  # in the search field:
  #
  #   COLLECTION_FILTERS = {
  #     open: ->(resources) { resources.where(open: true) }
  #   }.freeze
  COLLECTION_FILTERS = {}.freeze

  # Overwrite this method to customize how installation configs are displayed
  # across all pages of the admin dashboard.
  #
  # def display_resource(installation_config)
  #   "InstallationConfig ##{installation_config.id}"
  # end
end

================
File: dashboards/platform_app_dashboard.rb
================
require 'administrate/base_dashboard'

class PlatformAppDashboard < Administrate::BaseDashboard
  # ATTRIBUTE_TYPES
  # a hash that describes the type of each of the model's fields.
  #
  # Each different type represents an Administrate::Field object,
  # which determines how the attribute is displayed
  # on pages throughout the dashboard.
  ATTRIBUTE_TYPES = {
    access_token: Field::HasOne,
    id: Field::Number,
    name: Field::String,
    created_at: Field::DateTime,
    updated_at: Field::DateTime
  }.freeze

  # COLLECTION_ATTRIBUTES
  # an array of attributes that will be displayed on the model's index page.
  #
  # By default, it's limited to four items to reduce clutter on index pages.
  # Feel free to add, remove, or rearrange items.
  COLLECTION_ATTRIBUTES = %i[
    id
    name
  ].freeze

  # SHOW_PAGE_ATTRIBUTES
  # an array of attributes that will be displayed on the model's show page.
  SHOW_PAGE_ATTRIBUTES = %i[
    id
    name
    created_at
    updated_at
    access_token
  ].freeze

  # FORM_ATTRIBUTES
  # an array of attributes that will be displayed
  # on the model's form (`new` and `edit`) pages.
  FORM_ATTRIBUTES = %i[
    name
  ].freeze

  # COLLECTION_FILTERS
  # a hash that defines filters that can be used while searching via the search
  # field of the dashboard.
  #
  # For example to add an option to search for open resources by typing "open:"
  # in the search field:
  #
  #   COLLECTION_FILTERS = {
  #     open: ->(resources) { resources.where(open: true) }
  #   }.freeze
  COLLECTION_FILTERS = {}.freeze

  # Overwrite this method to customize how platform apps are displayed
  # across all pages of the admin dashboard.
  #
  # def display_resource(platform_app)
  #   "PlatformApp ##{platform_app.id}"
  # end
end

================
File: dashboards/user_dashboard.rb
================
require 'administrate/base_dashboard'

class UserDashboard < Administrate::BaseDashboard
  # ATTRIBUTE_TYPES
  # a hash that describes the type of each of the model's fields.
  #
  # Each different type represents an Administrate::Field object,
  # which determines how the attribute is displayed
  # on pages throughout the dashboard.
  ATTRIBUTE_TYPES = {
    account_users: Field::HasMany,
    id: Field::Number.with_options(searchable: true),
    avatar_url: AvatarField,
    avatar: Field::ActiveStorage.with_options(
      destroy_url: proc do |_namespace, _resource, attachment|
        [:avatar_super_admin_user, { attachment_id: attachment.id }]
      end
    ),
    provider: Field::String,
    uid: Field::String,
    password: Field::Password,
    sign_in_count: Field::Number,
    current_sign_in_at: Field::DateTime,
    last_sign_in_at: Field::DateTime,
    current_sign_in_ip: Field::String,
    last_sign_in_ip: Field::String,
    confirmation_token: Field::String,
    confirmed_at: Field::DateTime,
    confirmation_sent_at: Field::DateTime,
    unconfirmed_email: Field::String,
    name: Field::String.with_options(searchable: true),
    display_name: Field::String,
    email: Field::String.with_options(searchable: true),
    tokens: Field::String.with_options(searchable: false),
    created_at: Field::DateTime,
    updated_at: Field::DateTime,
    pubsub_token: Field::String,
    type: Field::Select.with_options(collection: [nil, 'SuperAdmin']),
    accounts: CountField,
    access_token: Field::HasOne
  }.freeze

  # COLLECTION_ATTRIBUTES
  # an array of attributes that will be displayed on the model's index page.
  #
  # By default, it's limited to four items to reduce clutter on index pages.
  # Feel free to add, remove, or rearrange items.
  COLLECTION_ATTRIBUTES = %i[
    id
    avatar_url
    name
    email
    accounts
    type
  ].freeze

  # SHOW_PAGE_ATTRIBUTES
  # an array of attributes that will be displayed on the model's show page.
  SHOW_PAGE_ATTRIBUTES = %i[
    id
    avatar_url
    unconfirmed_email
    name
    type
    display_name
    email
    created_at
    updated_at
    confirmed_at
    account_users
    access_token
  ].freeze

  # FORM_ATTRIBUTES
  # an array of attributes that will be displayed
  # on the model's form (`new` and `edit`) pages.
  FORM_ATTRIBUTES = %i[
    name
    avatar
    display_name
    email
    password
    confirmed_at
    type
  ].freeze

  # COLLECTION_FILTERS
  # a hash that defines filters that can be used while searching via the search
  # field of the dashboard.
  #
  # For example to add an option to search for open resources by typing "open:"
  # in the search field:
  #
  #   COLLECTION_FILTERS = {
  #     open: ->(resources) { resources.where(open: true) }
  #   }.freeze
  COLLECTION_FILTERS = {
    super_admin: ->(resources) { resources.where(type: 'SuperAdmin') },
    confirmed: ->(resources) { resources.where.not(confirmed_at: nil) },
    unconfirmed: ->(resources) { resources.where(confirmed_at: nil) },
    recent: ->(resources) { resources.where('created_at > ?', 30.days.ago) }
  }.freeze

  # Overwrite this method to customize how users are displayed
  # across all pages of the admin dashboard.
  #
  def display_resource(user)
    "##{user.id} #{user.name}"
  end
end

================
File: dispatchers/async_dispatcher.rb
================
class AsyncDispatcher < BaseDispatcher
  def dispatch(event_name, timestamp, data)
    EventDispatcherJob.perform_later(event_name, timestamp, data)
  end

  def publish_event(event_name, timestamp, data)
    event_object = Events::Base.new(event_name, timestamp, data)
    publish(event_object.method_name, event_object)
  end

  def listeners
    [
      AutomationRuleListener.instance,
      CampaignListener.instance,
      CsatSurveyListener.instance,
      HookListener.instance,
      InstallationWebhookListener.instance,
      NotificationListener.instance,
      ParticipationListener.instance,
      ReportingEventListener.instance,
      WebhookListener.instance
    ]
  end
end

AsyncDispatcher.prepend_mod_with('AsyncDispatcher')

================
File: dispatchers/base_dispatcher.rb
================
class BaseDispatcher
  include Wisper::Publisher

  def listeners
    []
  end

  def load_listeners
    listeners.each { |listener| subscribe(listener) }
  end
end

================
File: dispatchers/dispatcher.rb
================
class Dispatcher
  include Singleton

  attr_reader :async_dispatcher, :sync_dispatcher

  def self.dispatch(event_name, timestamp, data, async = false)
    Rails.configuration.dispatcher.dispatch(event_name, timestamp, data, async)
  end

  def initialize
    @sync_dispatcher = SyncDispatcher.new
    @async_dispatcher = AsyncDispatcher.new
  end

  def dispatch(event_name, timestamp, data, _async = false)
    @sync_dispatcher.dispatch(event_name, timestamp, data)
    @async_dispatcher.dispatch(event_name, timestamp, data)
  end

  def load_listeners
    @sync_dispatcher.load_listeners
    @async_dispatcher.load_listeners
  end
end

================
File: dispatchers/sync_dispatcher.rb
================
class SyncDispatcher < BaseDispatcher
  def dispatch(event_name, timestamp, data)
    event_object = Events::Base.new(event_name, timestamp, data)
    publish(event_object.method_name, event_object)
  end

  def listeners
    [ActionCableListener.instance, AgentBotListener.instance]
  end
end

================
File: drops/account_drop.rb
================
class AccountDrop < BaseDrop
  def name
    @obj.try(:name)
  end
end

================
File: drops/base_drop.rb
================
class BaseDrop < Liquid::Drop
  def initialize(obj)
    @obj = obj
  end

  def id
    @obj.try(:id)
  end

  def name
    @obj.try(:name)
  end
end

================
File: drops/contact_drop.rb
================
class ContactDrop < BaseDrop
  def name
    @obj.try(:name).try(:split).try(:map, &:capitalize).try(:join, ' ')
  end

  def email
    @obj.try(:email)
  end

  def phone_number
    @obj.try(:phone_number)
  end

  def first_name
    @obj.try(:name).try(:split).try(:first).try(:capitalize) if @obj.try(:name).try(:split).try(:size) > 1
  end

  def last_name
    @obj.try(:name).try(:split).try(:last).try(:capitalize) if @obj.try(:name).try(:split).try(:size) > 1
  end

  def custom_attribute
    custom_attributes = @obj.try(:custom_attributes) || {}
    custom_attributes.transform_keys(&:to_s)
  end
end

================
File: drops/conversation_drop.rb
================
class ConversationDrop < BaseDrop
  include MessageFormatHelper

  def display_id
    @obj.try(:display_id)
  end

  def contact_name
    @obj.try(:contact).name.try(:capitalize) || 'Customer'
  end

  def recent_messages
    @obj.try(:recent_messages).map do |message|
      {
        'sender' => message_sender_name(message.sender),
        'content' => render_message_content(transform_user_mention_content(message.content)),
        'attachments' => message.attachments.map(&:file_url)
      }
    end
  end

  def custom_attribute
    custom_attributes = @obj.try(:custom_attributes) || {}
    custom_attributes.transform_keys(&:to_s)
  end

  private

  def message_sender_name(sender)
    return 'Bot' if sender.blank?
    return contact_name if sender.instance_of?(Contact)

    sender&.available_name || sender&.name
  end
end

================
File: drops/inbox_drop.rb
================
class InboxDrop < BaseDrop
  def name
    @obj.try(:name)
  end
end

================
File: drops/message_drop.rb
================
class MessageDrop < BaseDrop
  include MessageFormatHelper

  def sender_display_name
    @obj.sender.try(:available_name)
  end

  def text_content
    content = @obj.try(:content) || ''
    render_message_content(transform_user_mention_content(content))
  end
end

================
File: drops/user_drop.rb
================
class UserDrop < BaseDrop
  def name
    @obj.try(:name).try(:split).try(:map, &:capitalize).try(:join, ' ')
  end

  def available_name
    @obj.try(:available_name)
  end

  def first_name
    @obj.try(:name).try(:split).try(:first).try(:capitalize) if @obj.try(:name).try(:split).try(:size) > 1
  end

  def last_name
    @obj.try(:name).try(:split).try(:last).try(:capitalize) if @obj.try(:name).try(:split).try(:size) > 1
  end
end

================
File: fields/enterprise/account_features_field.rb
================
require 'administrate/field/base'

class Enterprise::AccountFeaturesField < Administrate::Field::Base
  def to_s
    data
  end
end

================
File: fields/enterprise/account_limits_field.rb
================
require 'administrate/field/base'

class Enterprise::AccountLimitsField < Administrate::Field::Base
  def to_s
    data.present? ? data.to_json : { agents: nil, inboxes: nil, captain_responses: nil, captain_documents: nil }.to_json
  end
end

================
File: fields/avatar_field.rb
================
require 'administrate/field/base'

class AvatarField < Administrate::Field::Base
  def avatar_url
    return data.presence if data.presence

    resource.is_a?(User) ? '/assets/administrate/user/avatar.png' : '/assets/administrate/bot/avatar.png'
  end
end

================
File: fields/count_field.rb
================
require 'administrate/field/base'

class CountField < Administrate::Field::Base
  def to_s
    data.count
  end
end

================
File: fields/secret_field.rb
================
require 'administrate/field/base'

class SecretField < Administrate::Field::String
end

================
File: fields/serialized_field.rb
================
require 'administrate/field/base'

class SerializedField < Administrate::Field::Base
  def to_s
    hash? ? data.as_json : data.to_s
  end

  def hash?
    data.is_a? Hash
  end

  def array?
    data.is_a? Array
  end
end

================
File: finders/conversation_finder.rb
================
class ConversationFinder
  attr_reader :current_user, :current_account, :params

  DEFAULT_STATUS = 'open'.freeze
  SORT_OPTIONS = {
    'last_activity_at_asc' => %w[sort_on_last_activity_at asc],
    'last_activity_at_desc' => %w[sort_on_last_activity_at desc],
    'created_at_asc' => %w[sort_on_created_at asc],
    'created_at_desc' => %w[sort_on_created_at desc],
    'priority_asc' => %w[sort_on_priority asc],
    'priority_desc' => %w[sort_on_priority desc],
    'waiting_since_asc' => %w[sort_on_waiting_since asc],
    'waiting_since_desc' => %w[sort_on_waiting_since desc],

    # To be removed in v3.5.0
    'latest' => %w[sort_on_last_activity_at desc],
    'sort_on_created_at' => %w[sort_on_created_at asc],
    'sort_on_priority' => %w[sort_on_priority desc],
    'sort_on_waiting_since' => %w[sort_on_waiting_since asc]
  }.with_indifferent_access
  # assumptions
  # inbox_id if not given, take from all conversations, else specific to inbox
  # assignee_type if not given, take 'all'
  # conversation_status if not given, take 'open'

  # response of this class will be of type
  # {conversations: [array of conversations], count: {open: count, resolved: count}}

  # params
  # assignee_type, inbox_id, :status

  def initialize(current_user, params)
    @current_user = current_user
    @current_account = current_user.account
    @params = params
  end

  def perform
    set_up

    mine_count, unassigned_count, all_count, = set_count_for_all_conversations
    assigned_count = all_count - unassigned_count

    filter_by_assignee_type

    {
      conversations: conversations,
      count: {
        mine_count: mine_count,
        assigned_count: assigned_count,
        unassigned_count: unassigned_count,
        all_count: all_count
      }
    }
  end

  private

  def set_up
    set_inboxes
    set_team
    set_assignee_type

    find_all_conversations
    filter_by_status unless params[:q]
    filter_by_team
    filter_by_labels
    filter_by_query
    filter_by_source_id
  end

  def set_inboxes
    @inbox_ids = if params[:inbox_id]
                   @current_user.assigned_inboxes.where(id: params[:inbox_id])
                 else
                   @current_user.assigned_inboxes.pluck(:id)
                 end
  end

  def set_assignee_type
    @assignee_type = params[:assignee_type]
  end

  def set_team
    @team = current_account.teams.find(params[:team_id]) if params[:team_id]
  end

  def find_all_conversations
    @conversations = current_account.conversations.where(inbox_id: @inbox_ids)
    filter_by_conversation_type if params[:conversation_type]
    @conversations
  end

  def filter_by_assignee_type
    case @assignee_type
    when 'me'
      @conversations = @conversations.assigned_to(current_user)
    when 'unassigned'
      @conversations = @conversations.unassigned
    when 'assigned'
      @conversations = @conversations.assigned
    end
    @conversations
  end

  def filter_by_conversation_type
    case @params[:conversation_type]
    when 'mention'
      conversation_ids = current_account.mentions.where(user: current_user).pluck(:conversation_id)
      @conversations = @conversations.where(id: conversation_ids)
    when 'participating'
      @conversations = current_user.participating_conversations.where(account_id: current_account.id)
    when 'unattended'
      @conversations = @conversations.unattended
    end
    @conversations
  end

  def filter_by_query
    return unless params[:q]

    allowed_message_types = [Message.message_types[:incoming], Message.message_types[:outgoing]]
    @conversations = conversations.joins(:messages).where('messages.content ILIKE :search', search: "%#{params[:q]}%")
                                  .where(messages: { message_type: allowed_message_types }).includes(:messages)
                                  .where('messages.content ILIKE :search', search: "%#{params[:q]}%")
                                  .where(messages: { message_type: allowed_message_types })
  end

  def filter_by_status
    return if params[:status] == 'all'

    @conversations = @conversations.where(status: params[:status] || DEFAULT_STATUS)
  end

  def filter_by_team
    return unless @team

    @conversations = @conversations.where(team: @team)
  end

  def filter_by_labels
    return unless params[:labels]

    @conversations = @conversations.tagged_with(params[:labels], any: true)
  end

  def filter_by_source_id
    return unless params[:source_id]

    @conversations = @conversations.joins(:contact_inbox)
    @conversations = @conversations.where(contact_inboxes: { source_id: params[:source_id] })
  end

  def set_count_for_all_conversations
    [
      @conversations.assigned_to(current_user).count,
      @conversations.unassigned.count,
      @conversations.count
    ]
  end

  def current_page
    params[:page] || 1
  end

  def conversations_base_query
    @conversations.includes(
      :taggings, :inbox, { assignee: { avatar_attachment: [:blob] } }, { contact: { avatar_attachment: [:blob] } }, :team, :contact_inbox
    )
  end

  def conversations
    @conversations = conversations_base_query

    sort_by, sort_order = SORT_OPTIONS[params[:sort_by]] || SORT_OPTIONS['last_activity_at_desc']
    @conversations = @conversations.send(sort_by, sort_order)

    if params[:updated_within].present?
      @conversations.where('conversations.updated_at > ?', Time.zone.now - params[:updated_within].to_i.seconds)
    else
      @conversations.page(current_page).per(ENV.fetch('CONVERSATION_RESULTS_PER_PAGE', '25').to_i)
    end
  end
end
ConversationFinder.prepend_mod_with('ConversationFinder')

================
File: finders/email_channel_finder.rb
================
class EmailChannelFinder
  include EmailHelper

  def initialize(email_object)
    @email_object = email_object
  end

  def perform
    channel = nil

    recipient_mails.each do |email|
      normalized_email = normalize_email_with_plus_addressing(email)
      channel = Channel::Email.find_by('lower(email) = ? OR lower(forward_to_email) = ?', normalized_email, normalized_email)

      break if channel.present?
    end
    channel
  end

  def recipient_mails
    recipient_addresses = @email_object.to.to_a + @email_object.cc.to_a + @email_object.bcc.to_a + [@email_object['X-Original-To'].try(:value)]
    recipient_addresses.flatten.compact
  end
end

================
File: finders/message_finder.rb
================
class MessageFinder
  def initialize(conversation, params)
    @conversation = conversation
    @params = params
  end

  def perform
    current_messages
  end

  private

  def conversation_messages
    @conversation.messages.includes(:attachments, :sender, sender: { avatar_attachment: [:blob] })
  end

  def messages
    return conversation_messages if @params[:filter_internal_messages].blank?

    conversation_messages.where.not('private = ? OR message_type = ?', true, 2)
  end

  def current_messages
    if @params[:after].present? && @params[:before].present?
      messages_between(@params[:after].to_i, @params[:before].to_i)
    elsif @params[:before].present?
      messages_before(@params[:before].to_i)
    elsif @params[:after].present?
      messages_after(@params[:after].to_i)
    else
      messages_latest
    end
  end

  def messages_after(after_id)
    messages.reorder('created_at asc').where('id > ?', after_id).limit(100)
  end

  def messages_before(before_id)
    messages.reorder('created_at desc').where('id < ?', before_id).limit(20).reverse
  end

  def messages_between(after_id, before_id)
    messages.reorder('created_at asc').where('id >= ? AND id < ?', after_id, before_id).limit(1000)
  end

  def messages_latest
    messages.reorder('created_at desc').limit(20).reverse
  end
end

================
File: finders/notification_finder.rb
================
class NotificationFinder
  attr_reader :current_user, :current_account, :params

  RESULTS_PER_PAGE = 15

  def initialize(current_user, current_account, params = {})
    @current_user = current_user
    @current_account = current_account
    @params = params
    set_up
  end

  def notifications
    @notifications.page(current_page).per(RESULTS_PER_PAGE).order(last_activity_at: sort_order)
  end

  def unread_count
    @notifications.where(read_at: nil).count
  end

  def count
    @notifications.count
  end

  private

  def set_up
    find_all_notifications
    filter_snoozed_notifications
    fitler_read_notifications
  end

  def find_all_notifications
    @notifications = current_user.notifications.where(account_id: @current_account.id)
  end

  def filter_snoozed_notifications
    @notifications = @notifications.where(snoozed_until: nil) unless type_included?('snoozed')
  end

  def fitler_read_notifications
    @notifications = @notifications.where(read_at: nil) unless type_included?('read')
  end

  def type_included?(type)
    (params[:includes] || []).include?(type)
  end

  def current_page
    params[:page] || 1
  end

  def sort_order
    params[:sort_order] || :desc
  end
end

================
File: helpers/api/v1/widget/messages_helper.rb
================
module Api::V1::Widget::MessagesHelper
end

================
File: helpers/api/v1/agents_helper.rb
================
module Api::V1::AgentsHelper
end

================
File: helpers/api/v1/canned_responses_helper.rb
================
module Api::V1::CannedResponsesHelper
end

================
File: helpers/api/v1/conversations_helper.rb
================
module Api::V1::ConversationsHelper
end

================
File: helpers/api/v1/inboxes_helper.rb
================
module Api::V1::InboxesHelper
  def inbox_name(channel)
    return channel.try(:bot_name) if channel.is_a?(Channel::Telegram)

    permitted_params[:name]
  end

  def validate_email_channel(attributes)
    channel_data = permitted_params(attributes)[:channel]

    validate_imap(channel_data)
    validate_smtp(channel_data)
  end

  private

  def validate_imap(channel_data)
    return unless channel_data.key?('imap_enabled') && channel_data[:imap_enabled]

    Mail.defaults do
      retriever_method :imap, { address: channel_data[:imap_address],
                                port: channel_data[:imap_port],
                                user_name: channel_data[:imap_login],
                                password: channel_data[:imap_password],
                                enable_ssl: channel_data[:imap_enable_ssl] }
    end

    check_imap_connection(channel_data)
  end

  def validate_smtp(channel_data)
    return unless channel_data.key?('smtp_enabled') && channel_data[:smtp_enabled]

    smtp = Net::SMTP.new(channel_data[:smtp_address], channel_data[:smtp_port])

    set_smtp_encryption(channel_data, smtp)
    check_smtp_connection(channel_data, smtp)
  end

  def check_imap_connection(channel_data)
    Mail.connection {} # rubocop:disable:block
  rescue SocketError => e
    raise StandardError, I18n.t('errors.inboxes.imap.socket_error')
  rescue Net::IMAP::NoResponseError => e
    raise StandardError, I18n.t('errors.inboxes.imap.no_response_error')
  rescue Errno::EHOSTUNREACH => e
    raise StandardError, I18n.t('errors.inboxes.imap.host_unreachable_error')
  rescue Net::OpenTimeout => e
    raise StandardError,
          I18n.t('errors.inboxes.imap.connection_timed_out_error', address: channel_data[:imap_address], port: channel_data[:imap_port])
  rescue Net::IMAP::Error => e
    raise StandardError, I18n.t('errors.inboxes.imap.connection_closed_error')
  rescue StandardError => e
    raise StandardError, e.message
  ensure
    Rails.logger.error "[Api::V1::InboxesHelper] check_imap_connection failed with #{e.message}" if e.present?
  end

  def check_smtp_connection(channel_data, smtp)
    smtp.start(channel_data[:smtp_domain], channel_data[:smtp_login], channel_data[:smtp_password],
               channel_data[:smtp_authentication]&.to_sym || :login)
    smtp.finish
  end

  def set_smtp_encryption(channel_data, smtp)
    if channel_data[:smtp_enable_ssl_tls]
      set_enable_tls(channel_data, smtp)
    elsif channel_data[:smtp_enable_starttls_auto]
      set_enable_starttls_auto(channel_data, smtp)
    end
  end

  def set_enable_starttls_auto(channel_data, smtp)
    return unless smtp.respond_to?(:enable_starttls_auto)

    if channel_data[:smtp_openssl_verify_mode]
      context = enable_openssl_mode(channel_data[:smtp_openssl_verify_mode])
      smtp.enable_starttls_auto(context)
    else
      smtp.enable_starttls_auto
    end
  end

  def set_enable_tls(channel_data, smtp)
    return unless smtp.respond_to?(:enable_tls)

    if channel_data[:smtp_openssl_verify_mode]
      context = enable_openssl_mode(channel_data[:smtp_openssl_verify_mode])
      smtp.enable_tls(context)
    else
      smtp.enable_tls
    end
  end

  def enable_openssl_mode(smtp_openssl_verify_mode)
    openssl_verify_mode = "OpenSSL::SSL::VERIFY_#{smtp_openssl_verify_mode.upcase}".constantize if smtp_openssl_verify_mode.is_a?(String)
    context = Net::SMTP.default_ssl_context
    context.verify_mode = openssl_verify_mode
    context
  end

  def account_channels_method
    {
      'web_widget' => Current.account.web_widgets,
      'api' => Current.account.api_channels,
      'email' => Current.account.email_channels,
      'line' => Current.account.line_channels,
      'telegram' => Current.account.telegram_channels,
      'whatsapp' => Current.account.whatsapp_channels,
      'sms' => Current.account.sms_channels
    }[permitted_params[:channel][:type]]
  end

  def validate_limit
    return unless Current.account.inboxes.count >= Current.account.usage_limits[:inboxes]

    render_payment_required('Account limit exceeded. Upgrade to a higher plan')
  end
end

================
File: helpers/api/v2/accounts/heatmap_helper.rb
================
module Api::V2::Accounts::HeatmapHelper
  def generate_conversations_heatmap_report
    timezone_data = generate_heatmap_data_for_timezone(params[:timezone_offset])

    group_traffic_data(timezone_data)
  end

  private

  def group_traffic_data(data)
    # start with an empty array
    result_arr = []

    # pick all the unique dates from the data in ascending order
    dates = data.pluck(:date).uniq.sort

    # add the dates as the first row, leave an empty cell for the hour column
    # e.g. ['Start of the hour', '2023-01-01', '2023-1-02', '2023-01-03']
    result_arr << (['Start of the hour'] + dates)

    # group the data by hour, we do not need to sort it, because the data is already sorted
    # given it starts from the beginning of the day
    # here each hour is a key, and the value is an array of all the items for that hour at each date
    # e.g. hour = 1
    # value = [{date: 2023-01-01, value: 1}, {date: 2023-01-02, value: 1}, {date: 2023-01-03, value: 1}, ...]
    data.group_by { |d| d[:hour] }.each do |hour, items|
      # create a new row for each hour
      row = [format('%02d:00', hour)]

      # group the items by date, so we can easily access the value for each date
      # grouped values will be a hasg with the date as the key, and the value as the value
      # e.g. { '2023-01-01' => [{date: 2023-01-01, value: 1}], '2023-01-02' => [{date: 2023-01-02, value: 1}], ... }
      grouped_values = items.group_by { |d| d[:date] }

      # now for each unique date we have, we can access the value for that date and append it to the array
      dates.each do |date|
        row << (grouped_values[date][0][:value] if grouped_values[date].is_a?(Array))
      end

      # row will look like ['22:00', 0, 0, 1, 4, 6, 7, 4]
      # add the row to the result array

      result_arr << row
    end

    # return the resultant array
    # the result looks like this
    # [
    #   ['Start of the hour', '2023-01-01', '2023-1-02', '2023-01-03'],
    #   ['00:00', 0, 0, 0],
    #   ['01:00', 0, 0, 0],
    #   ['02:00', 0, 0, 0],
    #   ['03:00', 0, 0, 0],
    #   ['04:00', 0, 0, 0],
    # ]
    result_arr
  end

  def generate_heatmap_data_for_timezone(offset)
    timezone = ActiveSupport::TimeZone[offset]&.name
    timezone_today = DateTime.now.in_time_zone(timezone).beginning_of_day

    timezone_data_raw = generate_heatmap_data(timezone_today, offset)

    transform_data(timezone_data_raw, false)
  end

  def generate_heatmap_data(date, offset)
    report_params = {
      type: :account,
      group_by: 'hour',
      metric: 'conversations_count',
      business_hours: false
    }

    V2::ReportBuilder.new(Current.account, report_params.merge({
                                                                 since: since_timestamp(date),
                                                                 until: until_timestamp(date),
                                                                 timezone_offset: offset
                                                               })).build
  end

  def transform_data(data, zone_transform)
    # rubocop:disable Rails/TimeZone
    data.map do |d|
      date = zone_transform ? Time.zone.at(d[:timestamp]) : Time.at(d[:timestamp])
      {
        date: date.to_date.to_s,
        hour: date.hour,
        value: d[:value]
      }
    end
    # rubocop:enable Rails/TimeZone
  end

  def since_timestamp(date)
    number_of_days = params[:days_before].present? ? params[:days_before].to_i.days : 6.days
    (date - number_of_days).to_i.to_s
  end

  def until_timestamp(date)
    date.to_i.to_s
  end
end

================
File: helpers/api/v2/accounts/reports_helper.rb
================
module Api::V2::Accounts::ReportsHelper
  def generate_agents_report
    reports = V2::Reports::AgentSummaryBuilder.new(
      account: Current.account,
      params: build_params(type: :agent)
    ).build

    Current.account.users.map do |agent|
      report = reports.find { |r| r[:id] == agent.id }
      [agent.name] + generate_readable_report_metrics(report)
    end
  end

  def generate_inboxes_report
    reports = V2::Reports::InboxSummaryBuilder.new(
      account: Current.account,
      params: build_params(type: :inbox)
    ).build

    Current.account.inboxes.map do |inbox|
      report = reports.find { |r| r[:id] == inbox.id }
      [inbox.name, inbox.channel&.name] + generate_readable_report_metrics(report)
    end
  end

  def generate_teams_report
    reports = V2::Reports::TeamSummaryBuilder.new(
      account: Current.account,
      params: build_params(type: :team)
    ).build

    Current.account.teams.map do |team|
      report = reports.find { |r| r[:id] == team.id }
      [team.name] + generate_readable_report_metrics(report)
    end
  end

  def generate_labels_report
    Current.account.labels.map do |label|
      label_report = report_builder({ type: :label, id: label.id }).short_summary
      [label.title] + generate_readable_report_metrics(label_report)
    end
  end

  private

  def build_params(base_params)
    base_params.merge(
      {
        since: params[:since],
        until: params[:until],
        business_hours: ActiveModel::Type::Boolean.new.cast(params[:business_hours])
      }
    )
  end

  def report_builder(report_params)
    V2::ReportBuilder.new(Current.account, build_params(report_params))
  end

  def generate_readable_report_metrics(report)
    [
      report[:conversations_count],
      Reports::TimeFormatPresenter.new(report[:avg_first_response_time]).format,
      Reports::TimeFormatPresenter.new(report[:avg_resolution_time]).format,
      Reports::TimeFormatPresenter.new(report[:avg_reply_time]).format,
      report[:resolved_conversations_count]
    ]
  end
end

================
File: helpers/api/base_helper.rb
================
module Api::BaseHelper
end

================
File: helpers/filters/filter_helper.rb
================
module Filters::FilterHelper
  def build_condition_query(model_filters, query_hash, current_index)
    current_filter = model_filters[query_hash['attribute_key']]

    # Throw InvalidOperator Error if the attribute is a standard attribute
    # and the operator is not allowed in the config
    if current_filter.present? && current_filter['filter_operators'].exclude?(query_hash[:filter_operator])
      raise CustomExceptions::CustomFilter::InvalidOperator.new(
        attribute_name: query_hash['attribute_key'],
        allowed_keys: current_filter['filter_operators']
      )
    end

    # Every other filter expects a value to be present
    if %w[is_present is_not_present].exclude?(query_hash[:filter_operator]) && query_hash['values'].blank?
      raise CustomExceptions::CustomFilter::InvalidValue.new(attribute_name: query_hash['attribute_key'])
    end

    condition_query = build_condition_query_string(current_filter, query_hash, current_index)
    # The query becomes empty only when it doesn't match to any supported
    # standard attribute or custom attribute defined in the account.
    if condition_query.empty?
      raise CustomExceptions::CustomFilter::InvalidAttribute.new(key: query_hash['attribute_key'],
                                                                 allowed_keys: model_filters.keys)
    end

    condition_query
  end

  def build_condition_query_string(current_filter, query_hash, current_index)
    filter_operator_value = filter_operation(query_hash, current_index)

    return handle_nil_filter(query_hash, current_index) if current_filter.nil?

    case current_filter['attribute_type']
    when 'additional_attributes'
      handle_additional_attributes(query_hash, filter_operator_value, current_filter['data_type'])
    else
      handle_standard_attributes(current_filter, query_hash, current_index, filter_operator_value)
    end
  end

  def handle_nil_filter(query_hash, current_index)
    attribute_type = "#{filter_config[:entity].downcase}_attribute"
    custom_attribute_query(query_hash, attribute_type, current_index)
  end

  def handle_additional_attributes(query_hash, filter_operator_value, data_type)
    if data_type == 'text_case_insensitive'
      "LOWER(#{filter_config[:table_name]}.additional_attributes ->> '#{query_hash[:attribute_key]}') " \
        "#{filter_operator_value} #{query_hash[:query_operator]}"
    else
      "#{filter_config[:table_name]}.additional_attributes ->> '#{query_hash[:attribute_key]}' " \
        "#{filter_operator_value} #{query_hash[:query_operator]} "
    end
  end

  def handle_standard_attributes(current_filter, query_hash, current_index, filter_operator_value)
    case current_filter['data_type']
    when 'date'
      date_filter(current_filter, query_hash, filter_operator_value)
    when 'labels'
      tag_filter_query(query_hash, current_index)
    when 'text_case_insensitive'
      text_case_insensitive_filter(query_hash, filter_operator_value)
    else
      default_filter(query_hash, filter_operator_value)
    end
  end

  def date_filter(current_filter, query_hash, filter_operator_value)
    "(#{filter_config[:table_name]}.#{query_hash[:attribute_key]})::#{current_filter['data_type']} " \
      "#{filter_operator_value}#{current_filter['data_type']} #{query_hash[:query_operator]}"
  end

  def text_case_insensitive_filter(query_hash, filter_operator_value)
    "LOWER(#{filter_config[:table_name]}.#{query_hash[:attribute_key]}) " \
      "#{filter_operator_value} #{query_hash[:query_operator]}"
  end

  def default_filter(query_hash, filter_operator_value)
    "#{filter_config[:table_name]}.#{query_hash[:attribute_key]} #{filter_operator_value} #{query_hash[:query_operator]}"
  end

  def validate_single_condition(condition)
    return if condition['query_operator'].nil?
    return if condition['query_operator'].empty?

    operator = condition['query_operator'].upcase
    raise CustomExceptions::CustomFilter::InvalidQueryOperator.new({}) unless %w[AND OR].include?(operator)
  end

  def conversation_status_values(values)
    return Conversation.statuses.values if values.include?('all')

    values.map { |x| Conversation.statuses[x.to_sym] }
  end

  def conversation_priority_values(values)
    values.map { |x| Conversation.priorities[x.to_sym] }
  end

  def message_type_values(values)
    values.map { |x| Message.message_types[x.to_sym] }
  end
end

================
File: helpers/linear/integration_helper.rb
================
module Linear::IntegrationHelper
  # Generates a signed JWT token for Linear integration
  #
  # @param account_id [Integer] The account ID to encode in the token
  # @return [String, nil] The encoded JWT token or nil if client secret is missing
  def generate_linear_token(account_id)
    return if client_secret.blank?

    JWT.encode(token_payload(account_id), client_secret, 'HS256')
  rescue StandardError => e
    Rails.logger.error("Failed to generate Linear token: #{e.message}")
    nil
  end

  def token_payload(account_id)
    {
      sub: account_id,
      iat: Time.current.to_i
    }
  end

  # Verifies and decodes a Linear JWT token
  #
  # @param token [String] The JWT token to verify
  # @return [Integer, nil] The account ID from the token or nil if invalid
  def verify_linear_token(token)
    return if token.blank? || client_secret.blank?

    decode_token(token, client_secret)
  end

  private

  def client_secret
    @client_secret ||= GlobalConfigService.load('LINEAR_CLIENT_SECRET', nil)
  end

  def decode_token(token, secret)
    JWT.decode(token, secret, true, {
                 algorithm: 'HS256',
                 verify_expiration: true
               }).first['sub']
  rescue StandardError => e
    Rails.logger.error("Unexpected error verifying Linear token: #{e.message}")
    nil
  end
end

================
File: helpers/super_admin/account_features_helper.rb
================
module SuperAdmin::AccountFeaturesHelper
  def self.account_features
    YAML.safe_load(Rails.root.join('config/features.yml').read).freeze
  end

  def self.account_premium_features
    account_features.filter { |feature| feature['premium'] }.pluck('name')
  end

  # Returns a hash mapping feature names to their display names
  def self.feature_display_names
    account_features.each_with_object({}) do |feature, hash|
      hash[feature['name']] = feature['display_name']
    end
  end

  def self.filter_internal_features(features)
    return features if GlobalConfig.get_value('DEPLOYMENT_ENV') == 'cloud'

    internal_features = account_features.select { |f| f['chatwoot_internal'] }.pluck('name')
    features.except(*internal_features)
  end

  def self.filter_deprecated_features(features)
    deprecated_features = account_features.select { |f| f['deprecated'] }.pluck('name')
    features.except(*deprecated_features)
  end

  def self.sort_and_transform_features(features, display_names)
    features.sort_by { |key, _| display_names[key] || key }
            .to_h
            .transform_keys { |key| [key, display_names[key]] }
  end

  def self.partition_features(features)
    filtered = filter_internal_features(features)
    filtered = filter_deprecated_features(filtered)
    display_names = feature_display_names

    regular, premium = filtered.partition { |key, _value| account_premium_features.exclude?(key) }

    [
      sort_and_transform_features(regular, display_names),
      sort_and_transform_features(premium, display_names)
    ]
  end

  def self.filtered_features(features)
    regular, premium = partition_features(features)
    regular.merge(premium)
  end
end

================
File: helpers/application_helper.rb
================
module ApplicationHelper
  def available_locales_with_name
    LANGUAGES_CONFIG.map { |_key, val| val.slice(:name, :iso_639_1_code) }
  end

  def feature_help_urls
    features = YAML.safe_load(Rails.root.join('config/features.yml').read).freeze
    features.each_with_object({}) do |feature, hash|
      hash[feature['name']] = feature['help_url'] if feature['help_url']
    end
  end
end

================
File: helpers/billing_helper.rb
================
module BillingHelper
  private

  def default_plan?(account)
    installation_config = InstallationConfig.find_by(name: 'CHATWOOT_CLOUD_PLANS')
    default_plan = installation_config&.value&.first

    # Return false if not plans are configured, so that no checks are enforced
    return false if default_plan.blank?

    account.custom_attributes['plan_name'].nil? || account.custom_attributes['plan_name'] == default_plan['name']
  end

  def conversations_this_month(account)
    account.conversations.where('created_at > ?', 30.days.ago).count
  end

  def non_web_inboxes(account)
    account.inboxes.where.not(channel_type: Channel::WebWidget.to_s).count
  end
end

================
File: helpers/cache_keys_helper.rb
================
module CacheKeysHelper
  def get_prefixed_cache_key(account_id, key)
    "idb-cache-key-account-#{account_id}-#{key}"
  end

  def fetch_value_for_key(account_id, key)
    prefixed_cache_key = get_prefixed_cache_key(account_id, key)
    value_from_cache = Redis::Alfred.get(prefixed_cache_key)

    return value_from_cache if value_from_cache.present?

    # zero epoch time: 1970-01-01 00:00:00 UTC
    '0000000000'
  end
end

================
File: helpers/contact_helper.rb
================
module ContactHelper
  def parse_name(full_name)
    #  If the input is nil or not a string, return a hash with all values set to nil
    return default_name_hash if invalid_name?(full_name)

    # If the input is a number, return a hash with the number as the first name
    return numeric_name_hash(full_name) if valid_number?(full_name)

    full_name = full_name.squish

    # If full name consists of only one word, consider it as the first name
    return single_word_name_hash(full_name) if single_word?(full_name)

    parts = split_name(full_name)
    parts = handle_conjunction(parts)
    build_name_hash(parts)
  end

  private

  def default_name_hash
    { first_name: nil, last_name: nil, middle_name: nil, prefix: nil, suffix: nil }
  end

  def invalid_name?(full_name)
    !full_name.is_a?(String) || full_name.empty?
  end

  def numeric_name_hash(full_name)
    { first_name: full_name, last_name: nil, middle_name: nil, prefix: nil, suffix: nil }
  end

  def valid_number?(full_name)
    full_name.gsub(/\s+/, '').match?(/\A\+?\d+\z/)
  end

  def single_word_name_hash(full_name)
    { first_name: full_name, last_name: nil, middle_name: nil, prefix: nil, suffix: nil }
  end

  def single_word?(full_name)
    full_name.split.size == 1
  end

  def split_name(full_name)
    full_name.split
  end

  def handle_conjunction(parts)
    conjunctions = ['and', '&']
    parts.each_index do |i|
      next unless conjunctions.include?(parts[i]) && i.positive?

      parts[i - 1] = [parts[i - 1], parts[i + 1]].join(' ')
      parts.delete_at(i)
      parts.delete_at(i)
    end
    parts
  end

  def build_name_hash(parts)
    suffix = parts.pop if parts.last.match?(/(\w+\.|[IVXLM]+|[A-Z]+)$/)
    last_name = parts.pop
    prefix = parts.shift if parts.first.match?(/^\w+\./)
    first_name = parts.shift
    middle_name = parts.join(' ')

    hash = {
      first_name: first_name,
      last_name: last_name,
      prefix: prefix,
      middle_name: middle_name,
      suffix: suffix
    }

    # Reverse name if "," was used in Last, First notation.
    if hash[:first_name] =~ /,$/
      hash[:first_name] = hash[:last_name]
      hash[:last_name] = Regexp.last_match.pre_match
    end
    hash
  end
end

================
File: helpers/date_range_helper.rb
================
##############################################
# Helpers to implement date range filtering to APIs
# Include in your controller or service class where params is available
##############################################

module DateRangeHelper
  def range
    return if params[:since].blank? || params[:until].blank?

    parse_date_time(params[:since])...parse_date_time(params[:until])
  end

  def parse_date_time(datetime)
    return datetime if datetime.is_a?(DateTime)
    return datetime.to_datetime if datetime.is_a?(Time) || datetime.is_a?(Date)

    DateTime.strptime(datetime, '%s')
  end
end

================
File: helpers/email_helper.rb
================
module EmailHelper
  def extract_domain_without_tld(email)
    domain = email.split('@').last
    domain.split('.').first
  end

  # ref: https://www.rfc-editor.org/rfc/rfc5233.html
  # This is not a  mandatory requirement for email addresses, but it is a common practice.
  # john+test@xyc.com is the same as john@xyc.com
  def normalize_email_with_plus_addressing(email)
    "#{email.split('@').first.split('+').first}@#{email.split('@').last}".downcase
  end

  def parse_email_variables(conversation, email)
    case email
    when modified_liquid_content(email)
      template = Liquid::Template.parse(modified_liquid_content(email))
      template.render(message_drops(conversation))
    when URI::MailTo::EMAIL_REGEXP
      email
    end
  end

  def modified_liquid_content(email)
    # This regex is used to match the code blocks in the content
    # We don't want to process liquid in code blocks
    email.gsub(/`(.*?)`/m, '{% raw %}`\\1`{% endraw %}')
  end

  def message_drops(conversation)
    {
      'contact' => ContactDrop.new(conversation.contact)
    }
  end
end

================
File: helpers/file_type_helper.rb
================
module FileTypeHelper
  # NOTE: video, audio, image, etc are filetypes previewable in frontend
  def file_type(content_type)
    return :image if image_file?(content_type)
    return :video if video_file?(content_type)
    return :audio if content_type&.include?('audio/')

    :file
  end

  # Used in case of DIRECT_UPLOADS_ENABLED=true
  def file_type_by_signed_id(signed_id)
    blob = ActiveStorage::Blob.find_signed(signed_id)
    file_type(blob&.content_type)
  end

  def image_file?(content_type)
    [
      'image/jpeg',
      'image/png',
      'image/gif',
      'image/bmp',
      'image/webp',
      'image'
    ].include?(content_type)
  end

  def video_file?(content_type)
    [
      'video/ogg',
      'video/mp4',
      'video/webm',
      'video/quicktime',
      'video'
    ].include?(content_type)
  end
end

================
File: helpers/frontend_urls_helper.rb
================
module FrontendUrlsHelper
  def frontend_url(path, **query_params)
    url_params = query_params.blank? ? '' : "?#{query_params.to_query}"
    "#{root_url}app/#{path}#{url_params}"
  end
end

================
File: helpers/home_helper.rb
================
module HomeHelper
end

================
File: helpers/message_format_helper.rb
================
module MessageFormatHelper
  include RegexHelper

  def transform_user_mention_content(message_content)
    # attachment message without content, message_content is nil
    message_content.presence ? message_content.gsub(MENTION_REGEX, '\1') : ''
  end

  def render_message_content(message_content)
    ChatwootMarkdownRenderer.new(message_content).render_message
  end
end

================
File: helpers/portal_helper.rb
================
module PortalHelper
  def generate_portal_bg_color(portal_color, theme)
    base_color = theme == 'dark' ? 'black' : 'white'
    "color-mix(in srgb, #{portal_color} 20%, #{base_color})"
  end

  def generate_portal_bg(portal_color, theme)
    generate_portal_bg_color(portal_color, theme)
  end

  def generate_gradient_to_bottom(theme)
    base_color = theme == 'dark' ? '#151718' : 'white'
    "linear-gradient(to bottom, transparent, #{base_color})"
  end

  def generate_portal_hover_color(portal_color, theme)
    base_color = theme == 'dark' ? '#1B1B1B' : '#F9F9F9'
    "color-mix(in srgb, #{portal_color} 5%, #{base_color})"
  end

  def language_name(locale)
    language_map = YAML.load_file(Rails.root.join('config/languages/language_map.yml'))
    language_map[locale] || locale
  end

  def theme_query_string(theme)
    theme.present? && theme != 'system' ? "?theme=#{theme}" : ''
  end

  def generate_home_link(portal_slug, portal_locale, theme, is_plain_layout_enabled)
    if is_plain_layout_enabled
      "/hc/#{portal_slug}/#{portal_locale}#{theme_query_string(theme)}"
    else
      "/hc/#{portal_slug}/#{portal_locale}"
    end
  end

  def generate_category_link(params)
    portal_slug = params[:portal_slug]
    category_locale = params[:category_locale]
    category_slug = params[:category_slug]
    theme = params[:theme]
    is_plain_layout_enabled = params[:is_plain_layout_enabled]

    if is_plain_layout_enabled
      "/hc/#{portal_slug}/#{category_locale}/categories/#{category_slug}#{theme_query_string(theme)}"
    else
      "/hc/#{portal_slug}/#{category_locale}/categories/#{category_slug}"
    end
  end

  def generate_article_link(portal_slug, article_slug, theme, is_plain_layout_enabled)
    if is_plain_layout_enabled
      "/hc/#{portal_slug}/articles/#{article_slug}#{theme_query_string(theme)}"
    else
      "/hc/#{portal_slug}/articles/#{article_slug}"
    end
  end

  def render_category_content(content)
    ChatwootMarkdownRenderer.new(content).render_markdown_to_plain_text
  end

  def thumbnail_bg_color(username)
    colors = ['#6D95BA', '#A4C3C3', '#E19191']
    return colors.sample if username.blank?

    colors[username.length % colors.size]
  end
end

================
File: helpers/report_helper.rb
================
module ReportHelper
  private

  def scope
    case params[:type]
    when :account
      account
    when :inbox
      inbox
    when :agent
      user
    when :label
      label
    when :team
      team
    end
  end

  def conversations_count
    (get_grouped_values conversations).count
  end

  def incoming_messages_count
    (get_grouped_values incoming_messages).count
  end

  def outgoing_messages_count
    (get_grouped_values outgoing_messages).count
  end

  def resolutions_count
    (get_grouped_values resolutions).count
  end

  def bot_resolutions_count
    (get_grouped_values bot_resolutions).count
  end

  def bot_handoffs_count
    (get_grouped_values bot_handoffs).count
  end

  def conversations
    scope.conversations.where(account_id: account.id, created_at: range)
  end

  def incoming_messages
    scope.messages.where(account_id: account.id, created_at: range).incoming.unscope(:order)
  end

  def outgoing_messages
    scope.messages.where(account_id: account.id, created_at: range).outgoing.unscope(:order)
  end

  def resolutions
    scope.reporting_events.joins(:conversation).select(:conversation_id).where(account_id: account.id, name: :conversation_resolved,
                                                                               conversations: { status: :resolved }, created_at: range).distinct
  end

  def bot_resolutions
    scope.reporting_events.joins(:conversation).select(:conversation_id).where(account_id: account.id, name: :conversation_bot_resolved,
                                                                               conversations: { status: :resolved }, created_at: range).distinct
  end

  def bot_handoffs
    scope.reporting_events.joins(:conversation).select(:conversation_id).where(account_id: account.id, name: :conversation_bot_handoff,
                                                                               created_at: range).distinct
  end

  def avg_first_response_time
    grouped_reporting_events = (get_grouped_values scope.reporting_events.where(name: 'first_response', account_id: account.id))
    return grouped_reporting_events.average(:value_in_business_hours) if params[:business_hours]

    grouped_reporting_events.average(:value)
  end

  def reply_time
    grouped_reporting_events = (get_grouped_values scope.reporting_events.where(name: 'reply_time', account_id: account.id))
    return grouped_reporting_events.average(:value_in_business_hours) if params[:business_hours]

    grouped_reporting_events.average(:value)
  end

  def avg_resolution_time
    grouped_reporting_events = (get_grouped_values scope.reporting_events.where(name: 'conversation_resolved', account_id: account.id))
    return grouped_reporting_events.average(:value_in_business_hours) if params[:business_hours]

    grouped_reporting_events.average(:value)
  end

  def avg_resolution_time_summary
    reporting_events = scope.reporting_events
                            .where(name: 'conversation_resolved', account_id: account.id, created_at: range)
    avg_rt = if params[:business_hours].present?
               reporting_events.average(:value_in_business_hours)
             else
               reporting_events.average(:value)
             end

    return 0 if avg_rt.blank?

    avg_rt
  end

  def reply_time_summary
    reporting_events = scope.reporting_events
                            .where(name: 'reply_time', account_id: account.id, created_at: range)
    reply_time = params[:business_hours] ? reporting_events.average(:value_in_business_hours) : reporting_events.average(:value)

    return 0 if reply_time.blank?

    reply_time
  end

  def avg_first_response_time_summary
    reporting_events = scope.reporting_events
                            .where(name: 'first_response', account_id: account.id, created_at: range)
    avg_frt = if params[:business_hours].present?
                reporting_events.average(:value_in_business_hours)
              else
                reporting_events.average(:value)
              end

    return 0 if avg_frt.blank?

    avg_frt
  end
end

================
File: helpers/reporting_event_helper.rb
================
module ReportingEventHelper
  def business_hours(inbox, from, to)
    return 0 unless inbox.working_hours_enabled?

    inbox_working_hours = configure_working_hours(inbox.working_hours)
    return 0 if inbox_working_hours.blank?

    # Configure working hours
    WorkingHours::Config.working_hours = inbox_working_hours

    # Configure timezone
    WorkingHours::Config.time_zone = inbox.timezone

    # Use inbox timezone to change from & to values.
    from_in_inbox_timezone = from.in_time_zone(inbox.timezone).to_time
    to_in_inbox_timezone = to.in_time_zone(inbox.timezone).to_time
    from_in_inbox_timezone.working_time_until(to_in_inbox_timezone)
  end

  def last_non_human_activity(conversation)
    # check if a handoff event already exists
    handoff_event = ReportingEvent.where(conversation_id: conversation.id, name: 'conversation_bot_handoff').last

    # if a handoff exists, last non human activity is when the handoff ended,
    # otherwise it's when the conversation was created
    handoff_event&.event_end_time || conversation.created_at
  end

  private

  def configure_working_hours(working_hours)
    working_hours.each_with_object({}) do |working_hour, object|
      object[day(working_hour.day_of_week)] = working_hour_range(working_hour) unless working_hour.closed_all_day?
    end
  end

  def day(day_of_week)
    week_days = {
      0 => :sun,
      1 => :mon,
      2 => :tue,
      3 => :wed,
      4 => :thu,
      5 => :fri,
      6 => :sat
    }
    week_days[day_of_week]
  end

  def working_hour_range(working_hour)
    { format_time(working_hour.open_hour, working_hour.open_minutes) => format_time(working_hour.close_hour, working_hour.close_minutes) }
  end

  def format_time(hour, minute)
    hour = hour < 10 ? "0#{hour}" : hour
    minute = minute < 10 ? "0#{minute}" : minute
    "#{hour}:#{minute}"
  end
end

================
File: helpers/timezone_helper.rb
================
module TimezoneHelper
  # ActiveSupport TimeZone is not aware of the current time, so ActiveSupport::Timezone[offset]
  # would return the timezone without considering day light savings. To get the correct timezone,
  # this method uses zone.now.utc_offset for comparison as referenced in the issues below
  #
  # https://github.com/rails/rails/pull/22243
  # https://github.com/rails/rails/issues/21501
  # https://github.com/rails/rails/issues/7297
  def timezone_name_from_offset(offset)
    return 'UTC' if offset.blank?

    offset_in_seconds = offset.to_f * 3600
    matching_zone = ActiveSupport::TimeZone.all.find do |zone|
      zone.now.utc_offset == offset_in_seconds
    end

    return matching_zone.name if matching_zone
  end
end

================
File: helpers/widget_helper.rb
================
module WidgetHelper
  def build_contact_inbox_with_token(web_widget, additional_attributes = {})
    contact_inbox = web_widget.create_contact_inbox(additional_attributes)
    payload = { source_id: contact_inbox.source_id, inbox_id: web_widget.inbox.id }
    token = ::Widget::TokenService.new(payload: payload).generate_token

    [contact_inbox, token]
  end
end

================
File: javascript/dashboard/assets/scss/plugins/_dropdown.scss
================
.dropdown-pane {
  @apply border rounded-lg hidden relative invisible shadow-lg border-n-strong dark:border-n-strong box-content p-2 w-fit z-[9999];

  &.dropdown-pane--open {
    @apply bg-n-alpha-3 backdrop-blur-[100px] absolute  block visible;
  }
}

================
File: javascript/dashboard/assets/scss/plugins/_multiselect.scss
================
@mixin label-multiselect-hover {
  &::after {
    @apply text-woot-600 dark:text-woot-600;
  }

  &:hover {
    @apply bg-slate-50 dark:bg-slate-700;

    &::after {
      @apply text-woot-500 dark:text-woot-500;
    }
  }
}

.multiselect {
  &:not(.no-margin) {
    @apply mb-4;
  }

  &.multiselect--disabled {
    @apply opacity-50 border border-slate-200 dark:border-slate-600 rounded-md cursor-not-allowed;

    .multiselect__select {
      @apply cursor-not-allowed bg-white dark:bg-slate-900 rounded-md;
    }

    .multiselect__tags {
      @apply border-0;
    }
  }

  .multiselect--active {
    > .multiselect__tags {
      @apply border-woot-500 dark:border-woot-500;
    }
  }

  .multiselect__select {
    @apply min-h-[2.875rem] p-0 right-0 top-0;

    &::before {
      @apply right-0;
    }
  }

  .multiselect__content-wrapper {
    @apply bg-white dark:bg-slate-900 border border-solid border-slate-200 dark:border-slate-600 text-slate-800 dark:text-slate-100;
  }

  .multiselect__content {
    @apply max-w-full;

    .multiselect__option {
      @apply text-sm font-normal;

      span {
        @apply inline-block overflow-hidden text-ellipsis whitespace-nowrap w-fit;
      }

      p {
        @apply mb-0;
      }

      &.multiselect__option--highlight {
        @apply bg-white dark:bg-slate-800 text-slate-800 dark:text-slate-100;
      }

      &.multiselect__option--highlight:hover {
        @apply bg-woot-50 dark:bg-woot-600 text-slate-800 dark:text-slate-100;

        &::after {
          @apply bg-woot-50 dark:bg-woot-600 text-slate-600 dark:text-slate-200;
        }
      }

      &.multiselect__option--highlight::after {
        @apply bg-transparent;
      }

      &.multiselect__option--selected {
        @apply bg-woot-50 dark:bg-woot-600 text-slate-800 dark:text-slate-100;

        &.multiselect__option--highlight:hover {
          @apply bg-woot-75 dark:bg-woot-600;

          &::after {
            @apply bg-transparent;
          }

          &::after:hover {
            @apply text-slate-800 dark:text-slate-100;
          }
        }
      }
    }
  }

  .multiselect__tags {
    @apply bg-white dark:bg-slate-900 border border-solid border-slate-200 dark:border-slate-600 m-0 min-h-[2.875rem] pt-0;

    input {
      @apply border-0 border-none;
    }
  }

  .multiselect__tags-wrap {
    @apply inline-block leading-none mt-1;
  }

  .multiselect__placeholder {
    @apply text-slate-400 dark:text-slate-400 font-normal pt-3;
  }

  .multiselect__tag {
    @apply bg-slate-50 dark:bg-slate-800 mt-1 text-slate-800 dark:text-slate-100 pr-6 pl-2.5 py-1.5;
  }

  .multiselect__tag-icon {
    @include label-multiselect-hover;
  }

  .multiselect__input {
    @include ghost-input;
    @apply text-sm h-[2.875rem] mb-0 p-0;
  }

  .multiselect__single {
    @apply bg-white dark:bg-slate-900 text-slate-800 dark:text-slate-100 inline-block mb-0 py-3 px-2.5 overflow-hidden whitespace-nowrap text-ellipsis;
  }
}

.sidebar-labels-wrap {
  &.has-edited,
  &:hover {
    .multiselect {
      @apply cursor-pointer;
    }
  }

  .multiselect {
    > .multiselect__select {
      @apply invisible;
    }

    > .multiselect__tags {
      @apply border-transparent;
    }

    &.multiselect--active > .multiselect__tags {
      @apply border-woot-500 dark:border-woot-500;
    }
  }
}

.multiselect-wrap--small {
  // To be removed one SLA reports date picker is created
  &.tiny {
    .multiselect.no-margin {
      @apply min-h-[32px];
    }

    .multiselect__select {
      @apply min-h-[32px] h-8;

      &::before {
        @apply top-[60%];
      }
    }

    .multiselect__tags {
      @apply min-h-[32px] max-h-[32px];

      .multiselect__single {
        @apply pt-1 pb-1;
      }
    }
  }

  .multiselect__tags,
  .multiselect__input,
  .multiselect {
    @apply bg-white dark:bg-slate-900 text-slate-800 dark:text-slate-100 rounded-[5px] text-sm  min-h-[2.5rem];
  }

  .multiselect__input {
    @apply h-[2.375rem] min-h-[2.375rem];
  }

  .multiselect__single {
    @apply items-center flex m-0 text-sm max-h-[2.375rem] text-slate-800 dark:text-slate-100 bg-white dark:bg-slate-900 py-3 px-0.5;
  }

  .multiselect__placeholder {
    @apply m-0 py-2 px-0.5;
  }

  .multiselect__tag {
    @apply py-[6px] my-[1px];
  }

  .multiselect__select {
    @apply min-h-[2.5rem];
  }

  .multiselect--disabled .multiselect__current,
  .multiselect--disabled .multiselect__select {
    @apply bg-transparent;
  }
}

.multiselect-wrap--medium {
  .multiselect__tags,
  .multiselect__input {
    @apply items-center flex;
  }

  .multiselect__tags,
  .multiselect__input,
  .multiselect {
    @apply bg-white dark:bg-slate-900 text-slate-800 dark:text-slate-100 text-sm h-12 min-h-[3rem];
  }

  .multiselect__input {
    @apply h-[2.875rem] min-h-[2.875rem];
    margin-bottom: 0px !important;
  }

  .multiselect__single {
    @apply items-center flex m-0 text-sm py-1 px-0.5 text-slate-800 dark:text-slate-100 bg-white dark:bg-slate-900;
  }

  .multiselect__placeholder {
    @apply m-0 py-1 px-0.5;
  }

  .multiselect__select {
    @apply min-h-[3rem];
  }

  .multiselect--disabled .multiselect__current,
  .multiselect--disabled .multiselect__select {
    @apply bg-transparent;
  }

  .multiselect__tags-wrap {
    @apply flex-shrink-0;
  }
}

================
File: javascript/dashboard/assets/scss/super_admin/index.scss
================
@import 'shared/assets/fonts/inter';
@import 'tailwindcss/base';
@import 'tailwindcss/components';
@import 'tailwindcss/utilities';

body {
  font-family: Inter, -apple-system, system-ui, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif !important;
}

@layer base {
  // FIXME: Use a common color file for all packs
  // scss-lint:disable PropertySortOrder
  :root {
    --slate-1: 252 252 253;
    --slate-2: 249 249 251;
    --slate-3: 240 240 243;
    --slate-4: 232 232 236;
    --slate-5: 224 225 230;
    --slate-6: 217 217 224;
    --slate-7: 205 206 214;
    --slate-8: 185 187 198;
    --slate-9: 139 141 152;
    --slate-10: 128 131 141;
    --slate-11: 96 100 108;
    --slate-12: 28 32 36;

    --iris-1: 253 253 255;
    --iris-2: 248 248 255;
    --iris-3: 240 241 254;
    --iris-4: 230 231 255;
    --iris-5: 218 220 255;
    --iris-6: 203 205 255;
    --iris-7: 184 186 248;
    --iris-8: 155 158 240;
    --iris-9: 91 91 214;
    --iris-10: 81 81 205;
    --iris-11: 87 83 198;
    --iris-12: 39 41 98;

    --ruby-1: 255 252 253;
    --ruby-2: 255 247 248;
    --ruby-3: 254 234 237;
    --ruby-4: 255 220 225;
    --ruby-5: 255 206 214;
    --ruby-6: 248 191 200;
    --ruby-7: 239 172 184;
    --ruby-8: 229 146 163;
    --ruby-9: 229 70 102;
    --ruby-10: 220 59 93;
    --ruby-11: 202 36 77;
    --ruby-12: 100 23 43;

    --amber-1: 254 253 251;
    --amber-2: 254 251 233;
    --amber-3: 255 247 194;
    --amber-4: 255 238 156;
    --amber-5: 251 229 119;
    --amber-6: 243 214 115;
    --amber-7: 233 193 98;
    --amber-8: 226 163 54;
    --amber-9: 255 197 61;
    --amber-10: 255 186 24;
    --amber-11: 171 100 0;
    --amber-12: 79 52 34;

    --teal-1: 250 254 253;
    --teal-2: 243 251 249;
    --teal-3: 224 248 243;
    --teal-4: 204 243 234;
    --teal-5: 184 234 224;
    --teal-6: 161 222 210;
    --teal-7: 131 205 193;
    --teal-8: 83 185 171;
    --teal-9: 18 165 148;
    --teal-10: 13 155 138;
    --teal-11: 0 133 115;
    --teal-12: 13 61 56;

    --gray-1: 252 252 252;
    --gray-2: 249 249 249;
    --gray-3: 240 240 240;
    --gray-4: 232 232 232;
    --gray-5: 224 224 224;
    --gray-6: 217 217 217;
    --gray-7: 206 206 206;
    --gray-8: 187 187 187;
    --gray-9: 141 141 141;
    --gray-10: 131 131 131;
    --gray-11: 100 100 100;
    --gray-12: 32 32 32;

    --background-color: 253 253 253;
    --text-blue: 8 109 224;
    --border-container: 236 236 236;
    --border-strong: 235 235 235;
    --border-weak: 234 234 234;
    --solid-1: 255 255 255;
    --solid-2: 255 255 255;
    --solid-3: 255 255 255;
    --solid-active: 255 255 255;
    --solid-amber: 252 232 193;
    --solid-blue: 218 236 255;
    --solid-iris: 230 231 255;

    --alpha-1: 67, 67, 67, 0.06;
    --alpha-2: 201, 202, 207, 0.15;
    --alpha-3: 255, 255, 255, 0.96;
    --black-alpha-1: 0, 0, 0, 0.12;
    --black-alpha-2: 0, 0, 0, 0.04;
    --border-blue: 39, 129, 246, 0.5;
    --white-alpha: 255, 255, 255, 0.8;
  }

  .dark {
    --slate-1: 17 17 19;
    --slate-2: 24 25 27;
    --slate-3: 33 34 37;
    --slate-4: 39 42 45;
    --slate-5: 46 49 53;
    --slate-6: 54 58 63;
    --slate-7: 67 72 78;
    --slate-8: 90 97 105;
    --slate-9: 105 110 119;
    --slate-10: 119 123 132;
    --slate-11: 176 180 186;
    --slate-12: 237 238 240;

    --iris-1: 19 19 30;
    --iris-2: 23 22 37;
    --iris-3: 32 34 72;
    --iris-4: 38 42 101;
    --iris-5: 48 51 116;
    --iris-6: 61 62 130;
    --iris-7: 74 74 149;
    --iris-8: 89 88 177;
    --iris-9: 91 91 214;
    --iris-10: 84 114 228;
    --iris-11: 158 177 255;
    --iris-12: 224 223 254;

    --ruby-1: 25 17 19;
    --ruby-2: 30 21 23;
    --ruby-3: 58 20 30;
    --ruby-4: 78 19 37;
    --ruby-5: 94 26 46;
    --ruby-6: 111 37 57;
    --ruby-7: 136 52 71;
    --ruby-8: 179 68 90;
    --ruby-9: 229 70 102;
    --ruby-10: 236 90 114;
    --ruby-11: 255 148 157;
    --ruby-12: 254 210 225;

    --amber-1: 22 18 12;
    --amber-2: 29 24 15;
    --amber-3: 48 32 8;
    --amber-4: 63 39 0;
    --amber-5: 77 48 0;
    --amber-6: 92 61 5;
    --amber-7: 113 79 25;
    --amber-8: 143 100 36;
    --amber-9: 255 197 61;
    --amber-10: 255 214 10;
    --amber-11: 255 202 22;
    --amber-12: 255 231 179;

    --teal-1: 13 21 20;
    --teal-2: 17 28 27;
    --teal-3: 13 45 42;
    --teal-4: 2 59 55;
    --teal-5: 8 72 67;
    --teal-6: 20 87 80;
    --teal-7: 28 105 97;
    --teal-8: 32 126 115;
    --teal-9: 18 165 148;
    --teal-10: 14 179 158;
    --teal-11: 11 216 182;
    --teal-12: 173 240 221;

    --gray-1: 17 17 17;
    --gray-2: 25 25 25;
    --gray-3: 34 34 34;
    --gray-4: 42 42 42;
    --gray-5: 49 49 49;
    --gray-6: 58 58 58;
    --gray-7: 72 72 72;
    --gray-8: 96 96 96;
    --gray-9: 110 110 110;
    --gray-10: 123 123 123;
    --gray-11: 180 180 180;
    --gray-12: 238 238 238;

    --background-color: 18 18 19;
    --border-strong: 52 52 52;
    --border-weak: 38 38 42;
    --solid-1: 23 23 26;
    --solid-2: 29 30 36;
    --solid-3: 44 45 54;
    --solid-active: 53 57 66;
    --solid-amber: 42 37 30;
    --solid-blue: 16 49 91;
    --solid-iris: 38 42 101;
    --text-blue: 126 182 255;

    --alpha-1: 36, 36, 36, 0.8;
    --alpha-2: 139, 147, 182, 0.15;
    --alpha-3: 36, 38, 45, 0.9;
    --black-alpha-1: 0, 0, 0, 0.3;
    --black-alpha-2: 0, 0, 0, 0.2;
    --border-blue: 39, 129, 246, 0.5;
    --border-container: 236, 236, 236, 0;
    --white-alpha: 255, 255, 255, 0.1;
  }
}

================
File: javascript/dashboard/assets/scss/views/settings/inbox.scss
================
// to be removed

================
File: javascript/dashboard/assets/scss/views/settings/integrations.scss
================
// to be removed

================
File: javascript/dashboard/assets/scss/widgets/_base.scss
================
// scss-lint:disable QualifyingElement

// Base typography
h1,
h2,
h3,
h4,
h5,
h6 {
  @apply font-medium text-slate-800 dark:text-slate-50;
}

p {
  text-rendering: optimizeLegibility;

  @apply mb-2 leading-[1.65] text-sm;

  a {
    @apply text-woot-500 dark:text-woot-500 cursor-pointer;
  }
}

a {
  @apply text-sm;
}

hr {
  @apply clear-both max-w-full h-0 my-5 mx-0 border-slate-300 dark:border-slate-600;
}

ul,
ol,
dl {
  @apply list-disc list-outside leading-[1.65];
}

ul:not(.reset-base),
ol:not(.reset-base),
dl:not(.reset-base) {
  @apply mb-0;
}

// Form elements
label {
  @apply text-slate-800 dark:text-slate-200 block m-0 leading-7 text-sm font-medium;

  &.error {
    input {
      @apply mb-1;
    }
  }
}

.input-wrap,
.help-text {
  @apply text-slate-800 dark:text-slate-100 text-sm font-medium;

  .help-text {
    @apply font-normal text-slate-600 dark:text-slate-400;
  }
}

// Focus outline removal
.button,
textarea,
input:focus {
  outline: none;
}

// Inputs
input[type='text']:not(.reset-base),
input[type='number']:not(.reset-base),
input[type='password']:not(.reset-base),
input[type='date']:not(.reset-base),
input[type='email']:not(.reset-base),
input[type='url']:not(.reset-base) {
  @apply block box-border w-full transition-colors focus:border-woot-500 dark:focus:border-woot-600 duration-[0.25s] ease-[ease-in-out] h-10 appearance-none mx-0 mt-0 mb-4 p-2 rounded-md text-base font-normal bg-white dark:bg-slate-900 focus:bg-white focus:dark:bg-slate-900 text-slate-900 dark:text-slate-100 border border-solid border-slate-200 dark:border-slate-600;

  &[disabled] {
    @apply bg-slate-200 dark:bg-slate-700 text-slate-400 dark:text-slate-400 border-slate-200 dark:border-slate-600 cursor-not-allowed;
  }
}

input[type='file'] {
  @apply bg-white dark:bg-n-solid-1 leading-[1.15] mb-4;
}

// Select
select {
  background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' version='1.1' width='32' height='24' viewBox='0 0 32 24'><polygon points='0,0 32,0 16,24' style='fill: rgb%28110, 111, 115%29'></polygon></svg>");
  background-position: right -1rem center;
  background-size: 9px 6px;
  @apply h-10 mx-0 mt-0 mb-4 bg-origin-content focus-visible:outline-none bg-no-repeat py-2 pr-6 pl-2 rounded-md w-full text-base font-normal appearance-none transition-colors focus:border-woot-500 dark:focus:border-woot-600 duration-[0.25s] ease-[ease-in-out] bg-white dark:bg-slate-900 text-slate-900 dark:text-slate-100 border border-solid border-slate-200 dark:border-slate-600;
}

// Textarea
textarea {
  @apply block box-border w-full transition-colors focus:border-woot-500 dark:focus:border-woot-600 duration-[0.25s] ease-[ease-in-out] h-16 appearance-none mx-0 mt-0 mb-4 p-2 rounded-md text-base font-normal bg-white dark:bg-slate-900 focus:bg-white focus:dark:bg-slate-900 text-slate-900 dark:text-slate-100 border border-solid border-slate-200 dark:border-slate-600;

  &[disabled] {
    @apply bg-slate-200 dark:bg-slate-700 text-slate-400 dark:text-slate-400 border-slate-200 dark:border-slate-600 cursor-not-allowed;
  }
}

// Error handling
.has-multi-select-error {
  div.multiselect {
    @apply mb-1;
  }
}

.error {
  input,
  input:not([type]),
  textarea,
  select,
  .multiselect > .multiselect__tags,
  .multiselect:not(.no-margin) {
    @apply border border-solid border-red-400 dark:border-red-400 mb-1;
  }

  .message {
    @apply text-red-400 dark:text-red-400 block text-sm mb-2.5 w-full;
  }
}

.input-group.small {
  input {
    @apply text-sm h-8;
  }

  .error {
    @apply border-red-400 dark:border-red-400;
  }
}

// Code styling
code {
  font-family: 'ui-monospace', 'SFMono-Regular', 'Menlo', 'Monaco', 'Consolas',
    '"Liberation Mono"', '"Courier New"', 'monospace';
  @apply text-xs border-0;

  &.hljs {
    @apply bg-n-slate-3 dark:bg-n-solid-3 text-slate-800 dark:text-slate-50 rounded-lg p-5;

    .hljs-number,
    .hljs-string {
      @apply text-red-800 dark:text-red-400;
    }

    .hljs-name,
    .hljs-tag {
      @apply text-n-slate-11;
    }
  }
}

================
File: javascript/dashboard/assets/scss/widgets/_buttons.scss
================
// scss-lint:disable SpaceAfterPropertyColon
// scss-lint:disable MergeableSelector
button {
  font-family: inherit;
  transition:
    background-color 0.25s ease-out,
    color 0.25s ease-out;
  @apply inline-block items-center mb-0 text-center align-middle cursor-pointer text-sm mt-0 mx-0 py-1 px-2.5 border border-solid border-transparent dark:border-transparent rounded-[0.3125rem];

  &:disabled,
  &.disabled {
    @apply opacity-40 cursor-not-allowed;
  }
}

.button-group {
  @apply mb-0 flex flex-nowrap items-stretch;

  .button {
    flex: 0 0 auto;
    @apply m-0 text-sm rounded-none first:rounded-tl-[0.3125rem] first:rounded-bl-[0.3125rem] last:rounded-tr-[0.3125rem] last:rounded-br-[0.3125rem] rtl:space-x-reverse;
  }

  .button--only-icon {
    @apply w-10 justify-center pl-0 pr-0;
  }
}

.back-button {
  @apply m-0;
}

.button {
  @apply items-center bg-n-brand px-2.5 text-white dark:text-white inline-flex h-10 mb-0 gap-2 font-medium;

  .button__content {
    @apply w-full whitespace-nowrap overflow-hidden text-ellipsis;

    img,
    svg {
      @apply inline-block;
    }
  }

  &:hover:not(.secondary):not(.success):not(.alert):not(.warning):not(
      .clear
    ):not(.smooth):not(.hollow) {
    @apply bg-n-brand/80 dark:bg-n-brand/80;
  }

  &:disabled,
  &.disabled {
    @apply opacity-40 cursor-not-allowed;
  }

  &.success {
    @apply bg-n-teal-9 text-white dark:text-white;
  }

  &.secondary {
    @apply bg-n-solid-3 text-white dark:text-white;
  }

  &.primary {
    @apply bg-n-brand text-white dark:text-white;
  }

  &.clear {
    @apply text-n-blue-text dark:text-n-blue-text bg-transparent dark:bg-transparent;
  }

  &.alert {
    @apply bg-n-ruby-9 text-white dark:text-white;

    &.clear {
      @apply bg-transparent dark:bg-transparent;
    }
  }

  &.warning {
    @apply bg-n-amber-9 text-white dark:text-white;

    &.clear {
      @apply bg-transparent dark:bg-transparent;
    }
  }

  &.tiny {
    @apply h-6 text-[10px];
  }

  &.small {
    @apply h-8 text-xs;
  }

  .spinner {
    @apply px-2 py-0;
  }

  // @TODDO - Remove after moving all buttons to woot-button
  .icon + .button__content {
    @apply w-auto;
  }

  &.expanded {
    @apply flex justify-center text-center;
  }

  &.round {
    @apply rounded-full;
  }

  // @TODO Use with link

  &.compact {
    @apply pb-0 pt-0;
  }

  &.hollow {
    @apply border border-n-brand/40 bg-transparent text-n-blue-text hover:bg-n-brand/20;

    &.secondary {
      @apply text-n-slate-12 border-n-slate-5 hover:bg-n-slate-5;
    }

    &.success {
      @apply text-n-teal-9 border-n-teal-8 hover:bg-n-teal-5;
    }

    &.alert {
      @apply text-n-ruby-9 border-n-ruby-8 hover:bg-n-ruby-5;
    }

    &.warning {
      @apply text-n-amber-9 border-n-amber-8 hover:bg-n-amber-5;
    }
  }

  // Smooth style
  &.smooth {
    @apply bg-n-brand/10 dark:bg-n-brand/30 text-n-blue-text hover:bg-n-brand/20 dark:hover:bg-n-brand/40;

    &.secondary {
      @apply bg-n-slate-4 text-n-slate-11 hover:text-n-slate-11 hover:bg-n-slate-5;
    }

    &.success {
      @apply bg-n-teal-4 text-n-teal-11 hover:text-n-teal-11 hover:bg-n-teal-5;
    }

    &.alert {
      @apply bg-n-ruby-4 text-n-ruby-11 hover:text-n-ruby-11 hover:bg-n-ruby-5;
    }

    &.warning {
      @apply bg-n-amber-4 text-n-amber-11 hover:text-n-amber-11 hover:bg-n-amber-5;
    }
  }

  &.clear {
    @apply text-n-blue-text hover:bg-n-brand/10 dark:hover:bg-n-brand/30;

    &.secondary {
      @apply text-n-slate-12 hover:bg-n-slate-4;
    }

    &.success {
      @apply text-n-teal-10 hover:bg-n-teal-4;
    }

    &.alert {
      @apply text-n-ruby-11 hover:bg-n-ruby-4;
    }

    &.warning {
      @apply text-n-amber-11 hover:bg-n-amber-4;
    }

    &:active {
      &.secondary {
        @apply active:bg-n-slate-3 dark:active:bg-n-slate-7;
      }
    }

    &:focus {
      &.secondary {
        @apply focus:bg-n-slate-4 dark:focus:bg-n-slate-6;
      }
    }
  }

  // Sizes
  &.tiny {
    @apply h-6;
  }

  &.small {
    @apply h-8 pb-1 pt-1;
  }

  &.large {
    @apply h-12;
  }

  &.button--only-icon {
    @apply justify-center pl-0 pr-0 w-10;

    &.tiny {
      @apply w-6;
    }

    &.small {
      @apply w-8;
    }

    &.large {
      @apply w-12;
    }
  }

  &.link {
    @apply h-auto m-0 p-0;

    &:hover {
      @apply underline;
    }
  }
}

================
File: javascript/dashboard/assets/scss/widgets/_conversation-view.scss
================
// scss-lint:disable MergeableSelector

@tailwind utilities;
@layer utilities {
  .custom-gradient {
    background-image: linear-gradient(
      -180deg,
      transparent 3%,
      rgb(76 81 85) 130%
    );
  }

  .bubble-with-types {
    @apply py-2 text-sm font-normal bg-woot-500 dark:bg-woot-500 relative px-4 m-0 text-white dark:text-white;

    .message-text__wrap {
      @apply relative;

      .link {
        @apply text-white dark:text-white underline;
      }
    }

    .image,
    .video {
      @apply cursor-pointer relative;

      .modal-container {
        @apply text-center;
      }

      .modal-image {
        @apply max-h-[76vh] max-w-[76vw];
      }

      .modal-video {
        @apply max-h-[76vh] max-w-[76vw];
      }

      &::before {
        @apply custom-gradient bottom-0 h-[20%] content-[''] left-0 absolute w-full opacity-80;
      }
    }
  }
}

.conversation-panel {
  @apply flex-shrink flex-grow basis-px flex flex-col overflow-y-auto relative h-full m-0 pb-4;
}

.conversation-panel > li {
  @apply flex flex-shrink-0 flex-grow-0 flex-auto max-w-full mt-0 mr-0 mb-1 ml-0 relative first:mt-auto last:mb-0;

  &.unread--toast {
    + .right {
      @apply mb-1;
    }

    + .left {
      @apply mb-0;
    }

    span {
      @apply shadow-lg rounded-full bg-woot-500 dark:bg-woot-500 text-white dark:text-white text-xs font-medium my-2.5 mx-auto px-2.5 py-1.5;
    }
  }

  .bubble {
    @apply bubble-with-types text-left break-words;

    .aplayer {
      @apply shadow-none;
      font-family: inherit;
    }
  }

  &.left {
    .bubble {
      @apply rounded-r-lg rounded-l mr-auto break-words;

      &:not(.is-unsupported) {
        @apply border border-slate-50 dark:border-slate-700 bg-white dark:bg-slate-700 text-black-900 dark:text-slate-50;
      }

      &.is-image {
        @apply rounded-lg;
      }

      .link {
        @apply text-woot-600 dark:text-woot-600;
      }

      .file {
        .attachment-name {
          @apply text-slate-700 dark:text-woot-300;
        }

        .icon-wrap {
          @apply text-woot-600 dark:text-woot-600;
        }

        .download {
          @apply text-woot-600 dark:text-woot-600;
        }
      }
    }

    + .right {
      @apply mt-2.5;

      .bubble {
        @apply rounded-tr-lg;
      }
    }

    + .unread--toast {
      + .right {
        @apply mt-2.5;

        .bubble {
          @apply rounded-tr-lg;
        }
      }

      + .left {
        @apply mt-0;
      }
    }
  }

  &.right {
    @apply justify-end;

    .wrap {
      @apply flex items-end mr-4 text-right;

      .sender--info {
        @apply pt-2 pb-1 pr-0 pl-2;
      }
    }

    .bubble {
      @apply ml-auto break-words rounded-l-lg rounded-r;

      &.is-private {
        @apply text-black-900 dark:text-white relative border border-solid bg-yellow-100 dark:bg-yellow-700 border-yellow-200 dark:border-yellow-600/25;

        blockquote {
          @apply border-slate-400 dark:border-slate-400 text-slate-800 dark:text-slate-300;

          p {
            @apply text-slate-600 dark:text-slate-300;
          }
        }
      }

      &.is-image {
        @apply rounded-lg;

        .message__mail-head {
          @apply px-4 py-2;
        }
      }
    }

    + .left {
      @apply mt-2.5;

      .bubble {
        @apply rounded-tl-lg;
      }
    }

    + .unread--toast {
      + .left {
        @apply rounded-lg;

        .bubble {
          @apply rounded-tl-lg;
        }
      }

      + .right {
        @apply mt-0;
      }
    }
  }

  &.center {
    @apply items-center justify-center;
  }

  .wrap {
    max-width: Min(31rem, 84%);
    @apply my-0 mx-4;

    .sender--name {
      @apply text-xs mb-1;
    }
  }

  .sender--thumbnail {
    @apply h-3 mr-3 mt-0.5 w-3 rounded-full;
  }

  .activity-wrap {
    @apply flex justify-center text-sm my-1 mx-0 py-1 pr-0.5 pl-2.5 bg-slate-50 dark:bg-slate-600 text-slate-800 dark:text-slate-100 rounded-md border border-slate-100 dark:border-slate-600 border-solid;

    .is-text {
      @apply inline-flex items-center text-start 2xl:flex;
    }
  }
}

.activity-wrap .message-text__wrap {
  .text-content p {
    @apply mb-0;
  }
}

.conversation-footer {
  @apply flex relative flex-col;
}

.left .bubble .text-content {
  h1,
  h2,
  h3,
  h4,
  h5,
  h6 {
    @apply text-slate-800 dark:text-slate-100;
  }

  a {
    @apply text-woot-500 dark:text-woot-500 underline;
  }

  p:last-child {
    @apply mb-0;
  }
}

.right .bubble .text-content {
  h1,
  h2,
  h3,
  h4,
  h5,
  h6 {
    @apply text-white dark:text-white;
  }

  a {
    @apply text-white dark:text-white underline;
  }

  p:last-child {
    @apply mb-0;
  }
}

================
File: javascript/dashboard/assets/scss/widgets/_tabs.scss
================
.tabs--container {
  @apply flex;
}

.tabs--container--with-border {
  @apply border-b border-n-weak;
}

.tabs--container--compact.tab--chat-type {
  .tabs-title {
    a {
      @apply py-2 text-sm;
    }
  }
}

.tabs {
  @apply border-r-0 border-l-0 border-t-0 flex min-w-[6.25rem] py-0 px-4 list-none mb-0;
}

.tabs--with-scroll {
  @apply overflow-hidden py-0 px-1;
  max-width: calc(100% - 64px);
}

.tabs--scroll-button {
  @apply items-center rounded-none cursor-pointer flex h-auto justify-center min-w-[2rem];
}

// Tab chat type
.tab--chat-type {
  @apply flex;

  .tabs-title {
    a {
      @apply text-base font-medium py-3;
    }
  }
}

.tabs-title {
  @apply flex-shrink-0 my-0 mx-2;

  .badge {
    @apply bg-n-alpha-black2 dark:bg-n-solid-3 rounded-md text-n-slate-11 h-5 flex items-center justify-center text-xxs font-semibold my-0 mx-1 px-1 py-0;
  }

  &:first-child {
    @apply ml-0;
  }

  &:last-child {
    @apply mr-0;
  }

  &:hover,
  &:focus {
    a {
      @apply text-n-slate-12;
    }
  }

  a {
    @apply flex items-center flex-row border-b py-2.5 select-none cursor-pointer border-transparent text-n-slate-11 text-sm top-[1px] relative;
    transition: border-color 0.15s $swift-ease-out-function;
  }

  &.is-active {
    a {
      @apply border-b border-n-brand text-n-blue-text;
    }

    .badge {
      @apply bg-n-brand/10 dark:bg-n-brand/20 text-n-blue-text;
    }
  }
}

================
File: javascript/dashboard/assets/scss/widgets/_woot-tables.scss
================
table {
  @apply border-spacing-0 text-sm w-full;


}

.woot-table {
  thead {
    th {
      @apply font-semibold tracking-[1px] text-left px-2.5 uppercase text-slate-900 dark:text-slate-200;
    }
  }

  tbody {
    tr {
      @apply border-b border-slate-50 dark:border-slate-800/30;
    }

    td {
      @apply p-2.5 text-slate-700 dark:text-slate-100;
    }
  }

  tr {
    .show-if-hover {
      transition: opacity 0.2s $swift-ease-out-function;
      @apply opacity-0;
    }

    &:hover {
      .show-if-hover {
        @apply opacity-100;
      }
    }
  }

  .agent-name {
    @apply block font-medium capitalize;
  }

  .woot-thumbnail {
    @apply rounded-full h-[3.125rem] w-[3.125rem];
  }

  .button-wrapper {
    @apply flex justify-start flex-row min-w-[12.5rem] gap-1;
  }

  .button {
    margin: 0;
  }
}

.ve-table {
  .ve-table-container.ve-table-border-around {
    @apply border-slate-200 dark:border-slate-700;
  }

  .ve-table-content {
    .ve-table-header .ve-table-header-tr .ve-table-header-th {
      @apply bg-slate-50 dark:bg-slate-800 text-slate-800 dark:text-slate-100 border-slate-100 dark:border-slate-700/50;
    }

    .ve-table-body .ve-table-body-tr .ve-table-body-td {
      @apply bg-white dark:bg-slate-900 text-slate-900 dark:text-slate-100 border-slate-75 dark:border-slate-800;
    }

    .ve-table-body.ve-table-row-hover .ve-table-body-tr:hover td {
      @apply bg-slate-50 dark:bg-slate-700 text-slate-800 dark:text-slate-100;
    }
  }
}

.table-pagination {
  .ve-pagination-total {
    @apply text-slate-600 dark:text-slate-200;
  }

  .ve-pagination-goto {
    @apply text-slate-600 dark:text-slate-200;

    .ve-pagination-goto-input {
      @apply bg-white dark:bg-slate-900 text-slate-600 dark:text-slate-200;
    }
  }

  .ve-pagination-li {
    @apply bg-white dark:bg-slate-900 text-slate-600 dark:text-slate-200 border-slate-75 dark:border-slate-700;
  }
}

================
File: javascript/dashboard/assets/scss/_animations.scss
================
.slide-fade-enter-active {
  transition: all 0.3s var(--ease-in-cubic);
}

.slide-fade-leave-active {
  transition: all 0.3s var(--ease-out-cubic);
}

.slide-fade-enter,
.slide-fade-leave-to {
  opacity: 0;
  transform: translateX(10px);
}

.slide-fade-enter {
  transform: translateX($space-micro);
}

.slide-fade-leave-to {
  transform: translateX($space-medium);
}

.conversations-list-enter-active,
.conversations-list-leave-active {
  transition: all 0.25s var(--ease-out-cubic);
}

.conversations-list-enter,
.conversations-list-leave-to {
  opacity: 0;
  transform: translateX($space-medium);
}

.slide-up-enter-active {
  transition: all 0.3s var(--ease-in-cubic);
}

.slide-up-leave-active {
  transition: all 0.3s var(--ease-out-cubic);
}

.slide-up-enter,
.slide-up-leave-to {
  opacity: 0;
  transform: translateY(-$space-medium);
}

.menu-slide-enter-active,
.menu-slide-leave-active {
  transform: translateY(0);
  transition:
    transform 0.25s var(--ease-in-cubic),
    opacity 0.15s var(--ease-in-cubic);
}

.menu-slide-enter,
.menu-slide-leave-to {
  opacity: 0;
  transform: translateY($space-small);
}

.toast-fade-enter-active {
  transition: all 0.3s var(--ease-in-sine);
}

.toast-fade-leave-active {
  transition: all 0.1s var(--ease-out-sine);
}

.toast-fade-enter,
.toast-fade-leave-to {
  opacity: 0;
  transform: translateY(-$space-small);
}

.modal-fade-enter-active {
  transition: all 0.3s var(--ease-in-sine);
}

.modal-fade-leave-active {
  transition: all 0.1s var(--ease-out-sine);
}

.modal-fade-enter,
.modal-fade-leave-to {
  opacity: 0;
}

.network-notification-fade-enter-active {
  transition: all 0.1s var(--ease-in-sine);
}

.network-notification-fade-leave-active {
  transition: all 0.1s var(--ease-out-sine);
}

.network-notification-fade-enter,
.network-notification-fade-leave-to {
  opacity: 0;
  transform: translateY(-$space-small);
}

================
File: javascript/dashboard/assets/scss/_date-picker.scss
================
@import 'vue-datepicker-next/scss/index';

.date-picker {
  // To be removed one SLA reports date picker is created
  &.small {
    .mx-input {
      @apply h-8 text-sm;
    }
  }

  &.no-margin {
    .mx-input {
      @apply mb-0;
    }
  }

  &:not(.auto-width) {
    .mx-datepicker-range {
      @apply w-[320px];
    }
  }

  .mx-datepicker {
    @apply w-full;
  }

  .mx-input {
    @apply h-[2.5rem] flex border border-solid border-n-weak rounded-md shadow-none;
  }

  .mx-input:disabled,
  .mx-input[readonly] {
    @apply bg-white dark:bg-slate-900 cursor-pointer;
  }

  .mx-icon-calendar {
    @apply dark:text-slate-500;
  }
}

.mx-datepicker-main {
  @apply border-0 bg-n-solid-2 rounded-xl;

  .cell {
    &.disabled {
      @apply bg-slate-25 dark:bg-slate-900 text-slate-200 dark:text-slate-300;
    }

    &:hover,
    &.hover-in-range,
    &.in-range {
      @apply bg-slate-75 dark:bg-slate-700 text-slate-900 dark:text-slate-100;
    }
  }

  .mx-calendar+.mx-calendar {
    @apply border-l border-n-weak;
  }

  .mx-datepicker-footer {
    @apply border border-n-weak;
  }

  .mx-time {
    @apply border-0 bg-white dark:bg-slate-800;

    .mx-time-header {
      @apply border-0;
    }

    .mx-time-item {
      &.disabled {
        @apply bg-slate-25 dark:bg-slate-900;
      }

      &:hover {
        @apply bg-slate-75 dark:bg-slate-700;
      }
    }
  }

  .today {
    @apply font-semibold;
  }
}

.mx-datepicker-popup {
  @apply z-[99999];
}

.mx-datepicker-inline {
  @apply w-full;

  .mx-calendar {
    @apply w-full;
  }
}

================
File: javascript/dashboard/assets/scss/_formulate.scss
================
@import 'dashboard/assets/scss/variables';

.formulate-input {
  .formulate-input-errors {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }

  .formulate-input-error {
    color: var(--r-400);
    display: block;
    font-size: var(--font-size-small);
    font-weight: $font-weight-normal;
    margin-bottom: $space-one;
    width: 100%;
  }
}

.integration-hooks {
  .formulate-input[data-type='checkbox'] {
    .formulate-input-wrapper {
      @apply flex;

      .formulate-input-element {
        @apply pr-2;

        input {
          @apply mb-0;
        }
      }
    }

    .formulate-input-element-decorator {
      @apply hidden;
    }
  }
}

================
File: javascript/dashboard/assets/scss/_helper-classes.scss
================
// loader class
.spinner {
  @include color-spinner();
  @apply inline-block h-6 py-0 px-6 relative align-middle w-6;

  &.message {
    @include normal-shadow;
    @apply bg-white dark:bg-slate-800 rounded-full left-0 my-3 mx-auto p-4 top-0;

    &::before {
      @apply -ml-3 -mt-3;
    }
  }

  &.small {
    @apply h-4 w-4;

    &::before {
      @apply h-4 -mt-2 w-4;
    }
  }
}

================
File: javascript/dashboard/assets/scss/_layout.scss
================
// scss-lint:disable SpaceAfterPropertyColon
@import 'shared/assets/fonts/inter';

// Inter,
html,
body {
  font-family:
    'Inter',
    -apple-system,
    system-ui,
    BlinkMacSystemFont,
    'Segoe UI',
    Roboto,
    'Helvetica Neue',
    Tahoma,
    Arial,
    sans-serif !important;
  -moz-osx-font-smoothing: grayscale;
  -webkit-font-smoothing: antialiased;
  height: 100%;
  margin: 0;
  padding: 0;
  width: 100%;
}

.app-wrapper {
  @apply h-screen flex-grow-0 min-h-0 w-full;

  .button--fixed-top {
    @apply fixed ltr:right-2 rtl:left-2 top-2 flex flex-row;
  }
}

.banner + .app-wrapper {
  // Reduce the height of the dashboard to make room for the banner.
  // And causing the top right green-action button to be pushed down when scrolling.
  @apply h-[calc(100%-48px)];

  .button--fixed-top {
    @apply top-14;
  }

  .off-canvas-content {
    .button--fixed-top {
      @apply top-2;
    }
  }
}

================
File: javascript/dashboard/assets/scss/_mixins.scss
================
@import 'dashboard/assets/scss/variables';
@import 'widget/assets/scss/mixins';

$spinner-before-border-color: rgba(255, 255, 255, 0.7);

//borders
@mixin border-nil() {
  border-color: transparent;
  border: 0;
}

@mixin thin-border($color) {
  border: 1px solid $color;
}

@mixin custom-border-bottom($size, $color) {
  border-bottom: $size solid $color;
}

@mixin custom-border-top($size, $color) {
  border-top: $size solid $color;
}

@mixin border-normal() {
  @apply border border-slate-50 dark:border-slate-700;
}

@mixin border-normal-left() {
  @apply border-l border-slate-50 dark:border-slate-700;
}

@mixin border-normal-top() {
  @apply border-t border-slate-50 dark:border-slate-700;
}

@mixin border-normal-right() {
  @apply border-r border-slate-50 dark:border-slate-700;
}

@mixin border-normal-bottom() {
  @apply border-b border-slate-50 dark:border-slate-700;
}

@mixin border-light() {
  @apply border border-slate-25 dark:border-slate-700;
}

@mixin border-light-left() {
  @apply border-l border-slate-25 dark:border-slate-700;
}

@mixin border-light-top() {
  @apply border-t border-slate-25 dark:border-slate-700;
}

@mixin border-light-right() {
  @apply border-r border-slate-25 dark:border-slate-700;
}

@mixin border-light-bottom() {
  @apply border-b border-slate-25 dark:border-slate-700;
}

// background
@mixin background-gray() {
  background: $color-background;
}

@mixin background-light() {
  @apply bg-slate-50 dark:bg-slate-800;
}

@mixin background-white() {
  @apply bg-white dark:bg-slate-900;
}

// input form
@mixin ghost-input() {
  box-shadow: none;
  border-color: transparent;

  &:active,
  &:hover,
  &:focus {
    border-color: transparent;
    box-shadow: none;
  }
}

// flex-layout
@mixin space-between() {
  display: flex;
  justify-content: space-between;
}

@mixin space-between-column() {
  @include space-between;
  flex-direction: column;
}

@mixin space-between-row() {
  @include space-between;
  flex-direction: row;
}

@mixin flex-shrink() {
  flex: 0 0 auto;
  max-width: 100%;
}

@mixin flex-weight($value) {
  // Grab flex-grow for older browsers.
  $flex-grow: nth($value, 1);

  // 2009
  @include prefixer(box-flex, $flex-grow, webkit moz spec);

  // 2011 (IE 10), 2012
  @include prefixer(flex, $value, webkit moz ms spec);
}

// full height
@mixin full-height() {
  height: 100%;
}

@mixin round-corner() {
  border-radius: 1000px;
}

@mixin scroll-on-hover() {
  overflow: hidden;

  &:hover {
    overflow-y: auto;
  }
}


@mixin horizontal-scroll() {
  overflow-y: auto;
}

@mixin elegant-card() {
  @include normal-shadow;
  border-radius: $space-small;
}

@mixin color-spinner() {
  @keyframes spinner {
    to {
      transform: rotate(360deg);
    }
  }

  &::before {
    animation: spinner .9s linear infinite;
    border: 2px solid $spinner-before-border-color;
    border-radius: 50%;
    border-top-color: lighten($color-woot, 10%);
    box-sizing: border-box;
    content: '';
    height: $space-medium;
    left: 50%;
    margin-left: -$space-one;
    margin-top: -$space-one;
    position: absolute;
    top: 50%;
    width: $space-medium;
  }
}

// --------------------------------------------------------
// arrows
// --------------------------------------------------------
// $direction: top, left, right, bottom, top-left, top-right, bottom-left, bottom-right
// $color: hex, rgb or rbga
// $size: px or em
// @example
// .element{
//     @include arrow(top, #000, 50px);
// }
@mixin arrow($direction, $color, $size) {
  display: block;
  height: 0;
  width: 0;
  content: '';

  @if $direction == 'top' {
    border-bottom: $size solid $color;
    border-left: $size solid transparent;
    border-right: $size solid transparent;
  }

  @else if $direction == 'right' {
    border-bottom: $size solid transparent;
    border-left: $size solid $color;
    border-top: $size solid transparent;
  }

  @else if $direction == 'bottom' {
    border-left: $size solid transparent;
    border-right: $size solid transparent;
    border-top: $size solid $color;
  }

  @else if $direction == 'left' {
    border-bottom: $size solid transparent;
    border-right: $size solid $color;
    border-top: $size solid transparent;
  }

  @else if $direction == 'top-left' {
    border-right: $size solid transparent;
    border-top: $size solid $color;
  }

  @else if $direction == 'top-right' {
    border-left: $size solid transparent;
    border-top: $size solid $color;
  }

  @else if $direction == 'bottom-left' {
    border-bottom: $size solid $color;
    border-right: $size solid transparent;
  }

  @else if $direction == 'bottom-right' {
    border-bottom: $size solid $color;
    border-left: $size solid transparent;
  }
}

@mixin text-ellipsis {
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

@mixin three-column-grid($column-one-width: 16rem,
  $column-three-width: 16rem) {
  width: 100%;
  height: 100%;
  display: grid;
  grid-template-columns: minmax($column-one-width, 6fr) 10fr minmax($column-three-width, 6fr);
}

================
File: javascript/dashboard/assets/scss/_rtl.scss
================
.app-rtl--wrapper {
  direction: rtl;

  // Woot Tabs
  .tabs-title {
    &:first-child {
      margin-left: var(--space-small);
      margin-right: unset;
    }

    &:last-child {
      margin-left: unset;
      margin-right: var(--space-small);
    }
  }

  // woot tables
  table,
  thead,
  th {
    text-align: right;
  }

  // Table footer
  .footer {
    .page-meta {
      direction: initial;
    }
  }

  // Wizard box
  .wizard-box {
    direction: initial;
  }

  // Conversation details
  .conversation-details-wrap {
    .conversation-panel {
      // Message text
      .text-content {
        p {
          unicode-bidi: plaintext;
        }

        ul {
          padding-left: unset;
          padding-right: var(--space-two);
        }

        li {
          text-align: right;
        }
      }

      // Message items and actions
      li {
        &.right {
          .sender--info {
            padding: var(--space-small) var(--space-smaller)
              var(--space-smaller) 0;
          }

          .context-menu-wrap {
            margin-left: 0;
            margin-right: auto;
          }
        }
      }
    }

    // Conversation footer
    .conversation-footer {
      .preview-item {
        direction: initial;
      }
    }

    // Custom attributes section in conversation sidebar
    .conversation-sidebar-wrap .checkbox-wrap {
      .checkbox {
        margin-left: var(--space-small);
      }
    }

    // Conversation sidebar close button
    .close-button--rtl {
      transform: rotate(180deg);
    }

    // Resolve actions button
    .resolve-actions {
      .button-group .button:first-child {
        border-bottom-left-radius: 0;
        border-bottom-right-radius: var(--border-radius-normal);
        border-top-left-radius: 0;
        border-top-right-radius: var(--border-radius-normal);
      }

      .button-group .button:last-child {
        border-bottom-left-radius: var(--border-radius-normal);
        border-bottom-right-radius: 0;
        border-top-left-radius: var(--border-radius-normal);
        border-top-right-radius: 0;
      }
    }
  }

  // Conversation list
  .conversations-list-wrap {
    border-right: 0;

    .conversation {
      .conversation--meta {
        left: $space-normal;
        right: unset;

        .unread {
          margin-left: unset;
          margin-right: auto;
        }
      }

      .assignee-label {
        margin-left: 0;
        margin-right: var(--space-one);
      }

      .show-more--button {
        margin: unset;
        transform: rotate(180deg);
      }
    }

    // Basic filter dropdown
    .basic-filter {
      left: 0;
      right: unset;
    }

    // Bulk actions
    .bulk-action__container {
      .triangle {
        left: var(--triangle-position);
        right: unset;
      }

      .bulk-action__agents {
        left: var(--space-small);
        right: unset;
      }

      .labels-container {
        left: var(--space-small);
        right: unset;

        .label-checkbox {
          margin: 0 0 0 var(--space-one);
        }
      }

      .actions-container {
        left: var(--space-small);
        right: unset;
      }

      .bulk-action__teams {
        left: var(--space-small);
        right: unset;
      }
    }
  }

  // Contact notes
  .card.note-wrap {
    .time-stamp {
      unicode-bidi: plaintext;
    }
  }

  //   Help center
  .article-container .row--article-block {
    td:last-child {
      direction: initial;
    }
  }

  .portal-popover__container .portal {
    .actions-container {
      margin-left: unset;
      margin-right: var(--space-one);
    }
  }

  .edit-article--container {
    .header-right--wrap {
      .button-group .button:first-child {
        border-bottom-left-radius: 0;
        border-bottom-right-radius: var(--border-radius-normal);
        border-top-left-radius: 0;
        border-top-right-radius: var(--border-radius-normal);
      }

      .button-group .button:last-child {
        border-bottom-left-radius: var(--border-radius-normal);
        border-bottom-right-radius: 0;
        border-top-left-radius: var(--border-radius-normal);
        border-top-right-radius: 0;
      }
    }

    .header-left--wrap {
      .back-button {
        direction: initial;
      }
    }

    .article--buttons {
      .dropdown-pane {
        left: 0;
        position: absolute;
        right: unset;
      }
    }

    .sidebar-button {
      transform: rotate(180deg);
    }
  }

  .article-settings--container {
    border-left: 0;
    border-right: 1px solid var(--color-border-light);
    flex-direction: row-reverse;
    margin-left: 0;
    margin-right: var(--space-normal);
    padding-left: 0;
    padding-right: var(--space-normal);
  }

  .category-list--container .header-left--wrap {
    direction: initial;
    justify-content: flex-end;
  }

  // Toggle switch
  .toggle-button {
    &.small {
      span {
        &.active {
          transform: translate(var(--space-minus-small), var(--space-zero));
        }
      }
    }

    span {
      --minus-space-one-point-five: -0.9375rem;

      &.active {
        transform: translate(
          var(--minus-space-one-point-five),
          var(--space-zero)
        );
      }
    }
  }

  // Widget builder
  .widget-builder-container .widget-preview {
    direction: initial;
  }

  // Modal
  .modal-container {
    text-align: right;

    .modal-footer {
      button {
        margin-left: 0;
        margin-right: var(--space-small);
      }
    }
  }

  // Other changes

  .colorpicker--chrome {
    direction: initial;
  }

  .mention--box {
    direction: initial;
  }

  .contact--details .contact--bio {
    direction: ltr;
  }

  .merge-contacts .child-contact-wrap {
    direction: ltr;
  }

  .contact--form .input-group {
    direction: initial;
  }
}

================
File: javascript/dashboard/assets/scss/_variables.scss
================
// Font sizes
$font-size-nano: 0.5rem;
$font-size-micro: 0.675rem;
$font-size-mini: 0.75rem;
$font-size-small: 0.875rem;
$font-size-default: 1rem;
$font-size-medium: 1.125rem;
$font-size-large: 1.375rem;
$font-size-big: 1.5rem;
$font-size-bigger: 1.75rem;
$font-size-mega: 2.125rem;
$font-size-giga: 2.5rem;

// spaces
$zero: 0;
$space-micro: 0.125rem;
$space-smaller: 0.25rem;
$space-small: 0.5rem;
$space-one: 0.675rem;
$space-slab: 0.75rem;
$space-normal: 1rem;
$space-two: 1.25rem;
$space-medium: 1.5rem;
$space-large: 2rem;
$space-larger: 3rem;
$space-jumbo: 4rem;
$space-mega: 6.25rem;

// font-weight
$font-weight-feather: 100;
$font-weight-light: 300;
$font-weight-normal: 400;
$font-weight-medium: 500;
$font-weight-bold: 600;
$font-weight-black: 700;

//Navbar
$nav-bar-width: 14.375rem;
$header-height: 3.5rem;

$woot-logo-padding: $space-large $space-two;

// Colors
$color-woot: #1f93ff;
$color-gray: #6e6f73;
$color-light-gray: #999a9b;

$color-border: var(--s-75);
$color-border-light: var(--s-50);
$color-border-dark: var(--s-100);

$color-background: var(--s-50);
$color-background-light: var(--s-25);

$color-white: #fff;
$color-body: #3c4858;
$color-heading: #1f2d3d;
$color-extra-light-blue: #f5f7f9;

$primary-color: $color-woot;
$secondary-color: #5d7592;
$success-color: #44ce4b;
$warning-color: #ffc532;
$alert-color: #ff382d;

$masked-bg: rgba(0, 0, 0, .4);

// Color-palettes

$color-primary-light: #c7e3ff;
$color-primary-dark: darken($color-woot, 20%);

// Thumbnail
$thumbnail-radius: 2.5rem;

// chat-header
$conv-header-height: 2.5rem;

// Inbox List

$inbox-thumb-size: 3rem;


// Snackbar default
$woot-snackbar-bg: #323232;
$woot-snackbar-button: #ffeb3b;

$swift-ease-out-duration: .4s !default;
$swift-ease-out-function: cubic-bezier(0.37, 0, 0.63, 1) !default;
$swift-ease-out: all $swift-ease-out-duration $swift-ease-out-function !default;

// Transitions
$transition-ease-in: all 0.250s ease-in;

:root {
  --dashboard-app-tabs-height: 2.4375rem;
}

================
File: javascript/dashboard/assets/scss/_woot.scss
================
@import 'tailwindcss/base';
@import 'tailwindcss/components';
@import 'tailwindcss/utilities';

@import 'shared/assets/fonts/InterDisplay/inter-display';
@import 'shared/assets/fonts/inter';

@import 'shared/assets/stylesheets/animations';
@import 'shared/assets/stylesheets/colors';
@import 'shared/assets/stylesheets/spacing';
@import 'shared/assets/stylesheets/font-size';
@import 'shared/assets/stylesheets/font-weights';
@import 'shared/assets/stylesheets/shadows';
@import 'shared/assets/stylesheets/border-radius';
@import 'shared/assets/stylesheets/z-index';

@import 'variables';

@import 'mixins';
@import 'helper-classes';
@import 'formulate';
@import 'date-picker';

@import 'layout';
@import 'animations';
@import 'rtl';

@import 'widgets/base';
@import 'widgets/buttons';
@import 'widgets/conversation-view';
@import 'widgets/tabs';
@import 'widgets/woot-tables';

@import 'plugins/multiselect';
@import 'plugins/dropdown';

.tooltip {
  @apply bg-slate-900 text-white py-1 px-2 z-40 text-xs rounded-md dark:bg-slate-200 dark:text-slate-900 max-w-96;
}

#app {
  @apply h-full w-full;
}

.hide {
  @apply hidden;
}

.n-blue-border {
  @apply border-n-blue-border;
}

.n-blue-text {
  @apply text-n-blue-text;
}

// scss-lint:disable PropertySortOrder
@layer base {
  /* NEXT COLORS START */
  :root {
    /* slate */
    --slate-1: 252 252 253;
    --slate-2: 249 249 251;
    --slate-3: 240 240 243;
    --slate-4: 232 232 236;
    --slate-5: 224 225 230;
    --slate-6: 217 217 224;
    --slate-7: 205 206 214;
    --slate-8: 185 187 198;
    --slate-9: 139 141 152;
    --slate-10: 128 131 141;
    --slate-11: 96 100 108;
    --slate-12: 28 32 36;

    --iris-1: 253 253 255;
    --iris-2: 248 248 255;
    --iris-3: 240 241 254;
    --iris-4: 230 231 255;
    --iris-5: 218 220 255;
    --iris-6: 203 205 255;
    --iris-7: 184 186 248;
    --iris-8: 155 158 240;
    --iris-9: 91 91 214;
    --iris-10: 81 81 205;
    --iris-11: 87 83 198;
    --iris-12: 39 41 98;

    --ruby-1: 255 252 253;
    --ruby-2: 255 247 248;
    --ruby-3: 254 234 237;
    --ruby-4: 255 220 225;
    --ruby-5: 255 206 214;
    --ruby-6: 248 191 200;
    --ruby-7: 239 172 184;
    --ruby-8: 229 146 163;
    --ruby-9: 229 70 102;
    --ruby-10: 220 59 93;
    --ruby-11: 202 36 77;
    --ruby-12: 100 23 43;

    --amber-1: 254 253 251;
    --amber-2: 254 251 233;
    --amber-3: 255 247 194;
    --amber-4: 255 238 156;
    --amber-5: 251 229 119;
    --amber-6: 243 214 115;
    --amber-7: 233 193 98;
    --amber-8: 226 163 54;
    --amber-9: 255 197 61;
    --amber-10: 255 186 24;
    --amber-11: 171 100 0;
    --amber-12: 79 52 34;

    --teal-1: 250 254 253;
    --teal-2: 243 251 249;
    --teal-3: 224 248 243;
    --teal-4: 204 243 234;
    --teal-5: 184 234 224;
    --teal-6: 161 222 210;
    --teal-7: 131 205 193;
    --teal-8: 83 185 171;
    --teal-9: 18 165 148;
    --teal-10: 13 155 138;
    --teal-11: 0 133 115;
    --teal-12: 13 61 56;

    --gray-1: 252 252 252;
    --gray-2: 249 249 249;
    --gray-3: 240 240 240;
    --gray-4: 232 232 232;
    --gray-5: 224 224 224;
    --gray-6: 217 217 217;
    --gray-7: 206 206 206;
    --gray-8: 187 187 187;
    --gray-9: 141 141 141;
    --gray-10: 131 131 131;
    --gray-11: 100 100 100;
    --gray-12: 32 32 32;

    --background-color: 253 253 253;
    --text-blue: 8 109 224;
    --border-container: 236 236 236;
    --border-strong: 235 235 235;
    --border-weak: 234 234 234;
    --solid-1: 255 255 255;
    --solid-2: 255 255 255;
    --solid-3: 255 255 255;
    --solid-active: 255 255 255;
    --solid-amber: 252 232 193;
    --solid-blue: 218 236 255;
    --solid-iris: 230 231 255;

    --alpha-1: 67, 67, 67, 0.06;
    --alpha-2: 201, 202, 207, 0.15;
    --alpha-3: 255, 255, 255, 0.96;
    --black-alpha-1: 0, 0, 0, 0.12;
    --black-alpha-2: 0, 0, 0, 0.04;
    --border-blue: 39, 129, 246, 0.5;
    --white-alpha: 255, 255, 255, 0.8;
  }

  .dark {
    /* slate */
    --slate-1: 17 17 19;
    --slate-2: 24 25 27;
    --slate-3: 33 34 37;
    --slate-4: 39 42 45;
    --slate-5: 46 49 53;
    --slate-6: 54 58 63;
    --slate-7: 67 72 78;
    --slate-8: 90 97 105;
    --slate-9: 105 110 119;
    --slate-10: 119 123 132;
    --slate-11: 176 180 186;
    --slate-12: 237 238 240;

    --iris-1: 19 19 30;
    --iris-2: 23 22 37;
    --iris-3: 32 34 72;
    --iris-4: 38 42 101;
    --iris-5: 48 51 116;
    --iris-6: 61 62 130;
    --iris-7: 74 74 149;
    --iris-8: 89 88 177;
    --iris-9: 91 91 214;
    --iris-10: 84 114 228;
    --iris-11: 158 177 255;
    --iris-12: 224 223 254;

    --ruby-1: 25 17 19;
    --ruby-2: 30 21 23;
    --ruby-3: 58 20 30;
    --ruby-4: 78 19 37;
    --ruby-5: 94 26 46;
    --ruby-6: 111 37 57;
    --ruby-7: 136 52 71;
    --ruby-8: 179 68 90;
    --ruby-9: 229 70 102;
    --ruby-10: 236 90 114;
    --ruby-11: 255 148 157;
    --ruby-12: 254 210 225;

    --amber-1: 22 18 12;
    --amber-2: 29 24 15;
    --amber-3: 48 32 8;
    --amber-4: 63 39 0;
    --amber-5: 77 48 0;
    --amber-6: 92 61 5;
    --amber-7: 113 79 25;
    --amber-8: 143 100 36;
    --amber-9: 255 197 61;
    --amber-10: 255 214 10;
    --amber-11: 255 202 22;
    --amber-12: 255 231 179;

    --teal-1: 13 21 20;
    --teal-2: 17 28 27;
    --teal-3: 13 45 42;
    --teal-4: 2 59 55;
    --teal-5: 8 72 67;
    --teal-6: 20 87 80;
    --teal-7: 28 105 97;
    --teal-8: 32 126 115;
    --teal-9: 18 165 148;
    --teal-10: 14 179 158;
    --teal-11: 11 216 182;
    --teal-12: 173 240 221;

    --gray-1: 17 17 17;
    --gray-2: 25 25 25;
    --gray-3: 34 34 34;
    --gray-4: 42 42 42;
    --gray-5: 49 49 49;
    --gray-6: 58 58 58;
    --gray-7: 72 72 72;
    --gray-8: 96 96 96;
    --gray-9: 110 110 110;
    --gray-10: 123 123 123;
    --gray-11: 180 180 180;
    --gray-12: 238 238 238;

    --background-color: 18 18 19;
    --border-strong: 52 52 52;
    --border-weak: 38 38 42;
    --solid-1: 23 23 26;
    --solid-2: 29 30 36;
    --solid-3: 44 45 54;
    --solid-active: 53 57 66;
    --solid-amber: 42 37 30;
    --solid-blue: 16 49 91;
    --solid-iris: 38 42 101;
    --text-blue: 126 182 255;

    --alpha-1: 36, 36, 36, 0.8;
    --alpha-2: 139, 147, 182, 0.15;
    --alpha-3: 36, 38, 45, 0.9;
    --black-alpha-1: 0, 0, 0, 0.3;
    --black-alpha-2: 0, 0, 0, 0.2;
    --border-blue: 39, 129, 246, 0.5;
    --border-container: 236, 236, 236, 0;
    --white-alpha: 255, 255, 255, 0.1;
  }
  /* NEXT COLORS END */

  :root {
    --color-amber-25: 254 253 251;
    --color-amber-50: 255 249 237;
    --color-amber-75: 255 243 208;
    --color-amber-100: 255 236 183;
    --color-amber-200: 255 224 161;
    --color-amber-300: 245 208 140;
    --color-amber-400: 228 187 120;
    --color-amber-500: 214 163 92;
    --color-amber-600: 214 163 92;
    --color-amber-700: 255 186 26;
    --color-amber-800: 145 89 48;
    --color-amber-900: 79 52 34;

    --color-ash-100: 235 235 239;
    --color-ash-200: 228 228 233;
    --color-ash-25: 252 252 253;
    --color-ash-300: 221 221 227;
    --color-ash-400: 211 212 219;
    --color-ash-50: 249 249 251;
    --color-ash-500: 185 187 198;
    --color-ash-600: 139 141 152;
    --color-ash-700: 126 128 138;
    --color-ash-75: 242 242 245;
    --color-ash-800: 96 100 108;
    --color-ash-900: 28 32 36;

    --color-primary-25: 251 253 255;
    --color-primary-50: 245 249 255;
    --color-primary-75: 233 243 255;
    --color-primary-100: 218 236 255;
    --color-primary-200: 201 226 255;
    --color-primary-300: 181 213 255;
    --color-primary-400: 155 195 252;
    --color-primary-500: 117 171 247;
    --color-primary-600: 39 129 246;
    --color-primary-700: 16 115 233;
    --color-primary-800: 8 109 224;
    --color-primary-900: 11 50 101;

    --color-ruby-100: 255 220 225;
    --color-ruby-200: 255 206 214;
    --color-ruby-25: 255 252 253;
    --color-ruby-300: 248 191 200;
    --color-ruby-400: 239 172 184;
    --color-ruby-50: 255 247 248;
    --color-ruby-500: 229 146 163;
    --color-ruby-600: 229 70 102;
    --color-ruby-700: 220 59 93;
    --color-ruby-75: 254 234 237;
    --color-ruby-800: 202 36 77;
    --color-ruby-900: 100 23 43;

    --color-teal-100: 224 248 243;
    --color-teal-200: 204 243 234;
    --color-teal-25: 250 254 253;
    --color-teal-300: 184 234 224;
    --color-teal-400: 161 222 210;
    --color-teal-50: 243 251 249;
    --color-teal-500: 83 185 171;
    --color-teal-600: 18 165 148;
    --color-teal-700: 13 155 138;
    --color-teal-75: 236 249 255;
    --color-teal-800: 0 133 115;
    --color-teal-900: 13 61 56;

    --color-green-25: 251 254 252;
    --color-green-50: 244 251 246;
    --color-green-75: 230 246 235;
    --color-green-100: 214 241 223;
    --color-green-200: 196 232 209;
    --color-green-300: 173 221 192;
    --color-green-400: 142 206 170;
    --color-green-500: 91 185 139;
    --color-green-600: 48 164 108;
    --color-green-700: 43 154 102;
    --color-green-800: 33 131 88;
    --color-green-900: 25 59 45;

    --color-mint-25: 249 254 253;
    --color-mint-50: 242 251 249;
    --color-mint-75: 221 249 242;
    --color-mint-100: 200 244 233;
    --color-mint-200: 179 236 222;
    --color-mint-300: 156 224 208;
    --color-mint-400: 126 207 189;
    --color-mint-500: 76 187 165;
    --color-mint-600: 134 234 212;
    --color-mint-700: 125 224 203;
    --color-mint-800: 2 120 100;
    --color-mint-900: 22 67 60;

    --color-sky-25: 249 254 255;
    --color-sky-50: 241 250 253;
    --color-sky-75: 225 246 253;
    --color-sky-100: 209 240 250;
    --color-sky-200: 190 231 245;
    --color-sky-300: 169 218 237;
    --color-sky-400: 141 202 227;
    --color-sky-500: 96 179 215;
    --color-sky-600: 124 226 254;
    --color-sky-700: 116 218 248;
    --color-sky-800: 0 116 158;
    --color-sky-900: 29 62 86;

    --color-indigo-25: 253 253 254;
    --color-indigo-50: 247 249 255;
    --color-indigo-75: 237 242 254;
    --color-indigo-100: 225 233 255;
    --color-indigo-200: 210 222 255;
    --color-indigo-300: 193 208 255;
    --color-indigo-400: 171 189 249;
    --color-indigo-500: 141 164 239;
    --color-indigo-600: 62 99 221;
    --color-indigo-700: 51 88 212;
    --color-indigo-800: 58 91 199;
    --color-indigo-900: 31 45 92;

    --color-iris-25: 253 253 255;
    --color-iris-50: 248 248 255;
    --color-iris-75: 240 241 254;
    --color-iris-100: 230 231 255;
    --color-iris-200: 218 220 255;
    --color-iris-300: 203 205 255;
    --color-iris-400: 184 186 248;
    --color-iris-500: 155 158 240;
    --color-iris-600: 91 91 214;
    --color-iris-700: 81 81 205;
    --color-iris-800: 87 83 198;
    --color-iris-900: 39 41 98;

    --color-violet-25: 253 252 254;
    --color-violet-50: 250 248 255;
    --color-violet-75: 244 240 254;
    --color-violet-100: 235 228 255;
    --color-violet-200: 225 217 255;
    --color-violet-300: 212 202 254;
    --color-violet-400: 194 181 245;
    --color-violet-500: 170 153 236;
    --color-violet-600: 110 86 207;
    --color-violet-700: 101 77 196;
    --color-violet-800: 101 80 185;
    --color-violet-900: 47 38 95;

    --color-pink-25: 255 252 254;
    --color-pink-50: 254 247 251;
    --color-pink-75: 254 233 245;
    --color-pink-100: 251 220 239;
    --color-pink-200: 246 206 231;
    --color-pink-300: 239 191 221;
    --color-pink-400: 231 172 208;
    --color-pink-500: 221 147 194;
    --color-pink-600: 214 64 159;
    --color-pink-700: 207 56 151;
    --color-pink-800: 194 41 138;
    --color-pink-900: 101 18 73;

    --color-orange-25: 254 252 251;
    --color-orange-50: 255 247 237;
    --color-orange-75: 255 239 214;
    --color-orange-100: 255 223 181;
    --color-orange-200: 255 209 154;
    --color-orange-300: 255 193 130;
    --color-orange-400: 245 174 115;
    --color-orange-500: 236 148 85;
    --color-orange-600: 247 107 21;
    --color-orange-700: 239 95 0;
    --color-orange-800: 204 78 0;
    --color-orange-900: 88 45 29;
  }

  // scss-lint:disable QualifyingElement
  body.dark {
    --color-amber-25: 31 19 0;
    --color-amber-50: 37 24 4;
    --color-amber-75: 48 32 11;
    --color-amber-100: 57 39 15;
    --color-amber-200: 67 46 18;
    --color-amber-300: 83 57 22;
    --color-amber-400: 111 77 29;
    --color-amber-500: 169 118 42;
    --color-amber-600: 169 118 42;
    --color-amber-700: 255 203 71;
    --color-amber-800: 255 204 77;
    --color-amber-900: 255 231 179;

    --color-ash-100: 46 48 53;
    --color-ash-200: 53 55 60;
    --color-ash-25: 24 24 26;
    --color-ash-300: 60 63 68;
    --color-ash-400: 70 75 80;
    --color-ash-50: 27 27 31;
    --color-ash-500: 90 97 101;
    --color-ash-600: 105 110 119;
    --color-ash-700: 120 127 133;
    --color-ash-75: 39 40 45;
    --color-ash-800: 173 177 184;
    --color-ash-900: 237 238 240;

    --color-primary-25: 10 17 28;
    --color-primary-50: 15 24 38;
    --color-primary-75: 15 39 72;
    --color-primary-100: 10 49 99;
    --color-primary-200: 18 61 117;
    --color-primary-300: 29 74 134;
    --color-primary-400: 40 89 156;
    --color-primary-500: 48 106 186;
    --color-primary-600: 39 129 246;
    --color-primary-700: 21 116 231;
    --color-primary-800: 126 182 255;
    --color-primary-900: 205 227 255;

    --color-ruby-100: 78 19 37;
    --color-ruby-200: 94 26 46;
    --color-ruby-25: 25 17 19;
    --color-ruby-300: 111 37 57;
    --color-ruby-400: 136 52 71;
    --color-ruby-50: 30 21 23;
    --color-ruby-500: 179 68 90;
    --color-ruby-600: 229 70 102;
    --color-ruby-700: 236 90 114;
    --color-ruby-75: 58 20 30;
    --color-ruby-800: 255 148 157;
    --color-ruby-900: 254 210 225;

    --color-teal-100: 2 59 55;
    --color-teal-200: 8 72 67;
    --color-teal-25: 13 21 20;
    --color-teal-300: 28 105 97;
    --color-teal-400: 28 105 97;
    --color-teal-50: 17 28 27;
    --color-teal-500: 32 126 115;
    --color-teal-600: 41 163 131;
    --color-teal-700: 14 179 158;
    --color-teal-75: 13 45 42;
    --color-teal-800: 11 216 182;
    --color-teal-900: 173 240 221;

    --color-green-25: 14 21 18;
    --color-green-50: 18 27 23;
    --color-green-75: 19 45 33;
    --color-green-100: 17 59 41;
    --color-green-200: 23 73 51;
    --color-green-300: 32 87 62;
    --color-green-400: 40 104 74;
    --color-green-500: 47 124 87;
    --color-green-600: 48 164 108;
    --color-green-700: 51 176 116;
    --color-green-800: 61 214 140;
    --color-green-900: 177 241 203;

    --color-mint-25: 14 21 21;
    --color-mint-50: 15 27 27;
    --color-mint-75: 9 44 43;
    --color-mint-100: 0 58 56;
    --color-mint-200: 0 71 68;
    --color-mint-300: 16 86 80;
    --color-mint-400: 30 104 95;
    --color-mint-500: 39 127 112;
    --color-mint-600: 134 234 212;
    --color-mint-700: 168 245 229;
    --color-mint-800: 88 213 186;
    --color-mint-900: 196 245 225;

    --color-sky-25: 14 21 21;
    --color-sky-50: 15 27 27;
    --color-sky-75: 9 44 43;
    --color-sky-100: 0 58 56;
    --color-sky-200: 0 71 68;
    --color-sky-300: 16 86 80;
    --color-sky-400: 30 104 95;
    --color-sky-500: 39 127 112;
    --color-sky-600: 134 234 212;
    --color-sky-700: 168 245 229;
    --color-sky-800: 88 213 186;
    --color-sky-900: 196 245 225;

    --color-indigo-25: 17 19 31;
    --color-indigo-50: 20 23 38;
    --color-indigo-75: 24 36 73;
    --color-indigo-100: 29 46 98;
    --color-indigo-200: 37 57 116;
    --color-indigo-300: 48 67 132;
    --color-indigo-400: 58 79 151;
    --color-indigo-500: 67 93 177;
    --color-indigo-600: 62 99 221;
    --color-indigo-700: 84 114 228;
    --color-indigo-800: 158 177 255;
    --color-indigo-900: 214 225 255;

    --color-iris-25: 19 19 30;
    --color-iris-50: 23 22 37;
    --color-iris-75: 32 34 72;
    --color-iris-100: 38 42 101;
    --color-iris-200: 48 51 116;
    --color-iris-300: 61 62 130;
    --color-iris-400: 74 74 149;
    --color-iris-500: 89 88 177;
    --color-iris-600: 91 91 214;
    --color-iris-700: 110 106 222;
    --color-iris-800: 177 169 255;
    --color-iris-900: 224 223 254;

    --color-violet-25: 20 18 31;
    --color-violet-50: 27 21 37;
    --color-violet-75: 41 31 67;
    --color-violet-100: 51 37 91;
    --color-violet-200: 60 46 105;
    --color-violet-300: 71 56 118;
    --color-violet-400: 86 70 139;
    --color-violet-500: 105 88 173;
    --color-violet-600: 110 86 207;
    --color-violet-700: 125 102 217;
    --color-violet-800: 186 167 255;
    --color-violet-900: 226 221 254;

    --color-pink-25: 25 17 23;
    --color-pink-50: 33 18 29;
    --color-pink-75: 55 23 47;
    --color-pink-100: 75 20 61;
    --color-pink-200: 89 28 71;
    --color-pink-300: 105 41 85;
    --color-pink-400: 131 56 105;
    --color-pink-500: 168 72 133;
    --color-pink-600: 214 64 159;
    --color-pink-700: 222 81 168;
    --color-pink-800: 255 141 204;
    --color-pink-900: 253 209 234;
    --color-orange-25: 23 18 14;
    --color-orange-50: 30 22 15;
    --color-orange-75: 51 30 11;
    --color-orange-100: 70 33 0;
    --color-orange-200: 86 40 0;
    --color-orange-300: 102 53 12;
    --color-orange-400: 126 69 29;
    --color-orange-500: 163 88 41;
    --color-orange-600: 247 107 21;
    --color-orange-700: 255 128 31;
    --color-orange-800: 255 160 87;
    --color-orange-900: 255 224 194;
  }
}

@layer utilities {
  /* Hide scrollbar for Chrome, Safari and Opera */
  .no-scrollbar::-webkit-scrollbar {
    display: none;
  }
  /* Hide scrollbar for IE, Edge and Firefox */
  .no-scrollbar {
    -ms-overflow-style: none; /* IE and Edge */
    scrollbar-width: none; /* Firefox */
  }
}

================
File: javascript/dashboard/assets/scss/app.scss
================
@import 'woot';

================
File: javascript/dashboard/components/specs/__snapshots__/SidemenuIcon.spec.js.snap
================
// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`SidemenuIcon > matches snapshot 1`] = `
<button
  class="-ml-3 text-black-900 dark:text-slate-300"
  color-scheme="secondary"
  icon="list"
  size="small"
  variant="clear"
>
  
  
</button>
`;

================
File: javascript/dashboard/routes/dashboard/settings/reports/components/specs/__snapshots__/CSATMetrics.spec.js.snap
================
// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`CsatMetrics.vue > computes response count correctly 1`] = `
"<div class="flex-col lg:flex-row flex flex-wrap mx-0 shadow outline-1 outline outline-n-container rounded-xl bg-n-solid-2 px-6 py-8 gap-4">
  <csat-metric-card-stub label="CSAT_REPORTS.METRIC.TOTAL_RESPONSES.LABEL" infotext="CSAT_REPORTS.METRIC.TOTAL_RESPONSES.TOOLTIP" disabled="false" class="xs:w-full sm:max-w-[50%] lg:w-1/6 lg:max-w-[16%]" value="100"></csat-metric-card-stub>
  <csat-metric-card-stub label="CSAT_REPORTS.METRIC.SATISFACTION_SCORE.LABEL" infotext="CSAT_REPORTS.METRIC.SATISFACTION_SCORE.TOOLTIP" disabled="true" class="xs:w-full sm:max-w-[50%] lg:w-1/6 lg:max-w-[16%]" value="--"></csat-metric-card-stub>
  <csat-metric-card-stub label="CSAT_REPORTS.METRIC.RESPONSE_RATE.LABEL" infotext="CSAT_REPORTS.METRIC.RESPONSE_RATE.TOOLTIP" disabled="false" class="xs:w-full sm:max-w-[50%] lg:w-1/6 lg:max-w-[16%]" value="90%"></csat-metric-card-stub>
  <!--v-if-->
</div>"
`;

================
File: javascript/design-system/histoire.scss
================
@import 'dashboard/assets/scss/app';

*,
::before,
::after {
  --_histoire-color-primary-50: 235 245 255;
  --_histoire-color-primary-100: 194 225 255;
  --_histoire-color-primary-200: 153 206 255;
  --_histoire-color-primary-300: 112 186 255;
  --_histoire-color-primary-400: 71 166 255;
  --_histoire-color-primary-500: 31 147 255;
  --_histoire-color-primary-600: 25 118 204;
  --_histoire-color-primary-700: 19 88 153;
  --_histoire-color-primary-800: 12 59 102;
  --_histoire-color-primary-900: 6 29 51;
}

html,
body {
  font-family: 'Inter', sans-serif;
}

================
File: javascript/portal/application.scss
================
@import 'tailwindcss/base';
@import 'tailwindcss/components';
@import 'tailwindcss/utilities';

@import 'widget/assets/scss/reset';
@import 'widget/assets/scss/variables';
@import 'widget/assets/scss/buttons';
@import 'widget/assets/scss/mixins';
@import 'widget/assets/scss/forms';
@import 'shared/assets/fonts/InterDisplay/inter-display';

html,
body {
  font-family: 'InterDisplay', ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica Neue, Arial, Noto Sans, sans-serif, Apple Color Emoji, Segoe UI Emoji, Segoe UI Symbol, Noto Color Emoji;
  -moz-osx-font-smoothing: grayscale;
  -webkit-font-smoothing: antialiased;
  height: 100%;
  letter-spacing: 0.2px;
}


// Taking these utils from tailwind 3.x.x, need to remove once we upgrade
.scroll-mt-24 {
  scroll-margin-top: 6rem;
}

.top-24 {
  top: 6rem;
}

.heading {
  .permalink {
    visibility: hidden;
  }

  &:hover {
    .permalink {
      visibility: visible;
    }
  }
}

================
File: javascript/shared/assets/fonts/InterDisplay/inter-display.scss
================
@font-face {
  font-family: 'InterDisplay';
  font-style: normal;
  font-weight: 100;
  font-display: swap;
  src: url('shared/assets/fonts/InterDisplay/InterDisplay-Thin.woff2') format('woff2');
}

@font-face {
  font-family: 'InterDisplay';
  font-style: normal;
  font-weight: 200;
  font-display: swap;
  src: url('shared/assets/fonts/InterDisplay/InterDisplay-ExtraLight.woff2') format('woff2');
}

@font-face {
  font-family: 'InterDisplay';
  font-style: normal;
  font-weight: 300;
  font-display: swap;
  src: url('shared/assets/fonts/InterDisplay/InterDisplay-Light.woff2') format('woff2');
}

@font-face {
  font-family: 'InterDisplay';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: url('shared/assets/fonts/InterDisplay/InterDisplay-Regular.woff2') format('woff2');
}

@font-face {
  font-family: 'InterDisplay';
  font-style: normal;
  font-weight: 500;
  font-display: swap;
  src: url('shared/assets/fonts/InterDisplay/InterDisplay-Medium.woff2') format('woff2');
}

@font-face {
  font-family: 'InterDisplay';
  font-style: normal;
  font-weight: 600;
  font-display: swap;
  src: url('shared/assets/fonts/InterDisplay/InterDisplay-SemiBold.woff2') format('woff2');
}

@font-face {
  font-family: 'InterDisplay';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: url('shared/assets/fonts/InterDisplay/InterDisplay-Bold.woff2') format('woff2');
}

@font-face {
  font-family: 'InterDisplay';
  font-style: normal;
  font-weight: 800;
  font-display: swap;
  src: url('shared/assets/fonts/InterDisplay/InterDisplay-ExtraBold.woff2') format('woff2');
}

@font-face {
  font-family: 'InterDisplay';
  font-style: normal;
  font-weight: 900;
  font-display: swap;
  src: url('shared/assets/fonts/InterDisplay/InterDisplay-Black.woff2') format('woff2');
}

================
File: javascript/shared/assets/fonts/inter.scss
================
@font-face {
  font-family: 'Inter';
  font-style: normal;
  font-weight: 100;
  font-display: swap;
  src: url('shared/assets/fonts/Inter/Inter-Thin.woff2') format('woff2');
}

@font-face {
  font-family: 'Inter';
  font-style: normal;
  font-weight: 300;
  font-display: swap;
  src: url('shared/assets/fonts/Inter/Inter-Light.woff2') format('woff2');
}

@font-face {
  font-family: 'Inter';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: url('shared/assets/fonts/Inter/Inter-Regular.woff2') format('woff2');
}

@font-face {
  font-family: 'Inter';
  font-style: italic;
  font-weight: 400;
  font-display: swap;
  src: url('shared/assets/fonts/Inter/Inter-Italic.woff2') format('woff2');
}

@font-face {
  font-family: 'Inter';
  font-style: normal;
  font-weight: 500;
  font-display: swap;
  src: url('shared/assets/fonts/Inter/Inter-Medium.woff2') format('woff2');
}

@font-face {
  font-family: 'Inter';
  font-style: normal;
  font-weight: 600;
  font-display: swap;
  src: url('shared/assets/fonts/Inter/Inter-SemiBold.woff2') format('woff2');
}

@font-face {
  font-family: 'Inter';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: url('shared/assets/fonts/Inter/Inter-Bold.woff2') format('woff2');
}

================
File: javascript/shared/assets/fonts/widget_fonts.scss
================
@font-face {
  font-family: 'Inter';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: url('shared/assets/fonts/Inter/Inter-Regular.woff2') format('woff2');
}

@font-face {
  font-family: 'Inter';
  font-style: normal;
  font-weight: 500;
  font-display: swap;
  src: url('shared/assets/fonts/Inter/Inter-Medium.woff2') format('woff2');
}

================
File: javascript/shared/assets/stylesheets/animations.scss
================
// Taken from thoughtbot/bourbon library timing functions

:root {
  --ease-in-cubic: cubic-bezier(0.17, 0.67, 0.83, 0.67);
  --ease-in-sine: cubic-bezier(0.47, 0, 0.745, 0.715);

  --ease-out-cubic: cubic-bezier(0.215, 0.61, 0.355, 1);
  --ease-out-sine: cubic-bezier(0.39, 0.575, 0.565, 1);

  --ease-in-out-quad: cubic-bezier(0.455, 0.03, 0.515, 0.955);
}

================
File: javascript/shared/assets/stylesheets/border-radius.scss
================
:root {
  --border-radius-small: 0.1875rem;
  --border-radius-normal: 0.3125rem;
  --border-radius-medium: 0.4375rem;
  --border-radius-large: 0.5625rem;
  --border-radius-full: 6.25rem;
  --border-radius-rounded: 50%;
}

================
File: javascript/shared/assets/stylesheets/colors.scss
================
:root {
  --white: #fff;
  --white-transparent: rgba(255, 255, 255, 0.9);
  --black-transparent: rgba(0, 0, 0, 0.9);

  --w-25: #F5FAFF;
  --w-50: #EBF5FF;
  --w-75: #D6EBFF;
  --w-100: #C2E1FF;
  --w-200: #99CEFF;
  --w-300: #70BAFF;
  --w-400: #47A6FF;
  --w-500: #1F93FF;
  --w-600: #1976CC;
  --w-700: #135899;
  --w-800: #0C3B66;
  --w-900: #061D33;

  --g-50: #E6F8E6;
  --g-100: #C4EEC2;
  --g-200: #9DE29A;
  --g-300: #6FD86F;
  --g-400: #44CE4B;
  --g-500: #00C41D;
  --g-600: #00B412;
  --g-700: #00A200;
  --g-800: #009000;
  --g-900: #007000;

  --y-50: #FEFDE8;
  --y-100: #FDFCC4;
  --y-200: #FCF68C;
  --y-300: #F9E736;
  --y-400: #F6D819;
  --y-500: #E6C00C;
  --y-600: #C69608;
  --y-700: #9E6b0A;
  --y-800: #835510;
  --y-900: #6F4514;

  --s-25: #F8FAFC;
  --s-50: #F1F5F8;
  --s-75: #EBF0F5;
  --s-100: #E4EBF1;
  --s-200: #C9D7E3;
  --s-300: #AEC3D5;
  --s-400: #93AFC8;
  --s-500: #779BBB;
  --s-600: #446888;
  --s-700: #37546D;
  --s-800: #293F51;
  --s-900: #1B2836;

  --b-50: #F7F7F7;
  --b-100: #ECECED;
  --b-200: #DDDDE0;
  --b-300: #C6C7CA;
  --b-400: #ABACAF;
  --b-500: #96979C;
  --b-600: #6E6F73;
  --b-700: #5A5B5F;
  --b-800: #3C3D40;
  --b-900: #1B1C1F;

  --r-50: #FFEBEE;
  --r-100: #FFCCD1;
  --r-200: #F69898;
  --r-300: #EF6F6F;
  --r-400: #F94B4A;
  --r-500: #FF382D;
  --r-600: #F02B2D;
  --r-700: #DE1E27;
  --r-800: #D11320;
  --r-900: #C30011;

  --v-50: #FFFFFF;
  --v-100: #F5EBFF;
  --v-200: #DDB8FF;
  --v-300: #C585FF;
  --v-400: #AC52FF;
  --v-500: #941FFF;
  --v-600: #7B00EB;
  --v-700: #6000B8;
  --v-800: #450085;
  --v-900: #2B0052;

  // Common color aliases
  --color-woot: var(--w-500);

  --color-heading: #1f2d3d;
  --color-body: #3c4858;

  --color-border: var(--s-75);
  --color-border-light: var(--s-50);
  --color-border-dark: var(--s-100);

  --color-background: var(--s-50);
  --color-background-light: var(--s-25);

  // Social and inboxes brand colors
  --color-facebook-brand: #3b5998;
  --color-twitter-brand: #1da1f2;
  --color-whatsapp-brand: #25d366;
  --color-sms-twilio: #f42f46;
  --color-cloud-generic: #18b7b0;

  // Tech-debt
  --color-medium-gray: #8492a6;
}

================
File: javascript/shared/assets/stylesheets/font-size.scss
================
:root {
  --font-size-nano: 0.5rem;
  --font-size-micro: 0.625rem;
  --font-size-mini: 0.75rem;
  --font-size-small: 0.875rem;
  --font-size-default: 1rem;
  --font-size-medium: 1.125rem;
  --font-size-two: 1.25rem;
  --font-size-large: 1.375rem;
  --font-size-big: 1.5rem;
  --font-size-bigger: 1.875rem;
  --font-size-mega: 2.125rem;
  --font-size-giga: 2.5rem;
}

================
File: javascript/shared/assets/stylesheets/font-weights.scss
================
:root {
  --font-weight-feather: 100;
  --font-weight-light: 300;
  --font-weight-normal: 400;
  --font-weight-medium: 500;
  --font-weight-bold: 600;
  --font-weight-black: 700;
}

================
File: javascript/shared/assets/stylesheets/shadows.scss
================
:root {
    --shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1),
        0 1px 2px 0 rgba(0, 0, 0, 0.06);
    --shadow-small: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
    --shadow-medium: 0 4px 6px -1px rgba(0, 0, 0, 0.1),
        0 2px 4px -1px rgba(0, 0, 0, 0.06);
    --shadow-large: 0 10px 15px -3px rgba(0, 0, 0, 0.1),
        0 4px 6px -2px rgba(0, 0, 0, 0.05);
    --shadow-larger: 0 20px 25px -5px rgba(0, 0, 0, 0.1),
        0 10px 10px -5px rgba(0, 0, 0, 0.04);
    --shadow-dropdown-pane:
        0 0.5rem 1rem rgb(50 50 93 / 8%),
        0 0.25rem 0.75rem rgb(0 0 0 / 7%);
    --shadow-bulk-action-container:
        6px 3px 22px 9px rgb(181 181 181 / 25%);
    --shadow-context-menu: rgb(22 23 24 / 30%) 0px 10px 38px -10px,
    rgb(22 23 24 / 20%) 0px 10px 20px -15px;
    --shadow-widget-builder: 0 0px 20px 5px rgb(0 0 0 / 10%);
}

================
File: javascript/shared/assets/stylesheets/spacing.scss
================
:root {
  // spaces
  --space-zero: 0;
  --space-micro: 0.125rem;
  --space-smaller: 0.25rem;
  --space-small: 0.5rem;
  --space-one: 0.625rem;
  --space-slab: 0.75rem;
  --space-snug: 0.875rem;
  --space-normal: 1rem;
  --space-two: 1.25rem;
  --space-medium: 1.5rem;
  --space-large: 2rem;
  --space-larger: 3rem;
  --space-jumbo: 4rem;
  --space-mega: 6.25rem;
  --space-giga: 15rem;

  --space-minus-micro: -0.125rem;
  --space-minus-smaller: -0.25rem;
  --space-minus-half: -0.3125rem;
  --space-minus-small: -0.5rem;
  --space-minus-one: -0.625rem;
  --space-minus-slab: -0.75rem;
  --space-minus-snug: -0.875rem;
  --space-minus-normal: -1rem;
  --space-minus-two: -1.25rem;
  --space-minus-medium: -1.5rem;
  --space-minus-large: -2rem;
  --space-minus-larger: -3rem;
  --space-minus-jumbo: -4rem;
  --space-minus-mega: -6.25rem;
}

================
File: javascript/shared/assets/stylesheets/z-index.scss
================
:root {
  // z-index
  --z-index-minus: -1;
  --z-index-zero: 0;
  --z-index-one: 1;
  --z-index-low: 10;
  --z-index-twenty: 20;
  --z-index-normal: 100;
  --z-index-high: 1000;
  --z-index-higher: 2000;
  --z-index-much-higher: 5000;
  --z-index-very-high: 9999;
  --z-index-highest: 10000;
}

================
File: javascript/shared/components/specs/__snapshots__/DateSeparator.spec.js.snap
================
// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`DateSeparator > date separator snapshot 1`] = `
<div
  class="date--separator text-slate-700"
  data-v-b24b73fa=""
>
  Nov 18, 2019
</div>
`;

exports[`dateSeparator > date separator snapshot 1`] = `
<div
  class="date--separator text-slate-700"
  data-v-b24b73fa=""
>
   Nov 18, 2019 
</div>
`;

================
File: javascript/shared/components/specs/__snapshots__/Spinner.spec.js.snap
================
// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`Spinner > matches snapshot 1`] = `
<span
  class="spinner small"
  data-v-3e416633=""
/>
`;

================
File: javascript/survey/assets/scss/woot.scss
================
@import 'tailwindcss/base';
@import 'tailwindcss/components';
@import 'tailwindcss/utilities';
@import 'widget/assets/scss/reset';
@import 'widget/assets/scss/variables';
@import 'widget/assets/scss/buttons';
@import 'widget/assets/scss/mixins';
@import 'widget/assets/scss/forms';
@import 'shared/assets/fonts/widget_fonts';

html,
body {
  font-family: $font-family;
  -moz-osx-font-smoothing: grayscale;
  -webkit-font-smoothing: antialiased;
  height: 100%;
}

.woot-survey-wrap {
  height: 100%;
}

================
File: javascript/widget/assets/scss/views/_conversation.scss
================
.file-uploads .attachment-button + label {
  cursor: pointer;
}

.conversation-wrap {
  .agent-message {
    align-items: flex-end;
    display: flex;
    flex-direction: row;
    justify-content: flex-start;
    margin: 0 0 $space-micro $space-small;
    max-width: 88%;

    .avatar-wrap {
      flex-shrink: 0;
      height: $space-medium;
      width: $space-medium;

      .user-thumbnail-box {
        margin-top: -$space-large;
      }
    }

    .message-wrap {
      flex-grow: 1;
      flex-shrink: 0;
      margin-left: $space-small;
      max-width: 90%;
    }
  }

  &.is-typing .messages-wrap div:last-child {
    .agent-message {
      .agent-name {
        display: none;
      }

      .user-thumbnail-box {
        margin-top: 0;
      }
    }
  }

  .agent-name {
    font-size: $font-size-small;
    font-weight: $font-weight-medium;
    margin: $space-small 0;
    padding-left: $space-micro;
  }

  .has-attachment {
    overflow: hidden;

    :not([audio]) {
      padding: 0;
    }

    &.has-text {
      margin-top: $space-smaller;
    }
  }

  .agent-message-wrap {
    + .agent-message-wrap {
      margin-top: $space-micro;

      .agent-message .chat-bubble {
        border-top-left-radius: $space-smaller;
      }
    }

    + .user-message-wrap {
      margin-top: $space-normal;
    }

    &.has-response + .user-message-wrap {
      margin-top: $space-micro;

      .chat-bubble {
        border-top-right-radius: $space-smaller;
      }
    }

    &.has-response + .agent-message-wrap {
      margin-top: $space-normal;
    }
  }

  .user-message {
    align-items: flex-end;
    display: flex;
    flex-direction: row;
    justify-content: flex-end;
    margin: 0 $space-smaller $space-micro auto;
    max-width: 85%;
    text-align: right;

    .message-wrap {
      margin-right: $space-small;
      max-width: 100%;
    }

    .in-progress,
    .is-failed {
      opacity: 0.6;
    }

    .is-failed {
      align-items: flex-end;
      display: flex;
      flex-direction: row-reverse;

      .chat-bubble.user {
        background: $color-error !important;
        // TODO: Remove the important
      }
    }
  }

  .user.has-attachment {
    .icon-wrap {
      color: $color-white;
    }

    .download {
      color: $color-white;
    }
  }

  .user-message-wrap {
    + .user-message-wrap {
      margin-top: $space-micro;

      .user-message .chat-bubble {
        border-top-right-radius: $space-smaller;
      }
    }

    + .agent-message-wrap {
      margin-top: $space-normal;
    }
  }

  p:not(:last-child) {
    margin-bottom: $space-normal;
  }
}

.unread-messages {
  display: flex;
  flex-direction: column;
  flex-wrap: nowrap;
  margin-top: 0;
  overflow-y: auto;
  padding-bottom: $space-small;
  width: 100%;

  .chat-bubble-wrap {
    margin-bottom: $space-smaller;

    &:first-child {
      margin-top: auto;
    }

    .chat-bubble {
      border: 1px solid $color-border-dark;
    }

    + .chat-bubble-wrap {
      .chat-bubble {
        border-top-left-radius: $space-smaller;
      }
    }

    &:last-child .chat-bubble {
      border-bottom-left-radius: $space-two;
    }
  }
}

.is-widget-right .unread-wrap {
  overflow: hidden;
  text-align: right;

  .chat-bubble-wrap {
    .chat-bubble {
      border-bottom-right-radius: $space-smaller;
      border-radius: $space-two;
    }

    + .chat-bubble-wrap {
      .chat-bubble {
        border-top-right-radius: $space-smaller;
      }
    }

    &:last-child .chat-bubble {
      border-bottom-right-radius: $space-two;
    }
  }

  .close-unread-wrap {
    text-align: right;
  }
}

.chat-bubble {
  @include light-shadow;
  border-radius: $space-two;
  color: $color-white;
  display: inline-block;
  font-size: $font-size-default;
  line-height: 1.5;
  max-width: 100%;
  padding: $space-slab $space-normal;
  text-align: left;
  word-break: break-word;

  :not([audio]) {
    max-width: 100%;
  }

  > a {
    color: $color-primary;
    word-break: break-all;
  }

  .link {
    text-decoration: underline;
  }

  &.user {
    border-bottom-right-radius: $space-smaller;

    > a {
      color: $color-white;
    }
  }

  &.agent {
    border-bottom-left-radius: $space-smaller;
    color: $color-body;

    .link {
      color: $color-woot;
      word-break: break-word;
    }
  }
}

================
File: javascript/widget/assets/scss/_buttons.scss
================
$button-border-width: 1px;
// Buttons
.button {
  appearance: none;
  background: $color-primary;
  border: $button-border-width solid $color-primary;
  border-radius: $border-radius;
  color: $color-white;
  cursor: pointer;
  display: inline-block;
  font-size: $font-size-default;
  height: $space-two * 2;
  line-height: $line-height;
  outline: none;
  padding: $space-smaller $space-normal;
  text-align: center;
  text-decoration: none;
  transition: background .2s, border .2s, box-shadow .2s, color .2s;
  user-select: none;
  vertical-align: middle;
  white-space: nowrap;

  &:focus,
  &:hover {
    background: lighten($color-primary, 7%);
    border-color: $color-primary;
    text-decoration: none;
  }

  &:active,
  &.active {
    background: $color-primary;
    border-color: darken($color-primary, 5%);
    color: lighten($color-primary, 20%);
    text-decoration: none;
  }

  &[disabled],
  &:disabled,
  &.disabled {
    cursor: default;
    opacity: .5;
    pointer-events: none;
  }

  &.small {
    font-size: $font-size-small;
    height: $space-medium;
    padding: $space-smaller $space-slab;
  }

  &.large {
    font-size: $font-size-medium;
    height: $space-larger;
    padding: $space-small $space-medium;
  }

  &.block {
    width: 100%;
  }

  &.transparent {
    background: transparent;
    border: 0;
    height: auto;
  }

  &.compact {
    padding: 0;
  }
}

================
File: javascript/widget/assets/scss/_forms.scss
================
// scss-lint:disable PropertySortOrder DeclarationOrder QualifyingElement
$form-border-width: 1px;
$input-height: $space-two * 2;

.form-input {
  @include placeholder {
    color: $color-gray;
  }

  appearance: none;
  background: $color-white;
  border: 1px solid $color-border;
  border-radius: $border-radius;
  box-sizing: border-box;
  color: $color-body;
  display: block;
  font-family: $font-family;
  font-size: $font-size-medium;
  height: $input-height;
  line-height: 1.5;
  max-width: 100%;
  outline: none;
  padding: $space-smaller;
  position: relative;
  transition: background .2s,
  border .2s,
  box-shadow .2s,
  color .2s;
  width: 100%;

  &:focus {
    border-color: $color-primary;
  }

  &::placeholder {
    color: $color-gray;
  }

  // Input sizes
  &.small {
    font-size: $font-size-small;
    height: $space-large;
    padding: $space-small $space-one;
  }

  &.default {
    font-size: $font-size-default;
    height: $space-medium;
    padding: $space-smaller $space-slab;
  }

  &.large {
    font-size: $font-size-medium;
    height: $space-larger;
    padding: $space-slab $space-two;
  }

  &.input-inline {
    display: inline-block;
    vertical-align: middle;
    width: auto;
  }

  // Input types
  &[type="file"] {
    height: auto;
  }
}

// Form element: Textarea
textarea.form-input {
  font-family: $font-family;

  @include placeholder {
    color: $color-light-gray;
  }

  &,
  &.large,
  &.small {
    height: auto;
  }
}

================
File: javascript/widget/assets/scss/_mixins.scss
================
// scss-lint:disable PseudoElement SpaceBeforeBrace VendorPrefix
$shadow-color-1: rgba(50, 50, 93, 0.08);
$shadow-color-2: rgba(0, 0, 0, 0.07);
$shadow-color-3: rgba(50, 50, 93, 0.08);
$shadow-color-4: rgba(0, 0, 0, 0.05);

$color-shadow-medium: rgba(50, 50, 93, 0.08);
$color-shadow-light: rgba(50, 50, 93, 0.04);
$color-shadow-large: rgba(50, 50, 93, 0.25);
$color-shadow-outline: rgba(66, 153, 225, 0.5);

@mixin normal-shadow {
  box-shadow: 0 $space-small $space-normal $shadow-color-1,
    0 $space-smaller $space-slab $shadow-color-2;
}

@mixin light-shadow {
  box-shadow: 0 $space-smaller 6px $shadow-color-3, 0 1px 3px $shadow-color-4;
}

@mixin placeholder {
  &::-webkit-input-placeholder {
    @content;
  }

  &:-moz-placeholder {
    @content;
  }

  &::-moz-placeholder {
    @content;
  }

  &:-ms-input-placeholder {
    @content;
  }
}

@mixin shadow {
  box-shadow: 0 1px 10px 2px $color-shadow-medium,
    0 1px 5px 1px $color-shadow-light;
}

@mixin shadow-medium {
  box-shadow: 0 4px 24px 4px $color-shadow-medium,
    0 2px 16px 2px $color-shadow-light;
}

@mixin shadow-large {
  box-shadow: 0 10px 15px -16px $color-shadow-medium,
    0 4px 6px -8px $color-shadow-light;
}

@mixin shadow-big {
  box-shadow: 0 20px 25px -20px $color-shadow-medium,
    0 10px 10px -10px $color-shadow-light;
}

@mixin shadow-mega {
  box-shadow: 0 25px 50px -12px $color-shadow-big;
}

@mixin shadow-inner {
  box-shadow: inset 0 2px 4px 0 $color-shadow-light;
}

@mixin shadow-outline {
  box-shadow: 0 0 0 3px $color-shadow-outline;
}

@mixin shadow-none {
  box-shadow: none;
}

@mixin button-size {
  min-height: $space-large;
  min-width: $space-large;
}

================
File: javascript/widget/assets/scss/_reset.scss
================
// scss-lint:disable
/* http://meyerweb.com/eric/tools/css/reset/
   v2.0 | 20110126
   License: none (public domain)
*/

html, body, div, span, applet, object, iframe,
h1, h2, h3, h4, h5, h6, p, blockquote, pre,
a, abbr, acronym, address, big, cite, code,
del, dfn, em, img, ins, kbd, q, s, samp,
small, strike, strong, sub, sup, tt, var,
b, u, i, center,
dl, dt, dd, ol, ul, li,
fieldset, form, label, legend,
table, caption, tbody, tfoot, thead, tr, th, td,
article, aside, canvas, details, embed,
figure, figcaption, footer, header, hgroup,
menu, nav, output, ruby, section, summary,
time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
  font-size: 100%;
  vertical-align: baseline;
}

/* HTML5 display-role reset for older browsers */
article, aside, details, figcaption, figure,
footer, header, hgroup, menu, nav, section {
  display: block;
}

body {
  line-height: 1;
}

ol, ul {
  list-style: none;
}

blockquote, q {
  quotes: none;
}

blockquote:before, blockquote:after,
q:before, q:after {
  content: none;
}

table {
  border-collapse: collapse;
  border-spacing: 0;
}

================
File: javascript/widget/assets/scss/_utilities.scss
================
.icon-button {
  @include button-size;
}

================
File: javascript/widget/assets/scss/_variables.scss
================
// Font sizes
$font-size-micro: 0.5rem;
$font-size-mini: 0.625rem;
$font-size-small: 0.75rem;
$font-size-default: 0.875rem;
$font-size-medium: 1rem;
$font-size-large: 1.25rem;
$font-size-big: 1.5rem;
$font-size-bigger: 2rem;
$font-size-mega: 2.5rem;
$font-size-giga: 3.5rem;

// spaces
$zero: 0;
$space-micro: 0.125rem;
$space-smaller: 0.25rem;
$space-small: 0.5rem;
$space-one: 0.625rem;
$space-slab: 0.75rem;
$space-normal: 1rem;
$space-two: 1.25rem;
$space-medium: 1.5rem;
$space-large: 2rem;
$space-larger: 3rem;
$space-big: 4rem;
$space-jumbo: 5rem;
$space-mega: 6.25rem;

$border-radius-small: 0.1875rem;
$border-radius-normal: 0.3125rem;

// font-weight
$font-weight-feather: 100;
$font-weight-light: 300;
$font-weight-normal: 400;
$font-weight-medium: 500;
$font-weight-bold: 600;
$font-weight-black: 700;

// Colors
$color-woot: #1f93ff;
$color-primary: $color-woot;
$color-gray: #6e6f73;
$color-light-gray: #999a9b;
$color-border: #e0e6ed;
$color-border-transparent: rgba(224, 230, 237, 0.5);
$color-border-light: #f0f4f5;
$color-border-dark: #cad0d4;
$color-background: #f4f6fb;
$color-background-light: #fafafa;
$color-white: #fff;
$color-body: #3c4858;
$color-heading: #1f2d3d;
$color-error: #ff382d;
$color-success: #44ce4b;

// Color-palettes

$color-primary-light: #c7e3ff;
$color-primary-dark: darken($color-woot, 20%);

// Snackbar default
$woot-snackbar-bg: #323232;
$woot-snackbar-button: #ffeb3b;

$swift-ease-out-duration: 0.4s !default;
$swift-ease-out-timing-function: cubic-bezier(0.25, 0.8, 0.25, 1) !default;
$swift-ease-out: all $swift-ease-out-duration $swift-ease-out-timing-function !default;

$border-radius: 0.1875px;
$line-height: 1;
$footer-height: 11.2rem;
$header-expanded-height: $space-medium * 10;

$font-family: 'Inter',
  -apple-system,
  system-ui,
  BlinkMacSystemFont,
  'Segoe UI',
  Roboto,
  'Helvetica Neue',
  Tahoma,
  Arial,
  sans-serif;

// Break points
$break-point-medium: 667px;

================
File: javascript/widget/assets/scss/woot.scss
================
@import 'shared/assets/stylesheets/animations';
@import 'shared/assets/stylesheets/colors';

@import 'reset';
@import 'tailwindcss/base';
@import 'tailwindcss/components';
@import 'tailwindcss/utilities';
@import 'variables';
@import 'buttons';
@import 'mixins';
@import 'forms';
@import 'utilities';
@import 'shared/assets/fonts/widget_fonts';
@import 'views/conversation';

html,
body {
  font-family: $font-family;
  -moz-osx-font-smoothing: grayscale;
  -webkit-font-smoothing: antialiased;
  height: 100%;
}

.is-mobile {
  display: block;

  .actions {
    .close-button {
      display: block !important;
    }

    .new-window--button {
      display: none !important;
    }
  }
}

.is-bubble-hidden {
  .actions {
    .close-button {
      display: block !important;
    }
  }
}

.cursor-pointer {
  cursor: pointer;
}

.message-content {
  ul {
    list-style: disc;
    padding-left: $space-slab;
  }

  ol {
    list-style: decimal;
    padding-left: $space-normal;
  }
}

.is-flat-design {
  .chat-bubble {
    border-radius: 0 !important;
    box-shadow: none;
  }

  button {
    border-radius: 0 !important;
  }

  input {
    border-radius: 0;
  }

  .chat-message--input {
    border-radius: 0 !important;
    box-shadow: none !important;

    &.is-focused {
      box-shadow: none !important;
    }
  }
}

================
File: javascript/histoire.setup.ts
================
import './design-system/histoire.scss';
import { defineSetupVue3 } from '@histoire/plugin-vue';
import i18nMessages from 'dashboard/i18n';
import { createI18n } from 'vue-i18n';
import { vResizeObserver } from '@vueuse/components';
import store from 'dashboard/store';
import FloatingVue from 'floating-vue';
import VueDOMPurifyHTML from 'vue-dompurify-html';
import { domPurifyConfig } from 'shared/helpers/HTMLSanitizer.js';
import { directive as onClickaway } from 'vue3-click-away';

const i18n = createI18n({
  legacy: false, // https://github.com/intlify/vue-i18n/issues/1902
  locale: 'en',
  messages: i18nMessages,
});

export const setupVue3 = defineSetupVue3(({ app }) => {
  app.use(store);
  app.use(i18n);
  app.use(FloatingVue, {
    instantMove: true,
    arrowOverflow: false,
    disposeTimeout: 5000000,
  });

  app.directive('resize', vResizeObserver);
  app.use(VueDOMPurifyHTML, domPurifyConfig);
  app.directive('on-clickaway', onClickaway);
});

================
File: jobs/account/contacts_export_job.rb
================
class Account::ContactsExportJob < ApplicationJob
  queue_as :low

  def perform(account_id, user_id, column_names, params)
    @account = Account.find(account_id)
    @params = params
    @account_user = @account.users.find(user_id)

    headers = valid_headers(column_names)
    generate_csv(headers)
    send_mail
  end

  private

  def generate_csv(headers)
    csv_data = CSV.generate do |csv|
      csv << headers
      contacts.each do |contact|
        csv << headers.map { |header| contact.send(header) }
      end
    end

    attach_export_file(csv_data)
  end

  def contacts
    if @params.present? && @params[:payload].present? && @params[:payload].any?
      result = ::Contacts::FilterService.new(@account, @account_user, @params).perform
      result[:contacts]
    elsif @params[:label].present?
      @account.contacts.resolved_contacts.tagged_with(@params[:label], any: true)
    else
      @account.contacts.resolved_contacts
    end
  end

  def valid_headers(column_names)
    (column_names.presence || default_columns) & Contact.column_names
  end

  def attach_export_file(csv_data)
    return if csv_data.blank?

    @account.contacts_export.attach(
      io: StringIO.new(csv_data),
      filename: "#{@account.name}_#{@account.id}_contacts.csv",
      content_type: 'text/csv'
    )
  end

  def send_mail
    file_url = account_contact_export_url
    mailer = AdministratorNotifications::ChannelNotificationsMailer.with(account: @account)
    mailer.contact_export_complete(file_url, @account_user.email)&.deliver_later
  end

  def account_contact_export_url
    Rails.application.routes.url_helpers.rails_blob_url(@account.contacts_export)
  end

  def default_columns
    %w[id name email phone_number]
  end
end

================
File: jobs/account/conversations_resolution_scheduler_job.rb
================
class Account::ConversationsResolutionSchedulerJob < ApplicationJob
  queue_as :scheduled_jobs

  def perform
    Account.where.not(auto_resolve_duration: nil).all.find_each(batch_size: 100) do |account|
      Conversations::ResolutionJob.perform_later(account: account)
    end
  end
end
Account::ConversationsResolutionSchedulerJob.prepend_mod_with('Account::ConversationsResolutionSchedulerJob')

================
File: jobs/agent_bots/csml_job.rb
================
class AgentBots::CsmlJob < ApplicationJob
  queue_as :high

  def perform(event, agent_bot, message)
    event_data = { message: message }
    Integrations::Csml::ProcessorService.new(
      event_name: event, agent_bot: agent_bot, event_data: event_data
    ).perform
  end
end

================
File: jobs/agent_bots/webhook_job.rb
================
class AgentBots::WebhookJob < WebhookJob
  queue_as :high
end

================
File: jobs/agents/destroy_job.rb
================
class Agents::DestroyJob < ApplicationJob
  queue_as :low

  def perform(account, user)
    ActiveRecord::Base.transaction do
      destroy_notification_setting(account, user)
      remove_user_from_teams(account, user)
      remove_user_from_inboxes(account, user)
      unassign_conversations(account, user)
    end
  end

  private

  def remove_user_from_inboxes(account, user)
    inboxes = account.inboxes.all
    inbox_members = user.inbox_members.where(inbox_id: inboxes.pluck(:id))
    inbox_members.destroy_all
  end

  def remove_user_from_teams(account, user)
    teams = account.teams.all
    team_members = user.team_members.where(team_id: teams.pluck(:id))
    team_members.destroy_all
  end

  def destroy_notification_setting(account, user)
    setting = user.notification_settings.find_by(account_id: account.id)
    setting&.destroy!
  end

  def unassign_conversations(account, user)
    # rubocop:disable Rails/SkipsModelValidations
    user.assigned_conversations.where(account: account).in_batches.update_all(assignee_id: nil)
    # rubocop:enable Rails/SkipsModelValidations
  end
end

================
File: jobs/avatar/avatar_from_gravatar_job.rb
================
class Avatar::AvatarFromGravatarJob < ApplicationJob
  queue_as :low

  def perform(avatarable, email)
    return if GlobalConfigService.load('DISABLE_GRAVATAR', '').present?
    return if email.blank?
    return if avatarable.avatar_url.present?

    hash = Digest::MD5.hexdigest(email)
    gravatar_url = "https://www.gravatar.com/avatar/#{hash}?d=404"
    Avatar::AvatarFromUrlJob.perform_later(avatarable, gravatar_url)
  end
end

================
File: jobs/avatar/avatar_from_url_job.rb
================
class Avatar::AvatarFromUrlJob < ApplicationJob
  queue_as :low

  def perform(avatarable, avatar_url)
    return unless avatarable.respond_to?(:avatar)

    avatar_file = Down.download(
      avatar_url,
      max_size: 15 * 1024 * 1024
    )
    if valid_image?(avatar_file)
      avatarable.avatar.attach(io: avatar_file, filename: avatar_file.original_filename,
                               content_type: avatar_file.content_type)
    end
  rescue Down::NotFound, Down::Error => e
    Rails.logger.error "Exception: invalid avatar url #{avatar_url} : #{e.message}"
  end

  private

  def valid_image?(file)
    return false if file.original_filename.blank?

    # TODO: check if the file is an actual image

    true
  end
end

================
File: jobs/campaigns/trigger_oneoff_campaign_job.rb
================
class Campaigns::TriggerOneoffCampaignJob < ApplicationJob
  queue_as :low

  def perform(campaign)
    campaign.trigger!
  end
end

================
File: jobs/channels/whatsapp/templates_sync_job.rb
================
class Channels::Whatsapp::TemplatesSyncJob < ApplicationJob
  queue_as :low

  def perform(whatsapp_channel)
    whatsapp_channel.sync_templates
  end
end

================
File: jobs/channels/whatsapp/templates_sync_scheduler_job.rb
================
class Channels::Whatsapp::TemplatesSyncSchedulerJob < ApplicationJob
  queue_as :low

  def perform
    Channel::Whatsapp.order(Arel.sql('message_templates_last_updated IS NULL DESC, message_templates_last_updated ASC'))
                     .where('message_templates_last_updated <= ? OR message_templates_last_updated IS NULL', 3.hours.ago)
                     .limit(Limits::BULK_EXTERNAL_HTTP_CALLS_LIMIT)
                     .each do |channel|
      Channels::Whatsapp::TemplatesSyncJob.perform_later(channel)
    end
  end
end

================
File: jobs/conversations/activity_message_job.rb
================
class Conversations::ActivityMessageJob < ApplicationJob
  queue_as :high

  def perform(conversation, message_params)
    conversation.messages.create!(message_params)
  end
end

================
File: jobs/conversations/reopen_snoozed_conversations_job.rb
================
class Conversations::ReopenSnoozedConversationsJob < ApplicationJob
  queue_as :low

  def perform
    Conversation.where(status: :snoozed).where(snoozed_until: 3.days.ago..Time.current).all.find_each(batch_size: 100, &:open!)
  end
end

================
File: jobs/conversations/resolution_job.rb
================
class Conversations::ResolutionJob < ApplicationJob
  queue_as :low

  def perform(account:)
    # limiting the number of conversations to be resolved to avoid any performance issues
    resolvable_conversations = account.conversations.resolvable(account.auto_resolve_duration).limit(Limits::BULK_ACTIONS_LIMIT)
    resolvable_conversations.each(&:toggle_status)
  end
end

================
File: jobs/conversations/update_message_status_job.rb
================
class Conversations::UpdateMessageStatusJob < ApplicationJob
  queue_as :low

  # This job only support marking messages as read or delivered, update this array if we want to support more statuses
  VALID_STATUSES = %w[read delivered].freeze

  def perform(conversation_id, timestamp, status = :read)
    return unless VALID_STATUSES.include?(status.to_s)

    conversation = Conversation.find_by(id: conversation_id)

    return unless conversation

    # Mark every message created before the user's viewing time read or delivered
    conversation.messages.where(status: %w[sent delivered])
                .where.not(message_type: 'incoming')
                .where('messages.created_at <= ?', timestamp).find_each do |message|
      message.update!(status: status)
    end
  end
end

================
File: jobs/conversations/user_mention_job.rb
================
class Conversations::UserMentionJob < ApplicationJob
  queue_as :default

  def perform(mentioned_user_ids, conversation_id, account_id)
    mentioned_user_ids.each do |mentioned_user_id|
      mention = Mention.find_by(
        user_id: mentioned_user_id,
        conversation_id: conversation_id,
        account_id: account_id
      )

      if mention.nil?
        Mention.create!(
          user_id: mentioned_user_id,
          conversation_id: conversation_id,
          mentioned_at: Time.zone.now,
          account_id: account_id
        )
      else
        mention.update(mentioned_at: Time.zone.now)
      end
    end
  end
end

================
File: jobs/inboxes/fetch_imap_email_inboxes_job.rb
================
class Inboxes::FetchImapEmailInboxesJob < ApplicationJob
  queue_as :scheduled_jobs

  def perform
    email_inboxes = Inbox.where(channel_type: 'Channel::Email')
    email_inboxes.find_each(batch_size: 100) do |inbox|
      ::Inboxes::FetchImapEmailsJob.perform_later(inbox.channel) if should_fetch_emails?(inbox)
    end
  end

  private

  def should_fetch_emails?(inbox)
    inbox.channel.imap_enabled && !inbox.account.suspended?
  end
end

================
File: jobs/inboxes/fetch_imap_emails_job.rb
================
require 'net/imap'

class Inboxes::FetchImapEmailsJob < MutexApplicationJob
  queue_as :scheduled_jobs

  def perform(channel, interval = 1)
    return unless should_fetch_email?(channel)

    key = format(::Redis::Alfred::EMAIL_MESSAGE_MUTEX, inbox_id: channel.inbox.id)

    with_lock(key, 5.minutes) do
      process_email_for_channel(channel, interval)
    end
  rescue *ExceptionList::IMAP_EXCEPTIONS => e
    Rails.logger.error "Authorization error for email channel - #{channel.inbox.id} : #{e.message}"
  rescue EOFError, OpenSSL::SSL::SSLError, Net::IMAP::NoResponseError, Net::IMAP::BadResponseError, Net::IMAP::InvalidResponseError => e
    Rails.logger.error "Error for email channel - #{channel.inbox.id} : #{e.message}"
  rescue LockAcquisitionError
    Rails.logger.error "Lock failed for #{channel.inbox.id}"
  rescue StandardError => e
    ChatwootExceptionTracker.new(e, account: channel.account).capture_exception
  end

  private

  def should_fetch_email?(channel)
    channel.imap_enabled? && !channel.reauthorization_required?
  end

  def process_email_for_channel(channel, interval)
    inbound_emails = if channel.microsoft?
                       Imap::MicrosoftFetchEmailService.new(channel: channel, interval: interval).perform
                     elsif channel.google?
                       Imap::GoogleFetchEmailService.new(channel: channel, interval: interval).perform
                     else
                       Imap::FetchEmailService.new(channel: channel, interval: interval).perform
                     end
    inbound_emails.map do |inbound_mail|
      process_mail(inbound_mail, channel)
    end
  rescue OAuth2::Error => e
    Rails.logger.error "Error for email channel - #{channel.inbox.id} : #{e.message}"
    channel.authorization_error!
  end

  def process_mail(inbound_mail, channel)
    Imap::ImapMailbox.new.process(inbound_mail, channel)
  rescue StandardError => e
    ChatwootExceptionTracker.new(e, account: channel.account).capture_exception
    Rails.logger.error("
      #{channel.provider} Email dropped: #{inbound_mail.from} and message_source_id: #{inbound_mail.message_id}")
  end
end

================
File: jobs/inboxes/sync_widget_pre_chat_custom_fields_job.rb
================
class Inboxes::SyncWidgetPreChatCustomFieldsJob < ApplicationJob
  queue_as :default

  def perform(account, field_name)
    account.web_widgets.all.find_each do |web_widget|
      pre_chat_fields = web_widget.pre_chat_form_options['pre_chat_fields']
      web_widget.pre_chat_form_options['pre_chat_fields'] = pre_chat_fields.reject { |field| field['name'] == field_name }
      web_widget.save!
    end
  end
end

================
File: jobs/inboxes/update_widget_pre_chat_custom_fields_job.rb
================
class Inboxes::UpdateWidgetPreChatCustomFieldsJob < ApplicationJob
  queue_as :default

  def perform(account, custom_attribute)
    attribute_key = custom_attribute['attribute_key']
    account.web_widgets.all.find_each do |web_widget|
      pre_chat_fields = web_widget.pre_chat_form_options['pre_chat_fields']
      pre_chat_fields.each_with_index do |pre_chat_field, index|
        next unless pre_chat_field['name'] == attribute_key

        web_widget.pre_chat_form_options['pre_chat_fields'][index] =
          pre_chat_field.deep_merge({
                                      'label' => custom_attribute['attribute_display_name'],
                                      'placeholder' => custom_attribute['attribute_display_name'],
                                      'values' => custom_attribute['attribute_values'],
                                      'regex_pattern' => custom_attribute['regex_pattern'],
                                      'regex_cue' => custom_attribute['regex_cue']
                                    })
      end
      web_widget.save!
    end
  end
end

================
File: jobs/internal/check_new_versions_job.rb
================
class Internal::CheckNewVersionsJob < ApplicationJob
  queue_as :scheduled_jobs

  def perform
    return unless Rails.env.production?

    @instance_info = ChatwootHub.sync_with_hub
    update_version_info
  end

  private

  def update_version_info
    return if @instance_info['version'].blank?

    ::Redis::Alfred.set(::Redis::Alfred::LATEST_CHATWOOT_VERSION, @instance_info['version'])
  end
end

Internal::CheckNewVersionsJob.prepend_mod_with('Internal::CheckNewVersionsJob')

================
File: jobs/internal/process_stale_redis_keys_job.rb
================
# housekeeping
# remove contact inboxes that does not have any conversations
# and are older than 3 months

class Internal::ProcessStaleRedisKeysJob < ApplicationJob
  queue_as :low

  def perform(account)
    removed_count = Internal::RemoveStaleRedisKeysService.new(account_id: account.id).perform
    Rails.logger.info "Successfully cleaned up Redis keys for account #{account.id} (removed #{removed_count} keys)"
  end
end

================
File: jobs/internal/remove_stale_contact_inboxes_job.rb
================
# housekeeping
# remove contact inboxes that does not have any conversations
# and are older than 3 months

class Internal::RemoveStaleContactInboxesJob < ApplicationJob
  queue_as :scheduled_jobs

  def perform
    Internal::RemoveStaleContactInboxesService.new.perform
  end
end

================
File: jobs/internal/remove_stale_redis_keys_job.rb
================
# housekeeping
# ensure stale ONLINE PRESENCE KEYS for contacts are removed periodically
# should result in 50% redis mem size reduction

class Internal::RemoveStaleRedisKeysJob < ApplicationJob
  queue_as :scheduled_jobs

  def perform
    Account.find_in_batches(batch_size: 100) do |accounts|
      accounts.each do |account|
        Rails.logger.info "Enqueuing ProcessStaleRedisKeysJob for account #{account.id}"
        Internal::ProcessStaleRedisKeysJob.perform_later(account)
      end
    end
  end
end

================
File: jobs/internal/seed_account_job.rb
================
class Internal::SeedAccountJob < ApplicationJob
  queue_as :low

  def perform(account)
    Seeders::AccountSeeder.new(account: account).perform!
  end
end

================
File: jobs/labels/update_job.rb
================
class Labels::UpdateJob < ApplicationJob
  queue_as :default

  def perform(new_label_title, old_label_title, account_id)
    Labels::UpdateService.new(
      new_label_title: new_label_title,
      old_label_title: old_label_title,
      account_id: account_id
    ).perform
  end
end

================
File: jobs/migration/add_search_indexes_job.rb
================
# Delete migration and spec after 2 consecutive releases.
class Migration::AddSearchIndexesJob < ApplicationJob
  queue_as :scheduled_jobs

  def perform
    ActiveRecord::Migration[6.1].add_index(:messages, [:account_id, :inbox_id], algorithm: :concurrently)
    ActiveRecord::Migration[6.1].add_index(:messages, :content, using: 'gin', opclass: :gin_trgm_ops, algorithm: :concurrently)
    ActiveRecord::Migration[6.1].add_index(
      :contacts,
      [:name, :email, :phone_number, :identifier],
      using: 'gin',
      opclass: :gin_trgm_ops,
      name: 'index_contacts_on_name_email_phone_number_identifier',
      algorithm: :concurrently
    )
  end
end

================
File: jobs/migration/conversation_batch_cache_label_job.rb
================
class Migration::ConversationBatchCacheLabelJob < ApplicationJob
  queue_as :async_database_migration

  # To cache the label, we simply access it from the object and save it. Anytime the object is
  # saved in the future, ActsAsTaggable will automatically recompute it. This process is done
  # initially when the user has not performed any action.
  # Reference: https://github.com/mbleigh/acts-as-taggable-on/wiki/Caching
  def perform(conversation_batch)
    conversation_batch.each do |conversation|
      conversation.label_list
      conversation.save!
    end
  end
end

================
File: jobs/migration/conversation_cache_label_job.rb
================
class Migration::ConversationCacheLabelJob < ApplicationJob
  queue_as :async_database_migration

  def perform(account)
    account.conversations.find_in_batches(batch_size: 100) do |conversation_batch|
      Migration::ConversationBatchCacheLabelJob.perform_later(conversation_batch)
    end
  end
end

================
File: jobs/migration/conversations_first_reply_scheduler_job.rb
================
# Delete migration and spec after 2 consecutive releases.
class Migration::ConversationsFirstReplySchedulerJob < ApplicationJob
  queue_as :scheduled_jobs

  def perform(account)
    account.conversations.each do |conversation|
      # rubocop:disable Rails/SkipsModelValidations
      if conversation.messages.outgoing.where("(additional_attributes->'campaign_id') is null").count.positive?
        conversation.update_columns(first_reply_created_at: conversation.messages.outgoing.where("(additional_attributes->'campaign_id') is null")
        .first.created_at)
      else
        conversation.update_columns(first_reply_created_at: nil)
      end
      # rubocop:enable Rails/SkipsModelValidations
    end
  end
end

================
File: jobs/migration/remove_message_notifications.rb
================
# Delete migration and spec after 2 consecutive releases.
class Migration::RemoveMessageNotifications < ApplicationJob
  queue_as :scheduled_jobs

  def perform
    Notification.where(primary_actor_type: 'Message').in_batches(of: 100).delete_all
  end
end

================
File: jobs/migration/remove_stale_notifications_job.rb
================
# Delete migration and spec after 2 consecutive releases.
class Migration::RemoveStaleNotificationsJob < ApplicationJob
  queue_as :scheduled_jobs

  def perform
    remove_invalid_messages
  end

  private

  def remove_invalid_messages
    deleted_ids = []

    Message.unscoped.distinct.pluck(:inbox_id).each_slice(1000) do |id_list|
      deleted_ids = (id_list - Inbox.where(id: id_list).pluck(:id))
      Message.where(inbox_id: deleted_ids.flatten).destroy_all
    end
  end
end

================
File: jobs/migration/update_first_response_time_in_reporting_events_job.rb
================
# Delete migration and spec after 2 consecutive releases.
class Migration::UpdateFirstResponseTimeInReportingEventsJob < ApplicationJob
  include ReportingEventHelper

  queue_as :async_database_migration

  def perform(account)
    get_conversations_with_bot_handoffs(account)
    account.reporting_events.where(name: 'first_response').find_each do |event|
      conversation = event.conversation

      # if the conversation has a bot handoff event, we don't need to update the response_time
      next if conversation.nil? || @conversations_with_handoffs.include?(conversation.id)

      update_event_data(event, conversation)
    end
  end

  def get_conversations_with_bot_handoffs(account)
    @conversations_with_handoffs = account.reporting_events.where(name: 'conversation_bot_handoff').pluck(:conversation_id)
  end

  def update_event_data(event, conversation)
    last_bot_reply = conversation.messages.where(sender_type: 'AgentBot').order(created_at: :asc).last
    return if last_bot_reply.blank?

    first_human_reply = conversation.messages.where(sender_type: 'User').order(created_at: :asc).first
    return if first_human_reply.blank?

    # accomodate for campaign if required
    # new_value = difference between the first_human_reply and the first_bot_reply if it exists or first_human_reply and created at
    #
    # conversation       bot                         conversation
    # start              handoff                     resolved
    # |                  |                           |
    # |____|___|_________|____|_______|_____|________|
    #      bot reply     ^    ^  human reply
    #                    |    |
    #                    |    |
    #       last_bot_reply    first_human_reply
    #
    #
    # bot handoff happens at the last_bot_reply created time
    # the response time is the time between last bot reply created and the first human reply created
    return if last_bot_reply.created_at.to_i >= first_human_reply.created_at.to_i

    # this means a bot replied existed, so we need to update the event_start_time
    update_event_details(event, last_bot_reply, first_human_reply, conversation.inbox)
  end

  def update_event_details(event, last_bot_reply, first_human_reply, inbox)
    # rubocop:disable Rails/SkipsModelValidations
    event.update_columns(event_start_time: last_bot_reply.created_at,
                         event_end_time: first_human_reply.created_at,
                         value: calculate_event_value(last_bot_reply, first_human_reply),
                         value_in_business_hours: calculate_event_value_in_business_hours(inbox, last_bot_reply,
                                                                                          first_human_reply),
                         user_id: event.user_id || first_human_reply.sender_id)
    # rubocop:enable Rails/SkipsModelValidations
  end

  def calculate_event_value(last_bot_reply, first_human_reply)
    first_human_reply.created_at.to_i - last_bot_reply.created_at.to_i
  end

  def calculate_event_value_in_business_hours(inbox, last_bot_reply, first_human_reply)
    business_hours(inbox, last_bot_reply.created_at, first_human_reply.created_at)
  end
end

================
File: jobs/notification/delete_notification_job.rb
================
class Notification::DeleteNotificationJob < ApplicationJob
  queue_as :low

  def perform(user, type: :all)
    ActiveRecord::Base.transaction do
      if type == :all
        # Delete all notifications
        user.notifications.destroy_all
      elsif type == :read
        # Delete only read notifications
        user.notifications.where.not(read_at: nil).destroy_all
      end
    end
  end
end

================
File: jobs/notification/email_notification_job.rb
================
class Notification::EmailNotificationJob < ApplicationJob
  queue_as :default

  def perform(notification)
    # no need to send email if notification has been read already
    return if notification.read_at.present?

    Notification::EmailNotificationService.new(notification: notification).perform
  end
end

================
File: jobs/notification/push_notification_job.rb
================
class Notification::PushNotificationJob < ApplicationJob
  queue_as :default

  def perform(notification)
    Notification::PushNotificationService.new(notification: notification).perform
  end
end

================
File: jobs/notification/remove_duplicate_notification_job.rb
================
class Notification::RemoveDuplicateNotificationJob < ApplicationJob
  queue_as :default

  def perform(notification)
    return unless notification.is_a?(Notification)

    user_id = notification.user_id
    primary_actor_id = notification.primary_actor_id

    # Find older notifications with the same user and primary_actor_id
    duplicate_notifications = Notification.where(user_id: user_id, primary_actor_id: primary_actor_id)
                                          .order(created_at: :desc)

    # Skip the first one (the latest notification) and destroy the rest
    duplicate_notifications.offset(1).each(&:destroy)
  end
end

================
File: jobs/notification/remove_old_notification_job.rb
================
class Notification::RemoveOldNotificationJob < ApplicationJob
  queue_as :low

  def perform
    Notification.where('created_at < ?', 1.month.ago)
                .find_each(batch_size: 1000, &:delete)
  end
end

================
File: jobs/notification/reopen_snoozed_notifications_job.rb
================
class Notification::ReopenSnoozedNotificationsJob < ApplicationJob
  queue_as :low

  def perform
    Notification.where(snoozed_until: 3.days.ago..Time.current).find_in_batches(batch_size: 100) do |notifications_batch|
      notifications_batch.each do |notification|
        update_notification(notification)
      end
    end
  end

  private

  def update_notification(notification)
    updated_meta = (notification.meta || {}).merge('last_snoozed_at' => notification.snoozed_until)

    notification.update!(
      snoozed_until: nil,
      updated_at: Time.current,
      last_activity_at: Time.current,
      meta: updated_meta,
      read_at: nil
    )
  end
end

================
File: jobs/webhooks/facebook_delivery_job.rb
================
class Webhooks::FacebookDeliveryJob < ApplicationJob
  queue_as :low

  def perform(message)
    response = ::Integrations::Facebook::MessageParser.new(message)
    Integrations::Facebook::DeliveryStatus.new(params: response).perform
  end
end

================
File: jobs/webhooks/facebook_events_job.rb
================
class Webhooks::FacebookEventsJob < MutexApplicationJob
  queue_as :default
  retry_on LockAcquisitionError, wait: 1.second, attempts: 8

  def perform(message)
    response = ::Integrations::Facebook::MessageParser.new(message)

    key = format(::Redis::Alfred::FACEBOOK_MESSAGE_MUTEX, sender_id: response.sender_id, recipient_id: response.recipient_id)
    with_lock(key) do
      process_message(response)
    end
  end

  def process_message(response)
    ::Integrations::Facebook::MessageCreator.new(response).perform
  end
end

================
File: jobs/webhooks/instagram_events_job.rb
================
class Webhooks::InstagramEventsJob < MutexApplicationJob
  queue_as :default
  retry_on LockAcquisitionError, wait: 1.second, attempts: 8

  include HTTParty

  base_uri 'https://graph.facebook.com/v11.0/me'

  # @return [Array] We will support further events like reaction or seen in future
  SUPPORTED_EVENTS = [:message, :read].freeze

  def perform(entries)
    @entries = entries

    key = format(::Redis::Alfred::IG_MESSAGE_MUTEX, sender_id: sender_id, ig_account_id: ig_account_id)
    with_lock(key) do
      process_entries(entries)
    end
  end

  # @see https://developers.facebook.com/docs/messenger-platform/instagram/features/webhook
  def process_entries(entries)
    entries.each do |entry|
      entry = entry.with_indifferent_access
      messages(entry).each do |messaging|
        send(@event_name, messaging) if event_name(messaging)
      end
    end
  end

  private

  def ig_account_id
    @entries&.first&.dig(:id)
  end

  def sender_id
    @entries&.dig(0, :messaging, 0, :sender, :id)
  end

  def event_name(messaging)
    @event_name ||= SUPPORTED_EVENTS.find { |key| messaging.key?(key) }
  end

  def message(messaging)
    ::Instagram::MessageText.new(messaging).perform
  end

  def read(messaging)
    ::Instagram::ReadStatusService.new(params: messaging).perform
  end

  def messages(entry)
    (entry[:messaging].presence || entry[:standby] || [])
  end
end

================
File: jobs/webhooks/line_events_job.rb
================
class Webhooks::LineEventsJob < ApplicationJob
  queue_as :default

  def perform(params: {}, signature: '', post_body: '')
    @params = params
    return unless valid_event_payload?
    return unless valid_post_body?(post_body, signature)

    Line::IncomingMessageService.new(inbox: @channel.inbox, params: @params['line'].with_indifferent_access).perform
  end

  private

  def valid_event_payload?
    @channel = Channel::Line.find_by(line_channel_id: @params[:line_channel_id]) if @params[:line_channel_id]
  end

  # https://developers.line.biz/en/reference/messaging-api/#signature-validation
  # validate the line payload
  def valid_post_body?(post_body, signature)
    hash = OpenSSL::HMAC.digest(OpenSSL::Digest.new('SHA256'), @channel.line_channel_secret, post_body)
    Base64.strict_encode64(hash) == signature
  end
end

================
File: jobs/webhooks/sms_events_job.rb
================
class Webhooks::SmsEventsJob < ApplicationJob
  queue_as :default

  SUPPORTED_EVENTS = %w[message-received message-delivered message-failed].freeze

  def perform(params = {})
    return unless SUPPORTED_EVENTS.include?(params[:type])

    channel = Channel::Sms.find_by(phone_number: params[:to])
    return unless channel

    process_event_params(channel, params)
  end

  private

  def process_event_params(channel, params)
    if delivery_event?(params)
      Sms::DeliveryStatusService.new(channel: channel, params: params[:message].with_indifferent_access).perform
    else
      Sms::IncomingMessageService.new(inbox: channel.inbox, params: params[:message].with_indifferent_access).perform
    end
  end

  def delivery_event?(params)
    params[:type] == 'message-delivered' || params[:type] == 'message-failed'
  end
end

================
File: jobs/webhooks/telegram_events_job.rb
================
class Webhooks::TelegramEventsJob < ApplicationJob
  queue_as :default

  def perform(params = {})
    return unless params[:bot_token]

    channel = Channel::Telegram.find_by(bot_token: params[:bot_token])
    return unless channel

    process_event_params(channel, params)
  end

  private

  def process_event_params(channel, params)
    return unless params[:telegram]

    if params.dig(:telegram, :edited_message).present?
      Telegram::UpdateMessageService.new(inbox: channel.inbox, params: params['telegram'].with_indifferent_access).perform
    else
      Telegram::IncomingMessageService.new(inbox: channel.inbox, params: params['telegram'].with_indifferent_access).perform
    end
  end
end

================
File: jobs/webhooks/whatsapp_events_job.rb
================
class Webhooks::WhatsappEventsJob < ApplicationJob
  queue_as :low

  def perform(params = {})
    channel = find_channel_from_whatsapp_business_payload(params)
    return if channel_is_inactive?(channel)

    case channel.provider
    when 'whatsapp_cloud'
      Whatsapp::IncomingMessageWhatsappCloudService.new(inbox: channel.inbox, params: params).perform
    else
      Whatsapp::IncomingMessageService.new(inbox: channel.inbox, params: params).perform
    end
  end

  private

  def channel_is_inactive?(channel)
    return true if channel.blank?
    return true if channel.reauthorization_required?
    return true unless channel.account.active?

    false
  end

  def find_channel_by_url_param(params)
    return unless params[:phone_number]

    Channel::Whatsapp.find_by(phone_number: params[:phone_number])
  end

  def find_channel_from_whatsapp_business_payload(params)
    # for the case where facebook cloud api support multiple numbers for a single app
    # https://github.com/chatwoot/chatwoot/issues/4712#issuecomment-1173838350
    # we will give priority to the phone_number in the payload
    return get_channel_from_wb_payload(params) if params[:object] == 'whatsapp_business_account'

    find_channel_by_url_param(params)
  end

  def get_channel_from_wb_payload(wb_params)
    phone_number = "+#{wb_params[:entry].first[:changes].first.dig(:value, :metadata, :display_phone_number)}"
    phone_number_id = wb_params[:entry].first[:changes].first.dig(:value, :metadata, :phone_number_id)
    channel = Channel::Whatsapp.find_by(phone_number: phone_number)
    # validate to ensure the phone number id matches the whatsapp channel
    return channel if channel && channel.provider_config['phone_number_id'] == phone_number_id
  end
end

================
File: jobs/action_cable_broadcast_job.rb
================
class ActionCableBroadcastJob < ApplicationJob
  queue_as :critical
  include Events::Types

  CONVERSATION_UPDATE_EVENTS = [
    CONVERSATION_READ,
    CONVERSATION_UPDATED,
    TEAM_CHANGED,
    ASSIGNEE_CHANGED,
    CONVERSATION_STATUS_CHANGED
  ].freeze

  def perform(members, event_name, data)
    return if members.blank?

    broadcast_data = prepare_broadcast_data(event_name, data)
    broadcast_to_members(members, event_name, broadcast_data)
  end

  private

  # Ensures that only the latest available data is sent to prevent UI issues
  # caused by out-of-order events during high-traffic periods. This prevents
  # the conversation job from processing outdated data.
  def prepare_broadcast_data(event_name, data)
    return data unless CONVERSATION_UPDATE_EVENTS.include?(event_name)

    account = Account.find(data[:account_id])
    conversation = account.conversations.find_by!(display_id: data[:id])
    conversation.push_event_data.merge(account_id: data[:account_id])
  end

  def broadcast_to_members(members, event_name, broadcast_data)
    members.each do |member|
      ActionCable.server.broadcast(
        member,
        {
          event: event_name,
          data: broadcast_data
        }
      )
    end
  end
end

================
File: jobs/application_job.rb
================
class ApplicationJob < ActiveJob::Base
  # https://api.rubyonrails.org/v5.2.1/classes/ActiveJob/Exceptions/ClassMethods.html
  discard_on ActiveJob::DeserializationError do |job, error|
    Rails.logger.info("Skipping #{job.class} with #{
      job.instance_variable_get(:@serialized_arguments)
    } because of ActiveJob::DeserializationError (#{error.message})")
  end
end

================
File: jobs/bulk_actions_job.rb
================
class BulkActionsJob < ApplicationJob
  include DateRangeHelper

  queue_as :medium
  attr_accessor :records

  MODEL_TYPE = ['Conversation'].freeze

  def perform(account:, params:, user:)
    @account = account
    Current.user = user
    @params = params
    @records = records_to_updated(params[:ids])
    bulk_update
  ensure
    Current.reset
  end

  def bulk_update
    bulk_remove_labels
    bulk_conversation_update
  end

  def bulk_conversation_update
    params = available_params(@params)
    records.each do |conversation|
      bulk_add_labels(conversation)
      bulk_snoozed_until(conversation)
      conversation.update(params) if params
    end
  end

  def bulk_remove_labels
    records.each do |conversation|
      remove_labels(conversation)
    end
  end

  def available_params(params)
    return unless params[:fields]

    params[:fields].delete_if { |key, value| value.nil? && key == 'status' }
  end

  def bulk_add_labels(conversation)
    conversation.add_labels(@params[:labels][:add]) if @params[:labels] && @params[:labels][:add]
  end

  def bulk_snoozed_until(conversation)
    conversation.snoozed_until = parse_date_time(@params[:snoozed_until].to_s) if @params[:snoozed_until]
  end

  def remove_labels(conversation)
    return unless @params[:labels] && @params[:labels][:remove]

    labels = conversation.label_list - @params[:labels][:remove]
    conversation.update(label_list: labels)
  end

  def records_to_updated(ids)
    current_model = @params[:type].camelcase
    return unless MODEL_TYPE.include?(current_model)

    current_model.constantize&.where(account_id: @account.id, display_id: ids)
  end
end

================
File: jobs/contact_ip_lookup_job.rb
================
class ContactIpLookupJob < ApplicationJob
  queue_as :default

  def perform(contact)
    update_contact_location_from_ip(contact)
  rescue Errno::ETIMEDOUT => e
    Rails.logger.warn "Exception: ip resolution failed : #{e.message}"
  end

  private

  def update_contact_location_from_ip(contact)
    geocoder_result = IpLookupService.new.perform(get_contact_ip(contact))
    return unless geocoder_result

    contact.additional_attributes ||= {}
    contact.additional_attributes['city'] = geocoder_result.city
    contact.additional_attributes['country'] = geocoder_result.country
    contact.additional_attributes['country_code'] = geocoder_result.country_code
    contact.save!
  end

  def get_contact_ip(contact)
    contact.additional_attributes&.dig('updated_at_ip') || contact.additional_attributes&.dig('created_at_ip')
  end
end

================
File: jobs/data_import_job.rb
================
# TODO: logic is written tailored to contact import since its the only import available
# let's break this logic and clean this up in future

class DataImportJob < ApplicationJob
  queue_as :low
  retry_on ActiveStorage::FileNotFoundError, wait: 1.minute, attempts: 3

  def perform(data_import)
    @data_import = data_import
    @contact_manager = DataImport::ContactManager.new(@data_import.account)
    begin
      process_import_file
      send_import_notification_to_admin
    rescue CSV::MalformedCSVError => e
      handle_csv_error(e)
    end
  end

  private

  def process_import_file
    @data_import.update!(status: :processing)
    contacts, rejected_contacts = parse_csv_and_build_contacts

    import_contacts(contacts)
    update_data_import_status(contacts.length, rejected_contacts.length)
    save_failed_records_csv(rejected_contacts)
  end

  def parse_csv_and_build_contacts
    contacts = []
    rejected_contacts = []
    # Ensuring that importing non utf-8 characters will not throw error
    data = @data_import.import_file.download
    utf8_data = data.force_encoding('UTF-8')

    # Ensure that the data is valid UTF-8, preserving valid characters
    clean_data = utf8_data.valid_encoding? ? utf8_data : utf8_data.encode('UTF-16le', invalid: :replace, replace: '').encode('UTF-8')

    csv = CSV.parse(clean_data, headers: true)

    csv.each do |row|
      current_contact = @contact_manager.build_contact(row.to_h.with_indifferent_access)
      if current_contact.valid?
        contacts << current_contact
      else
        append_rejected_contact(row, current_contact, rejected_contacts)
      end
    end

    [contacts, rejected_contacts]
  end

  def append_rejected_contact(row, contact, rejected_contacts)
    row['errors'] = contact.errors.full_messages.join(', ')
    rejected_contacts << row
  end

  def import_contacts(contacts)
    # <struct ActiveRecord::Import::Result failed_instances=[], num_inserts=1, ids=[444, 445], results=[]>
    Contact.import(contacts, synchronize: contacts, on_duplicate_key_ignore: true, track_validation_failures: true, validate: true, batch_size: 1000)
  end

  def update_data_import_status(processed_records, rejected_records)
    @data_import.update!(status: :completed, processed_records: processed_records, total_records: processed_records + rejected_records)
  end

  def save_failed_records_csv(rejected_contacts)
    csv_data = generate_csv_data(rejected_contacts)
    return if csv_data.blank?

    @data_import.failed_records.attach(io: StringIO.new(csv_data), filename: "#{Time.zone.today.strftime('%Y%m%d')}_contacts.csv",
                                       content_type: 'text/csv')
    send_import_notification_to_admin
  end

  def generate_csv_data(rejected_contacts)
    headers = CSV.parse(@data_import.import_file.download, headers: true).headers
    headers << 'errors'
    return if rejected_contacts.blank?

    CSV.generate do |csv|
      csv << headers
      rejected_contacts.each do |record|
        csv << record
      end
    end
  end

  def handle_csv_error(error) # rubocop:disable Lint/UnusedMethodArgument
    @data_import.update!(status: :failed)
    send_import_failed_notification_to_admin
  end

  def send_import_notification_to_admin
    AdministratorNotifications::ChannelNotificationsMailer.with(account: @data_import.account).contact_import_complete(@data_import).deliver_later
  end

  def send_import_failed_notification_to_admin
    AdministratorNotifications::ChannelNotificationsMailer.with(account: @data_import.account).contact_import_failed.deliver_later
  end
end

================
File: jobs/delete_object_job.rb
================
class DeleteObjectJob < ApplicationJob
  queue_as :low

  def perform(object, user = nil, ip = nil)
    object.destroy!
    process_post_deletion_tasks(object, user, ip)
  end

  def process_post_deletion_tasks(object, user, ip); end
end

DeleteObjectJob.prepend_mod_with('DeleteObjectJob')

================
File: jobs/event_dispatcher_job.rb
================
class EventDispatcherJob < ApplicationJob
  queue_as :critical

  def perform(event_name, timestamp, data)
    Rails.configuration.dispatcher.async_dispatcher.publish_event(event_name, timestamp, data)
  end
end

================
File: jobs/hook_job.rb
================
class HookJob < ApplicationJob
  queue_as :medium

  def perform(hook, event_name, event_data = {})
    return if hook.disabled?

    case hook.app_id
    when 'slack'
      process_slack_integration(hook, event_name, event_data)
    when 'dialogflow'
      process_dialogflow_integration(hook, event_name, event_data)
    when 'google_translate'
      google_translate_integration(hook, event_name, event_data)
    end
  rescue StandardError => e
    Rails.logger.error e
  end

  private

  def process_slack_integration(hook, event_name, event_data)
    return unless ['message.created'].include?(event_name)

    message = event_data[:message]
    if message.attachments.blank?
      ::SendOnSlackJob.perform_later(message, hook)
    else
      ::SendOnSlackJob.set(wait: 2.seconds).perform_later(message, hook)
    end
  end

  def process_dialogflow_integration(hook, event_name, event_data)
    return unless ['message.created', 'message.updated'].include?(event_name)

    Integrations::Dialogflow::ProcessorService.new(event_name: event_name, hook: hook, event_data: event_data).perform
  end

  def google_translate_integration(hook, event_name, event_data)
    return unless ['message.created'].include?(event_name)

    message = event_data[:message]
    Integrations::GoogleTranslate::DetectLanguageService.new(hook: hook, message: message).perform
  end
end

================
File: jobs/macros_execution_job.rb
================
class MacrosExecutionJob < ApplicationJob
  queue_as :medium

  def perform(macro, conversation_ids:, user:)
    account = macro.account
    conversations = account.conversations.where(display_id: conversation_ids.to_a)

    return if conversations.blank?

    conversations.each do |conversation|
      ::Macros::ExecutionService.new(macro, conversation, user).perform
    end
  end
end

================
File: jobs/mutex_application_job.rb
================
# MutexApplicationJob serves as a base class for jobs that require distributed locking mechanisms.
# It abstracts the locking logic using Redis and ensures that a block of code can be executed with
# mutual exclusion.
#
# The primary mechanism provided is the `with_lock` method, which accepts a key format and associated
# arguments. This method attempts to acquire a lock using the generated key, and if successful, it
# executes the provided block of code. If the lock cannot be acquired, it raises a LockAcquisitionError.
#
# To use this class, inherit from MutexApplicationJob and make use of the `with_lock` method in the
# `perform` method of the derived job class.
#
# Also see, retry mechanism here: https://edgeapi.rubyonrails.org/classes/ActiveJob/Exceptions/ClassMethods.html#method-i-retry_on
#
class MutexApplicationJob < ApplicationJob
  class LockAcquisitionError < StandardError; end

  def with_lock(lock_key, timeout = Redis::LockManager::LOCK_TIMEOUT)
    lock_manager = Redis::LockManager.new

    begin
      if lock_manager.lock(lock_key, timeout)
        log_attempt(lock_key, executions)
        yield
        # release the lock after the block has been executed
        lock_manager.unlock(lock_key)
      else
        handle_failed_lock_acquisition(lock_key)
      end
    rescue StandardError => e
      handle_error(e, lock_manager, lock_key)
    end
  end

  private

  def log_attempt(lock_key, executions)
    Rails.logger.info "[#{self.class.name}] Acquired lock for: #{lock_key} on attempt #{executions}"
  end

  def handle_error(err, lock_manager, lock_key)
    lock_manager.unlock(lock_key) unless err.is_a?(LockAcquisitionError)
    raise err
  end

  def handle_failed_lock_acquisition(lock_key)
    Rails.logger.warn "[#{self.class.name}] Failed to acquire lock on attempt #{executions}: #{lock_key}"
    raise LockAcquisitionError, "Failed to acquire lock for key: #{lock_key}"
  end
end

================
File: jobs/send_on_slack_job.rb
================
class SendOnSlackJob < MutexApplicationJob
  queue_as :medium
  retry_on LockAcquisitionError, wait: 1.second, attempts: 8

  def perform(message, hook)
    key = format(::Redis::Alfred::SLACK_MESSAGE_MUTEX, conversation_id: message.conversation_id, reference_id: hook.reference_id)
    with_lock(key) do
      Integrations::Slack::SendOnSlackService.new(message: message, hook: hook).perform
    end
  end
end

================
File: jobs/send_reply_job.rb
================
class SendReplyJob < ApplicationJob
  queue_as :high

  def perform(message_id)
    message = Message.find(message_id)
    conversation = message.conversation
    channel_name = conversation.inbox.channel.class.to_s

    services = {
      'Channel::TwitterProfile' => ::Twitter::SendOnTwitterService,
      'Channel::TwilioSms' => ::Twilio::SendOnTwilioService,
      'Channel::Line' => ::Line::SendOnLineService,
      'Channel::Telegram' => ::Telegram::SendOnTelegramService,
      'Channel::Whatsapp' => ::Whatsapp::SendOnWhatsappService,
      'Channel::Sms' => ::Sms::SendOnSmsService
    }

    case channel_name
    when 'Channel::FacebookPage'
      send_on_facebook_page(message)
    else
      services[channel_name].new(message: message).perform if services[channel_name].present?
    end
  end

  private

  def send_on_facebook_page(message)
    if message.conversation.additional_attributes['type'] == 'instagram_direct_message'
      ::Instagram::SendOnInstagramService.new(message: message).perform
    else
      ::Facebook::SendOnFacebookService.new(message: message).perform
    end
  end
end

================
File: jobs/slack_unfurl_job.rb
================
class SlackUnfurlJob < ApplicationJob
  queue_as :low

  def perform(params)
    @params = params
    set_integration_hook

    return unless channel_has_access

    Integrations::Slack::SlackLinkUnfurlService.new(params: @params, integration_hook: @integration_hook).perform
  end

  private

  # Find the integration hook by taking first link from array of links
  # Assume that all the links are from the same account, how ever there is a possibility that the links are from different accounts.
  # TODO: Fix this edge case later
  def set_integration_hook
    url = extract_url
    return unless url

    account_id = extract_account_id(url)
    @integration_hook = Integrations::Hook.find_by(account_id: account_id, app_id: 'slack')
  end

  def extract_url
    @params.dig(:event, :links)&.first&.[](:url)
  end

  def extract_account_id(url)
    account_id_regex = %r{/accounts/(\d+)}
    match_data = url.match(account_id_regex)
    match_data[1] if match_data
  end

  # Check the channel has access to the bot to unfurl the links
  def channel_has_access
    return if @integration_hook.blank?

    slack_client = Slack::Web::Client.new(token: @integration_hook.access_token)
    response = slack_client.conversations_members(channel: @params.dig(:event, :channel))
    response['ok']
  rescue Slack::Web::Api::Errors::ChannelNotFound => e
    # The link unfurl event will not work for private channels and other accounts channels
    # So we can ignore the error
    Rails.logger.error "Exception in SlackUnfurlJob: #{e.message}"
    false
  end
end

================
File: jobs/trigger_scheduled_items_job.rb
================
class TriggerScheduledItemsJob < ApplicationJob
  queue_as :scheduled_jobs

  def perform
    # trigger the scheduled campaign jobs
    Campaign.where(campaign_type: :one_off,
                   campaign_status: :active).where(scheduled_at: 3.days.ago..Time.current).all.find_each(batch_size: 100) do |campaign|
      Campaigns::TriggerOneoffCampaignJob.perform_later(campaign)
    end

    # Job to reopen snoozed conversations
    Conversations::ReopenSnoozedConversationsJob.perform_later

    # Job to reopen snoozed notifications
    Notification::ReopenSnoozedNotificationsJob.perform_later

    # Job to auto-resolve conversations
    Account::ConversationsResolutionSchedulerJob.perform_later

    # Job to sync whatsapp templates
    Channels::Whatsapp::TemplatesSyncSchedulerJob.perform_later

    # Job to clear notifications which are older than 1 month
    Notification::RemoveOldNotificationJob.perform_later
  end
end

TriggerScheduledItemsJob.prepend_mod_with('TriggerScheduledItemsJob')

================
File: jobs/webhook_job.rb
================
class WebhookJob < ApplicationJob
  queue_as :medium
  #  There are 3 types of webhooks, account, inbox and agent_bot
  def perform(url, payload, webhook_type = :account_webhook)
    Webhooks::Trigger.execute(url, payload, webhook_type)
  end
end

================
File: listeners/action_cable_listener.rb
================
class ActionCableListener < BaseListener
  include Events::Types

  def notification_created(event)
    notification, account, unread_count, count = extract_notification_and_account(event)
    tokens = [event.data[:notification].user.pubsub_token]
    broadcast(account, tokens, NOTIFICATION_CREATED, { notification: notification.push_event_data, unread_count: unread_count, count: count })
  end

  def notification_updated(event)
    notification, account, unread_count, count = extract_notification_and_account(event)
    tokens = [event.data[:notification].user.pubsub_token]
    broadcast(account, tokens, NOTIFICATION_UPDATED, { notification: notification.push_event_data, unread_count: unread_count, count: count })
  end

  def notification_deleted(event)
    return if event.data[:notification].user.blank?

    notification, account, unread_count, count = extract_notification_and_account(event)
    tokens = [event.data[:notification].user.pubsub_token]
    broadcast(account, tokens, NOTIFICATION_DELETED, { notification: { id: notification.id }, unread_count: unread_count, count: count })
  end

  def account_cache_invalidated(event)
    account = event.data[:account]
    tokens = user_tokens(account, account.agents)

    broadcast(account, tokens, ACCOUNT_CACHE_INVALIDATED, {
                cache_keys: event.data[:cache_keys]
              })
  end

  def message_created(event)
    message, account = extract_message_and_account(event)
    conversation = message.conversation
    tokens = user_tokens(account, conversation.inbox.members) + contact_tokens(conversation.contact_inbox, message)

    broadcast(account, tokens, MESSAGE_CREATED, message.push_event_data)
  end

  def message_updated(event)
    message, account = extract_message_and_account(event)
    conversation = message.conversation
    tokens = user_tokens(account, conversation.inbox.members) + contact_tokens(conversation.contact_inbox, message)

    broadcast(account, tokens, MESSAGE_UPDATED, message.push_event_data.merge(previous_changes: event.data[:previous_changes]))
  end

  def first_reply_created(event)
    message, account = extract_message_and_account(event)
    conversation = message.conversation
    tokens = user_tokens(account, conversation.inbox.members)

    broadcast(account, tokens, FIRST_REPLY_CREATED, message.push_event_data)
  end

  def conversation_created(event)
    conversation, account = extract_conversation_and_account(event)
    tokens = user_tokens(account, conversation.inbox.members) + contact_inbox_tokens(conversation.contact_inbox)

    broadcast(account, tokens, CONVERSATION_CREATED, conversation.push_event_data)
  end

  def conversation_read(event)
    conversation, account = extract_conversation_and_account(event)
    tokens = user_tokens(account, conversation.inbox.members)

    broadcast(account, tokens, CONVERSATION_READ, conversation.push_event_data)
  end

  def conversation_status_changed(event)
    conversation, account = extract_conversation_and_account(event)
    tokens = user_tokens(account, conversation.inbox.members) + contact_inbox_tokens(conversation.contact_inbox)

    broadcast(account, tokens, CONVERSATION_STATUS_CHANGED, conversation.push_event_data)
  end

  def conversation_updated(event)
    conversation, account = extract_conversation_and_account(event)
    tokens = user_tokens(account, conversation.inbox.members) + contact_inbox_tokens(conversation.contact_inbox)

    broadcast(account, tokens, CONVERSATION_UPDATED, conversation.push_event_data)
  end

  def conversation_typing_on(event)
    conversation = event.data[:conversation]
    account = conversation.account
    user = event.data[:user]
    tokens = typing_event_listener_tokens(account, conversation, user)

    broadcast(
      account,
      tokens,
      CONVERSATION_TYPING_ON,
      conversation: conversation.push_event_data,
      user: user.push_event_data,
      is_private: event.data[:is_private] || false
    )
  end

  def conversation_typing_off(event)
    conversation = event.data[:conversation]
    account = conversation.account
    user = event.data[:user]
    tokens = typing_event_listener_tokens(account, conversation, user)

    broadcast(
      account,
      tokens,
      CONVERSATION_TYPING_OFF,
      conversation: conversation.push_event_data,
      user: user.push_event_data,
      is_private: event.data[:is_private] || false
    )
  end

  def assignee_changed(event)
    conversation, account = extract_conversation_and_account(event)
    tokens = user_tokens(account, conversation.inbox.members)

    broadcast(account, tokens, ASSIGNEE_CHANGED, conversation.push_event_data)
  end

  def team_changed(event)
    conversation, account = extract_conversation_and_account(event)
    tokens = user_tokens(account, conversation.inbox.members)

    broadcast(account, tokens, TEAM_CHANGED, conversation.push_event_data)
  end

  def conversation_contact_changed(event)
    conversation, account = extract_conversation_and_account(event)
    tokens = user_tokens(account, conversation.inbox.members)

    broadcast(account, tokens, CONVERSATION_CONTACT_CHANGED, conversation.push_event_data)
  end

  def contact_created(event)
    contact, account = extract_contact_and_account(event)
    tokens = user_tokens(account, account.agents)

    broadcast(account, tokens, CONTACT_CREATED, contact.push_event_data)
  end

  def contact_updated(event)
    contact, account = extract_contact_and_account(event)
    tokens = user_tokens(account, account.agents)

    broadcast(account, tokens, CONTACT_UPDATED, contact.push_event_data)
  end

  def contact_merged(event)
    contact, account = extract_contact_and_account(event)
    tokens = event.data[:tokens]

    broadcast(account, tokens, CONTACT_MERGED, contact.push_event_data)
  end

  def contact_deleted(event)
    contact, account = extract_contact_and_account(event)
    tokens = user_tokens(account, account.agents)

    broadcast(account, tokens, CONTACT_DELETED, contact.push_event_data)
  end

  def conversation_mentioned(event)
    conversation, account = extract_conversation_and_account(event)
    user = event.data[:user]

    broadcast(account, [user.pubsub_token], CONVERSATION_MENTIONED, conversation.push_event_data)
  end

  private

  def typing_event_listener_tokens(account, conversation, user)
    current_user_token = user.is_a?(Contact) ? conversation.contact_inbox.pubsub_token : user.pubsub_token
    (user_tokens(account, conversation.inbox.members) + [conversation.contact_inbox.pubsub_token]) - [current_user_token]
  end

  def user_tokens(account, agents)
    agent_tokens = agents.pluck(:pubsub_token)
    admin_tokens = account.administrators.pluck(:pubsub_token)
    (agent_tokens + admin_tokens).uniq
  end

  def contact_tokens(contact_inbox, message)
    return [] if message.private?
    return [] if message.activity?
    return [] if contact_inbox.nil?

    contact_inbox_tokens(contact_inbox)
  end

  def contact_inbox_tokens(contact_inbox)
    contact = contact_inbox.contact

    contact_inbox.hmac_verified? ? contact.contact_inboxes.where(hmac_verified: true).filter_map(&:pubsub_token) : [contact_inbox.pubsub_token]
  end

  def broadcast(account, tokens, event_name, data)
    return if tokens.blank?

    payload = data.merge(account_id: account.id)
    # So the frondend knows who performed the action.
    # Useful in cases like conversation assignment for generating a notification with assigner name.
    payload[:performer] = Current.user&.push_event_data if Current.user.present?

    ::ActionCableBroadcastJob.perform_later(tokens.uniq, event_name, payload)
  end
end

================
File: listeners/agent_bot_listener.rb
================
class AgentBotListener < BaseListener
  def conversation_resolved(event)
    conversation = extract_conversation_and_account(event)[0]
    inbox = conversation.inbox
    return unless connected_agent_bot_exist?(inbox)

    event_name = __method__.to_s
    payload = conversation.webhook_data.merge(event: event_name)
    process_webhook_bot_event(inbox.agent_bot, payload)
  end

  def conversation_opened(event)
    conversation = extract_conversation_and_account(event)[0]
    inbox = conversation.inbox
    return unless connected_agent_bot_exist?(inbox)

    event_name = __method__.to_s
    payload = conversation.webhook_data.merge(event: event_name)
    process_webhook_bot_event(inbox.agent_bot, payload)
  end

  def message_created(event)
    message = extract_message_and_account(event)[0]
    inbox = message.inbox
    return unless connected_agent_bot_exist?(inbox)
    return unless message.webhook_sendable?

    method_name = __method__.to_s
    process_message_event(method_name, inbox.agent_bot, message, event)
  end

  def message_updated(event)
    message = extract_message_and_account(event)[0]
    inbox = message.inbox
    return unless connected_agent_bot_exist?(inbox)
    return unless message.webhook_sendable?

    method_name = __method__.to_s
    process_message_event(method_name, inbox.agent_bot, message, event)
  end

  def webwidget_triggered(event)
    contact_inbox = event.data[:contact_inbox]
    inbox = contact_inbox.inbox
    return unless connected_agent_bot_exist?(inbox)

    event_name = __method__.to_s
    payload = contact_inbox.webhook_data.merge(event: event_name)
    payload[:event_info] = event.data[:event_info]
    process_webhook_bot_event(inbox.agent_bot, payload)
  end

  private

  def connected_agent_bot_exist?(inbox)
    return if inbox.agent_bot_inbox.blank?
    return unless inbox.agent_bot_inbox.active?

    true
  end

  def process_message_event(method_name, agent_bot, message, event)
    case agent_bot.bot_type
    when 'webhook'
      payload = message.webhook_data.merge(event: method_name)
      process_webhook_bot_event(agent_bot, payload)
    when 'csml'
      process_csml_bot_event(event.name, agent_bot, message)
    end
  end

  def process_webhook_bot_event(agent_bot, payload)
    return if agent_bot.outgoing_url.blank?

    AgentBots::WebhookJob.perform_later(agent_bot.outgoing_url, payload)
  end

  def process_csml_bot_event(event, agent_bot, message)
    AgentBots::CsmlJob.perform_later(event, agent_bot, message)
  end
end

================
File: listeners/automation_rule_listener.rb
================
class AutomationRuleListener < BaseListener
  def conversation_updated(event)
    return if performed_by_automation?(event)

    conversation = event.data[:conversation]
    account = conversation.account
    changed_attributes = event.data[:changed_attributes]

    return unless rule_present?('conversation_updated', account)

    rules = current_account_rules('conversation_updated', account)

    rules.each do |rule|
      conditions_match = ::AutomationRules::ConditionsFilterService.new(rule, conversation, { changed_attributes: changed_attributes }).perform
      AutomationRules::ActionService.new(rule, account, conversation).perform if conditions_match.present?
    end
  end

  def conversation_created(event)
    return if performed_by_automation?(event)

    conversation = event.data[:conversation]
    account = conversation.account
    changed_attributes = event.data[:changed_attributes]

    return unless rule_present?('conversation_created', account)

    rules = current_account_rules('conversation_created', account)

    rules.each do |rule|
      conditions_match = ::AutomationRules::ConditionsFilterService.new(rule, conversation, { changed_attributes: changed_attributes }).perform
      ::AutomationRules::ActionService.new(rule, account, conversation).perform if conditions_match.present?
    end
  end

  def conversation_opened(event)
    return if performed_by_automation?(event)

    conversation = event.data[:conversation]
    account = conversation.account
    changed_attributes = event.data[:changed_attributes]

    return unless rule_present?('conversation_opened', account)

    rules = current_account_rules('conversation_opened', account)

    rules.each do |rule|
      conditions_match = ::AutomationRules::ConditionsFilterService.new(rule, conversation, { changed_attributes: changed_attributes }).perform
      AutomationRules::ActionService.new(rule, account, conversation).perform if conditions_match.present?
    end
  end

  def message_created(event)
    message = event.data[:message]

    return if ignore_message_created_event?(event)

    account = message.try(:account)
    changed_attributes = event.data[:changed_attributes]

    return unless rule_present?('message_created', account)

    rules = current_account_rules('message_created', account)

    rules.each do |rule|
      conditions_match = ::AutomationRules::ConditionsFilterService.new(rule, message.conversation,
                                                                        { message: message, changed_attributes: changed_attributes }).perform
      ::AutomationRules::ActionService.new(rule, account, message.conversation).perform if conditions_match.present?
    end
  end

  def rule_present?(event_name, account)
    return if account.blank?

    current_account_rules(event_name, account).any?
  end

  def current_account_rules(event_name, account)
    AutomationRule.where(
      event_name: event_name,
      account_id: account.id,
      active: true
    )
  end

  def performed_by_automation?(event)
    event.data[:performed_by].present? && event.data[:performed_by].instance_of?(AutomationRule)
  end

  def ignore_message_created_event?(event)
    message = event.data[:message]
    performed_by_automation?(event) || message.activity?
  end
end

================
File: listeners/base_listener.rb
================
class BaseListener
  include Singleton

  def extract_conversation_and_account(event)
    conversation = event.data[:conversation]
    [conversation, conversation.account]
  end

  def extract_notification_and_account(event)
    notification = event.data[:notification]
    notification_finder = NotificationFinder.new(notification.user, notification.account)
    unread_count = notification_finder.unread_count
    count = notification_finder.count
    [notification, notification.account, unread_count, count]
  end

  def extract_message_and_account(event)
    message = event.data[:message]
    [message, message.account]
  end

  def extract_contact_and_account(event)
    contact = event.data[:contact]
    [contact, contact.account]
  end

  def extract_inbox_and_account(event)
    inbox = event.data[:inbox]
    [inbox, inbox.account]
  end

  def extract_changed_attributes(event)
    changed_attributes = event.data[:changed_attributes]

    return if changed_attributes.blank?

    changed_attributes.map { |k, v| { k => { previous_value: v[0], current_value: v[1] } } }
  end
end

================
File: listeners/campaign_listener.rb
================
class CampaignListener < BaseListener
  def campaign_triggered(event)
    contact_inbox = event.data[:contact_inbox]
    campaign_display_id = event.data[:event_info][:campaign_id]
    custom_attributes = event.data[:event_info][:custom_attributes]

    return if campaign_display_id.blank?

    ::Campaigns::CampaignConversationBuilder.new(
      contact_inbox_id: contact_inbox.id,
      campaign_display_id: campaign_display_id,
      conversation_additional_attributes: event.data[:event_info].except(:campaign_id, :custom_attributes),
      custom_attributes: custom_attributes
    ).perform
  end
end

================
File: listeners/csat_survey_listener.rb
================
class CsatSurveyListener < BaseListener
  def message_updated(event)
    message = extract_message_and_account(event)[0]
    return unless message.input_csat?

    CsatSurveys::ResponseBuilder.new(message: message).perform
  end
end

================
File: listeners/hook_listener.rb
================
class HookListener < BaseListener
  def message_created(event)
    message = extract_message_and_account(event)[0]

    execute_hooks(event, message)
  end

  def message_updated(event)
    message = extract_message_and_account(event)[0]

    execute_hooks(event, message)
  end

  private

  def execute_hooks(event, message)
    message.account.hooks.each do |hook|
      # In case of dialogflow, we would have a hook for each inbox.
      # Which means we will execute the same hook multiple times if the below filter isn't there
      next if hook.inbox.present? && hook.inbox != message.inbox

      HookJob.perform_later(hook, event.name, message: message)
    end
  end
end

================
File: listeners/installation_webhook_listener.rb
================
class InstallationWebhookListener < BaseListener
  def account_created(event)
    payload = account(event).webhook_data.merge(
      event: __method__.to_s,
      users: users(event)
    )
    deliver_webhook_payloads(payload)
  end

  private

  def account(event)
    event.data[:account]
  end

  def users(event)
    account(event).administrators.map(&:webhook_data)
  end

  def deliver_webhook_payloads(payload)
    # Deliver the installation event
    webhook_url = InstallationConfig.find_by(name: 'INSTALLATION_EVENTS_WEBHOOK_URL')&.value
    WebhookJob.perform_later(webhook_url, payload) if webhook_url
  end
end

================
File: listeners/notification_listener.rb
================
class NotificationListener < BaseListener
  def conversation_bot_handoff(event)
    conversation, account = extract_conversation_and_account(event)
    return if conversation.pending?

    conversation.inbox.members.each do |agent|
      NotificationBuilder.new(
        notification_type: 'conversation_creation',
        user: agent,
        account: account,
        primary_actor: conversation
      ).perform
    end
  end

  def conversation_created(event)
    conversation, account = extract_conversation_and_account(event)
    return if conversation.pending?

    conversation.inbox.members.each do |agent|
      NotificationBuilder.new(
        notification_type: 'conversation_creation',
        user: agent,
        account: account,
        primary_actor: conversation
      ).perform
    end
  end

  def assignee_changed(event)
    conversation, account = extract_conversation_and_account(event)
    assignee = conversation.assignee
    return if event.data[:notifiable_assignee_change].blank?
    return if conversation.pending?

    NotificationBuilder.new(
      notification_type: 'conversation_assignment',
      user: assignee,
      account: account,
      primary_actor: conversation
    ).perform
  end

  def message_created(event)
    message = extract_message_and_account(event)[0]

    Messages::MentionService.new(message: message).perform
    Messages::NewMessageNotificationService.new(message: message).perform
  end
end

================
File: listeners/participation_listener.rb
================
class ParticipationListener < BaseListener
  include Events::Types

  def assignee_changed(event)
    conversation, _account = extract_conversation_and_account(event)
    return if conversation.assignee_id.blank?

    conversation.conversation_participants.find_or_create_by!(user_id: conversation.assignee_id)
  # We have observed race conditions triggering these errors
  # example: Assignment happening via automation, while auto assignment is also configured.
  rescue ActiveRecord::RecordNotUnique, ActiveRecord::RecordInvalid
    Rails.logger.warn "Failed to create conversation participant for account #{conversation.account.id} " \
                      ": user #{conversation.assignee_id} : conversation #{conversation.id}"
  end
end

================
File: listeners/reporting_event_listener.rb
================
class ReportingEventListener < BaseListener
  include ReportingEventHelper

  def conversation_resolved(event)
    conversation = extract_conversation_and_account(event)[0]
    time_to_resolve = conversation.updated_at.to_i - conversation.created_at.to_i

    reporting_event = ReportingEvent.new(
      name: 'conversation_resolved',
      value: time_to_resolve,
      value_in_business_hours: business_hours(conversation.inbox, conversation.created_at,
                                              conversation.updated_at),
      account_id: conversation.account_id,
      inbox_id: conversation.inbox_id,
      user_id: conversation.assignee_id,
      conversation_id: conversation.id,
      event_start_time: conversation.created_at,
      event_end_time: conversation.updated_at
    )

    create_bot_resolved_event(conversation, reporting_event)
    reporting_event.save!
  end

  def first_reply_created(event)
    message = extract_message_and_account(event)[0]
    conversation = message.conversation
    first_response_time = message.created_at.to_i - last_non_human_activity(conversation).to_i

    reporting_event = ReportingEvent.new(
      name: 'first_response',
      value: first_response_time,
      value_in_business_hours: business_hours(conversation.inbox, last_non_human_activity(conversation),
                                              message.created_at),
      account_id: conversation.account_id,
      inbox_id: conversation.inbox_id,
      user_id: message.sender_id,
      conversation_id: conversation.id,
      event_start_time: last_non_human_activity(conversation),
      event_end_time: message.created_at
    )

    reporting_event.save!
  end

  def reply_created(event)
    message = extract_message_and_account(event)[0]
    conversation = message.conversation
    waiting_since = event.data[:waiting_since]
    reply_time = message.created_at.to_i - waiting_since.to_i

    reporting_event = ReportingEvent.new(
      name: 'reply_time',
      value: reply_time,
      value_in_business_hours: business_hours(conversation.inbox, waiting_since, message.created_at),
      account_id: conversation.account_id,
      inbox_id: conversation.inbox_id,
      user_id: conversation.assignee_id,
      conversation_id: conversation.id,
      event_start_time: waiting_since,
      event_end_time: message.created_at
    )
    reporting_event.save!
  end

  def conversation_bot_handoff(event)
    conversation = extract_conversation_and_account(event)[0]

    # check if a conversation_bot_handoff event exists for this conversation
    bot_handoff_event = ReportingEvent.find_by(conversation_id: conversation.id, name: 'conversation_bot_handoff')
    return if bot_handoff_event.present?

    time_to_handoff = conversation.updated_at.to_i - conversation.created_at.to_i

    reporting_event = ReportingEvent.new(
      name: 'conversation_bot_handoff',
      value: time_to_handoff,
      value_in_business_hours: business_hours(conversation.inbox, conversation.created_at, conversation.updated_at),
      account_id: conversation.account_id,
      inbox_id: conversation.inbox_id,
      user_id: conversation.assignee_id,
      conversation_id: conversation.id,
      event_start_time: conversation.created_at,
      event_end_time: conversation.updated_at
    )
    reporting_event.save!
  end

  private

  def create_bot_resolved_event(conversation, reporting_event)
    return unless conversation.inbox.active_bot?
    # We don't want to create a bot_resolved event if there is user interaction on the conversation
    return if conversation.messages.exists?(message_type: :outgoing, sender_type: 'User')

    bot_resolved_event = reporting_event.dup
    bot_resolved_event.name = 'conversation_bot_resolved'
    bot_resolved_event.save!
  end
end

================
File: listeners/webhook_listener.rb
================
class WebhookListener < BaseListener
  def conversation_status_changed(event)
    conversation = extract_conversation_and_account(event)[0]
    changed_attributes = extract_changed_attributes(event)
    inbox = conversation.inbox
    payload = conversation.webhook_data.merge(event: __method__.to_s, changed_attributes: changed_attributes)
    deliver_webhook_payloads(payload, inbox)
  end

  def conversation_updated(event)
    conversation = extract_conversation_and_account(event)[0]
    changed_attributes = extract_changed_attributes(event)
    inbox = conversation.inbox
    payload = conversation.webhook_data.merge(event: __method__.to_s, changed_attributes: changed_attributes)
    deliver_webhook_payloads(payload, inbox)
  end

  def conversation_created(event)
    conversation = extract_conversation_and_account(event)[0]
    inbox = conversation.inbox
    payload = conversation.webhook_data.merge(event: __method__.to_s)
    deliver_webhook_payloads(payload, inbox)
  end

  def message_created(event)
    message = extract_message_and_account(event)[0]
    inbox = message.inbox

    return unless message.webhook_sendable?

    payload = message.webhook_data.merge(event: __method__.to_s)
    deliver_webhook_payloads(payload, inbox)
  end

  def message_updated(event)
    message = extract_message_and_account(event)[0]
    inbox = message.inbox

    return unless message.webhook_sendable?

    payload = message.webhook_data.merge(event: __method__.to_s)
    deliver_webhook_payloads(payload, inbox)
  end

  def webwidget_triggered(event)
    contact_inbox = event.data[:contact_inbox]
    inbox = contact_inbox.inbox

    payload = contact_inbox.webhook_data.merge(event: __method__.to_s)
    payload[:event_info] = event.data[:event_info]
    deliver_webhook_payloads(payload, inbox)
  end

  def contact_created(event)
    contact, account = extract_contact_and_account(event)
    payload = contact.webhook_data.merge(event: __method__.to_s)
    deliver_account_webhooks(payload, account)
  end

  def contact_updated(event)
    contact, account = extract_contact_and_account(event)
    changed_attributes = extract_changed_attributes(event)
    return if changed_attributes.blank?

    payload = contact.webhook_data.merge(event: __method__.to_s, changed_attributes: changed_attributes)
    deliver_account_webhooks(payload, account)
  end

  def inbox_created(event)
    inbox, account = extract_inbox_and_account(event)
    inbox_webhook_data = Inbox::EventDataPresenter.new(inbox).push_data
    payload = inbox_webhook_data.merge(event: __method__.to_s)
    deliver_account_webhooks(payload, account)
  end

  def inbox_updated(event)
    inbox, account = extract_inbox_and_account(event)
    changed_attributes = extract_changed_attributes(event)
    return if changed_attributes.blank?

    inbox_webhook_data = Inbox::EventDataPresenter.new(inbox).push_data
    payload = inbox_webhook_data.merge(event: __method__.to_s, changed_attributes: changed_attributes)
    deliver_account_webhooks(payload, account)
  end

  private

  def deliver_account_webhooks(payload, account)
    account.webhooks.account_type.each do |webhook|
      next unless webhook.subscriptions.include?(payload[:event])

      WebhookJob.perform_later(webhook.url, payload)
    end
  end

  def deliver_api_inbox_webhooks(payload, inbox)
    return unless inbox.channel_type == 'Channel::Api'
    return if inbox.channel.webhook_url.blank?

    WebhookJob.perform_later(inbox.channel.webhook_url, payload, :api_inbox_webhook)
  end

  def deliver_webhook_payloads(payload, inbox)
    deliver_account_webhooks(payload, inbox.account)
    deliver_api_inbox_webhooks(payload, inbox)
  end
end

================
File: mailboxes/imap/imap_mailbox.rb
================
class Imap::ImapMailbox
  include MailboxHelper
  include IncomingEmailValidityHelper
  attr_accessor :channel, :account, :inbox, :conversation, :processed_mail

  def process(mail, channel)
    @inbound_mail = mail
    @channel = channel
    load_account
    load_inbox
    decorate_mail

    Rails.logger.info("Processing Email from: #{@processed_mail.original_sender} : inbox #{@inbox.id} : message_id #{@processed_mail.message_id}")

    # Skip processing email if it belongs to any of the edge cases
    return unless incoming_email_from_valid_email?

    ActiveRecord::Base.transaction do
      find_or_create_contact
      find_or_create_conversation
      create_message
      add_attachments_to_message
    end
  end

  private

  def load_account
    @account = @channel.account
  end

  def load_inbox
    @inbox = @channel.inbox
  end

  def decorate_mail
    @processed_mail = MailPresenter.new(@inbound_mail, @account)
  end

  def find_conversation_by_in_reply_to
    return if in_reply_to.blank?

    message = @inbox.messages.find_by(source_id: in_reply_to)
    if message.nil?
      @inbox.conversations.where("additional_attributes->>'in_reply_to' = ?", in_reply_to).first
    else
      @inbox.conversations.find(message.conversation_id)
    end
  end

  def find_conversation_by_reference_ids
    return if @inbound_mail.references.blank? && in_reply_to.present?

    message = find_message_by_references

    return if message.nil?

    @inbox.conversations.find(message.conversation_id)
  end

  def in_reply_to
    @processed_mail.in_reply_to
  end

  def find_message_by_references
    message_to_return = nil

    references = Array.wrap(@inbound_mail.references)

    references.each do |message_id|
      message = @inbox.messages.find_by(source_id: message_id)
      message_to_return = message if message.present?
    end
    message_to_return
  end

  def find_or_create_conversation
    @conversation = find_conversation_by_in_reply_to || find_conversation_by_reference_ids || ::Conversation.create!(
      {
        account_id: @account.id,
        inbox_id: @inbox.id,
        contact_id: @contact.id,
        contact_inbox_id: @contact_inbox.id,
        additional_attributes: {
          source: 'email',
          in_reply_to: in_reply_to,
          mail_subject: @processed_mail.subject,
          initiated_at: {
            timestamp: Time.now.utc
          }
        }
      }
    )
  end

  def find_or_create_contact
    @contact = @inbox.contacts.from_email(@processed_mail.original_sender)
    if @contact.present?
      @contact_inbox = ContactInbox.find_by(inbox: @inbox, contact: @contact)
    else
      create_contact
    end
  end

  def identify_contact_name
    processed_mail.sender_name || processed_mail.from.first.split('@').first
  end
end

================
File: mailboxes/application_mailbox.rb
================
class ApplicationMailbox < ActionMailbox::Base
  include MailboxHelper

  # Last part is the regex for the UUID
  # Eg: email should be something like : reply+6bdc3f4d-0bec-4515-a284-5d916fdde489@domain.com
  REPLY_EMAIL_UUID_PATTERN = /^reply\+([0-9a-f]{8}\b-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-\b[0-9a-f]{12})$/i
  CONVERSATION_MESSAGE_ID_PATTERN = %r{conversation/([a-zA-Z0-9-]*?)/messages/(\d+?)@(\w+\.\w+)}

  # routes as a reply to existing conversations
  routing(
    ->(inbound_mail) { valid_to_address?(inbound_mail) && (reply_uuid_mail?(inbound_mail) || in_reply_to_mail?(inbound_mail)) } => :reply
  )

  # routes as a new conversation in email channel
  routing(
    ->(inbound_mail) { valid_to_address?(inbound_mail) && EmailChannelFinder.new(inbound_mail.mail).perform.present? } => :support
  )

  # catchall
  routing(all: :default)

  class << self
    # checks if follow this pattern then send it to reply_mailbox
    # <account/#{@account.id}/conversation/#{@conversation.uuid}@#{@account.inbound_email_domain}>
    def in_reply_to_mail?(inbound_mail)
      in_reply_to = inbound_mail.mail.in_reply_to

      in_reply_to.present? && (
        in_reply_to_matches?(in_reply_to) || Message.exists?(source_id: in_reply_to)
      )
    end

    def in_reply_to_matches?(in_reply_to)
      Array.wrap(in_reply_to).any? { _1.match?(CONVERSATION_MESSAGE_ID_PATTERN) }
    end

    # checks if follow this pattern  send it to reply_mailbox
    # reply+<conversation-uuid>@<mailer-domain.com>
    def reply_uuid_mail?(inbound_mail)
      inbound_mail.mail.to&.any? do |email|
        conversation_uuid = email.split('@')[0]
        conversation_uuid.match?(REPLY_EMAIL_UUID_PATTERN)
      end
    end

    # if mail.to returns a string, then it is a malformed `to` header
    # valid `to` header will be of type Mail::AddressContainer
    # validate if the to address is of type string
    def valid_to_address?(inbound_mail)
      to_address_class = inbound_mail.mail.to&.class
      return true if to_address_class == Mail::AddressContainer

      Rails.logger.error "Email to address header is malformed `#{inbound_mail.mail.to}`"
      false
    end
  end
end

================
File: mailboxes/default_mailbox.rb
================
class DefaultMailbox < ApplicationMailbox
  def process; end
end

================
File: mailboxes/incoming_email_validity_helper.rb
================
module IncomingEmailValidityHelper
  private

  def incoming_email_from_valid_email?
    return false unless valid_external_email_for_active_account?

    # we skip processing auto reply emails like delivery status notifications
    # out of office replies, etc.
    return false if auto_reply_email?

    # return if email doesn't have a valid sender
    # This can happen in cases like bounce emails for invalid contact email address
    # TODO: Handle the bounce separately and mark the contact as invalid in case of reply bounces
    # The returned value could be "\"\"" for some email clients
    return false unless Devise.email_regexp.match?(@processed_mail.original_sender)

    true
  end

  def valid_external_email_for_active_account?
    return false unless @account.active?
    return false if @processed_mail.notification_email_from_chatwoot?

    true
  end

  def auto_reply_email?
    if @processed_mail.auto_reply?
      Rails.logger.info "is_auto_reply? : #{processed_mail.auto_reply?}"
      true
    else
      false
    end
  end
end

================
File: mailboxes/mailbox_helper.rb
================
module MailboxHelper
  private

  def create_message
    Rails.logger.info "[MailboxHelper] Creating message #{processed_mail.message_id}"
    return if @conversation.messages.find_by(source_id: processed_mail.message_id).present?

    @message = @conversation.messages.create!(
      account_id: @conversation.account_id,
      sender: @conversation.contact,
      content: mail_content&.truncate(150_000),
      inbox_id: @conversation.inbox_id,
      message_type: 'incoming',
      content_type: 'incoming_email',
      source_id: processed_mail.message_id,
      content_attributes: {
        email: processed_mail.serialized_data,
        cc_email: processed_mail.cc,
        bcc_email: processed_mail.bcc
      }
    )
  end

  def add_attachments_to_message
    return if @message.blank?

    # ensure we don't add more than the permitted number of attachments
    all_attachments = processed_mail.attachments.last(Message::NUMBER_OF_PERMITTED_ATTACHMENTS)
    grouped_attachments = group_attachments(all_attachments)

    process_inline_attachments(grouped_attachments[:inline]) if grouped_attachments[:inline].present?
    process_regular_attachments(grouped_attachments[:regular]) if grouped_attachments[:regular].present?

    @message.save!
  end

  def group_attachments(attachments)
    # If the email lacks a text body or if inline attachments aren't images,
    # treat them as standard attachments for processing.
    inline_attachments = attachments.select do |attachment|
      mail_content.present? && attachment[:original].inline? && attachment[:original].content_type.to_s.start_with?('image/')
    end

    regular_attachments = attachments - inline_attachments
    { inline: inline_attachments, regular: regular_attachments }
  end

  def process_regular_attachments(attachments)
    Rails.logger.info "[MailboxHelper] Processing regular attachments for message with ID: #{processed_mail.message_id}"
    attachments.each do |mail_attachment|
      attachment = @message.attachments.new(
        account_id: @conversation.account_id,
        file_type: 'file'
      )
      attachment.file.attach(mail_attachment[:blob])
    end
  end

  def process_inline_attachments(attachments)
    Rails.logger.info "[MailboxHelper] Processing inline attachments for message with ID: #{processed_mail.message_id}"

    # create an instance variable here, the `embed_inline_image_source`
    # updates them directly. And then the value is eventaully used to update the message content
    @html_content = processed_mail.serialized_data[:html_content][:full]
    @text_content = processed_mail.serialized_data[:text_content][:reply]

    attachments.each do |mail_attachment|
      embed_inline_image_source(mail_attachment)
    end

    # update the message content with the updated html and text content
    @message.content_attributes[:email][:html_content][:full] = @html_content
    @message.content_attributes[:email][:text_content][:full] = @text_content
  end

  def embed_inline_image_source(mail_attachment)
    if @html_content.present?
      upload_inline_image(mail_attachment)
    elsif @text_content.present?
      embed_plain_text_email_with_inline_image(mail_attachment)
    end
  end

  def upload_inline_image(mail_attachment)
    content_id = mail_attachment[:original].cid

    @html_content = @html_content.gsub("cid:#{content_id}", inline_image_url(mail_attachment[:blob]).to_s)
  end

  def embed_plain_text_email_with_inline_image(mail_attachment)
    attachment_name = mail_attachment[:original].filename
    img_tag = "<img src=\"#{inline_image_url(mail_attachment[:blob])}\" alt=\"#{attachment_name}\">"

    tag_to_replace = "[image: #{attachment_name}]"

    if @text_content.include?(tag_to_replace)
      @text_content = @text_content.gsub(tag_to_replace, img_tag)
    else
      @text_content += "\n\n#{img_tag}"
    end
  end

  def inline_image_url(blob)
    Rails.application.routes.url_helpers.url_for(blob)
  end

  def create_contact
    @contact_inbox = ::ContactInboxWithContactBuilder.new(
      source_id: processed_mail.original_sender,
      inbox: @inbox,
      contact_attributes: {
        name: identify_contact_name,
        email: processed_mail.original_sender,
        additional_attributes: { source_id: "email:#{processed_mail.message_id}" }
      }
    ).perform

    @contact = @contact_inbox.contact
    Rails.logger.info "[MailboxHelper] Contact created with ID: #{@contact.id} for inbox with ID: #{@inbox.id}"
  end

  def mail_content
    if processed_mail.text_content.present?
      processed_mail.text_content[:reply]
    elsif processed_mail.html_content.present?
      processed_mail.html_content[:reply]
    end
  end
end

================
File: mailboxes/reply_mailbox.rb
================
class ReplyMailbox < ApplicationMailbox
  attr_accessor :conversation_uuid, :processed_mail

  # Last part is the regex for the UUID
  # Eg: email should be something like : reply+6bdc3f4d-0bec-4515-a284-5d916fdde489@domain.com
  EMAIL_PART_PATTERN = /^reply\+([0-9a-f]{8}\b-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-\b[0-9a-f]{12})$/i

  before_processing :conversation_uuid_from_to_address,
                    :find_relative_conversation

  def process
    return if @conversation.blank?

    decorate_mail
    create_message
    add_attachments_to_message
  end

  private

  def find_relative_conversation
    if @conversation_uuid
      find_conversation_with_uuid
    elsif mail.in_reply_to.present?
      find_conversation_with_in_reply_to
    end
  end

  def conversation_uuid_from_to_address
    @mail = MailPresenter.new(mail)

    return if @mail.mail_receiver.blank?

    @mail.mail_receiver.each do |email|
      username = email.split('@')[0]
      match_result = username.match(ApplicationMailbox::REPLY_EMAIL_UUID_PATTERN)
      if match_result
        @conversation_uuid = match_result.captures
        break
      end
    end
    @conversation_uuid
  end

  # find conversation uuid from below pattern
  # reply+<conversation-uuid>@<mailer-domain.com>
  def find_conversation_with_uuid
    @conversation = Conversation.find_by(uuid: conversation_uuid)
    validate_resource @conversation
  end

  def find_conversation_by_uuid(match_result)
    @conversation_uuid = match_result.captures[0]

    find_conversation_with_uuid
  end

  def find_conversation_by_message_id(in_reply_to)
    @message = Message.find_by(source_id: in_reply_to)
    @conversation = @message.conversation if @message.present?
    @conversation_uuid = @conversation.uuid if @conversation.present?
  end

  # find conversation uuid from below pattern
  # <conversation/#{@conversation.uuid}/messages/#{@messages&.last&.id}@#{@account.inbound_email_domain}>
  def find_conversation_with_in_reply_to
    match_result = nil
    in_reply_to_addresses = mail.in_reply_to
    in_reply_to_addresses = [in_reply_to_addresses] if in_reply_to_addresses.is_a?(String)
    in_reply_to_addresses.each do |in_reply_to|
      match_result = in_reply_to.match(::ApplicationMailbox::CONVERSATION_MESSAGE_ID_PATTERN)
      break if match_result
    end
    find_by_in_reply_to_addresses(match_result, in_reply_to_addresses)
  end

  def find_by_in_reply_to_addresses(match_result, in_reply_to_addresses)
    find_conversation_by_uuid(match_result) if match_result
    find_conversation_by_message_id(in_reply_to_addresses) if @conversation.blank?
  end

  def validate_resource(resource)
    Rails.logger.error "[App::Mailboxes::ReplyMailbox] Email conversation with uuid: #{conversation_uuid} not found" if resource.nil?

    resource
  end

  def decorate_mail
    @processed_mail = MailPresenter.new(mail, @conversation.account)
  end
end

================
File: mailboxes/support_mailbox.rb
================
class SupportMailbox < ApplicationMailbox
  include IncomingEmailValidityHelper
  attr_accessor :channel, :account, :inbox, :conversation, :processed_mail

  before_processing :find_channel,
                    :load_account,
                    :load_inbox,
                    :decorate_mail

  def process
    Rails.logger.info "Processing email #{mail.message_id} from #{original_sender_email} to #{mail.to} with subject #{mail.subject}"

    # Skip processing email if it belongs to any of the edge cases
    return unless incoming_email_from_valid_email?

    ActiveRecord::Base.transaction do
      find_or_create_contact
      find_or_create_conversation
      create_message
      add_attachments_to_message
    end
  end

  private

  def find_channel
    find_channel_with_to_mail if @channel.blank?

    raise 'Email channel/inbox not found' if @channel.nil?

    @channel
  end

  def find_channel_with_to_mail
    @channel = EmailChannelFinder.new(mail).perform
  end

  def load_account
    @account = @channel.account
  end

  def load_inbox
    @inbox = @channel.inbox
  end

  def decorate_mail
    @processed_mail = MailPresenter.new(mail, @account)
  end

  def find_conversation_by_in_reply_to
    return if in_reply_to.blank?

    @account.conversations.where("additional_attributes->>'in_reply_to' = ?", in_reply_to).first
  end

  def in_reply_to
    mail['In-Reply-To'].try(:value)
  end

  def original_sender_email
    @processed_mail.original_sender&.downcase
  end

  def find_or_create_conversation
    @conversation = find_conversation_by_in_reply_to || ::Conversation.create!({
                                                                                 account_id: @account.id,
                                                                                 inbox_id: @inbox.id,
                                                                                 contact_id: @contact.id,
                                                                                 contact_inbox_id: @contact_inbox.id,
                                                                                 additional_attributes: {
                                                                                   in_reply_to: in_reply_to,
                                                                                   source: 'email',
                                                                                   mail_subject: @processed_mail.subject,
                                                                                   initiated_at: {
                                                                                     timestamp: Time.now.utc
                                                                                   }
                                                                                 }
                                                                               })
  end

  def find_or_create_contact
    @contact = @inbox.contacts.from_email(original_sender_email)
    if @contact.present?
      @contact_inbox = ContactInbox.find_by(inbox: @inbox, contact: @contact)
    else
      create_contact
    end
  end

  def identify_contact_name
    processed_mail.sender_name || processed_mail.from.first.split('@').first
  end
end

================
File: mailers/administrator_notifications/channel_notifications_mailer.rb
================
class AdministratorNotifications::ChannelNotificationsMailer < ApplicationMailer
  def slack_disconnect
    return unless smtp_config_set_or_development?

    subject = 'Your Slack integration has expired'
    @action_url = "#{ENV.fetch('FRONTEND_URL', nil)}/app/accounts/#{Current.account.id}/settings/integrations/slack"
    send_mail_with_liquid(to: admin_emails, subject: subject) and return
  end

  def dialogflow_disconnect
    return unless smtp_config_set_or_development?

    subject = 'Your Dialogflow integration was disconnected'
    send_mail_with_liquid(to: admin_emails, subject: subject) and return
  end

  def facebook_disconnect(inbox)
    return unless smtp_config_set_or_development?

    subject = 'Your Facebook page connection has expired'
    @action_url = "#{ENV.fetch('FRONTEND_URL', nil)}/app/accounts/#{Current.account.id}/settings/inboxes/#{inbox.id}"
    send_mail_with_liquid(to: admin_emails, subject: subject) and return
  end

  def whatsapp_disconnect(inbox)
    return unless smtp_config_set_or_development?

    subject = 'Your Whatsapp connection has expired'
    @action_url = "#{ENV.fetch('FRONTEND_URL', nil)}/app/accounts/#{Current.account.id}/settings/inboxes/#{inbox.id}"
    send_mail_with_liquid(to: admin_emails, subject: subject) and return
  end

  def email_disconnect(inbox)
    return unless smtp_config_set_or_development?

    subject = 'Your email inbox has been disconnected. Please update the credentials for SMTP/IMAP'
    @action_url = "#{ENV.fetch('FRONTEND_URL', nil)}/app/accounts/#{Current.account.id}/settings/inboxes/#{inbox.id}"
    send_mail_with_liquid(to: admin_emails, subject: subject) and return
  end

  def contact_import_complete(resource)
    return unless smtp_config_set_or_development?

    subject = 'Contact Import Completed'

    @action_url = Rails.application.routes.url_helpers.rails_blob_url(resource.failed_records) if resource.failed_records.attached?
    @action_url ||= "#{ENV.fetch('FRONTEND_URL', nil)}/app/accounts/#{resource.account.id}/contacts"
    @meta = {}
    @meta['failed_contacts'] = resource.total_records - resource.processed_records
    @meta['imported_contacts'] = resource.processed_records
    send_mail_with_liquid(to: admin_emails, subject: subject) and return
  end

  def contact_import_failed
    return unless smtp_config_set_or_development?

    subject = 'Contact Import Failed'

    @meta = {}
    send_mail_with_liquid(to: admin_emails, subject: subject) and return
  end

  def contact_export_complete(file_url, email_to)
    return unless smtp_config_set_or_development?

    @action_url = file_url
    subject = "Your contact's export file is available to download."

    send_mail_with_liquid(to: email_to, subject: subject) and return
  end

  def automation_rule_disabled(rule)
    return unless smtp_config_set_or_development?

    @action_url ||= "#{ENV.fetch('FRONTEND_URL', nil)}/app/accounts/#{Current.account.id}/settings/automation/list"

    subject = 'Automation rule disabled due to validation errors.'.freeze
    @meta = {}
    @meta['rule_name'] = rule.name

    send_mail_with_liquid(to: admin_emails, subject: subject) and return
  end

  private

  def admin_emails
    Current.account.administrators.pluck(:email)
  end

  def liquid_locals
    super.merge({ meta: @meta })
  end
end

================
File: mailers/agent_notifications/conversation_notifications_mailer.rb
================
class AgentNotifications::ConversationNotificationsMailer < ApplicationMailer
  def conversation_creation(conversation, agent, _user)
    return unless smtp_config_set_or_development?

    @agent = agent
    @conversation = conversation
    subject = "#{@agent.available_name}, A new conversation [ID - #{@conversation.display_id}] has been created in #{@conversation.inbox&.name}."
    @action_url = app_account_conversation_url(account_id: @conversation.account_id, id: @conversation.display_id)
    send_mail_with_liquid(to: @agent.email, subject: subject) and return
  end

  def conversation_assignment(conversation, agent, _user)
    return unless smtp_config_set_or_development?

    @agent = agent
    @conversation = conversation
    subject = "#{@agent.available_name}, A new conversation [ID - #{@conversation.display_id}] has been assigned to you."
    @action_url = app_account_conversation_url(account_id: @conversation.account_id, id: @conversation.display_id)
    send_mail_with_liquid(to: @agent.email, subject: subject) and return
  end

  def conversation_mention(conversation, agent, message)
    return unless smtp_config_set_or_development?

    @agent = agent
    @conversation = conversation
    @message = message
    subject = "#{@agent.available_name}, You have been mentioned in conversation [ID - #{@conversation.display_id}]"
    @action_url = app_account_conversation_url(account_id: @conversation.account_id, id: @conversation.display_id)
    send_mail_with_liquid(to: @agent.email, subject: subject) and return
  end

  def assigned_conversation_new_message(conversation, agent, message)
    return unless smtp_config_set_or_development?
    # Don't spam with email notifications if agent is online
    return if ::OnlineStatusTracker.get_presence(message.account_id, 'User', agent.id)

    @agent = agent
    @conversation = conversation
    subject = "#{@agent.available_name}, New message in your assigned conversation [ID - #{@conversation.display_id}]."
    @action_url = app_account_conversation_url(account_id: @conversation.account_id, id: @conversation.display_id)
    send_mail_with_liquid(to: @agent.email, subject: subject) and return
  end

  def participating_conversation_new_message(conversation, agent, message)
    return unless smtp_config_set_or_development?
    # Don't spam with email notifications if agent is online
    return if ::OnlineStatusTracker.get_presence(message.account_id, 'User', agent.id)

    @agent = agent
    @conversation = conversation
    subject = "#{@agent.available_name}, New message in your participating conversation [ID - #{@conversation.display_id}]."
    @action_url = app_account_conversation_url(account_id: @conversation.account_id, id: @conversation.display_id)
    send_mail_with_liquid(to: @agent.email, subject: subject) and return
  end

  private

  def liquid_droppables
    super.merge({
                  user: @agent,
                  conversation: @conversation,
                  inbox: @conversation.inbox,
                  message: @message
                })
  end
end

AgentNotifications::ConversationNotificationsMailer.prepend_mod_with('AgentNotifications::ConversationNotificationsMailer')

================
File: mailers/team_notifications/automation_notification_mailer.rb
================
class TeamNotifications::AutomationNotificationMailer < ApplicationMailer
  def conversation_creation(conversation, team, message)
    return unless smtp_config_set_or_development?

    @agents = team.team_members
    @conversation = conversation
    @custom_message = message
    @action_url = app_account_conversation_url(account_id: @conversation.account_id, id: @conversation.display_id)

    send_an_email_to_team
  end

  private

  def send_an_email_to_team
    subject = 'This email has been sent via automation rule actions.'
    @action_url = app_account_conversation_url(account_id: @conversation.account_id, id: @conversation.display_id)
    @agent_emails = @agents.collect(&:user).pluck(:email)
    send_mail_with_liquid(to: @agent_emails, subject: subject) and return
  end

  def liquid_droppables
    super.merge!({
                   conversation: @conversation,
                   inbox: @conversation.inbox
                 })
  end

  def liquid_locals
    super.merge!({
                   custom_message: @custom_message
                 })
  end
end

================
File: mailers/application_mailer.rb
================
class ApplicationMailer < ActionMailer::Base
  include ActionView::Helpers::SanitizeHelper

  default from: ENV.fetch('MAILER_SENDER_EMAIL', 'Chatwoot <accounts@chatwoot.com>')
  before_action { ensure_current_account(params.try(:[], :account)) }
  around_action :switch_locale
  layout 'mailer/base'
  # Fetch template from Database if available
  # Order: Account Specific > Installation Specific > Fallback to file
  prepend_view_path ::EmailTemplate.resolver
  append_view_path Rails.root.join('app/views/mailers')
  helper :frontend_urls
  helper do
    def global_config
      @global_config ||= GlobalConfig.get('BRAND_NAME', 'BRAND_URL')
    end
  end

  rescue_from(*ExceptionList::SMTP_EXCEPTIONS, with: :handle_smtp_exceptions)

  def smtp_config_set_or_development?
    ENV.fetch('SMTP_ADDRESS', nil).present? || Rails.env.development?
  end

  private

  def handle_smtp_exceptions(message)
    Rails.logger.warn 'Failed to send Email'
    Rails.logger.error "Exception: #{message}"
  end

  def send_mail_with_liquid(*args)
    Rails.logger.info "Email sent to #{args[0][:to]} with subject #{args[0][:subject]}"
    mail(*args) do |format|
      # explored sending a multipart email containing both text type and html
      # parsing the html with nokogiri will remove the links as well
      # might also remove tags like b,li etc. so lets rethink about this later
      # format.text { Nokogiri::HTML(render(layout: false)).text }
      format.html { render }
    end
  end

  def liquid_droppables
    # Merge additional objects into this in your mailer
    # liquid template handler converts these objects into drop objects
    {
      account: Current.account,
      user: @agent,
      conversation: @conversation,
      inbox: @conversation&.inbox
    }
  end

  def liquid_locals
    # expose variables you want to be exposed in liquid
    locals = {
      global_config: GlobalConfig.get('BRAND_NAME', 'BRAND_URL'),
      action_url: @action_url
    }

    locals.merge({ attachment_url: @attachment_url }) if @attachment_url
    locals.merge({ failed_contacts: @failed_contacts, imported_contacts: @imported_contacts })
    locals
  end

  def locale_from_account(account)
    return unless account

    I18n.available_locales.map(&:to_s).include?(account.locale) ? account.locale : nil
  end

  def ensure_current_account(account)
    Current.reset
    Current.account = account if account.present?
  end

  def switch_locale(&)
    locale ||= locale_from_account(Current.account)
    locale ||= I18n.default_locale
    # ensure locale won't bleed into other requests
    # https://guides.rubyonrails.org/i18n.html#managing-the-locale-across-requests
    I18n.with_locale(locale, &)
  end
end

================
File: mailers/conversation_reply_mailer_helper.rb
================
module ConversationReplyMailerHelper
  def prepare_mail(cc_bcc_enabled)
    @options = {
      to: to_emails,
      from: email_from,
      reply_to: email_reply_to,
      subject: mail_subject,
      message_id: custom_message_id,
      in_reply_to: in_reply_to_email
    }

    if cc_bcc_enabled
      @options[:cc] = cc_bcc_emails[0]
      @options[:bcc] = cc_bcc_emails[1]
    end
    ms_smtp_settings
    google_smtp_settings
    set_delivery_method

    Rails.logger.info("Email sent from #{email_from} to #{to_emails} with subject #{mail_subject}")

    mail(@options)
  end

  private

  def google_smtp_settings
    return unless @inbox.email? && @channel.imap_enabled && @inbox.channel.google?

    smtp_settings = base_smtp_settings('smtp.gmail.com')

    @options[:delivery_method] = :smtp
    @options[:delivery_method_options] = smtp_settings
  end

  def ms_smtp_settings
    return unless @inbox.email? && @channel.imap_enabled && @inbox.channel.microsoft?

    smtp_settings = base_smtp_settings('smtp.office365.com')

    @options[:delivery_method] = :smtp
    @options[:delivery_method_options] = smtp_settings
  end

  def base_smtp_settings(domain)
    {
      address: domain,
      port: 587,
      user_name: @channel.imap_login,
      password: @channel.provider_config['access_token'],
      domain: domain,
      tls: false,
      enable_starttls_auto: true,
      openssl_verify_mode: 'none',
      authentication: 'xoauth2'
    }
  end

  def set_delivery_method
    return unless @inbox.inbox_type == 'Email' && @channel.smtp_enabled

    smtp_settings = {
      address: @channel.smtp_address,
      port: @channel.smtp_port,
      user_name: @channel.smtp_login,
      password: @channel.smtp_password,
      domain: @channel.smtp_domain,
      tls: @channel.smtp_enable_ssl_tls,
      enable_starttls_auto: @channel.smtp_enable_starttls_auto,
      openssl_verify_mode: @channel.smtp_openssl_verify_mode,
      authentication: @channel.smtp_authentication
    }

    @options[:delivery_method] = :smtp
    @options[:delivery_method_options] = smtp_settings
  end

  def email_smtp_enabled
    @inbox.inbox_type == 'Email' && @channel.smtp_enabled
  end

  def email_imap_enabled
    @inbox.inbox_type == 'Email' && @channel.imap_enabled
  end

  def email_oauth_enabled
    @inbox.inbox_type == 'Email' && (@channel.microsoft? || @channel.google?)
  end

  def email_from
    email_oauth_enabled || email_smtp_enabled ? channel_email_with_name : from_email_with_name
  end

  def email_reply_to
    email_imap_enabled ? @channel.email : reply_email
  end

  # Use channel email domain in case of account email domain is not set for custom message_id and in_reply_to
  def channel_email_domain
    return @account.inbound_email_domain if @account.inbound_email_domain.present?

    email = @inbox.channel.try(:email)
    email.present? ? email.split('@').last : raise(StandardError, 'Channel email domain not present.')
  end
end

================
File: mailers/conversation_reply_mailer.rb
================
class ConversationReplyMailer < ApplicationMailer
  include ConversationReplyMailerHelper
  default from: ENV.fetch('MAILER_SENDER_EMAIL', 'Chatwoot <accounts@chatwoot.com>')
  layout :choose_layout

  def reply_with_summary(conversation, last_queued_id)
    return unless smtp_config_set_or_development?

    init_conversation_attributes(conversation)
    return if conversation_already_viewed?

    recap_messages = @conversation.messages.chat.where('id < ?', last_queued_id).last(10)
    new_messages = @conversation.messages.chat.where('id >= ?', last_queued_id)
    @messages = recap_messages + new_messages
    @messages = @messages.select(&:email_reply_summarizable?)
    prepare_mail(true)
  end

  def reply_without_summary(conversation, last_queued_id)
    return unless smtp_config_set_or_development?

    init_conversation_attributes(conversation)
    return if conversation_already_viewed?

    @messages = @conversation.messages.chat.where(message_type: [:outgoing, :template]).where('id >= ?', last_queued_id)
    @messages = @messages.reject { |m| m.template? && !m.input_csat? }
    return false if @messages.count.zero?

    prepare_mail(false)
  end

  def email_reply(message)
    return unless smtp_config_set_or_development?

    init_conversation_attributes(message.conversation)
    @message = message
    reply_mail_object = prepare_mail(true)
    message.update(source_id: reply_mail_object.message_id)
  end

  def conversation_transcript(conversation, to_email)
    return unless smtp_config_set_or_development?

    init_conversation_attributes(conversation)

    @messages = @conversation.messages.chat.select(&:conversation_transcriptable?)

    Rails.logger.info("Email sent from #{from_email_with_name} \
      to #{to_email} with subject #{@conversation.display_id} \
      #{I18n.t('conversations.reply.transcript_subject')} ")
    mail({
           to: to_email,
           from: from_email_with_name,
           subject: "[##{@conversation.display_id}] #{I18n.t('conversations.reply.transcript_subject')}"
         })
  end

  private

  def init_conversation_attributes(conversation)
    @conversation = conversation
    @account = @conversation.account
    @contact = @conversation.contact
    @agent = @conversation.assignee
    @inbox = @conversation.inbox
    @channel = @inbox.channel
  end

  def should_use_conversation_email_address?
    @inbox.inbox_type == 'Email' || inbound_email_enabled?
  end

  def conversation_already_viewed?
    # whether contact already saw the message on widget
    return unless @conversation.contact_last_seen_at
    return unless last_outgoing_message&.created_at

    @conversation.contact_last_seen_at > last_outgoing_message&.created_at
  end

  def last_outgoing_message
    @conversation.messages.chat.where.not(message_type: :incoming)&.last
  end

  def sender_name(sender_email)
    if @inbox.friendly?
      I18n.t('conversations.reply.email.header.friendly_name', sender_name: custom_sender_name, business_name: business_name,
                                                               from_email: sender_email)
    else
      I18n.t('conversations.reply.email.header.professional_name', business_name: business_name, from_email: sender_email)
    end
  end

  def current_message
    @message || @conversation.messages.outgoing.last
  end

  def custom_sender_name
    current_message&.sender&.available_name || @agent&.available_name || 'Notifications'
  end

  def business_name
    @inbox.business_name || @inbox.name
  end

  def from_email
    should_use_conversation_email_address? ? parse_email(@account.support_email) : parse_email(inbox_from_email_address)
  end

  def mail_subject
    subject = @conversation.additional_attributes['mail_subject']
    return "[##{@conversation.display_id}] #{I18n.t('conversations.reply.email_subject')}" if subject.nil?

    chat_count = @conversation.messages.chat.count
    if chat_count > 1
      "Re: #{subject}"
    else
      subject
    end
  end

  def reply_email
    if should_use_conversation_email_address?
      sender_name("reply+#{@conversation.uuid}@#{@account.inbound_email_domain}")
    else
      @inbox.email_address || @agent&.email
    end
  end

  def from_email_with_name
    sender_name(from_email)
  end

  def channel_email_with_name
    sender_name(@channel.email)
  end

  def parse_email(email_string)
    Mail::Address.new(email_string).address
  end

  def inbox_from_email_address
    return @inbox.email_address if @inbox.email_address

    @account.support_email
  end

  def custom_message_id
    last_message = @message || @messages&.last

    "<conversation/#{@conversation.uuid}/messages/#{last_message&.id}@#{channel_email_domain}>"
  end

  def in_reply_to_email
    conversation_reply_email_id || "<account/#{@account.id}/conversation/#{@conversation.uuid}@#{channel_email_domain}>"
  end

  def conversation_reply_email_id
    content_attributes = @conversation.messages.incoming.last&.content_attributes

    if content_attributes && content_attributes['email'] && content_attributes['email']['message_id']
      return "<#{content_attributes['email']['message_id']}>"
    end

    nil
  end

  def cc_bcc_emails
    content_attributes = @conversation.messages.outgoing.last&.content_attributes

    return [] unless content_attributes
    return [] unless content_attributes[:cc_emails] || content_attributes[:bcc_emails]

    [content_attributes[:cc_emails], content_attributes[:bcc_emails]]
  end

  def to_emails_from_content_attributes
    content_attributes = @conversation.messages.outgoing.last&.content_attributes

    return [] unless content_attributes
    return [] unless content_attributes[:to_emails]

    content_attributes[:to_emails]
  end

  def to_emails
    # if there is no to_emails from content_attributes, send it to @contact&.email
    to_emails_from_content_attributes.presence || [@contact&.email]
  end

  def inbound_email_enabled?
    @inbound_email_enabled ||= @account.feature_enabled?('inbound_emails') && @account.inbound_email_domain
                                                                                      .present? && @account.support_email.present?
  end

  def choose_layout
    return false if action_name == 'reply_without_summary' || action_name == 'email_reply'

    'mailer/base'
  end
end

================
File: models/channel/api.rb
================
# == Schema Information
#
# Table name: channel_api
#
#  id                    :bigint           not null, primary key
#  additional_attributes :jsonb
#  hmac_mandatory        :boolean          default(FALSE)
#  hmac_token            :string
#  identifier            :string
#  webhook_url           :string
#  created_at            :datetime         not null
#  updated_at            :datetime         not null
#  account_id            :integer          not null
#
# Indexes
#
#  index_channel_api_on_hmac_token  (hmac_token) UNIQUE
#  index_channel_api_on_identifier  (identifier) UNIQUE
#

class Channel::Api < ApplicationRecord
  include Channelable

  self.table_name = 'channel_api'
  EDITABLE_ATTRS = [:webhook_url, :hmac_mandatory, { additional_attributes: {} }].freeze

  has_secure_token :identifier
  has_secure_token :hmac_token
  validate :ensure_valid_agent_reply_time_window
  validates :webhook_url, length: { maximum: Limits::URL_LENGTH_LIMIT }

  def name
    'API'
  end

  def messaging_window_enabled?
    additional_attributes.present? && additional_attributes['agent_reply_time_window'].present?
  end

  private

  def ensure_valid_agent_reply_time_window
    return if additional_attributes['agent_reply_time_window'].blank?
    return if additional_attributes['agent_reply_time_window'].to_i.positive?

    errors.add(:agent_reply_time_window, 'agent_reply_time_window must be greater than 0')
  end
end

================
File: models/channel/email.rb
================
# == Schema Information
#
# Table name: channel_email
#
#  id                        :bigint           not null, primary key
#  email                     :string           not null
#  forward_to_email          :string           not null
#  imap_address              :string           default("")
#  imap_enable_ssl           :boolean          default(TRUE)
#  imap_enabled              :boolean          default(FALSE)
#  imap_login                :string           default("")
#  imap_password             :string           default("")
#  imap_port                 :integer          default(0)
#  provider                  :string
#  provider_config           :jsonb
#  smtp_address              :string           default("")
#  smtp_authentication       :string           default("login")
#  smtp_domain               :string           default("")
#  smtp_enable_ssl_tls       :boolean          default(FALSE)
#  smtp_enable_starttls_auto :boolean          default(TRUE)
#  smtp_enabled              :boolean          default(FALSE)
#  smtp_login                :string           default("")
#  smtp_openssl_verify_mode  :string           default("none")
#  smtp_password             :string           default("")
#  smtp_port                 :integer          default(0)
#  created_at                :datetime         not null
#  updated_at                :datetime         not null
#  account_id                :integer          not null
#
# Indexes
#
#  index_channel_email_on_email             (email) UNIQUE
#  index_channel_email_on_forward_to_email  (forward_to_email) UNIQUE
#

class Channel::Email < ApplicationRecord
  include Channelable
  include Reauthorizable

  AUTHORIZATION_ERROR_THRESHOLD = 10

  self.table_name = 'channel_email'
  EDITABLE_ATTRS = [:email, :imap_enabled, :imap_login, :imap_password, :imap_address, :imap_port, :imap_enable_ssl,
                    :smtp_enabled, :smtp_login, :smtp_password, :smtp_address, :smtp_port, :smtp_domain, :smtp_enable_starttls_auto,
                    :smtp_enable_ssl_tls, :smtp_openssl_verify_mode, :smtp_authentication, :provider].freeze

  validates :email, uniqueness: true
  validates :forward_to_email, uniqueness: true

  before_validation :ensure_forward_to_email, on: :create

  def name
    'Email'
  end

  def microsoft?
    provider == 'microsoft'
  end

  def google?
    provider == 'google'
  end

  def legacy_google?
    imap_enabled && imap_address == 'imap.gmail.com'
  end

  private

  def ensure_forward_to_email
    self.forward_to_email ||= "#{SecureRandom.hex}@#{account.inbound_email_domain}"
  end
end

================
File: models/channel/facebook_page.rb
================
# == Schema Information
#
# Table name: channel_facebook_pages
#
#  id                :integer          not null, primary key
#  page_access_token :string           not null
#  user_access_token :string           not null
#  created_at        :datetime         not null
#  updated_at        :datetime         not null
#  account_id        :integer          not null
#  instagram_id      :string
#  page_id           :string           not null
#
# Indexes
#
#  index_channel_facebook_pages_on_page_id                 (page_id)
#  index_channel_facebook_pages_on_page_id_and_account_id  (page_id,account_id) UNIQUE
#

class Channel::FacebookPage < ApplicationRecord
  include Channelable
  include Reauthorizable

  self.table_name = 'channel_facebook_pages'

  validates :page_id, uniqueness: { scope: :account_id }

  after_create_commit :subscribe
  before_destroy :unsubscribe

  def name
    'Facebook'
  end

  def messaging_window_enabled?
    false
  end

  def create_contact_inbox(instagram_id, name)
    @contact_inbox = ::ContactInboxWithContactBuilder.new({
                                                            source_id: instagram_id,
                                                            inbox: inbox,
                                                            contact_attributes: { name: name }
                                                          }).perform
  end

  def subscribe
    # ref https://developers.facebook.com/docs/messenger-platform/reference/webhook-events
    Facebook::Messenger::Subscriptions.subscribe(
      access_token: page_access_token,
      subscribed_fields: %w[
        messages message_deliveries message_echoes message_reads standby messaging_handovers
      ]
    )
  rescue StandardError => e
    Rails.logger.debug { "Rescued: #{e.inspect}" }
    true
  end

  def unsubscribe
    Facebook::Messenger::Subscriptions.unsubscribe(access_token: page_access_token)
  rescue StandardError => e
    Rails.logger.debug { "Rescued: #{e.inspect}" }
    true
  end

  # TODO: We will be removing this code after instagram_manage_insights is implemented
  def fetch_instagram_story_link(message)
    k = Koala::Facebook::API.new(page_access_token)
    result = k.get_object(message.source_id, fields: %w[story]) || {}
    story_link = result['story']['mention']['link']
    # If the story is expired then it raises the ClientError and if the story is deleted with valid story-id it responses with nil
    delete_instagram_story(message) if story_link.blank?
    story_link
  rescue Koala::Facebook::ClientError => e
    Rails.logger.debug { "Instagram Story Expired: #{e.inspect}" }
    delete_instagram_story(message)
  end

  def delete_instagram_story(message)
    message.attachments.destroy_all
    message.update(content: I18n.t('conversations.messages.instagram_deleted_story_content'), content_attributes: {})
  end
end

================
File: models/channel/line.rb
================
# == Schema Information
#
# Table name: channel_line
#
#  id                  :bigint           not null, primary key
#  line_channel_secret :string           not null
#  line_channel_token  :string           not null
#  created_at          :datetime         not null
#  updated_at          :datetime         not null
#  account_id          :integer          not null
#  line_channel_id     :string           not null
#
# Indexes
#
#  index_channel_line_on_line_channel_id  (line_channel_id) UNIQUE
#

class Channel::Line < ApplicationRecord
  include Channelable

  self.table_name = 'channel_line'
  EDITABLE_ATTRS = [:line_channel_id, :line_channel_secret, :line_channel_token].freeze

  validates :line_channel_id, uniqueness: true, presence: true
  validates :line_channel_secret, presence: true
  validates :line_channel_token, presence: true

  def name
    'LINE'
  end

  def client
    @client ||= Line::Bot::Client.new do |config|
      config.channel_id = line_channel_id
      config.channel_secret = line_channel_secret
      config.channel_token = line_channel_token
    end
  end
end

================
File: models/channel/sms.rb
================
# == Schema Information
#
# Table name: channel_sms
#
#  id              :bigint           not null, primary key
#  phone_number    :string           not null
#  provider        :string           default("default")
#  provider_config :jsonb
#  created_at      :datetime         not null
#  updated_at      :datetime         not null
#  account_id      :integer          not null
#
# Indexes
#
#  index_channel_sms_on_phone_number  (phone_number) UNIQUE
#

class Channel::Sms < ApplicationRecord
  include Channelable

  self.table_name = 'channel_sms'
  EDITABLE_ATTRS = [:phone_number, { provider_config: {} }].freeze

  validates :phone_number, presence: true, uniqueness: true
  # before_save :validate_provider_config

  def name
    'Sms'
  end

  # all this should happen in provider service . but hack mode on
  def api_base_path
    'https://messaging.bandwidth.com/api/v2'
  end

  def send_message(contact_number, message)
    body = message_body(contact_number, message.content)
    body['media'] = message.attachments.map(&:download_url) if message.attachments.present?

    send_to_bandwidth(body, message)
  end

  def send_text_message(contact_number, message_content)
    body = message_body(contact_number, message_content)
    send_to_bandwidth(body)
  end

  private

  def message_body(contact_number, message_content)
    {
      'to' => contact_number,
      'from' => phone_number,
      'text' => message_content,
      'applicationId' => provider_config['application_id']
    }
  end

  def send_to_bandwidth(body, message = nil)
    response = HTTParty.post(
      "#{api_base_path}/users/#{provider_config['account_id']}/messages",
      basic_auth: bandwidth_auth,
      headers: { 'Content-Type' => 'application/json' },
      body: body.to_json
    )

    if response.success?
      response.parsed_response['id']
    else
      handle_error(response, message)
      nil
    end
  end

  def handle_error(response, message)
    Rails.logger.error("[#{account_id}] Error sending SMS: #{response.parsed_response['description']}")
    return if message.blank?

    # https://dev.bandwidth.com/apis/messaging-apis/messaging/#tag/Messages/operation/createMessage
    message.external_error = response.parsed_response['description']
    message.status = :failed
    message.save!
  end

  def bandwidth_auth
    { username: provider_config['api_key'], password: provider_config['api_secret'] }
  end

  # Extract later into provider Service
  # let's revisit later
  def validate_provider_config
    response = HTTParty.post(
      "#{api_base_path}/users/#{provider_config['account_id']}/messages",
      basic_auth: bandwidth_auth,
      headers: { 'Content-Type': 'application/json' }
    )
    errors.add(:provider_config, 'error setting up') unless response.success?
  end
end

================
File: models/channel/telegram.rb
================
# == Schema Information
#
# Table name: channel_telegram
#
#  id         :bigint           not null, primary key
#  bot_name   :string
#  bot_token  :string           not null
#  created_at :datetime         not null
#  updated_at :datetime         not null
#  account_id :integer          not null
#
# Indexes
#
#  index_channel_telegram_on_bot_token  (bot_token) UNIQUE
#

class Channel::Telegram < ApplicationRecord
  include Channelable

  self.table_name = 'channel_telegram'
  EDITABLE_ATTRS = [:bot_token].freeze

  before_validation :ensure_valid_bot_token, on: :create
  validates :bot_token, presence: true, uniqueness: true
  before_save :setup_telegram_webhook

  def name
    'Telegram'
  end

  def telegram_api_url
    "https://api.telegram.org/bot#{bot_token}"
  end

  def send_message_on_telegram(message)
    message_id = send_message(message) if message.content.present?
    message_id = Telegram::SendAttachmentsService.new(message: message).perform if message.attachments.present?
    message_id
  end

  def get_telegram_profile_image(user_id)
    # get profile image from telegram
    response = HTTParty.get("#{telegram_api_url}/getUserProfilePhotos", query: { user_id: user_id })
    return nil unless response.success?

    photos = response.parsed_response.dig('result', 'photos')
    return if photos.blank?

    get_telegram_file_path(photos.first.last['file_id'])
  end

  def get_telegram_file_path(file_id)
    response = HTTParty.get("#{telegram_api_url}/getFile", query: { file_id: file_id })
    return nil unless response.success?

    "https://api.telegram.org/file/bot#{bot_token}/#{response.parsed_response['result']['file_path']}"
  end

  def process_error(message, response)
    return unless response.parsed_response['ok'] == false

    # https://github.com/TelegramBotAPI/errors/tree/master/json
    message.external_error = "#{response.parsed_response['error_code']}, #{response.parsed_response['description']}"
    message.status = :failed
    message.save!
  end

  def chat_id(message)
    message.conversation[:additional_attributes]['chat_id']
  end

  def reply_to_message_id(message)
    message.content_attributes['in_reply_to_external_id']
  end

  private

  def ensure_valid_bot_token
    response = HTTParty.get("#{telegram_api_url}/getMe")
    unless response.success?
      errors.add(:bot_token, 'invalid token')
      return
    end

    self.bot_name = response.parsed_response['result']['username']
  end

  def setup_telegram_webhook
    HTTParty.post("#{telegram_api_url}/deleteWebhook")
    response = HTTParty.post("#{telegram_api_url}/setWebhook",
                             body: {
                               url: "#{ENV.fetch('FRONTEND_URL', nil)}/webhooks/telegram/#{bot_token}"
                             })
    errors.add(:bot_token, 'error setting up the webook') unless response.success?
  end

  def send_message(message)
    response = message_request(chat_id(message), message.content, reply_markup(message), reply_to_message_id(message))
    process_error(message, response)
    response.parsed_response['result']['message_id'] if response.success?
  end

  def reply_markup(message)
    return unless message.content_type == 'input_select'

    {
      one_time_keyboard: true,
      inline_keyboard: message.content_attributes['items'].map do |item|
        [{
          text: item['title'],
          callback_data: item['value']
        }]
      end
    }.to_json
  end

  def convert_markdown_to_telegram_html(text)
    # ref: https://core.telegram.org/bots/api#html-style

    # escape html tags in text. We are subbing \n to <br> since commonmark will strip exta '\n'
    text = CGI.escapeHTML(text.gsub("\n", '<br>'))

    # convert markdown to html
    html = CommonMarker.render_html(text).strip

    # remove all html tags except b, strong, i, em, u, ins, s, strike, del, a, code, pre, blockquote
    stripped_html = Rails::HTML5::SafeListSanitizer.new.sanitize(html, tags: %w[b strong i em u ins s strike del a code pre blockquote],
                                                                       attributes: %w[href])

    # converted escaped br tags to \n
    stripped_html.gsub('&lt;br&gt;', "\n")
  end

  def message_request(chat_id, text, reply_markup = nil, reply_to_message_id = nil)
    text_payload = convert_markdown_to_telegram_html(text)

    HTTParty.post("#{telegram_api_url}/sendMessage",
                  body: {
                    chat_id: chat_id,
                    text: text_payload,
                    reply_markup: reply_markup,
                    parse_mode: 'HTML',
                    reply_to_message_id: reply_to_message_id
                  })
  end
end

================
File: models/channel/twilio_sms.rb
================
# == Schema Information
#
# Table name: channel_twilio_sms
#
#  id                    :bigint           not null, primary key
#  account_sid           :string           not null
#  api_key_sid           :string
#  auth_token            :string           not null
#  medium                :integer          default("sms")
#  messaging_service_sid :string
#  phone_number          :string
#  created_at            :datetime         not null
#  updated_at            :datetime         not null
#  account_id            :integer          not null
#
# Indexes
#
#  index_channel_twilio_sms_on_account_sid_and_phone_number  (account_sid,phone_number) UNIQUE
#  index_channel_twilio_sms_on_messaging_service_sid         (messaging_service_sid) UNIQUE
#  index_channel_twilio_sms_on_phone_number                  (phone_number) UNIQUE
#

class Channel::TwilioSms < ApplicationRecord
  include Channelable
  include Rails.application.routes.url_helpers

  self.table_name = 'channel_twilio_sms'

  validates :account_sid, presence: true
  # The same parameter is used to store api_key_secret if api_key authentication is opted
  validates :auth_token, presence: true

  # Must have _one_ of messaging_service_sid _or_ phone_number, and messaging_service_sid is preferred
  validates :messaging_service_sid, uniqueness: true, presence: true, unless: :phone_number?
  validates :phone_number, absence: true, if: :messaging_service_sid?
  validates :phone_number, uniqueness: true, allow_nil: true

  enum medium: { sms: 0, whatsapp: 1 }

  def name
    medium == 'sms' ? 'Twilio SMS' : 'Whatsapp'
  end

  def messaging_window_enabled?
    medium == 'whatsapp'
  end

  def send_message(to:, body:, media_url: nil)
    params = send_message_from.merge(to: to, body: body)
    params[:media_url] = media_url if media_url.present?
    params[:status_callback] = twilio_delivery_status_index_url
    client.messages.create(**params)
  end

  private

  def client
    if api_key_sid.present?
      Twilio::REST::Client.new(api_key_sid, auth_token, account_sid)
    else
      Twilio::REST::Client.new(account_sid, auth_token)
    end
  end

  def send_message_from
    if messaging_service_sid?
      { messaging_service_sid: messaging_service_sid }
    else
      { from: phone_number }
    end
  end
end

================
File: models/channel/twitter_profile.rb
================
# == Schema Information
#
# Table name: channel_twitter_profiles
#
#  id                          :bigint           not null, primary key
#  tweets_enabled              :boolean          default(TRUE)
#  twitter_access_token        :string           not null
#  twitter_access_token_secret :string           not null
#  created_at                  :datetime         not null
#  updated_at                  :datetime         not null
#  account_id                  :integer          not null
#  profile_id                  :string           not null
#
# Indexes
#
#  index_channel_twitter_profiles_on_account_id_and_profile_id  (account_id,profile_id) UNIQUE
#

class Channel::TwitterProfile < ApplicationRecord
  include Channelable

  self.table_name = 'channel_twitter_profiles'

  validates :profile_id, uniqueness: { scope: :account_id }

  before_destroy :unsubscribe

  EDITABLE_ATTRS = [:tweets_enabled].freeze

  def name
    'Twitter'
  end

  def create_contact_inbox(profile_id, name, additional_attributes)
    ::ContactInboxWithContactBuilder.new({
                                           source_id: profile_id,
                                           inbox: inbox,
                                           contact_attributes: { name: name, additional_attributes: additional_attributes }
                                         }).perform
  end

  def twitter_client
    Twitty::Facade.new do |config|
      config.consumer_key = ENV.fetch('TWITTER_CONSUMER_KEY', nil)
      config.consumer_secret = ENV.fetch('TWITTER_CONSUMER_SECRET', nil)
      config.access_token = twitter_access_token
      config.access_token_secret = twitter_access_token_secret
      config.base_url = 'https://api.twitter.com'
      config.environment = ENV.fetch('TWITTER_ENVIRONMENT', '')
    end
  end

  private

  def unsubscribe
    ### Fix unsubscription with new endpoint
    unsubscribe_response = twitter_client.remove_subscription(user_id: profile_id)
    Rails.logger.info "TWITTER_UNSUBSCRIBE: #{unsubscribe_response.body}"
  rescue StandardError => e
    Rails.logger.error e
  end
end

================
File: models/channel/web_widget.rb
================
# == Schema Information
#
# Table name: channel_web_widgets
#
#  id                    :integer          not null, primary key
#  continuity_via_email  :boolean          default(TRUE), not null
#  feature_flags         :integer          default(7), not null
#  hmac_mandatory        :boolean          default(FALSE)
#  hmac_token            :string
#  pre_chat_form_enabled :boolean          default(FALSE)
#  pre_chat_form_options :jsonb
#  reply_time            :integer          default("in_a_few_minutes")
#  website_token         :string
#  website_url           :string
#  welcome_tagline       :string
#  welcome_title         :string
#  widget_color          :string           default("#1f93ff")
#  created_at            :datetime         not null
#  updated_at            :datetime         not null
#  account_id            :integer
#
# Indexes
#
#  index_channel_web_widgets_on_hmac_token     (hmac_token) UNIQUE
#  index_channel_web_widgets_on_website_token  (website_token) UNIQUE
#

class Channel::WebWidget < ApplicationRecord
  include Channelable
  include FlagShihTzu

  self.table_name = 'channel_web_widgets'
  EDITABLE_ATTRS = [:website_url, :widget_color, :welcome_title, :welcome_tagline, :reply_time, :pre_chat_form_enabled,
                    :continuity_via_email, :hmac_mandatory,
                    { pre_chat_form_options: [:pre_chat_message, :require_email,
                                              { pre_chat_fields:
                                                [:field_type, :label, :placeholder, :name, :enabled, :type, :enabled, :required,
                                                 :locale, { values: [] }, :regex_pattern, :regex_cue] }] },
                    { selected_feature_flags: [] }].freeze

  before_validation :validate_pre_chat_options
  validates :website_url, presence: true
  validates :widget_color, presence: true
  has_many :portals, foreign_key: 'channel_web_widget_id', dependent: :nullify, inverse_of: :channel_web_widget

  has_secure_token :website_token
  has_secure_token :hmac_token

  has_flags 1 => :attachments,
            2 => :emoji_picker,
            3 => :end_conversation,
            4 => :use_inbox_avatar_for_bot,
            :column => 'feature_flags',
            :check_for_column => false

  enum reply_time: { in_a_few_minutes: 0, in_a_few_hours: 1, in_a_day: 2 }

  def name
    'Website'
  end

  def web_widget_script
    "
    <script>
      (function(d,t) {
        var BASE_URL=\"#{ENV.fetch('FRONTEND_URL', '')}\";
        var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
        g.src=BASE_URL+\"/packs/js/sdk.js\";
        g.defer = true;
        g.async = true;
        s.parentNode.insertBefore(g,s);
        g.onload=function(){
          window.chatwootSDK.run({
            websiteToken: '#{website_token}',
            baseUrl: BASE_URL
          })
        }
      })(document,\"script\");
    </script>
    "
  end

  def validate_pre_chat_options
    return if pre_chat_form_options.with_indifferent_access['pre_chat_fields'].present?

    self.pre_chat_form_options = {
      pre_chat_message: 'Share your queries or comments here.',
      pre_chat_fields: [
        {
          'field_type': 'standard', 'label': 'Email Id', 'name': 'emailAddress', 'type': 'email', 'required': true, 'enabled': false
        },
        {
          'field_type': 'standard', 'label': 'Full name', 'name': 'fullName', 'type': 'text', 'required': false, 'enabled': false
        },
        {
          'field_type': 'standard', 'label': 'Phone number', 'name': 'phoneNumber', 'type': 'text', 'required': false, 'enabled': false
        }
      ]
    }
  end

  def create_contact_inbox(additional_attributes = {})
    ::ContactInboxWithContactBuilder.new({
                                           inbox: inbox,
                                           contact_attributes: { additional_attributes: additional_attributes }
                                         }).perform
  end
end

================
File: models/channel/whatsapp.rb
================
# == Schema Information
#
# Table name: channel_whatsapp
#
#  id                             :bigint           not null, primary key
#  message_templates              :jsonb
#  message_templates_last_updated :datetime
#  phone_number                   :string           not null
#  provider                       :string           default("default")
#  provider_config                :jsonb
#  created_at                     :datetime         not null
#  updated_at                     :datetime         not null
#  account_id                     :integer          not null
#
# Indexes
#
#  index_channel_whatsapp_on_phone_number  (phone_number) UNIQUE
#

class Channel::Whatsapp < ApplicationRecord
  include Channelable
  include Reauthorizable

  self.table_name = 'channel_whatsapp'
  EDITABLE_ATTRS = [:phone_number, :provider, { provider_config: {} }].freeze

  # default at the moment is 360dialog lets change later.
  PROVIDERS = %w[default whatsapp_cloud].freeze
  before_validation :ensure_webhook_verify_token

  validates :provider, inclusion: { in: PROVIDERS }
  validates :phone_number, presence: true, uniqueness: true
  validate :validate_provider_config

  after_create :sync_templates

  def name
    'Whatsapp'
  end

  def provider_service
    if provider == 'whatsapp_cloud'
      Whatsapp::Providers::WhatsappCloudService.new(whatsapp_channel: self)
    else
      Whatsapp::Providers::Whatsapp360DialogService.new(whatsapp_channel: self)
    end
  end

  def messaging_window_enabled?
    true
  end

  def mark_message_templates_updated
    # rubocop:disable Rails/SkipsModelValidations
    update_column(:message_templates_last_updated, Time.zone.now)
    # rubocop:enable Rails/SkipsModelValidations
  end

  delegate :send_message, to: :provider_service
  delegate :send_template, to: :provider_service
  delegate :sync_templates, to: :provider_service
  delegate :media_url, to: :provider_service
  delegate :api_headers, to: :provider_service

  private

  def ensure_webhook_verify_token
    provider_config['webhook_verify_token'] ||= SecureRandom.hex(16) if provider == 'whatsapp_cloud'
  end

  def validate_provider_config
    errors.add(:provider_config, 'Invalid Credentials') unless provider_service.validate_provider_config?
  end
end

================
File: models/concerns/access_tokenable.rb
================
module AccessTokenable
  extend ActiveSupport::Concern
  included do
    has_one :access_token, as: :owner, dependent: :destroy_async
    after_create :create_access_token
  end

  def create_access_token
    AccessToken.create!(owner: self)
  end
end

================
File: models/concerns/account_cache_revalidator.rb
================
module AccountCacheRevalidator
  extend ActiveSupport::Concern

  included do
    after_commit :update_account_cache, on: [:create, :update, :destroy]
  end

  def update_account_cache
    account.update_cache_key(self.class.name.underscore)
  end
end

================
File: models/concerns/activity_message_handler.rb
================
module ActivityMessageHandler
  extend ActiveSupport::Concern

  include PriorityActivityMessageHandler
  include LabelActivityMessageHandler
  include SlaActivityMessageHandler
  include TeamActivityMessageHandler

  private

  def create_activity
    user_name = determine_user_name

    handle_status_change(user_name)
    handle_priority_change(user_name)
    handle_label_change(user_name)
    handle_sla_policy_change(user_name)
  end

  def determine_user_name
    Current.user&.name
  end

  def handle_status_change(user_name)
    return unless saved_change_to_status?

    status_change_activity(user_name)
  end

  def handle_priority_change(user_name)
    return unless saved_change_to_priority?

    priority_change_activity(user_name)
  end

  def handle_label_change(user_name)
    return unless saved_change_to_label_list?

    create_label_change(activity_message_owner(user_name))
  end

  def handle_sla_policy_change(user_name)
    return unless saved_change_to_sla_policy_id?

    sla_change_type = determine_sla_change_type
    create_sla_change_activity(sla_change_type, activity_message_owner(user_name))
  end

  def status_change_activity(user_name)
    content = if Current.executed_by.present?
                automation_status_change_activity_content
              else
                user_status_change_activity_content(user_name)
              end

    ::Conversations::ActivityMessageJob.perform_later(self, activity_message_params(content)) if content
  end

  def user_status_change_activity_content(user_name)
    if user_name
      I18n.t("conversations.activity.status.#{status}", user_name: user_name)
    elsif Current.contact.present? && resolved?
      I18n.t('conversations.activity.status.contact_resolved', contact_name: Current.contact.name.capitalize)
    elsif resolved?
      I18n.t('conversations.activity.status.auto_resolved', duration: auto_resolve_duration)
    end
  end

  def automation_status_change_activity_content
    if Current.executed_by.instance_of?(AutomationRule)
      I18n.t("conversations.activity.status.#{status}", user_name: 'Automation System')
    elsif Current.executed_by.instance_of?(Contact)
      Current.executed_by = nil
      I18n.t('conversations.activity.status.system_auto_open')
    end
  end

  def activity_message_params(content)
    { account_id: account_id, inbox_id: inbox_id, message_type: :activity, content: content }
  end

  def create_muted_message
    create_mute_change_activity('muted')
  end

  def create_unmuted_message
    create_mute_change_activity('unmuted')
  end

  def create_mute_change_activity(change_type)
    return unless Current.user

    content = I18n.t("conversations.activity.#{change_type}", user_name: Current.user.name)
    ::Conversations::ActivityMessageJob.perform_later(self, activity_message_params(content)) if content
  end

  def generate_assignee_change_activity_content(user_name)
    params = { assignee_name: assignee&.name, user_name: user_name }.compact
    key = assignee_id ? 'assigned' : 'removed'
    key = 'self_assigned' if self_assign? assignee_id
    I18n.t("conversations.activity.assignee.#{key}", **params)
  end

  def create_assignee_change_activity(user_name)
    user_name = activity_message_owner(user_name)

    return unless user_name

    content = generate_assignee_change_activity_content(user_name)
    ::Conversations::ActivityMessageJob.perform_later(self, activity_message_params(content)) if content
  end

  def activity_message_owner(user_name)
    user_name = 'Automation System' if !user_name && Current.executed_by.present?
    user_name
  end
end

================
File: models/concerns/assignment_handler.rb
================
module AssignmentHandler
  extend ActiveSupport::Concern
  include Events::Types

  included do
    before_save :ensure_assignee_is_from_team
    after_commit :notify_assignment_change, :process_assignment_changes
  end

  private

  def ensure_assignee_is_from_team
    return unless team_id_changed?

    validate_current_assignee_team
    self.assignee ||= find_assignee_from_team
  end

  def validate_current_assignee_team
    self.assignee_id = nil if team&.members&.exclude?(assignee)
  end

  def find_assignee_from_team
    return if team&.allow_auto_assign.blank?

    team_members_with_capacity = inbox.member_ids_with_assignment_capacity & team.members.ids
    ::AutoAssignment::AgentAssignmentService.new(conversation: self, allowed_agent_ids: team_members_with_capacity).find_assignee
  end

  def notify_assignment_change
    {
      ASSIGNEE_CHANGED => -> { saved_change_to_assignee_id? },
      TEAM_CHANGED => -> { saved_change_to_team_id? }
    }.each do |event, condition|
      condition.call && dispatcher_dispatch(event, previous_changes)
    end
  end

  def process_assignment_changes
    process_assignment_activities
  end

  def process_assignment_activities
    user_name = Current.user.name if Current.user.present?
    if saved_change_to_team_id?
      create_team_change_activity(user_name)
    elsif saved_change_to_assignee_id?
      create_assignee_change_activity(user_name)
    end
  end
end

================
File: models/concerns/auto_assignment_handler.rb
================
module AutoAssignmentHandler
  extend ActiveSupport::Concern
  include Events::Types

  included do
    after_save :run_auto_assignment
  end

  private

  def run_auto_assignment
    # Round robin kicks in on conversation create & update
    # run it only when conversation status changes to open
    return unless conversation_status_changed_to_open?
    return unless should_run_auto_assignment?

    ::AutoAssignment::AgentAssignmentService.new(conversation: self, allowed_agent_ids: inbox.member_ids_with_assignment_capacity).perform
  end

  def should_run_auto_assignment?
    return false unless inbox.enable_auto_assignment?

    # run only if assignee is blank or doesn't have access to inbox
    assignee.blank? || inbox.members.exclude?(assignee)
  end
end

================
File: models/concerns/availability_statusable.rb
================
module AvailabilityStatusable
  extend ActiveSupport::Concern

  def online_presence?
    obj_id = is_a?(Contact) ? id : user_id
    ::OnlineStatusTracker.get_presence(account_id, self.class.name, obj_id)
  end

  def availability_status
    if is_a? Contact
      contact_availability_status
    else
      user_availability_status
    end
  end

  private

  def contact_availability_status
    online_presence? ? 'online' : 'offline'
  end

  def user_availability_status
    # we are not considering presence in this case. Just returns the availability
    return availability unless auto_offline

    # availability as a fallback in case the status is not present in redis
    online_presence? ? (::OnlineStatusTracker.get_status(account_id, user_id) || availability) : 'offline'
  end
end

================
File: models/concerns/avatarable.rb
================
# frozen_string_literal: true

module Avatarable
  extend ActiveSupport::Concern
  include Rails.application.routes.url_helpers

  included do
    has_one_attached :avatar
    validate :acceptable_avatar, if: -> { avatar.changed? }
    after_save :fetch_avatar_from_gravatar
  end

  def avatar_url
    return url_for(avatar.representation(resize_to_fill: [250, nil])) if avatar.attached? && avatar.representable?

    ''
  end

  def fetch_avatar_from_gravatar
    return unless saved_changes.key?(:email)
    return if email.blank?

    # Incase avatar_url is supplied, we don't want to fetch avatar from gravatar
    # So we will wait for it to be processed
    Avatar::AvatarFromGravatarJob.set(wait: 30.seconds).perform_later(self, email)
  end

  def acceptable_avatar
    return unless avatar.attached?

    errors.add(:avatar, 'is too big') if avatar.byte_size > 15.megabytes

    acceptable_types = ['image/jpeg', 'image/png', 'image/gif'].freeze
    errors.add(:avatar, 'filetype not supported') unless acceptable_types.include?(avatar.content_type)
  end
end

================
File: models/concerns/cache_keys.rb
================
module CacheKeys
  extend ActiveSupport::Concern

  include CacheKeysHelper
  include Events::Types

  CACHE_KEYS_EXPIRY = 72.hours

  included do
    class_attribute :cacheable_models
    self.cacheable_models = [Label, Inbox, Team]
  end

  def cache_keys
    keys = {}
    self.class.cacheable_models.each do |model|
      keys[model.name.underscore.to_sym] = fetch_value_for_key(id, model.name.underscore)
    end

    keys
  end

  def update_cache_key(key)
    update_cache_key_for_account(id, key)
    dispatch_cache_update_event
  end

  def reset_cache_keys
    self.class.cacheable_models.each do |model|
      update_cache_key_for_account(id, model.name.underscore)
    end

    dispatch_cache_update_event
  end

  private

  def update_cache_key_for_account(account_id, key)
    prefixed_cache_key = get_prefixed_cache_key(account_id, key)
    Redis::Alfred.setex(prefixed_cache_key, Time.now.utc.to_i, CACHE_KEYS_EXPIRY)
  end

  def dispatch_cache_update_event
    Rails.configuration.dispatcher.dispatch(ACCOUNT_CACHE_INVALIDATED, Time.zone.now, cache_keys: cache_keys, account: self)
  end
end

================
File: models/concerns/channelable.rb
================
module Channelable
  extend ActiveSupport::Concern
  included do
    validates :account_id, presence: true
    belongs_to :account
    has_one :inbox, as: :channel, dependent: :destroy_async, touch: true
    after_update :create_audit_log_entry
  end

  def messaging_window_enabled?
    false
  end

  def create_audit_log_entry; end
end

Channelable.prepend_mod_with('Channelable')

================
File: models/concerns/content_attribute_validator.rb
================
class ContentAttributeValidator < ActiveModel::Validator
  ALLOWED_SELECT_ITEM_KEYS = [:title, :value].freeze
  ALLOWED_CARD_ITEM_KEYS = [:title, :description, :media_url, :actions].freeze
  ALLOWED_CARD_ITEM_ACTION_KEYS = [:text, :type, :payload, :uri].freeze
  ALLOWED_FORM_ITEM_KEYS = [:type, :placeholder, :label, :name, :options, :default, :required, :pattern, :title, :pattern_error].freeze
  ALLOWED_ARTICLE_KEYS = [:title, :description, :link].freeze

  def validate(record)
    case record.content_type
    when 'input_select'
      validate_items!(record)
      validate_item_attributes!(record, ALLOWED_SELECT_ITEM_KEYS)
    when 'cards'
      validate_items!(record)
      validate_item_attributes!(record, ALLOWED_CARD_ITEM_KEYS)
      validate_item_actions!(record)
    when 'form'
      validate_items!(record)
      validate_item_attributes!(record, ALLOWED_FORM_ITEM_KEYS)
    when 'article'
      validate_items!(record)
      validate_item_attributes!(record, ALLOWED_ARTICLE_KEYS)
    end
  end

  private

  def validate_items!(record)
    record.errors.add(:content_attributes, 'At least one item is required.') if record.items.blank?
    record.errors.add(:content_attributes, 'Items should be a hash.') if record.items.reject { |item| item.is_a?(Hash) }.present?
  end

  def validate_item_attributes!(record, valid_keys)
    item_keys = record.items.collect(&:keys).flatten.filter_map(&:to_sym)
    invalid_keys = item_keys - valid_keys
    record.errors.add(:content_attributes, "contains invalid keys for items : #{invalid_keys}") if invalid_keys.present?
  end

  def validate_item_actions!(record)
    if record.items.select { |item| item[:actions].blank? }.present?
      record.errors.add(:content_attributes, 'contains items missing actions') && return
    end

    validate_item_action_attributes!(record)
  end

  def validate_item_action_attributes!(record)
    item_action_keys = record.items.collect { |item| item[:actions].collect(&:keys) }
    invalid_keys = item_action_keys.flatten.compact.map(&:to_sym) - ALLOWED_CARD_ITEM_ACTION_KEYS
    record.errors.add(:content_attributes, "contains invalid keys for actions:  #{invalid_keys}") if invalid_keys.present?
  end
end

================
File: models/concerns/conversation_mute_helpers.rb
================
module ConversationMuteHelpers
  extend ActiveSupport::Concern

  def mute!
    resolved!
    contact.update(blocked: true)
    create_muted_message
  end

  def unmute!
    contact.update(blocked: false)
    create_unmuted_message
  end

  def muted?
    contact.blocked?
  end
end

================
File: models/concerns/featurable.rb
================
module Featurable
  extend ActiveSupport::Concern

  QUERY_MODE = {
    flag_query_mode: :bit_operator,
    check_for_column: false
  }.freeze

  FEATURE_LIST = YAML.safe_load(Rails.root.join('config/features.yml').read).freeze

  FEATURES = FEATURE_LIST.each_with_object({}) do |feature, result|
    result[result.keys.size + 1] = "feature_#{feature['name']}".to_sym
  end

  included do
    include FlagShihTzu
    has_flags FEATURES.merge(column: 'feature_flags').merge(QUERY_MODE)

    before_create :enable_default_features
  end

  def enable_features(*names)
    names.each do |name|
      send("feature_#{name}=", true)
    end
  end

  def enable_features!(*names)
    enable_features(*names)
    save
  end

  def disable_features(*names)
    names.each do |name|
      send("feature_#{name}=", false)
    end
  end

  def disable_features!(*names)
    disable_features(*names)
    save
  end

  def feature_enabled?(name)
    send("feature_#{name}?")
  end

  def all_features
    FEATURE_LIST.pluck('name').index_with do |feature_name|
      feature_enabled?(feature_name)
    end
  end

  def enabled_features
    all_features.select { |_feature, enabled| enabled == true }
  end

  def disabled_features
    all_features.select { |_feature, enabled| enabled == false }
  end

  private

  def enable_default_features
    config = InstallationConfig.find_by(name: 'ACCOUNT_LEVEL_FEATURE_DEFAULTS')
    return true if config.blank?

    features_to_enabled = config.value.select { |f| f[:enabled] }.pluck(:name)
    enable_features(*features_to_enabled)
  end
end

================
File: models/concerns/json_schema_validator.rb
================
# This file defines a custom validator class `JsonSchemaValidator` for validating a JSON object against a schema.
# To use this validator, define a schema as a Ruby hash and include it in the validation options when validating a model.
# The schema should define the expected structure and types of the JSON object, as well as any validation rules.
# Here's an example schema:
#
# schema = {
#   'type' => 'object',
#   'properties' => {
#     'name' => { 'type' => 'string' },
#     'age' => { 'type' => 'integer' },
#     'is_active' => { 'type' => 'boolean' },
#     'tags' => { 'type' => 'array' },
#     'address' => {
#       'type' => 'object',
#       'properties' => {
#         'street' => { 'type' => 'string' },
#         'city' => { 'type' => 'string' }
#       },
#       'required' => ['street', 'city']
#     }
#   },
#   'required': ['name', 'age']
# }.to_json.freeze
#
# To validate a model using this schema, include the `JsonSchemaValidator` in the model's validations and pass the schema
# as an option:
#
# class MyModel < ApplicationRecord
#   validates_with JsonSchemaValidator, schema: schema
# end

class JsonSchemaValidator < ActiveModel::Validator
  def validate(record)
    # Get the attribute resolver function from options or use a default one
    attribute_resolver = options[:attribute_resolver] || ->(rec) { rec.additional_attributes }

    # Resolve the JSON data to be validated
    json_data = attribute_resolver.call(record)

    # Get the schema to be used for validation
    schema = options[:schema]

    # Create a JSONSchemer instance using the schema
    schemer = JSONSchemer.schema(schema)

    # Validate the JSON data against the schema
    validation_errors = schemer.validate(json_data)

    # Add validation errors to the record with a formatted statement
    validation_errors.each do |error|
      format_and_append_error(error, record)
    end
  end

  private

  def format_and_append_error(error, record)
    return handle_required(error, record) if error['type'] == 'required'

    type = error['type'] == 'object' ? 'hash' : error['type']

    handle_type(error, record, type)
  end

  def handle_required(error, record)
    missing_values = error['details']['missing_keys']
    missing_values.each do |missing|
      record.errors.add(missing, 'is required')
    end
  end

  def handle_type(error, record, expected_type)
    data = get_name_from_data_pointer(error)
    record.errors.add(data, "must be of type #{expected_type}")
  end

  def get_name_from_data_pointer(error)
    data = error['data_pointer']

    # if data starts with a "/" remove it
    data[1..] if data[0] == '/'
  end
end

================
File: models/concerns/label_activity_message_handler.rb
================
module LabelActivityMessageHandler
  extend ActiveSupport::Concern

  private

  def create_label_added(user_name, labels = [])
    create_label_change_activity('added', user_name, labels)
  end

  def create_label_removed(user_name, labels = [])
    create_label_change_activity('removed', user_name, labels)
  end

  def create_label_change_activity(change_type, user_name, labels = [])
    return unless labels.size.positive?

    content = I18n.t("conversations.activity.labels.#{change_type}", user_name: user_name, labels: labels.join(', '))
    ::Conversations::ActivityMessageJob.perform_later(self, activity_message_params(content)) if content
  end
end

================
File: models/concerns/labelable.rb
================
module Labelable
  extend ActiveSupport::Concern

  included do
    acts_as_taggable_on :labels
  end

  def update_labels(labels = nil)
    update!(label_list: labels)
  end

  def add_labels(new_labels = nil)
    new_labels = Array(new_labels) # Make sure new_labels is an array
    combined_labels = labels + new_labels
    update!(label_list: combined_labels)
  end
end

================
File: models/concerns/liquidable.rb
================
module Liquidable
  extend ActiveSupport::Concern

  included do
    before_create :process_liquid_in_content
  end

  private

  def message_drops
    {
      'contact' => ContactDrop.new(conversation.contact),
      'agent' => UserDrop.new(sender),
      'conversation' => ConversationDrop.new(conversation),
      'inbox' => InboxDrop.new(inbox),
      'account' => AccountDrop.new(conversation.account)
    }
  end

  def liquid_processable_message?
    content.present? && (message_type == 'outgoing' || message_type == 'template')
  end

  def process_liquid_in_content
    return unless liquid_processable_message?

    template = Liquid::Template.parse(modified_liquid_content)
    self.content = template.render(message_drops)
  rescue Liquid::Error
    # If there is an error in the liquid syntax, we don't want to process it
  end

  def modified_liquid_content
    # This regex is used to match the code blocks in the content
    # We don't want to process liquid in code blocks
    content.gsub(/`(.*?)`/m, '{% raw %}`\\1`{% endraw %}')
  end
end

================
File: models/concerns/llm_formattable.rb
================
module LlmFormattable
  extend ActiveSupport::Concern

  def to_llm_text
    LlmFormatter::LlmTextFormatterService.new(self).format
  end
end

================
File: models/concerns/message_filter_helpers.rb
================
module MessageFilterHelpers
  extend ActiveSupport::Concern

  def reportable?
    incoming? || outgoing?
  end

  def webhook_sendable?
    incoming? || outgoing? || template?
  end

  def slack_hook_sendable?
    incoming? || outgoing? || template?
  end

  def notifiable?
    incoming? || outgoing?
  end

  def conversation_transcriptable?
    incoming? || outgoing?
  end

  def email_reply_summarizable?
    incoming? || outgoing? || input_csat?
  end

  def instagram_story_mention?
    inbox.instagram? && try(:content_attributes)[:image_type] == 'story_mention'
  end
end

================
File: models/concerns/out_of_offisable.rb
================
# frozen_string_literal: true

module OutOfOffisable
  extend ActiveSupport::Concern

  OFFISABLE_ATTRS = %w[day_of_week closed_all_day open_hour open_minutes close_hour close_minutes open_all_day].freeze

  included do
    has_many :working_hours, dependent: :destroy_async
    after_create :create_default_working_hours
  end

  def out_of_office?
    working_hours_enabled? && working_hours.today.closed_now?
  end

  def working_now?
    !out_of_office?
  end

  def weekly_schedule
    working_hours.order(day_of_week: :asc).select(*OFFISABLE_ATTRS).as_json(except: :id)
  end

  # accepts an array of hashes similiar to the format of weekly_schedule
  #  [
  #    { "day_of_week"=>1,
  #      "closed_all_day"=>false,
  #      "open_hour"=>9,
  #      "open_minutes"=>0,
  #      "close_hour"=>17,
  #      "close_minutes"=>0,
  #      "open_all_day=>false" },...]
  def update_working_hours(params)
    ActiveRecord::Base.transaction do
      params.each do |working_hour|
        working_hours.find_by(day_of_week: working_hour['day_of_week']).update(working_hour.slice(*OFFISABLE_ATTRS))
      end
    end
  end

  private

  def create_default_working_hours
    working_hours.create!(day_of_week: 0, closed_all_day: true, open_all_day: false)
    working_hours.create!(day_of_week: 1, open_hour: 9, open_minutes: 0, close_hour: 17, close_minutes: 0, open_all_day: false)
    working_hours.create!(day_of_week: 2, open_hour: 9, open_minutes: 0, close_hour: 17, close_minutes: 0, open_all_day: false)
    working_hours.create!(day_of_week: 3, open_hour: 9, open_minutes: 0, close_hour: 17, close_minutes: 0, open_all_day: false)
    working_hours.create!(day_of_week: 4, open_hour: 9, open_minutes: 0, close_hour: 17, close_minutes: 0, open_all_day: false)
    working_hours.create!(day_of_week: 5, open_hour: 9, open_minutes: 0, close_hour: 17, close_minutes: 0, open_all_day: false)
    working_hours.create!(day_of_week: 6, closed_all_day: true, open_all_day: false)
  end
end

================
File: models/concerns/priority_activity_message_handler.rb
================
module PriorityActivityMessageHandler
  extend ActiveSupport::Concern

  private

  def priority_change_activity(user_name)
    old_priority, new_priority = previous_changes.values_at('priority')[0]
    return unless priority_change?(old_priority, new_priority)

    user = Current.executed_by.instance_of?(AutomationRule) ? 'Automation System' : user_name
    content = build_priority_change_content(user, old_priority, new_priority)

    ::Conversations::ActivityMessageJob.perform_later(self, activity_message_params(content)) if content
  end

  def priority_change?(old_priority, new_priority)
    old_priority.present? || new_priority.present?
  end

  def build_priority_change_content(user_name, old_priority = nil, new_priority = nil)
    change_type = get_priority_change_type(old_priority, new_priority)

    I18n.t("conversations.activity.priority.#{change_type}", user_name: user_name, new_priority: new_priority, old_priority: old_priority)
  end

  def get_priority_change_type(old_priority, new_priority)
    case [old_priority.present?, new_priority.present?]
    when [true, true] then 'updated'
    when [false, true] then 'added'
    when [true, false] then 'removed'
    end
  end
end

================
File: models/concerns/pubsubable.rb
================
# frozen_string_literal: true

module Pubsubable
  extend ActiveSupport::Concern

  included do
    # Used by the actionCable/PubSub Service we use for real time communications
    has_secure_token :pubsub_token
    before_save :rotate_pubsub_token
  end

  def rotate_pubsub_token
    # ATM we are only rotating the token if the user is changing their password
    return unless is_a?(User)

    # Using the class method to avoid the extra Save
    # TODO: Should we do this on signin ?
    self.pubsub_token = self.class.generate_unique_secure_token if will_save_change_to_encrypted_password?
  end

  def pubsub_token
    # backfills tokens for existing records
    regenerate_pubsub_token if self[:pubsub_token].blank? && persisted?
    self[:pubsub_token]
  end
end

================
File: models/concerns/push_data_helper.rb
================
module PushDataHelper
  extend ActiveSupport::Concern

  def push_event_data
    Conversations::EventDataPresenter.new(self).push_data
  end

  def lock_event_data
    Conversations::EventDataPresenter.new(self).lock_data
  end

  def webhook_data
    Conversations::EventDataPresenter.new(self).push_data
  end
end

================
File: models/concerns/reauthorizable.rb
================
# This concern is primarily targeted for business models dependent on external services
# The auth tokens we obtained on their behalf could expire or becomes invalid.
# We would be aware of it until we make the API call to the service and it throws error

# Example:
# when a user changes his/her password, the auth token they provided to chatwoot becomes invalid

# This module helps to capture the errors into a counter and when threshold is passed would mark
# the object to be reauthorized. We will also send an email to the owners alerting them of the error.

# In the UI, we will check for the reauthorization_required? status and prompt the reauthorization flow

module Reauthorizable
  extend ActiveSupport::Concern

  AUTHORIZATION_ERROR_THRESHOLD = 2

  # model attribute
  def reauthorization_required?
    ::Redis::Alfred.get(reauthorization_required_key).present?
  end

  # model attribute
  def authorization_error_count
    ::Redis::Alfred.get(authorization_error_count_key).to_i
  end

  # action to be performed when we receive authorization errors
  # Implement in your exception handling logic for authorization errors
  def authorization_error!
    ::Redis::Alfred.incr(authorization_error_count_key)
    # we are giving precendence to the authorization error threshhold defined in the class
    # so that channels can override the default value
    prompt_reauthorization! if authorization_error_count >= self.class::AUTHORIZATION_ERROR_THRESHOLD
  end

  # Performed automatically if error threshold is breached
  # could used to manually prompt reauthorization if auth scope changes
  def prompt_reauthorization!
    ::Redis::Alfred.set(reauthorization_required_key, true)

    mailer = AdministratorNotifications::ChannelNotificationsMailer.with(account: account)

    case self.class.name
    when 'Integrations::Hook'
      process_integration_hook_reauthorization_emails(mailer)
    when 'Channel::FacebookPage'
      mailer.facebook_disconnect(inbox).deliver_later
    when 'Channel::Whatsapp'
      mailer.whatsapp_disconnect(inbox).deliver_later
    when 'Channel::Email'
      mailer.email_disconnect(inbox).deliver_later
    when 'AutomationRule'
      update!(active: false)
      mailer.automation_rule_disabled(self).deliver_later
    end

    invalidate_inbox_cache unless instance_of?(::AutomationRule)
  end

  def process_integration_hook_reauthorization_emails(mailer)
    if slack?
      mailer.slack_disconnect.deliver_later
    elsif dialogflow?
      mailer.dialogflow_disconnect.deliver_later
    end
  end

  # call this after you successfully Reauthorized the object in UI
  def reauthorized!
    ::Redis::Alfred.delete(authorization_error_count_key)
    ::Redis::Alfred.delete(reauthorization_required_key)

    invalidate_inbox_cache unless instance_of?(::AutomationRule)
  end

  private

  def invalidate_inbox_cache
    inbox.update_account_cache if inbox.present?
  end

  def authorization_error_count_key
    format(::Redis::Alfred::AUTHORIZATION_ERROR_COUNT, obj_type: self.class.table_name.singularize, obj_id: id)
  end

  def reauthorization_required_key
    format(::Redis::Alfred::REAUTHORIZATION_REQUIRED, obj_type: self.class.table_name.singularize, obj_id: id)
  end
end

================
File: models/concerns/reportable.rb
================
# frozen_string_literal: true

module Reportable
  extend ActiveSupport::Concern

  included do
    has_many :reporting_events, dependent: :destroy
  end
end

================
File: models/concerns/sla_activity_message_handler.rb
================
module SlaActivityMessageHandler
  extend ActiveSupport::Concern

  private

  def create_sla_change_activity(change_type, user_name)
    content = case change_type
              when 'added'
                I18n.t('conversations.activity.sla.added', user_name: user_name, sla_name: sla_policy_name)
              when 'removed'
                I18n.t('conversations.activity.sla.removed', user_name: user_name, sla_name: sla_policy_name)
              when 'updated'
                I18n.t('conversations.activity.sla.updated', user_name: user_name, sla_name: sla_policy_name)
              end
    ::Conversations::ActivityMessageJob.perform_later(self, activity_message_params(content)) if content
  end

  def sla_policy_name
    SlaPolicy.find_by(id: sla_policy_id)&.name || ''
  end

  def determine_sla_change_type
    sla_policy_id_before, sla_policy_id_after = previous_changes[:sla_policy_id]

    if sla_policy_id_before.nil? && sla_policy_id_after.present?
      'added'
    elsif sla_policy_id_before.present? && sla_policy_id_after.nil?
      'removed'
    end
  end
end

================
File: models/concerns/sort_handler.rb
================
module SortHandler
  extend ActiveSupport::Concern

  class_methods do
    def sort_on_last_activity_at(sort_direction = :desc)
      order(last_activity_at: sort_direction)
    end

    def sort_on_created_at(sort_direction = :asc)
      order(created_at: sort_direction)
    end

    def sort_on_priority(sort_direction = :desc)
      order(generate_sql_query("priority #{sort_direction.to_s.upcase} NULLS LAST, last_activity_at DESC"))
    end

    def sort_on_waiting_since(sort_direction = :asc)
      order(generate_sql_query("waiting_since #{sort_direction.to_s.upcase} NULLS LAST, created_at ASC"))
    end

    def last_messaged_conversations
      Message.except(:order).select(
        'DISTINCT ON (conversation_id) conversation_id, id, created_at, message_type'
      ).order('conversation_id, created_at DESC')
    end

    def sort_on_last_user_message_at
      order('grouped_conversations.message_type', 'grouped_conversations.created_at ASC')
    end

    private

    def generate_sql_query(query)
      Arel::Nodes::SqlLiteral.new(sanitize_sql_for_order(query))
    end
  end
end

================
File: models/concerns/sso_authenticatable.rb
================
module SsoAuthenticatable
  extend ActiveSupport::Concern

  def generate_sso_auth_token
    token = SecureRandom.hex(32)
    ::Redis::Alfred.setex(sso_token_key(token), true, 5.minutes)
    token
  end

  def invalidate_sso_auth_token(token)
    ::Redis::Alfred.delete(sso_token_key(token))
  end

  def valid_sso_auth_token?(token)
    ::Redis::Alfred.get(sso_token_key(token)).present?
  end

  def generate_sso_link
    encoded_email = ERB::Util.url_encode(email)
    "#{ENV.fetch('FRONTEND_URL', nil)}/app/login?email=#{encoded_email}&sso_auth_token=#{generate_sso_auth_token}"
  end

  private

  def sso_token_key(token)
    format(::Redis::RedisKeys::USER_SSO_AUTH_TOKEN, user_id: id, token: token)
  end
end

================
File: models/concerns/team_activity_message_handler.rb
================
module TeamActivityMessageHandler
  extend ActiveSupport::Concern

  private

  def create_team_change_activity(user_name)
    user_name = activity_message_owner(user_name)
    return unless user_name

    key = generate_team_change_activity_key
    params = { assignee_name: assignee&.name, team_name: team&.name, user_name: user_name }
    params[:team_name] = generate_team_name_for_activity if key == 'removed'
    content = I18n.t("conversations.activity.team.#{key}", **params)

    ::Conversations::ActivityMessageJob.perform_later(self, activity_message_params(content)) if content
  end

  def generate_team_change_activity_key
    team = Team.find_by(id: team_id)
    key = team.present? ? 'assigned' : 'removed'
    key += '_with_assignee' if key == 'assigned' && saved_change_to_assignee_id? && assignee
    key
  end

  def generate_team_name_for_activity
    previous_team_id = previous_changes[:team_id][0]
    Team.find_by(id: previous_team_id)&.name if previous_team_id.present?
  end
end

================
File: models/concerns/user_attribute_helpers.rb
================
module UserAttributeHelpers
  extend ActiveSupport::Concern

  def available_name
    self[:display_name].presence || name
  end

  def availability_status
    current_account_user&.availability_status
  end

  def auto_offline
    current_account_user&.auto_offline
  end

  def inviter
    current_account_user&.inviter
  end

  def active_account_user
    account_users.order(active_at: :desc)&.first
  end

  def current_account_user
    # We want to avoid subsequent queries in case where the association is preloaded.
    # using where here will trigger n+1 queries.
    account_users.find { |ac_usr| ac_usr.account_id == Current.account.id } if Current.account
  end

  def account
    current_account_user&.account
  end

  def administrator?
    current_account_user&.administrator?
  end

  def agent?
    current_account_user&.agent?
  end

  def role
    current_account_user&.role
  end

  # Used internally for Chatwoot in Chatwoot
  def hmac_identifier
    hmac_key = GlobalConfig.get('CHATWOOT_INBOX_HMAC_KEY')['CHATWOOT_INBOX_HMAC_KEY']
    return OpenSSL::HMAC.hexdigest('sha256', hmac_key, email) if hmac_key.present?

    ''
  end
end

================
File: models/integrations/app.rb
================
class Integrations::App
  include Linear::IntegrationHelper
  attr_accessor :params

  def initialize(params)
    @params = params
  end

  def id
    params[:id]
  end

  def name
    I18n.t("integration_apps.#{params[:i18n_key]}.name")
  end

  def description
    I18n.t("integration_apps.#{params[:i18n_key]}.description")
  end

  def logo
    params[:logo]
  end

  def fields
    params[:fields]
  end

  # There is no way to get the account_id from the linear callback
  # so we are using the generate_linear_token method to generate a token and encode it in the state parameter
  def encode_state
    generate_linear_token(Current.account.id)
  end

  def action
    case params[:id]
    when 'slack'
      "#{params[:action]}&client_id=#{ENV.fetch('SLACK_CLIENT_ID', nil)}&redirect_uri=#{self.class.slack_integration_url}"
    when 'linear'
      build_linear_action
    else
      params[:action]
    end
  end

  def active?(account)
    case params[:id]
    when 'slack'
      ENV['SLACK_CLIENT_SECRET'].present?
    when 'linear'
      account.feature_enabled?('linear_integration')
    else
      true
    end
  end

  def build_linear_action
    app_id = GlobalConfigService.load('LINEAR_CLIENT_ID', nil)
    [
      "#{params[:action]}?response_type=code",
      "client_id=#{app_id}",
      "redirect_uri=#{self.class.linear_integration_url}",
      "state=#{encode_state}",
      'scope=read,write',
      'prompt=consent'
    ].join('&')
  end

  def enabled?(account)
    case params[:id]
    when 'webhook'
      account.webhooks.exists?
    when 'dashboard_apps'
      account.dashboard_apps.exists?
    else
      account.hooks.exists?(app_id: id)
    end
  end

  def hooks
    Current.account.hooks.where(app_id: id)
  end

  def self.slack_integration_url
    "#{ENV.fetch('FRONTEND_URL', nil)}/app/accounts/#{Current.account.id}/settings/integrations/slack"
  end

  def self.linear_integration_url
    "#{ENV.fetch('FRONTEND_URL', nil)}/linear/callback"
  end

  class << self
    def apps
      Hashie::Mash.new(APPS_CONFIG)
    end

    def all
      apps.values.each_with_object([]) do |app, result|
        result << new(app)
      end
    end

    def find(params)
      all.detect { |app| app.id == params[:id] }
    end
  end
end

================
File: models/integrations/hook.rb
================
# == Schema Information
#
# Table name: integrations_hooks
#
#  id           :bigint           not null, primary key
#  access_token :string
#  hook_type    :integer          default("account")
#  settings     :jsonb
#  status       :integer          default("enabled")
#  created_at   :datetime         not null
#  updated_at   :datetime         not null
#  account_id   :integer
#  app_id       :string
#  inbox_id     :integer
#  reference_id :string
#
class Integrations::Hook < ApplicationRecord
  include Reauthorizable

  attr_readonly :app_id, :account_id, :inbox_id, :hook_type
  before_validation :ensure_hook_type

  validates :account_id, presence: true
  validates :app_id, presence: true
  validates :inbox_id, presence: true, if: -> { hook_type == 'inbox' }
  validate :validate_settings_json_schema
  validates :app_id, uniqueness: { scope: [:account_id], unless: -> { app.present? && app.params[:allow_multiple_hooks].present? } }

  # TODO: This seems to be only used for slack at the moment
  # We can add a validator when storing the integration settings and toggle this in future
  enum status: { disabled: 0, enabled: 1 }

  belongs_to :account
  belongs_to :inbox, optional: true
  has_secure_token :access_token

  enum hook_type: { account: 0, inbox: 1 }

  def app
    @app ||= Integrations::App.find(id: app_id)
  end

  def slack?
    app_id == 'slack'
  end

  def dialogflow?
    app_id == 'dialogflow'
  end

  def disable
    update(status: 'disabled')
  end

  def process_event(event)
    case app_id
    when 'openai'
      Integrations::Openai::ProcessorService.new(hook: self, event: event).perform if app_id == 'openai'
    else
      { error: 'No processor found' }
    end
  end

  private

  def ensure_hook_type
    self.hook_type = app.params[:hook_type] if app.present?
  end

  def validate_settings_json_schema
    return if app.blank? || app.params[:settings_json_schema].blank?

    errors.add(:settings, ': Invalid settings data') unless JSONSchemer.schema(app.params[:settings_json_schema]).valid?(settings)
  end
end

================
File: models/access_token.rb
================
# == Schema Information
#
# Table name: access_tokens
#
#  id         :bigint           not null, primary key
#  owner_type :string
#  token      :string
#  created_at :datetime         not null
#  updated_at :datetime         not null
#  owner_id   :bigint
#
# Indexes
#
#  index_access_tokens_on_owner_type_and_owner_id  (owner_type,owner_id)
#  index_access_tokens_on_token                    (token) UNIQUE
#

class AccessToken < ApplicationRecord
  has_secure_token :token
  belongs_to :owner, polymorphic: true
end

================
File: models/account_user.rb
================
# == Schema Information
#
# Table name: account_users
#
#  id             :bigint           not null, primary key
#  active_at      :datetime
#  auto_offline   :boolean          default(TRUE), not null
#  availability   :integer          default("online"), not null
#  role           :integer          default("agent")
#  created_at     :datetime         not null
#  updated_at     :datetime         not null
#  account_id     :bigint
#  custom_role_id :bigint
#  inviter_id     :bigint
#  user_id        :bigint
#
# Indexes
#
#  index_account_users_on_account_id      (account_id)
#  index_account_users_on_custom_role_id  (custom_role_id)
#  index_account_users_on_user_id         (user_id)
#  uniq_user_id_per_account_id            (account_id,user_id) UNIQUE
#

class AccountUser < ApplicationRecord
  include AvailabilityStatusable

  belongs_to :account
  belongs_to :user
  belongs_to :inviter, class_name: 'User', optional: true

  enum role: { agent: 0, administrator: 1 }
  enum availability: { online: 0, offline: 1, busy: 2 }

  accepts_nested_attributes_for :account

  after_create_commit :notify_creation, :create_notification_setting
  after_destroy :notify_deletion, :remove_user_from_account
  after_save :update_presence_in_redis, if: :saved_change_to_availability?

  validates :user_id, uniqueness: { scope: :account_id }

  def create_notification_setting
    setting = user.notification_settings.new(account_id: account.id)
    setting.selected_email_flags = [:email_conversation_assignment]
    setting.selected_push_flags = [:push_conversation_assignment]
    setting.save!
  end

  def remove_user_from_account
    ::Agents::DestroyJob.perform_later(account, user)
  end

  def permissions
    administrator? ? ['administrator'] : ['agent']
  end

  def push_event_data
    {
      id: id,
      availability: availability,
      role: role,
      user_id: user_id
    }
  end

  private

  def notify_creation
    Rails.configuration.dispatcher.dispatch(AGENT_ADDED, Time.zone.now, account: account)
  end

  def notify_deletion
    Rails.configuration.dispatcher.dispatch(AGENT_REMOVED, Time.zone.now, account: account)
  end

  def update_presence_in_redis
    OnlineStatusTracker.set_status(account.id, user.id, availability)
  end
end

AccountUser.prepend_mod_with('AccountUser')
AccountUser.include_mod_with('Audit::AccountUser')
AccountUser.include_mod_with('Concerns::AccountUser')

================
File: models/account.rb
================
# == Schema Information
#
# Table name: accounts
#
#  id                         :integer          not null, primary key
#  auto_resolve_duration      :integer
#  contactable_contacts_count :integer          default(0)
#  custom_attributes          :jsonb
#  domain                     :string(100)
#  feature_flags              :bigint           default(0), not null
#  internal_attributes        :jsonb            not null
#  limits                     :jsonb
#  locale                     :integer          default("en")
#  name                       :string           not null
#  status                     :integer          default("active")
#  support_email              :string(100)
#  created_at                 :datetime         not null
#  updated_at                 :datetime         not null
#
# Indexes
#
#  index_accounts_on_status  (status)
#

class Account < ApplicationRecord
  # used for single column multi flags
  include FlagShihTzu
  include Reportable
  include Featurable
  include CacheKeys

  DEFAULT_QUERY_SETTING = {
    flag_query_mode: :bit_operator,
    check_for_column: false
  }.freeze

  validates :auto_resolve_duration, numericality: { greater_than_or_equal_to: 1, less_than_or_equal_to: 999, allow_nil: true }
  validates :domain, length: { maximum: 100 }

  has_many :account_users, dependent: :destroy_async
  has_many :agent_bot_inboxes, dependent: :destroy_async
  has_many :agent_bots, dependent: :destroy_async
  has_many :api_channels, dependent: :destroy_async, class_name: '::Channel::Api'
  has_many :articles, dependent: :destroy_async, class_name: '::Article'
  has_many :automation_rules, dependent: :destroy_async
  has_many :macros, dependent: :destroy_async
  has_many :campaigns, dependent: :destroy_async
  has_many :canned_responses, dependent: :destroy_async
  has_many :categories, dependent: :destroy_async, class_name: '::Category'
  has_many :contacts, dependent: :destroy_async
  has_many :conversations, dependent: :destroy_async
  has_many :csat_survey_responses, dependent: :destroy_async
  has_many :custom_attribute_definitions, dependent: :destroy_async
  has_many :custom_filters, dependent: :destroy_async
  has_many :dashboard_apps, dependent: :destroy_async
  has_many :data_imports, dependent: :destroy_async
  has_many :email_channels, dependent: :destroy_async, class_name: '::Channel::Email'
  has_many :facebook_pages, dependent: :destroy_async, class_name: '::Channel::FacebookPage'
  has_many :hooks, dependent: :destroy_async, class_name: 'Integrations::Hook'
  has_many :inboxes, dependent: :destroy_async
  has_many :labels, dependent: :destroy_async
  has_many :line_channels, dependent: :destroy_async, class_name: '::Channel::Line'
  has_many :mentions, dependent: :destroy_async
  has_many :messages, dependent: :destroy_async
  has_many :notes, dependent: :destroy_async
  has_many :notification_settings, dependent: :destroy_async
  has_many :notifications, dependent: :destroy_async
  has_many :portals, dependent: :destroy_async, class_name: '::Portal'
  has_many :sms_channels, dependent: :destroy_async, class_name: '::Channel::Sms'
  has_many :teams, dependent: :destroy_async
  has_many :telegram_bots, dependent: :destroy_async
  has_many :telegram_channels, dependent: :destroy_async, class_name: '::Channel::Telegram'
  has_many :twilio_sms, dependent: :destroy_async, class_name: '::Channel::TwilioSms'
  has_many :twitter_profiles, dependent: :destroy_async, class_name: '::Channel::TwitterProfile'
  has_many :users, through: :account_users
  has_many :web_widgets, dependent: :destroy_async, class_name: '::Channel::WebWidget'
  has_many :webhooks, dependent: :destroy_async
  has_many :whatsapp_channels, dependent: :destroy_async, class_name: '::Channel::Whatsapp'
  has_many :working_hours, dependent: :destroy_async

  has_one_attached :contacts_export

  enum locale: LANGUAGES_CONFIG.map { |key, val| [val[:iso_639_1_code], key] }.to_h
  enum status: { active: 0, suspended: 1 }

  before_validation :validate_limit_keys
  after_create_commit :notify_creation
  after_destroy :remove_account_sequences

  def agents
    users.where(account_users: { role: :agent })
  end

  def administrators
    users.where(account_users: { role: :administrator })
  end

  def all_conversation_tags
    # returns array of tags
    conversation_ids = conversations.pluck(:id)
    ActsAsTaggableOn::Tagging.includes(:tag)
                             .where(context: 'labels',
                                    taggable_type: 'Conversation',
                                    taggable_id: conversation_ids)
                             .map { |tagging| tagging.tag.name }
  end

  def webhook_data
    {
      id: id,
      name: name
    }
  end

  def inbound_email_domain
    domain.presence || GlobalConfig.get('MAILER_INBOUND_EMAIL_DOMAIN')['MAILER_INBOUND_EMAIL_DOMAIN'] || ENV.fetch('MAILER_INBOUND_EMAIL_DOMAIN',
                                                                                                                   false)
  end

  def support_email
    super.presence || ENV.fetch('MAILER_SENDER_EMAIL') { GlobalConfig.get('MAILER_SUPPORT_EMAIL')['MAILER_SUPPORT_EMAIL'] }
  end

  def usage_limits
    {
      agents: ChatwootApp.max_limit.to_i,
      inboxes: ChatwootApp.max_limit.to_i
    }
  end

  private

  def notify_creation
    Rails.configuration.dispatcher.dispatch(ACCOUNT_CREATED, Time.zone.now, account: self)
  end

  trigger.after(:insert).for_each(:row) do
    "execute format('create sequence IF NOT EXISTS conv_dpid_seq_%s', NEW.id);"
  end

  trigger.name('camp_dpid_before_insert').after(:insert).for_each(:row) do
    "execute format('create sequence IF NOT EXISTS camp_dpid_seq_%s', NEW.id);"
  end

  def validate_limit_keys
    # method overridden in enterprise module
  end

  def remove_account_sequences
    ActiveRecord::Base.connection.exec_query("drop sequence IF EXISTS camp_dpid_seq_#{id}")
    ActiveRecord::Base.connection.exec_query("drop sequence IF EXISTS conv_dpid_seq_#{id}")
  end
end

Account.prepend_mod_with('Account')
Account.include_mod_with('Concerns::Account')
Account.include_mod_with('Audit::Account')

================
File: models/agent_bot_inbox.rb
================
# == Schema Information
#
# Table name: agent_bot_inboxes
#
#  id           :bigint           not null, primary key
#  status       :integer          default("active")
#  created_at   :datetime         not null
#  updated_at   :datetime         not null
#  account_id   :integer
#  agent_bot_id :integer
#  inbox_id     :integer
#

class AgentBotInbox < ApplicationRecord
  validates :inbox_id, presence: true
  validates :agent_bot_id, presence: true
  before_validation :ensure_account_id

  belongs_to :inbox
  belongs_to :agent_bot
  belongs_to :account
  enum status: { active: 0, inactive: 1 }

  private

  def ensure_account_id
    self.account_id = inbox&.account_id
  end
end

================
File: models/agent_bot.rb
================
# == Schema Information
#
# Table name: agent_bots
#
#  id           :bigint           not null, primary key
#  bot_config   :jsonb
#  bot_type     :integer          default("webhook")
#  description  :string
#  name         :string
#  outgoing_url :string
#  created_at   :datetime         not null
#  updated_at   :datetime         not null
#  account_id   :bigint
#
# Indexes
#
#  index_agent_bots_on_account_id  (account_id)
#

class AgentBot < ApplicationRecord
  include AccessTokenable
  include Avatarable

  has_many :agent_bot_inboxes, dependent: :destroy_async
  has_many :inboxes, through: :agent_bot_inboxes
  has_many :messages, as: :sender, dependent: :nullify
  belongs_to :account, optional: true
  enum bot_type: { webhook: 0, csml: 1 }

  validate :validate_agent_bot_config
  validates :outgoing_url, length: { maximum: Limits::URL_LENGTH_LIMIT }

  def available_name
    name
  end

  def push_event_data(inbox = nil)
    {
      id: id,
      name: name,
      avatar_url: avatar_url || inbox&.avatar_url,
      type: 'agent_bot'
    }
  end

  def webhook_data
    {
      id: id,
      name: name,
      type: 'agent_bot'
    }
  end

  private

  def validate_agent_bot_config
    errors.add(:bot_config, 'Invalid Bot Configuration') unless AgentBots::ValidateBotService.new(agent_bot: self).perform
  end
end

================
File: models/application_record.rb
================
class ApplicationRecord < ActiveRecord::Base
  include Events::Types
  self.abstract_class = true

  before_validation :validates_column_content_length

  # the models that exposed in email templates through liquid
  def droppables
    %w[Account Channel Conversation Inbox User Message]
  end

  # ModelDrop class should exist in app/drops
  def to_drop
    return unless droppables.include?(self.class.name)

    "#{self.class.name}Drop".constantize.new(self)
  end

  private

  # Generic validation for all columns of type string and text
  # Validates the length of the column to prevent DOS via large payloads
  # if a custom length validation is already present, skip the validation
  def validates_column_content_length
    self.class.columns.each do |column|
      check_and_validate_content_length(column) if column_of_type_string_or_text?(column)
    end
  end

  def column_of_type_string_or_text?(column)
    %i[string text].include?(column.type)
  end

  def check_and_validate_content_length(column)
    length_validator = self.class.validators_on(column.name).find { |v| v.kind == :length }
    validate_content_length(column) if length_validator.blank?
  end

  def validate_content_length(column)
    max_length = column.type == :text ? 20_000 : 255
    return if self[column.name].nil? || self[column.name].length <= max_length

    errors.add(column.name.to_sym, "is too long (maximum is #{max_length} characters)")
  end

  def normalize_empty_string_to_nil(attrs = [])
    attrs.each do |attr|
      self[attr] = nil if self[attr].blank?
    end
  end
end

ApplicationRecord.prepend_mod_with('ApplicationRecord')

================
File: models/article.rb
================
# == Schema Information
#
# Table name: articles
#
#  id                    :bigint           not null, primary key
#  content               :text
#  description           :text
#  locale                :string           default("en"), not null
#  meta                  :jsonb
#  position              :integer
#  slug                  :string           not null
#  status                :integer
#  title                 :string
#  views                 :integer
#  created_at            :datetime         not null
#  updated_at            :datetime         not null
#  account_id            :integer          not null
#  associated_article_id :bigint
#  author_id             :bigint
#  category_id           :integer
#  folder_id             :integer
#  portal_id             :integer          not null
#
# Indexes
#
#  index_articles_on_associated_article_id  (associated_article_id)
#  index_articles_on_author_id              (author_id)
#  index_articles_on_slug                   (slug) UNIQUE
#
class Article < ApplicationRecord
  include PgSearch::Model

  has_many :associated_articles,
           class_name: :Article,
           foreign_key: :associated_article_id,
           dependent: :nullify,
           inverse_of: 'root_article'

  belongs_to :root_article,
             class_name: :Article,
             foreign_key: :associated_article_id,
             inverse_of: :associated_articles,
             optional: true
  belongs_to :account
  belongs_to :category, optional: true
  belongs_to :portal
  belongs_to :author, class_name: 'User', inverse_of: :articles

  before_validation :ensure_account_id
  before_validation :ensure_article_slug
  before_validation :ensure_locale_in_article

  validates :account_id, presence: true
  validates :author_id, presence: true
  validates :title, presence: true
  validates :content, presence: true

  # ensuring that the position is always set correctly
  before_create :add_position_to_article
  after_save :category_id_changed_action, if: :saved_change_to_category_id?

  enum status: { draft: 0, published: 1, archived: 2 }

  scope :search_by_category_slug, ->(category_slug) { where(categories: { slug: category_slug }) if category_slug.present? }
  scope :search_by_category_locale, ->(locale) { where(categories: { locale: locale }) if locale.present? }
  scope :search_by_locale, ->(locale) { where(locale: locale) if locale.present? }
  scope :search_by_author, ->(author_id) { where(author_id: author_id) if author_id.present? }
  scope :search_by_status, ->(status) { where(status: status) if status.present? }
  scope :order_by_updated_at, -> { reorder(updated_at: :desc) }
  scope :order_by_position, -> { reorder(position: :asc) }
  scope :order_by_views, -> { reorder(views: :desc) }

  # TODO: if text search slows down https://www.postgresql.org/docs/current/textsearch-features.html#TEXTSEARCH-UPDATE-TRIGGERS
  pg_search_scope(
    :text_search,
    against: %i[
      title
      description
      content
    ],
    using: {
      tsearch: {
        prefix: true
      }
    }
  )

  def self.search(params)
    records = left_outer_joins(
      :category
    ).search_by_category_slug(
      params[:category_slug]
    ).search_by_locale(params[:locale]).search_by_author(params[:author_id]).search_by_status(params[:status])

    records = records.text_search(params[:query]) if params[:query].present?
    records
  end

  def associate_root_article(associated_article_id)
    article = portal.articles.find(associated_article_id) if associated_article_id.present?

    return if article.nil?

    root_article_id = self.class.find_root_article_id(article)

    update(associated_article_id: root_article_id) if root_article_id.present?
  end

  # Make sure we always associate the parent's associated id to avoid the deeper associations od articles.
  def self.find_root_article_id(article)
    article.associated_article_id || article.id
  end

  def draft!
    update(status: :draft)
  end

  def increment_view_count
    # rubocop:disable Rails/SkipsModelValidations
    update_column(:views, views? ? views + 1 : 1)
    # rubocop:enable Rails/SkipsModelValidations
  end

  def self.update_positions(positions_hash)
    positions_hash.each do |article_id, new_position|
      # Find the article by its ID and update its position
      article = Article.find(article_id)
      article.update!(position: new_position)
    end
  end

  private

  def category_id_changed_action
    # We need to update the position of the article in the new category
    return unless persisted?

    # this means the article is just created
    # and the category_id is newly set
    # and the position is already present
    return if created_at_before_last_save.nil? && position.present? && category_id_before_last_save.nil?

    update_article_position_in_category
  end

  def ensure_locale_in_article
    self.locale = if category.present?
                    category.locale
                  else
                    locale.presence || portal.default_locale
                  end
  end

  def add_position_to_article
    # on creation if a position is already present, ignore it
    return if position.present?

    update_article_position_in_category
  end

  def update_article_position_in_category
    max_position = Article.where(category_id: category_id, account_id: account_id).maximum(:position)

    new_position = max_position.present? ? max_position + 10 : 10

    # update column to avoid validations if the article is already persisted
    if persisted?
      # rubocop:disable Rails/SkipsModelValidations
      update_column(:position, new_position)
      # rubocop:enable Rails/SkipsModelValidations
    else
      self.position = new_position
    end
  end

  def ensure_account_id
    self.account_id = portal&.account_id
  end

  def ensure_article_slug
    self.slug ||= "#{Time.now.utc.to_i}-#{title.underscore.parameterize(separator: '-')}" if title.present?
  end
end
Article.include_mod_with('Concerns::Article')

================
File: models/attachment.rb
================
# == Schema Information
#
# Table name: attachments
#
#  id               :integer          not null, primary key
#  coordinates_lat  :float            default(0.0)
#  coordinates_long :float            default(0.0)
#  extension        :string
#  external_url     :string
#  fallback_title   :string
#  file_type        :integer          default("image")
#  meta             :jsonb
#  created_at       :datetime         not null
#  updated_at       :datetime         not null
#  account_id       :integer          not null
#  message_id       :integer          not null
#
# Indexes
#
#  index_attachments_on_account_id  (account_id)
#  index_attachments_on_message_id  (message_id)
#

class Attachment < ApplicationRecord
  include Rails.application.routes.url_helpers

  ACCEPTABLE_FILE_TYPES = %w[
    text/csv text/plain text/rtf
    application/json application/pdf
    application/zip application/x-7z-compressed application/vnd.rar application/x-tar
    application/msword application/vnd.ms-excel application/vnd.ms-powerpoint application/rtf
    application/vnd.oasis.opendocument.text
    application/vnd.openxmlformats-officedocument.presentationml.presentation
    application/vnd.openxmlformats-officedocument.spreadsheetml.sheet
    application/vnd.openxmlformats-officedocument.wordprocessingml.document
  ].freeze
  belongs_to :account
  belongs_to :message
  has_one_attached :file
  validate :acceptable_file
  validates :external_url, length: { maximum: Limits::URL_LENGTH_LIMIT }
  enum file_type: { :image => 0, :audio => 1, :video => 2, :file => 3, :location => 4, :fallback => 5, :share => 6, :story_mention => 7,
                    :contact => 8, :ig_reel => 9 }

  def push_event_data
    return unless file_type
    return base_data.merge(location_metadata) if file_type.to_sym == :location
    return base_data.merge(fallback_data) if file_type.to_sym == :fallback
    return base_data.merge(contact_metadata) if file_type.to_sym == :contact

    base_data.merge(file_metadata)
  end

  # NOTE: the URl returned does a 301 redirect to the actual file
  def file_url
    file.attached? ? url_for(file) : ''
  end

  # NOTE: for External services use this methods since redirect doesn't work effectively in a lot of cases
  def download_url
    ActiveStorage::Current.url_options = Rails.application.routes.default_url_options if ActiveStorage::Current.url_options.blank?
    file.attached? ? file.blob.url : ''
  end

  def thumb_url
    if file.attached? && file.representable?
      url_for(file.representation(resize_to_fill: [250, nil]))
    else
      ''
    end
  end

  def with_attached_file?
    [:image, :audio, :video, :file].include?(file_type.to_sym)
  end

  private

  def file_metadata
    metadata = {
      extension: extension,
      data_url: file_url,
      thumb_url: thumb_url,
      file_size: file.byte_size,
      width: file.metadata[:width],
      height: file.metadata[:height]
    }

    metadata[:data_url] = metadata[:thumb_url] = external_url if message.inbox.instagram? && message.incoming?
    metadata
  end

  def location_metadata
    {
      coordinates_lat: coordinates_lat,
      coordinates_long: coordinates_long,
      fallback_title: fallback_title,
      data_url: external_url
    }
  end

  def fallback_data
    {
      fallback_title: fallback_title,
      data_url: external_url
    }
  end

  def base_data
    {
      id: id,
      message_id: message_id,
      file_type: file_type,
      account_id: account_id
    }
  end

  def contact_metadata
    {
      fallback_title: fallback_title,
      meta: meta || {}
    }
  end

  def should_validate_file?
    return unless file.attached?
    # we are only limiting attachment types in case of website widget
    return unless message.inbox.channel_type == 'Channel::WebWidget'

    true
  end

  def acceptable_file
    return unless should_validate_file?

    validate_file_size(file.byte_size)
    validate_file_content_type(file.content_type)
  end

  def validate_file_content_type(file_content_type)
    errors.add(:file, 'type not supported') unless media_file?(file_content_type) || ACCEPTABLE_FILE_TYPES.include?(file_content_type)
  end

  def validate_file_size(byte_size)
    errors.add(:file, 'size is too big') if byte_size > 40.megabytes
  end

  def media_file?(file_content_type)
    file_content_type.start_with?('image/', 'video/', 'audio/')
  end
end

================
File: models/automation_rule.rb
================
# == Schema Information
#
# Table name: automation_rules
#
#  id          :bigint           not null, primary key
#  actions     :jsonb            not null
#  active      :boolean          default(TRUE), not null
#  conditions  :jsonb            not null
#  description :text
#  event_name  :string           not null
#  name        :string           not null
#  created_at  :datetime         not null
#  updated_at  :datetime         not null
#  account_id  :bigint           not null
#
# Indexes
#
#  index_automation_rules_on_account_id  (account_id)
#
class AutomationRule < ApplicationRecord
  include Rails.application.routes.url_helpers
  include Reauthorizable

  belongs_to :account
  has_many_attached :files

  validate :json_conditions_format
  validate :json_actions_format
  validate :query_operator_presence
  validate :query_operator_value
  validates :account_id, presence: true

  after_update_commit :reauthorized!, if: -> { saved_change_to_conditions? }

  scope :active, -> { where(active: true) }

  def conditions_attributes
    %w[content email country_code status message_type browser_language assignee_id team_id referer city company inbox_id
       mail_subject phone_number priority conversation_language]
  end

  def actions_attributes
    %w[send_message add_label remove_label send_email_to_team assign_team assign_agent send_webhook_event mute_conversation
       send_attachment change_status resolve_conversation snooze_conversation change_priority send_email_transcript].freeze
  end

  def file_base_data
    files.map do |file|
      {
        id: file.id,
        automation_rule_id: id,
        file_type: file.content_type,
        account_id: account_id,
        file_url: url_for(file),
        blob_id: file.blob_id,
        filename: file.filename.to_s
      }
    end
  end

  private

  def json_conditions_format
    return if conditions.blank?

    attributes = conditions.map { |obj, _| obj['attribute_key'] }
    conditions = attributes - conditions_attributes
    conditions -= account.custom_attribute_definitions.pluck(:attribute_key)
    errors.add(:conditions, "Automation conditions #{conditions.join(',')} not supported.") if conditions.any?
  end

  def json_actions_format
    return if actions.blank?

    attributes = actions.map { |obj, _| obj['action_name'] }
    actions = attributes - actions_attributes

    errors.add(:actions, "Automation actions #{actions.join(',')} not supported.") if actions.any?
  end

  def query_operator_presence
    return if conditions.blank?

    operators = conditions.select { |obj, _| obj['query_operator'].nil? }
    errors.add(:conditions, 'Automation conditions should have query operator.') if operators.length > 1
  end

  # This validation ensures logical operators are being used correctly in automation conditions.
  # And we don't push any unsanitized query operators to the database.
  def query_operator_value
    conditions.each do |obj|
      validate_single_condition(obj)
    end
  end

  def validate_single_condition(condition)
    query_operator = condition['query_operator']

    return if query_operator.nil?
    return if query_operator.empty?

    operator = query_operator.upcase
    errors.add(:conditions, 'Query operator must be either "AND" or "OR"') unless %w[AND OR].include?(operator)
  end
end

AutomationRule.include_mod_with('Audit::AutomationRule')
AutomationRule.prepend_mod_with('AutomationRule')

================
File: models/campaign.rb
================
# == Schema Information
#
# Table name: campaigns
#
#  id                                 :bigint           not null, primary key
#  audience                           :jsonb
#  campaign_status                    :integer          default("active"), not null
#  campaign_type                      :integer          default("ongoing"), not null
#  description                        :text
#  enabled                            :boolean          default(TRUE)
#  message                            :text             not null
#  scheduled_at                       :datetime
#  title                              :string           not null
#  trigger_only_during_business_hours :boolean          default(FALSE)
#  trigger_rules                      :jsonb
#  created_at                         :datetime         not null
#  updated_at                         :datetime         not null
#  account_id                         :bigint           not null
#  display_id                         :integer          not null
#  inbox_id                           :bigint           not null
#  sender_id                          :integer
#
# Indexes
#
#  index_campaigns_on_account_id       (account_id)
#  index_campaigns_on_campaign_status  (campaign_status)
#  index_campaigns_on_campaign_type    (campaign_type)
#  index_campaigns_on_inbox_id         (inbox_id)
#  index_campaigns_on_scheduled_at     (scheduled_at)
#
class Campaign < ApplicationRecord
  include UrlHelper
  validates :account_id, presence: true
  validates :inbox_id, presence: true
  validates :title, presence: true
  validates :message, presence: true
  validate :validate_campaign_inbox
  validate :validate_url
  validate :prevent_completed_campaign_from_update, on: :update
  validate :sender_must_belong_to_account

  belongs_to :account
  belongs_to :inbox
  belongs_to :sender, class_name: 'User', optional: true

  enum campaign_type: { ongoing: 0, one_off: 1 }
  # TODO : enabled attribute is unneccessary . lets move that to the campaign status with additional statuses like draft, disabled etc.
  enum campaign_status: { active: 0, completed: 1 }

  has_many :conversations, dependent: :nullify, autosave: true

  before_validation :ensure_correct_campaign_attributes
  after_commit :set_display_id, unless: :display_id?

  def trigger!
    return unless one_off?
    return if completed?

    Twilio::OneoffSmsCampaignService.new(campaign: self).perform if inbox.inbox_type == 'Twilio SMS'
    Sms::OneoffSmsCampaignService.new(campaign: self).perform if inbox.inbox_type == 'Sms'
  end

  private

  def set_display_id
    reload
  end

  def validate_campaign_inbox
    return unless inbox

    errors.add :inbox, 'Unsupported Inbox type' unless ['Website', 'Twilio SMS', 'Sms'].include? inbox.inbox_type
  end

  # TO-DO we clean up with better validations when campaigns evolve into more inboxes
  def ensure_correct_campaign_attributes
    return if inbox.blank?

    if ['Twilio SMS', 'Sms'].include?(inbox.inbox_type)
      self.campaign_type = 'one_off'
      self.scheduled_at ||= Time.now.utc
    else
      self.campaign_type = 'ongoing'
      self.scheduled_at = nil
    end
  end

  def validate_url
    return unless trigger_rules['url']

    use_http_protocol = trigger_rules['url'].starts_with?('http://') || trigger_rules['url'].starts_with?('https://')
    errors.add(:url, 'invalid') if inbox.inbox_type == 'Website' && !use_http_protocol
  end

  def sender_must_belong_to_account
    return unless sender

    return if account.users.exists?(id: sender.id)

    errors.add(:sender_id, 'must belong to the same account as the campaign')
  end

  def prevent_completed_campaign_from_update
    errors.add :status, 'The campaign is already completed' if !campaign_status_changed? && completed?
  end

  # creating db triggers
  trigger.before(:insert).for_each(:row) do
    "NEW.display_id := nextval('camp_dpid_seq_' || NEW.account_id);"
  end
end

================
File: models/canned_response.rb
================
# == Schema Information
#
# Table name: canned_responses
#
#  id         :integer          not null, primary key
#  content    :text
#  short_code :string
#  created_at :datetime         not null
#  updated_at :datetime         not null
#  account_id :integer          not null
#

class CannedResponse < ApplicationRecord
  validates :content, presence: true
  validates :short_code, presence: true
  validates :account, presence: true
  validates :short_code, uniqueness: { scope: :account_id }

  belongs_to :account

  scope :order_by_search, lambda { |search|
    short_code_starts_with = sanitize_sql_array(['WHEN short_code ILIKE ? THEN 1', "#{search}%"])
    short_code_like = sanitize_sql_array(['WHEN short_code ILIKE ? THEN 0.5', "%#{search}%"])
    content_like = sanitize_sql_array(['WHEN content ILIKE ? THEN 0.2', "%#{search}%"])

    order_clause = "CASE #{short_code_starts_with} #{short_code_like} #{content_like} ELSE 0 END"

    order(Arel.sql(order_clause) => :desc)
  }
end

================
File: models/category.rb
================
# == Schema Information
#
# Table name: categories
#
#  id                     :bigint           not null, primary key
#  description            :text
#  icon                   :string           default("")
#  locale                 :string           default("en")
#  name                   :string
#  position               :integer
#  slug                   :string           not null
#  created_at             :datetime         not null
#  updated_at             :datetime         not null
#  account_id             :integer          not null
#  associated_category_id :bigint
#  parent_category_id     :bigint
#  portal_id              :integer          not null
#
# Indexes
#
#  index_categories_on_associated_category_id         (associated_category_id)
#  index_categories_on_locale                         (locale)
#  index_categories_on_locale_and_account_id          (locale,account_id)
#  index_categories_on_parent_category_id             (parent_category_id)
#  index_categories_on_slug_and_locale_and_portal_id  (slug,locale,portal_id) UNIQUE
#
class Category < ApplicationRecord
  belongs_to :account
  belongs_to :portal
  has_many :folders, dependent: :destroy_async
  has_many :articles, dependent: :nullify
  has_many :category_related_categories,
           class_name: :RelatedCategory,
           dependent: :destroy_async
  has_many :related_categories,
           through: :category_related_categories,
           class_name: :Category,
           dependent: :nullify
  has_many :sub_categories,
           class_name: :Category,
           foreign_key: :parent_category_id,
           dependent: :nullify,
           inverse_of: 'parent_category'
  has_many :associated_categories,
           class_name: :Category,
           foreign_key: :associated_category_id,
           dependent: :nullify,
           inverse_of: 'root_category'
  belongs_to :parent_category, class_name: :Category, optional: true
  belongs_to :root_category,
             class_name: :Category,
             foreign_key: :associated_category_id,
             inverse_of: :associated_categories,
             optional: true

  before_validation :ensure_account_id
  validates :account_id, presence: true
  validates :slug, presence: true
  validates :name, presence: true
  validate :allowed_locales
  validates :locale, uniqueness: { scope: %i[slug portal_id],
                                   message: I18n.t('errors.categories.locale.unique') }
  accepts_nested_attributes_for :related_categories

  scope :search_by_locale, ->(locale) { where(locale: locale) if locale.present? }

  def self.search(params)
    search_by_locale(params[:locale]).page(current_page(params)).order(position: :asc)
  end

  def self.current_page(params)
    params[:page] || 1
  end

  private

  def ensure_account_id
    self.account_id = portal&.account_id
  end

  def allowed_locales
    return if portal.blank?

    allowed_locales = portal.config['allowed_locales']

    return true if allowed_locales.include?(locale)

    errors.add(:locale, "#{locale} of category is not part of portal's #{allowed_locales}.")
  end
end

================
File: models/contact_inbox.rb
================
# == Schema Information
#
# Table name: contact_inboxes
#
#  id            :bigint           not null, primary key
#  hmac_verified :boolean          default(FALSE)
#  pubsub_token  :string
#  created_at    :datetime         not null
#  updated_at    :datetime         not null
#  contact_id    :bigint
#  inbox_id      :bigint
#  source_id     :string           not null
#
# Indexes
#
#  index_contact_inboxes_on_contact_id              (contact_id)
#  index_contact_inboxes_on_inbox_id                (inbox_id)
#  index_contact_inboxes_on_inbox_id_and_source_id  (inbox_id,source_id) UNIQUE
#  index_contact_inboxes_on_pubsub_token            (pubsub_token) UNIQUE
#  index_contact_inboxes_on_source_id               (source_id)
#

class ContactInbox < ApplicationRecord
  include Pubsubable
  include RegexHelper
  validates :inbox_id, presence: true
  validates :contact_id, presence: true
  validates :source_id, presence: true
  validate :valid_source_id_format?

  belongs_to :contact
  belongs_to :inbox

  has_many :conversations, dependent: :destroy_async

  # contact_inboxes that are not associated with any conversation
  scope :stale_without_conversations, lambda { |time_period|
    left_joins(:conversations)
      .where('contact_inboxes.created_at < ?', time_period)
      .where(conversations: { contact_id: nil })
  }

  def webhook_data
    {
      id: id,
      contact: contact.try(:webhook_data),
      inbox: inbox.webhook_data,
      account: inbox.account.webhook_data,
      current_conversation: current_conversation.try(:webhook_data),
      source_id: source_id
    }
  end

  def current_conversation
    conversations.last
  end

  private

  def validate_twilio_source_id
    # https://www.twilio.com/docs/glossary/what-e164#regex-matching-for-e164
    if inbox.channel.medium == 'sms' && !TWILIO_CHANNEL_SMS_REGEX.match?(source_id)
      errors.add(:source_id, "invalid source id for twilio sms inbox. valid Regex #{TWILIO_CHANNEL_SMS_REGEX}")
    elsif inbox.channel.medium == 'whatsapp' && !TWILIO_CHANNEL_WHATSAPP_REGEX.match?(source_id)
      errors.add(:source_id, "invalid source id for twilio whatsapp inbox. valid Regex #{TWILIO_CHANNEL_WHATSAPP_REGEX}")
    end
  end

  def validate_whatsapp_source_id
    return if WHATSAPP_CHANNEL_REGEX.match?(source_id)

    errors.add(:source_id, "invalid source id for whatsapp inbox. valid Regex #{WHATSAPP_CHANNEL_REGEX}")
  end

  def valid_source_id_format?
    validate_twilio_source_id if inbox.channel_type == 'Channel::TwilioSms'
    validate_whatsapp_source_id if inbox.channel_type == 'Channel::Whatsapp'
  end
end

================
File: models/contact.rb
================
# rubocop:disable Layout/LineLength

# == Schema Information
#
# Table name: contacts
#
#  id                    :integer          not null, primary key
#  additional_attributes :jsonb
#  blocked               :boolean          default(FALSE), not null
#  contact_type          :integer          default("visitor")
#  country_code          :string           default("")
#  custom_attributes     :jsonb
#  email                 :string
#  identifier            :string
#  last_activity_at      :datetime
#  last_name             :string           default("")
#  location              :string           default("")
#  middle_name           :string           default("")
#  name                  :string           default("")
#  phone_number          :string
#  created_at            :datetime         not null
#  updated_at            :datetime         not null
#  account_id            :integer          not null
#
# Indexes
#
#  index_contacts_on_account_id                          (account_id)
#  index_contacts_on_account_id_and_last_activity_at     (account_id,last_activity_at DESC NULLS LAST)
#  index_contacts_on_blocked                             (blocked)
#  index_contacts_on_lower_email_account_id              (lower((email)::text), account_id)
#  index_contacts_on_name_email_phone_number_identifier  (name,email,phone_number,identifier) USING gin
#  index_contacts_on_nonempty_fields                     (account_id,email,phone_number,identifier) WHERE (((email)::text <> ''::text) OR ((phone_number)::text <> ''::text) OR ((identifier)::text <> ''::text))
#  index_contacts_on_phone_number_and_account_id         (phone_number,account_id)
#  index_resolved_contact_account_id                     (account_id) WHERE (((email)::text <> ''::text) OR ((phone_number)::text <> ''::text) OR ((identifier)::text <> ''::text))
#  uniq_email_per_account_contact                        (email,account_id) UNIQUE
#  uniq_identifier_per_account_contact                   (identifier,account_id) UNIQUE
#

# rubocop:enable Layout/LineLength

class Contact < ApplicationRecord
  include Avatarable
  include AvailabilityStatusable
  include Labelable
  include LlmFormattable

  validates :account_id, presence: true
  validates :email, allow_blank: true, uniqueness: { scope: [:account_id], case_sensitive: false },
                    format: { with: Devise.email_regexp, message: I18n.t('errors.contacts.email.invalid') }
  validates :identifier, allow_blank: true, uniqueness: { scope: [:account_id] }
  validates :phone_number,
            allow_blank: true, uniqueness: { scope: [:account_id] },
            format: { with: /\+[1-9]\d{1,14}\z/, message: I18n.t('errors.contacts.phone_number.invalid') }

  belongs_to :account
  has_many :conversations, dependent: :destroy_async
  has_many :contact_inboxes, dependent: :destroy_async
  has_many :csat_survey_responses, dependent: :destroy_async
  has_many :inboxes, through: :contact_inboxes
  has_many :messages, as: :sender, dependent: :destroy_async
  has_many :notes, dependent: :destroy_async
  before_validation :prepare_contact_attributes
  after_create_commit :dispatch_create_event, :ip_lookup
  after_update_commit :dispatch_update_event
  after_destroy_commit :dispatch_destroy_event
  before_save :sync_contact_attributes

  enum contact_type: { visitor: 0, lead: 1, customer: 2 }

  scope :order_on_last_activity_at, lambda { |direction|
    order(
      Arel::Nodes::SqlLiteral.new(
        sanitize_sql_for_order("\"contacts\".\"last_activity_at\" #{direction}
          NULLS LAST")
      )
    )
  }
  scope :order_on_created_at, lambda { |direction|
    order(
      Arel::Nodes::SqlLiteral.new(
        sanitize_sql_for_order("\"contacts\".\"created_at\" #{direction}
          NULLS LAST")
      )
    )
  }
  scope :order_on_company_name, lambda { |direction|
    order(
      Arel::Nodes::SqlLiteral.new(
        sanitize_sql_for_order(
          "\"contacts\".\"additional_attributes\"->>'company_name' #{direction}
          NULLS LAST"
        )
      )
    )
  }
  scope :order_on_city, lambda { |direction|
    order(
      Arel::Nodes::SqlLiteral.new(
        sanitize_sql_for_order(
          "\"contacts\".\"additional_attributes\"->>'city' #{direction}
          NULLS LAST"
        )
      )
    )
  }
  scope :order_on_country_name, lambda { |direction|
    order(
      Arel::Nodes::SqlLiteral.new(
        sanitize_sql_for_order(
          "\"contacts\".\"additional_attributes\"->>'country' #{direction}
          NULLS LAST"
        )
      )
    )
  }

  scope :order_on_name, lambda { |direction|
    order(
      Arel::Nodes::SqlLiteral.new(
        sanitize_sql_for_order(
          "CASE
           WHEN \"contacts\".\"name\" ~~* '^+\d*' THEN 'z'
           WHEN \"contacts\".\"name\"  ~~*  '^\b*' THEN 'z'
           ELSE LOWER(\"contacts\".\"name\")
           END #{direction}"
        )
      )
    )
  }

  def get_source_id(inbox_id)
    contact_inboxes.find_by!(inbox_id: inbox_id).source_id
  end

  def push_event_data
    {
      additional_attributes: additional_attributes,
      custom_attributes: custom_attributes,
      email: email,
      id: id,
      identifier: identifier,
      name: name,
      phone_number: phone_number,
      thumbnail: avatar_url,
      blocked: blocked,
      type: 'contact'
    }
  end

  def webhook_data
    {
      account: account.webhook_data,
      additional_attributes: additional_attributes,
      avatar: avatar_url,
      custom_attributes: custom_attributes,
      email: email,
      id: id,
      identifier: identifier,
      name: name,
      phone_number: phone_number,
      thumbnail: avatar_url,
      blocked: blocked
    }
  end

  def self.resolved_contacts
    where("contacts.email <> '' OR contacts.phone_number <> '' OR contacts.identifier <> ''")
  end

  def discard_invalid_attrs
    phone_number_format
    email_format
  end

  def self.from_email(email)
    find_by(email: email&.downcase)
  end

  private

  def ip_lookup
    return unless account.feature_enabled?('ip_lookup')

    ContactIpLookupJob.perform_later(self)
  end

  def phone_number_format
    return if phone_number.blank?

    self.phone_number = phone_number_was unless phone_number.match?(/\+[1-9]\d{1,14}\z/)
  end

  def email_format
    return if email.blank?

    self.email = email_was unless email.match(Devise.email_regexp)
  end

  def prepare_contact_attributes
    prepare_email_attribute
    prepare_jsonb_attributes
  end

  def prepare_email_attribute
    # So that the db unique constraint won't throw error when email is ''
    self.email = email.present? ? email.downcase : nil
  end

  def prepare_jsonb_attributes
    self.additional_attributes = {} if additional_attributes.blank?
    self.custom_attributes = {} if custom_attributes.blank?
  end

  def sync_contact_attributes
    ::Contacts::SyncAttributes.new(self).perform
  end

  def dispatch_create_event
    Rails.configuration.dispatcher.dispatch(CONTACT_CREATED, Time.zone.now, contact: self)
  end

  def dispatch_update_event
    Rails.configuration.dispatcher.dispatch(CONTACT_UPDATED, Time.zone.now, contact: self, changed_attributes: previous_changes)
  end

  def dispatch_destroy_event
    Rails.configuration.dispatcher.dispatch(CONTACT_DELETED, Time.zone.now, contact: self)
  end
end

================
File: models/conversation_participant.rb
================
# == Schema Information
#
# Table name: conversation_participants
#
#  id              :bigint           not null, primary key
#  created_at      :datetime         not null
#  updated_at      :datetime         not null
#  account_id      :bigint           not null
#  conversation_id :bigint           not null
#  user_id         :bigint           not null
#
# Indexes
#
#  index_conversation_participants_on_account_id                   (account_id)
#  index_conversation_participants_on_conversation_id              (conversation_id)
#  index_conversation_participants_on_user_id                      (user_id)
#  index_conversation_participants_on_user_id_and_conversation_id  (user_id,conversation_id) UNIQUE
#
class ConversationParticipant < ApplicationRecord
  validates :account_id, presence: true
  validates :conversation_id, presence: true
  validates :user_id, presence: true
  validates :user_id, uniqueness: { scope: [:conversation_id] }
  validate :ensure_inbox_access

  belongs_to :account
  belongs_to :conversation
  belongs_to :user

  before_validation :ensure_account_id

  private

  def ensure_account_id
    self.account_id = conversation&.account_id
  end

  def ensure_inbox_access
    errors.add(:user, 'must have inbox access') if conversation && conversation.inbox.assignable_agents.exclude?(user)
  end
end

================
File: models/conversation.rb
================
# == Schema Information
#
# Table name: conversations
#
#  id                     :integer          not null, primary key
#  additional_attributes  :jsonb
#  agent_last_seen_at     :datetime
#  assignee_last_seen_at  :datetime
#  cached_label_list      :text
#  contact_last_seen_at   :datetime
#  custom_attributes      :jsonb
#  first_reply_created_at :datetime
#  identifier             :string
#  last_activity_at       :datetime         not null
#  priority               :integer
#  snoozed_until          :datetime
#  status                 :integer          default("open"), not null
#  uuid                   :uuid             not null
#  waiting_since          :datetime
#  created_at             :datetime         not null
#  updated_at             :datetime         not null
#  account_id             :integer          not null
#  assignee_id            :integer
#  campaign_id            :bigint
#  contact_id             :bigint
#  contact_inbox_id       :bigint
#  display_id             :integer          not null
#  inbox_id               :integer          not null
#  sla_policy_id          :bigint
#  team_id                :bigint
#
# Indexes
#
#  conv_acid_inbid_stat_asgnid_idx                    (account_id,inbox_id,status,assignee_id)
#  index_conversations_on_account_id                  (account_id)
#  index_conversations_on_account_id_and_display_id   (account_id,display_id) UNIQUE
#  index_conversations_on_assignee_id_and_account_id  (assignee_id,account_id)
#  index_conversations_on_campaign_id                 (campaign_id)
#  index_conversations_on_contact_id                  (contact_id)
#  index_conversations_on_contact_inbox_id            (contact_inbox_id)
#  index_conversations_on_first_reply_created_at      (first_reply_created_at)
#  index_conversations_on_id_and_account_id           (account_id,id)
#  index_conversations_on_inbox_id                    (inbox_id)
#  index_conversations_on_priority                    (priority)
#  index_conversations_on_status_and_account_id       (status,account_id)
#  index_conversations_on_status_and_priority         (status,priority)
#  index_conversations_on_team_id                     (team_id)
#  index_conversations_on_uuid                        (uuid) UNIQUE
#  index_conversations_on_waiting_since               (waiting_since)
#

class Conversation < ApplicationRecord
  include Labelable
  include LlmFormattable
  include AssignmentHandler
  include AutoAssignmentHandler
  include ActivityMessageHandler
  include UrlHelper
  include SortHandler
  include PushDataHelper
  include ConversationMuteHelpers

  validates :account_id, presence: true
  validates :inbox_id, presence: true
  validates :contact_id, presence: true
  before_validation :validate_additional_attributes
  validates :additional_attributes, jsonb_attributes_length: true
  validates :custom_attributes, jsonb_attributes_length: true
  validates :uuid, uniqueness: true
  validate :validate_referer_url

  enum status: { open: 0, resolved: 1, pending: 2, snoozed: 3 }
  enum priority: { low: 0, medium: 1, high: 2, urgent: 3 }

  scope :unassigned, -> { where(assignee_id: nil) }
  scope :assigned, -> { where.not(assignee_id: nil) }
  scope :assigned_to, ->(agent) { where(assignee_id: agent.id) }
  scope :unattended, -> { where(first_reply_created_at: nil).or(where.not(waiting_since: nil)) }
  scope :resolvable, lambda { |auto_resolve_duration|
    return none if auto_resolve_duration.to_i.zero?

    open.where('last_activity_at < ? ', Time.now.utc - auto_resolve_duration.days)
  }

  scope :last_user_message_at, lambda {
    joins(
      "INNER JOIN (#{last_messaged_conversations.to_sql}) AS grouped_conversations
      ON grouped_conversations.conversation_id = conversations.id"
    ).sort_on_last_user_message_at
  }

  belongs_to :account
  belongs_to :inbox
  belongs_to :assignee, class_name: 'User', optional: true, inverse_of: :assigned_conversations
  belongs_to :contact
  belongs_to :contact_inbox
  belongs_to :team, optional: true
  belongs_to :campaign, optional: true

  has_many :mentions, dependent: :destroy_async
  has_many :messages, dependent: :destroy_async, autosave: true
  has_one :csat_survey_response, dependent: :destroy_async
  has_many :conversation_participants, dependent: :destroy_async
  has_many :notifications, as: :primary_actor, dependent: :destroy_async
  has_many :attachments, through: :messages

  before_save :ensure_snooze_until_reset
  before_create :determine_conversation_status
  before_create :ensure_waiting_since

  after_update_commit :execute_after_update_commit_callbacks
  after_create_commit :notify_conversation_creation
  after_create_commit :load_attributes_created_by_db_triggers

  delegate :auto_resolve_duration, to: :account

  def can_reply?
    channel = inbox&.channel

    return can_reply_on_instagram? if additional_attributes['type'] == 'instagram_direct_message'

    return true unless channel&.messaging_window_enabled?

    messaging_window = inbox.api? ? channel.additional_attributes['agent_reply_time_window'].to_i : 24
    last_message_in_messaging_window?(messaging_window)
  end

  def last_activity_at
    self[:last_activity_at] || created_at
  end

  def last_incoming_message
    messages&.incoming&.last
  end

  def last_message_in_messaging_window?(time)
    return false if last_incoming_message.nil?

    Time.current < last_incoming_message.created_at + time.hours
  end

  def can_reply_on_instagram?
    global_config = GlobalConfig.get('ENABLE_MESSENGER_CHANNEL_HUMAN_AGENT')

    return false if last_incoming_message.nil?

    if global_config['ENABLE_MESSENGER_CHANNEL_HUMAN_AGENT']
      Time.current < last_incoming_message.created_at + 7.days
    else
      last_message_in_messaging_window?(24)
    end
  end

  def toggle_status
    # FIXME: implement state machine with aasm
    self.status = open? ? :resolved : :open
    self.status = :open if pending? || snoozed?
    save
  end

  def toggle_priority(priority = nil)
    self.priority = priority.presence
    save
  end

  def bot_handoff!
    open!
    dispatcher_dispatch(CONVERSATION_BOT_HANDOFF)
  end

  def unread_messages
    agent_last_seen_at.present? ? messages.created_since(agent_last_seen_at) : messages
  end

  def unread_incoming_messages
    unread_messages.where(account_id: account_id).incoming.last(10)
  end

  def cached_label_list_array
    (cached_label_list || '').split(',').map(&:strip)
  end

  def notifiable_assignee_change?
    return false unless saved_change_to_assignee_id?
    return false if assignee_id.blank?
    return false if self_assign?(assignee_id)

    true
  end

  def tweet?
    inbox.inbox_type == 'Twitter' && additional_attributes['type'] == 'tweet'
  end

  def recent_messages
    messages.chat.last(5)
  end

  def csat_survey_link
    "#{ENV.fetch('FRONTEND_URL', nil)}/survey/responses/#{uuid}"
  end

  def dispatch_conversation_updated_event(previous_changes = nil)
    dispatcher_dispatch(CONVERSATION_UPDATED, previous_changes)
  end

  private

  def execute_after_update_commit_callbacks
    notify_status_change
    create_activity
    notify_conversation_updation
  end

  def ensure_snooze_until_reset
    self.snoozed_until = nil unless snoozed?
  end

  def ensure_waiting_since
    self.waiting_since = created_at
  end

  def validate_additional_attributes
    self.additional_attributes = {} unless additional_attributes.is_a?(Hash)
  end

  def determine_conversation_status
    self.status = :resolved and return if contact.blocked?

    # Message template hooks aren't executed for conversations from campaigns
    # So making these conversations open for agent visibility
    return if campaign.present?

    # TODO: make this an inbox config instead of assuming bot conversations should start as pending
    self.status = :pending if inbox.active_bot?
  end

  def notify_conversation_creation
    dispatcher_dispatch(CONVERSATION_CREATED)
  end

  def notify_conversation_updation
    return unless previous_changes.keys.present? && allowed_keys?

    dispatch_conversation_updated_event(previous_changes)
  end

  def list_of_keys
    %w[team_id assignee_id status snoozed_until custom_attributes label_list waiting_since first_reply_created_at
       priority]
  end

  def allowed_keys?
    (
      previous_changes.keys.intersect?(list_of_keys) ||
      (previous_changes['additional_attributes'].present? && previous_changes['additional_attributes'][1].keys.intersect?(%w[conversation_language]))
    )
  end

  def self_assign?(assignee_id)
    assignee_id.present? && Current.user&.id == assignee_id
  end

  def load_attributes_created_by_db_triggers
    # Display id is set via a trigger in the database
    # So we need to specifically fetch it after the record is created
    # We can't use reload because it will clear the previous changes, which we need for the dispatcher
    obj_from_db = self.class.find(id)
    self[:display_id] = obj_from_db[:display_id]
    self[:uuid] = obj_from_db[:uuid]
  end

  def notify_status_change
    {
      CONVERSATION_OPENED => -> { saved_change_to_status? && open? },
      CONVERSATION_RESOLVED => -> { saved_change_to_status? && resolved? },
      CONVERSATION_STATUS_CHANGED => -> { saved_change_to_status? },
      CONVERSATION_READ => -> { saved_change_to_contact_last_seen_at? },
      CONVERSATION_CONTACT_CHANGED => -> { saved_change_to_contact_id? }
    }.each do |event, condition|
      condition.call && dispatcher_dispatch(event, status_change)
    end
  end

  def dispatcher_dispatch(event_name, changed_attributes = nil)
    Rails.configuration.dispatcher.dispatch(event_name, Time.zone.now, conversation: self, notifiable_assignee_change: notifiable_assignee_change?,
                                                                       changed_attributes: changed_attributes,
                                                                       performed_by: Current.executed_by)
  end

  def conversation_status_changed_to_open?
    return false unless open?
    # saved_change_to_status? method only works in case of update
    return true if previous_changes.key?(:id) || saved_change_to_status?
  end

  def create_label_change(user_name)
    return unless user_name

    previous_labels, current_labels = previous_changes[:label_list]
    return unless (previous_labels.is_a? Array) && (current_labels.is_a? Array)

    dispatcher_dispatch(CONVERSATION_UPDATED, previous_changes)

    create_label_added(user_name, current_labels - previous_labels)
    create_label_removed(user_name, previous_labels - current_labels)
  end

  def validate_referer_url
    return unless additional_attributes['referer']

    self['additional_attributes']['referer'] = nil unless url_valid?(additional_attributes['referer'])
  end

  # creating db triggers
  trigger.before(:insert).for_each(:row) do
    "NEW.display_id := nextval('conv_dpid_seq_' || NEW.account_id);"
  end
end

Conversation.include_mod_with('Concerns::Conversation')
Conversation.prepend_mod_with('Conversation')

================
File: models/csat_survey_response.rb
================
# == Schema Information
#
# Table name: csat_survey_responses
#
#  id                :bigint           not null, primary key
#  feedback_message  :text
#  rating            :integer          not null
#  created_at        :datetime         not null
#  updated_at        :datetime         not null
#  account_id        :bigint           not null
#  assigned_agent_id :bigint
#  contact_id        :bigint           not null
#  conversation_id   :bigint           not null
#  message_id        :bigint           not null
#
# Indexes
#
#  index_csat_survey_responses_on_account_id         (account_id)
#  index_csat_survey_responses_on_assigned_agent_id  (assigned_agent_id)
#  index_csat_survey_responses_on_contact_id         (contact_id)
#  index_csat_survey_responses_on_conversation_id    (conversation_id)
#  index_csat_survey_responses_on_message_id         (message_id) UNIQUE
#
class CsatSurveyResponse < ApplicationRecord
  belongs_to :account
  belongs_to :conversation
  belongs_to :contact
  belongs_to :message
  belongs_to :assigned_agent, class_name: 'User', optional: true, inverse_of: :csat_survey_responses

  validates :rating, presence: true, inclusion: { in: [1, 2, 3, 4, 5] }
  validates :account_id, presence: true
  validates :contact_id, presence: true
  validates :conversation_id, presence: true

  scope :filter_by_created_at, ->(range) { where(created_at: range) if range.present? }
  scope :filter_by_assigned_agent_id, ->(user_ids) { where(assigned_agent_id: user_ids) if user_ids.present? }
  scope :filter_by_inbox_id, ->(inbox_id) { joins(:conversation).where(conversations: { inbox_id: inbox_id }) if inbox_id.present? }
  scope :filter_by_team_id, ->(team_id) { joins(:conversation).where(conversations: { team_id: team_id }) if team_id.present? }
  # filter by rating value
  scope :filter_by_rating, ->(rating) { where(rating: rating) if rating.present? }
end

================
File: models/custom_attribute_definition.rb
================
# == Schema Information
#
# Table name: custom_attribute_definitions
#
#  id                     :bigint           not null, primary key
#  attribute_description  :text
#  attribute_display_name :string
#  attribute_display_type :integer          default("text")
#  attribute_key          :string
#  attribute_model        :integer          default("conversation_attribute")
#  attribute_values       :jsonb
#  default_value          :integer
#  regex_cue              :string
#  regex_pattern          :string
#  created_at             :datetime         not null
#  updated_at             :datetime         not null
#  account_id             :bigint
#
# Indexes
#
#  attribute_key_model_index                         (attribute_key,attribute_model,account_id) UNIQUE
#  index_custom_attribute_definitions_on_account_id  (account_id)
#
class CustomAttributeDefinition < ApplicationRecord
  STANDARD_ATTRIBUTES = {
    :conversation => %w[status priority assignee_id inbox_id team_id display_id campaign_id labels browser_language country_code referer created_at
                        last_activity_at],
    :contact => %w[name email phone_number identifier country_code city created_at last_activity_at referer blocked]
  }.freeze

  scope :with_attribute_model, ->(attribute_model) { attribute_model.presence && where(attribute_model: attribute_model) }
  validates :attribute_display_name, presence: true

  validates :attribute_key,
            presence: true,
            uniqueness: { scope: [:account_id, :attribute_model] }

  validates :attribute_display_type, presence: true
  validates :attribute_model, presence: true
  validate :attribute_must_not_conflict, on: :create

  enum attribute_model: { conversation_attribute: 0, contact_attribute: 1 }
  enum attribute_display_type: { text: 0, number: 1, currency: 2, percent: 3, link: 4, date: 5, list: 6, checkbox: 7 }

  belongs_to :account
  after_update :update_widget_pre_chat_custom_fields
  after_destroy :sync_widget_pre_chat_custom_fields

  private

  def sync_widget_pre_chat_custom_fields
    ::Inboxes::SyncWidgetPreChatCustomFieldsJob.perform_later(account, attribute_key)
  end

  def update_widget_pre_chat_custom_fields
    ::Inboxes::UpdateWidgetPreChatCustomFieldsJob.perform_later(account, self)
  end

  def attribute_must_not_conflict
    model_keys = attribute_model.to_sym == :conversation_attribute ? :conversation : :contact
    return unless attribute_key.in?(STANDARD_ATTRIBUTES[model_keys])

    errors.add(:attribute_key, I18n.t('errors.custom_attribute_definition.key_conflict'))
  end
end

================
File: models/custom_filter.rb
================
# == Schema Information
#
# Table name: custom_filters
#
#  id          :bigint           not null, primary key
#  filter_type :integer          default("conversation"), not null
#  name        :string           not null
#  query       :jsonb            not null
#  created_at  :datetime         not null
#  updated_at  :datetime         not null
#  account_id  :bigint           not null
#  user_id     :bigint           not null
#
# Indexes
#
#  index_custom_filters_on_account_id  (account_id)
#  index_custom_filters_on_user_id     (user_id)
#
class CustomFilter < ApplicationRecord
  MAX_FILTER_PER_USER = 50
  belongs_to :user
  belongs_to :account

  enum filter_type: { conversation: 0, contact: 1, report: 2 }
  validate :validate_number_of_filters

  def validate_number_of_filters
    return true if account.custom_filters.where(user_id: user_id).size < MAX_FILTER_PER_USER

    errors.add :account_id, I18n.t('errors.custom_filters.number_of_records')
  end
end

================
File: models/dashboard_app.rb
================
# == Schema Information
#
# Table name: dashboard_apps
#
#  id         :bigint           not null, primary key
#  content    :jsonb
#  title      :string           not null
#  created_at :datetime         not null
#  updated_at :datetime         not null
#  account_id :bigint           not null
#  user_id    :bigint
#
# Indexes
#
#  index_dashboard_apps_on_account_id  (account_id)
#  index_dashboard_apps_on_user_id     (user_id)
#
class DashboardApp < ApplicationRecord
  belongs_to :user
  belongs_to :account
  validate :validate_content

  private

  def validate_content
    has_invalid_data = self[:content].blank? || !self[:content].is_a?(Array)
    self[:content] = [] if has_invalid_data

    content_schema = {
      'type' => 'array',
      'items' => {
        'type' => 'object',
        'required' => %w[url type],
        'properties' => {
          'type' => { 'enum': ['frame'] },
          'url' => { '$ref' => '#/definitions/saneUrl' }
        }
      },
      'definitions' => {
        'saneUrl' => { 'format' => 'uri', 'pattern' => '^https?://' }
      },
      'additionalProperties' => false,
      'minItems' => 1
    }
    errors.add(:content, ': Invalid data') unless JSONSchemer.schema(content_schema.to_json).valid?(self[:content])
  end
end

================
File: models/data_import.rb
================
# == Schema Information
#
# Table name: data_imports
#
#  id                :bigint           not null, primary key
#  data_type         :string           not null
#  processed_records :integer
#  processing_errors :text
#  status            :integer          default("pending"), not null
#  total_records     :integer
#  created_at        :datetime         not null
#  updated_at        :datetime         not null
#  account_id        :bigint           not null
#
# Indexes
#
#  index_data_imports_on_account_id  (account_id)
#
class DataImport < ApplicationRecord
  belongs_to :account
  validates :data_type, inclusion: { in: ['contacts'], message: I18n.t('errors.data_import.data_type.invalid') }
  enum status: { pending: 0, processing: 1, completed: 2, failed: 3 }

  has_one_attached :import_file
  has_one_attached :failed_records

  after_create_commit :process_data_import

  private

  def process_data_import
    # we wait for the file to be uploaded to the cloud
    DataImportJob.set(wait: 1.minute).perform_later(self)
  end
end

================
File: models/email_template.rb
================
# == Schema Information
#
# Table name: email_templates
#
#  id            :bigint           not null, primary key
#  body          :text             not null
#  locale        :integer          default("en"), not null
#  name          :string           not null
#  template_type :integer          default("content")
#  created_at    :datetime         not null
#  updated_at    :datetime         not null
#  account_id    :integer
#
# Indexes
#
#  index_email_templates_on_name_and_account_id  (name,account_id) UNIQUE
#
class EmailTemplate < ApplicationRecord
  enum locale: LANGUAGES_CONFIG.map { |key, val| [val[:iso_639_1_code], key] }.to_h
  enum template_type: { layout: 0, content: 1 }
  belongs_to :account, optional: true

  validates :name, uniqueness: { scope: :account }

  def self.resolver(options = {})
    ::EmailTemplates::DbResolverService.using self, options
  end
end

================
File: models/folder.rb
================
# == Schema Information
#
# Table name: folders
#
#  id          :bigint           not null, primary key
#  name        :string
#  created_at  :datetime         not null
#  updated_at  :datetime         not null
#  account_id  :integer          not null
#  category_id :integer          not null
#
class Folder < ApplicationRecord
  belongs_to :account
  belongs_to :category
  has_many :articles, dependent: :nullify

  validates :account_id, presence: true
  validates :category_id, presence: true
  validates :name, presence: true
end

================
File: models/inbox_member.rb
================
# == Schema Information
#
# Table name: inbox_members
#
#  id         :integer          not null, primary key
#  created_at :datetime         not null
#  updated_at :datetime         not null
#  inbox_id   :integer          not null
#  user_id    :integer          not null
#
# Indexes
#
#  index_inbox_members_on_inbox_id              (inbox_id)
#  index_inbox_members_on_inbox_id_and_user_id  (inbox_id,user_id) UNIQUE
#

class InboxMember < ApplicationRecord
  validates :inbox_id, presence: true
  validates :user_id, presence: true
  validates :user_id, uniqueness: { scope: :inbox_id }

  belongs_to :user
  belongs_to :inbox

  after_create :add_agent_to_round_robin
  after_destroy :remove_agent_from_round_robin

  private

  def add_agent_to_round_robin
    ::AutoAssignment::InboxRoundRobinService.new(inbox: inbox).add_agent_to_queue(user_id)
  end

  def remove_agent_from_round_robin
    ::AutoAssignment::InboxRoundRobinService.new(inbox: inbox).remove_agent_from_queue(user_id) if inbox.present?
  end
end

InboxMember.include_mod_with('Audit::InboxMember')

================
File: models/inbox.rb
================
# frozen_string_literal: true

# == Schema Information
#
# Table name: inboxes
#
#  id                            :integer          not null, primary key
#  allow_messages_after_resolved :boolean          default(TRUE)
#  auto_assignment_config        :jsonb
#  business_name                 :string
#  channel_type                  :string
#  csat_survey_enabled           :boolean          default(FALSE)
#  email_address                 :string
#  enable_auto_assignment        :boolean          default(TRUE)
#  enable_email_collect          :boolean          default(TRUE)
#  greeting_enabled              :boolean          default(FALSE)
#  greeting_message              :string
#  lock_to_single_conversation   :boolean          default(FALSE), not null
#  name                          :string           not null
#  out_of_office_message         :string
#  sender_name_type              :integer          default("friendly"), not null
#  timezone                      :string           default("UTC")
#  working_hours_enabled         :boolean          default(FALSE)
#  created_at                    :datetime         not null
#  updated_at                    :datetime         not null
#  account_id                    :integer          not null
#  channel_id                    :integer          not null
#  portal_id                     :bigint
#
# Indexes
#
#  index_inboxes_on_account_id                   (account_id)
#  index_inboxes_on_channel_id_and_channel_type  (channel_id,channel_type)
#  index_inboxes_on_portal_id                    (portal_id)
#
# Foreign Keys
#
#  fk_rails_...  (portal_id => portals.id)
#

class Inbox < ApplicationRecord
  include Reportable
  include Avatarable
  include OutOfOffisable
  include AccountCacheRevalidator

  # Not allowing characters:
  validates :name, presence: true
  validates :name, if: :check_channel_type?, format: { with: %r{^^\b[^/\\<>@]*\b$}, multiline: true,
                                                       message: I18n.t('errors.inboxes.validations.name') }
  validates :account_id, presence: true
  validates :timezone, inclusion: { in: TZInfo::Timezone.all_identifiers }
  validates :out_of_office_message, length: { maximum: Limits::OUT_OF_OFFICE_MESSAGE_MAX_LENGTH }
  validates :greeting_message, length: { maximum: Limits::GREETING_MESSAGE_MAX_LENGTH }
  validate :ensure_valid_max_assignment_limit

  belongs_to :account
  belongs_to :portal, optional: true

  belongs_to :channel, polymorphic: true, dependent: :destroy

  has_many :campaigns, dependent: :destroy_async
  has_many :contact_inboxes, dependent: :destroy_async
  has_many :contacts, through: :contact_inboxes

  has_many :inbox_members, dependent: :destroy_async
  has_many :members, through: :inbox_members, source: :user
  has_many :conversations, dependent: :destroy_async
  has_many :messages, dependent: :destroy_async

  has_one :agent_bot_inbox, dependent: :destroy_async
  has_one :agent_bot, through: :agent_bot_inbox
  has_many :webhooks, dependent: :destroy_async
  has_many :hooks, dependent: :destroy_async, class_name: 'Integrations::Hook'

  enum sender_name_type: { friendly: 0, professional: 1 }

  after_destroy :delete_round_robin_agents

  after_create_commit :dispatch_create_event
  after_update_commit :dispatch_update_event

  scope :order_by_name, -> { order('lower(name) ASC') }

  # Adds multiple members to the inbox
  # @param user_ids [Array<Integer>] Array of user IDs to add as members
  # @return [void]
  def add_members(user_ids)
    inbox_members.create!(user_ids.map { |user_id| { user_id: user_id } })
    update_account_cache
  end

  # Removes multiple members from the inbox
  # @param user_ids [Array<Integer>] Array of user IDs to remove
  # @return [void]
  def remove_members(user_ids)
    inbox_members.where(user_id: user_ids).destroy_all
    update_account_cache
  end

  def facebook?
    channel_type == 'Channel::FacebookPage'
  end

  def instagram?
    facebook? && channel.instagram_id.present?
  end

  def web_widget?
    channel_type == 'Channel::WebWidget'
  end

  def api?
    channel_type == 'Channel::Api'
  end

  def email?
    channel_type == 'Channel::Email'
  end

  def twilio?
    channel_type == 'Channel::TwilioSms'
  end

  def twitter?
    channel_type == 'Channel::TwitterProfile'
  end

  def whatsapp?
    channel_type == 'Channel::Whatsapp'
  end

  def assignable_agents
    (account.users.where(id: members.select(:user_id)) + account.administrators).uniq
  end

  def active_bot?
    agent_bot_inbox&.active? || hooks.where(app_id: %w[dialogflow],
                                            status: 'enabled').count.positive?
  end

  def inbox_type
    channel.name
  end

  def webhook_data
    {
      id: id,
      name: name
    }
  end

  def callback_webhook_url
    case channel_type
    when 'Channel::TwilioSms'
      "#{ENV.fetch('FRONTEND_URL', nil)}/twilio/callback"
    when 'Channel::Sms'
      "#{ENV.fetch('FRONTEND_URL', nil)}/webhooks/sms/#{channel.phone_number.delete_prefix('+')}"
    when 'Channel::Line'
      "#{ENV.fetch('FRONTEND_URL', nil)}/webhooks/line/#{channel.line_channel_id}"
    when 'Channel::Whatsapp'
      "#{ENV.fetch('FRONTEND_URL', nil)}/webhooks/whatsapp/#{channel.phone_number}"
    end
  end

  def member_ids_with_assignment_capacity
    members.ids
  end

  private

  def dispatch_create_event
    return if ENV['ENABLE_INBOX_EVENTS'].blank?

    Rails.configuration.dispatcher.dispatch(INBOX_CREATED, Time.zone.now, inbox: self)
  end

  def dispatch_update_event
    return if ENV['ENABLE_INBOX_EVENTS'].blank?

    Rails.configuration.dispatcher.dispatch(INBOX_UPDATED, Time.zone.now, inbox: self, changed_attributes: previous_changes)
  end

  def ensure_valid_max_assignment_limit
    # overridden in enterprise/app/models/enterprise/inbox.rb
  end

  def delete_round_robin_agents
    ::AutoAssignment::InboxRoundRobinService.new(inbox: self).clear_queue
  end

  def check_channel_type?
    ['Channel::Email', 'Channel::Api', 'Channel::WebWidget'].include?(channel_type)
  end
end

Inbox.prepend_mod_with('Inbox')
Inbox.include_mod_with('Audit::Inbox')
Inbox.include_mod_with('Concerns::Inbox')

================
File: models/installation_config.rb
================
# == Schema Information
#
# Table name: installation_configs
#
#  id               :bigint           not null, primary key
#  locked           :boolean          default(TRUE), not null
#  name             :string           not null
#  serialized_value :jsonb            not null
#  created_at       :datetime         not null
#  updated_at       :datetime         not null
#
# Indexes
#
#  index_installation_configs_on_name                 (name) UNIQUE
#  index_installation_configs_on_name_and_created_at  (name,created_at) UNIQUE
#
class InstallationConfig < ApplicationRecord
  # https://stackoverflow.com/questions/72970170/upgrading-to-rails-6-1-6-1-causes-psychdisallowedclass-tried-to-load-unspecif
  # https://discuss.rubyonrails.org/t/cve-2022-32224-possible-rce-escalation-bug-with-serialized-columns-in-active-record/81017
  # FIX ME : fixes breakage of installation config. we need to migrate.
  # Fix configuration in application.rb
  serialize :serialized_value, ActiveSupport::HashWithIndifferentAccess

  before_validation :set_lock
  validates :name, presence: true

  # TODO: Get rid of default scope
  # https://stackoverflow.com/a/1834250/939299
  default_scope { order(created_at: :desc) }
  scope :editable, -> { where(locked: false) }

  after_commit :clear_cache

  def value
    serialized_value[:value]
  end

  def value=(value_to_assigned)
    self.serialized_value = {
      value: value_to_assigned
    }.with_indifferent_access
  end

  private

  def set_lock
    self.locked = true if locked.nil?
  end

  def clear_cache
    GlobalConfig.clear_cache
  end
end

================
File: models/integrations.rb
================
module Integrations
  def self.table_name_prefix
    'integrations_'
  end
end

================
File: models/jsonb_attributes_length_validator.rb
================
class JsonbAttributesLengthValidator < ActiveModel::EachValidator
  def validate_each(record, attribute, value)
    return if value.empty?

    @attribute = attribute
    @record = record

    value.each do |key, attribute_value|
      validate_keys(key, attribute_value)
    end
  end

  def validate_keys(key, attribute_value)
    case attribute_value.class.name
    when 'String'
      @record.errors.add @attribute, "#{key} length should be < 1500" if attribute_value.length > 1500
    when 'Integer'
      @record.errors.add @attribute, "#{key} value should be < 9999999999" if attribute_value > 9_999_999_999
    end
  end
end

================
File: models/kbase.rb
================
module Kbase
  def self.table_name_prefix
    'kbase_'
  end
end

================
File: models/label.rb
================
# == Schema Information
#
# Table name: labels
#
#  id              :bigint           not null, primary key
#  color           :string           default("#1f93ff"), not null
#  description     :text
#  show_on_sidebar :boolean
#  title           :string
#  created_at      :datetime         not null
#  updated_at      :datetime         not null
#  account_id      :bigint
#
# Indexes
#
#  index_labels_on_account_id            (account_id)
#  index_labels_on_title_and_account_id  (title,account_id) UNIQUE
#
class Label < ApplicationRecord
  include RegexHelper
  include AccountCacheRevalidator

  belongs_to :account

  validates :title,
            presence: { message: I18n.t('errors.validations.presence') },
            format: { with: UNICODE_CHARACTER_NUMBER_HYPHEN_UNDERSCORE },
            uniqueness: { scope: :account_id }

  after_update_commit :update_associated_models
  default_scope { order(:title) }

  before_validation do
    self.title = title.downcase if attribute_present?('title')
  end

  def conversations
    account.conversations.tagged_with(title)
  end

  def messages
    account.messages.where(conversation_id: conversations.pluck(:id))
  end

  def reporting_events
    account.reporting_events.where(conversation_id: conversations.pluck(:id))
  end

  private

  def update_associated_models
    return unless title_previously_changed?

    Labels::UpdateJob.perform_later(title, title_previously_was, account_id)
  end
end

================
File: models/macro.rb
================
# == Schema Information
#
# Table name: macros
#
#  id            :bigint           not null, primary key
#  actions       :jsonb            not null
#  name          :string           not null
#  visibility    :integer          default("personal")
#  created_at    :datetime         not null
#  updated_at    :datetime         not null
#  account_id    :bigint           not null
#  created_by_id :bigint
#  updated_by_id :bigint
#
# Indexes
#
#  index_macros_on_account_id  (account_id)
#
class Macro < ApplicationRecord
  include Rails.application.routes.url_helpers

  belongs_to :account
  belongs_to :created_by,
             class_name: :User, optional: true, inverse_of: :macros
  belongs_to :updated_by,
             class_name: :User, optional: true
  has_many_attached :files

  enum visibility: { personal: 0, global: 1 }

  validate :json_actions_format

  ACTIONS_ATTRS = %w[send_message add_label assign_team assign_agent mute_conversation change_status remove_label remove_assigned_team
                     resolve_conversation snooze_conversation change_priority send_email_transcript send_attachment add_private_note].freeze

  def set_visibility(user, params)
    self.visibility = params[:visibility]
    self.visibility = :personal if user.agent?
  end

  def self.with_visibility(user, _params)
    records = Current.account.macros.global
    records = records.or(personal.where(created_by_id: user.id, account_id: Current.account.id))
    records.order(:id)
  end

  def self.current_page(params)
    params[:page] || 1
  end

  def file_base_data
    files.map do |file|
      {
        id: file.id,
        macro_id: id,
        file_type: file.content_type,
        account_id: account_id,
        file_url: url_for(file),
        blob_id: file.blob_id,
        filename: file.filename.to_s
      }
    end
  end

  private

  def json_actions_format
    return if actions.blank?

    attributes = actions.map { |obj, _| obj['action_name'] }
    actions = attributes - ACTIONS_ATTRS

    errors.add(:actions, "Macro execution actions #{actions.join(',')} not supported.") if actions.any?
  end
end

Macro.include_mod_with('Audit::Macro')

================
File: models/mention.rb
================
# == Schema Information
#
# Table name: mentions
#
#  id              :bigint           not null, primary key
#  mentioned_at    :datetime         not null
#  created_at      :datetime         not null
#  updated_at      :datetime         not null
#  account_id      :bigint           not null
#  conversation_id :bigint           not null
#  user_id         :bigint           not null
#
# Indexes
#
#  index_mentions_on_account_id                   (account_id)
#  index_mentions_on_conversation_id              (conversation_id)
#  index_mentions_on_user_id                      (user_id)
#  index_mentions_on_user_id_and_conversation_id  (user_id,conversation_id) UNIQUE
#
class Mention < ApplicationRecord
  include SortHandler

  before_validation :ensure_account_id
  validates :mentioned_at, presence: true
  validates :account_id, presence: true
  validates :conversation_id, presence: true
  validates :user_id, presence: true
  validates :user, uniqueness: { scope: :conversation }

  belongs_to :account
  belongs_to :conversation
  belongs_to :user

  after_commit :notify_mentioned_user

  scope :latest, -> { order(mentioned_at: :desc) }

  def self.last_user_message_at
    # INNER query finds the last message created in the conversation group
    # The outer query JOINS with the latest created message conversations
    # Then select only latest incoming message from the conversations which doesn't have last message as outgoing
    # Order by message created_at
    Mention.joins(
      "INNER JOIN (#{last_messaged_conversations.to_sql}) AS grouped_conversations
      ON grouped_conversations.conversation_id = mentions.conversation_id"
    ).sort_on_last_user_message_at
  end

  private

  def ensure_account_id
    self.account_id = conversation&.account_id
  end

  def notify_mentioned_user
    Rails.configuration.dispatcher.dispatch(CONVERSATION_MENTIONED, Time.zone.now, user: user, conversation: conversation)
  end
end

================
File: models/message.rb
================
# == Schema Information
#
# Table name: messages
#
#  id                        :integer          not null, primary key
#  additional_attributes     :jsonb
#  content                   :text
#  content_attributes        :json
#  content_type              :integer          default("text"), not null
#  external_source_ids       :jsonb
#  message_type              :integer          not null
#  private                   :boolean          default(FALSE), not null
#  processed_message_content :text
#  sender_type               :string
#  sentiment                 :jsonb
#  status                    :integer          default("sent")
#  created_at                :datetime         not null
#  updated_at                :datetime         not null
#  account_id                :integer          not null
#  conversation_id           :integer          not null
#  inbox_id                  :integer          not null
#  sender_id                 :bigint
#  source_id                 :string
#
# Indexes
#
#  index_messages_on_account_created_type               (account_id,created_at,message_type)
#  index_messages_on_account_id                         (account_id)
#  index_messages_on_account_id_and_inbox_id            (account_id,inbox_id)
#  index_messages_on_additional_attributes_campaign_id  (((additional_attributes -> 'campaign_id'::text))) USING gin
#  index_messages_on_content                            (content) USING gin
#  index_messages_on_conversation_account_type_created  (conversation_id,account_id,message_type,created_at)
#  index_messages_on_conversation_id                    (conversation_id)
#  index_messages_on_created_at                         (created_at)
#  index_messages_on_inbox_id                           (inbox_id)
#  index_messages_on_sender_type_and_sender_id          (sender_type,sender_id)
#  index_messages_on_source_id                          (source_id)
#

class Message < ApplicationRecord
  include MessageFilterHelpers
  include Liquidable
  NUMBER_OF_PERMITTED_ATTACHMENTS = 15

  TEMPLATE_PARAMS_SCHEMA = {
    'type': 'object',
    'properties': {
      'template_params': {
        'type': 'object',
        'properties': {
          'name': { 'type': 'string' },
          'category': { 'type': 'string' },
          'language': { 'type': 'string' },
          'namespace': { 'type': 'string' },
          'processed_params': { 'type': 'object' }
        },
        'required': %w[name]
      }
    }
  }.to_json.freeze

  before_validation :ensure_content_type
  before_validation :prevent_message_flooding
  before_save :ensure_processed_message_content
  before_save :ensure_in_reply_to

  validates :account_id, presence: true
  validates :inbox_id, presence: true
  validates :conversation_id, presence: true
  validates_with ContentAttributeValidator
  validates_with JsonSchemaValidator,
                 schema: TEMPLATE_PARAMS_SCHEMA,
                 attribute_resolver: ->(record) { record.additional_attributes }

  validates :content_type, presence: true
  validates :content, length: { maximum: 150_000 }
  validates :processed_message_content, length: { maximum: 150_000 }

  # when you have a temperory id in your frontend and want it echoed back via action cable
  attr_accessor :echo_id

  enum message_type: { incoming: 0, outgoing: 1, activity: 2, template: 3 }
  enum content_type: {
    text: 0,
    input_text: 1,
    input_textarea: 2,
    input_email: 3,
    input_select: 4,
    cards: 5,
    form: 6,
    article: 7,
    incoming_email: 8,
    input_csat: 9,
    integrations: 10,
    sticker: 11
  }
  enum status: { sent: 0, delivered: 1, read: 2, failed: 3 }
  # [:submitted_email, :items, :submitted_values] : Used for bot message types
  # [:email] : Used by conversation_continuity incoming email messages
  # [:in_reply_to] : Used to reply to a particular tweet in threads
  # [:deleted] : Used to denote whether the message was deleted by the agent
  # [:external_created_at] : Can specify if the message was created at a different timestamp externally
  # [:external_error : Can specify if the message creation failed due to an error at external API
  store :content_attributes, accessors: [:submitted_email, :items, :submitted_values, :email, :in_reply_to, :deleted,
                                         :external_created_at, :story_sender, :story_id, :external_error,
                                         :translations, :in_reply_to_external_id, :is_unsupported], coder: JSON

  store :external_source_ids, accessors: [:slack], coder: JSON, prefix: :external_source_id

  scope :created_since, ->(datetime) { where('created_at > ?', datetime) }
  scope :chat, -> { where.not(message_type: :activity).where(private: false) }
  scope :non_activity_messages, -> { where.not(message_type: :activity).reorder('id desc') }
  scope :today, -> { where("date_trunc('day', created_at) = ?", Date.current) }

  # TODO: Get rid of default scope
  # https://stackoverflow.com/a/1834250/939299
  # if you want to change order, use `reorder`
  default_scope { order(created_at: :asc) }

  belongs_to :account
  belongs_to :inbox
  belongs_to :conversation, touch: true
  belongs_to :sender, polymorphic: true, optional: true

  has_many :attachments, dependent: :destroy, autosave: true, before_add: :validate_attachments_limit
  has_one :csat_survey_response, dependent: :destroy_async
  has_many :notifications, as: :primary_actor, dependent: :destroy_async

  after_create_commit :execute_after_create_commit_callbacks

  after_update_commit :dispatch_update_event

  def channel_token
    @token ||= inbox.channel.try(:page_access_token)
  end

  def push_event_data
    data = attributes.symbolize_keys.merge(
      created_at: created_at.to_i,
      message_type: message_type_before_type_cast,
      conversation_id: conversation.display_id,
      conversation: conversation_push_event_data
    )
    data[:echo_id] = echo_id if echo_id.present?
    data[:attachments] = attachments.map(&:push_event_data) if attachments.present?
    merge_sender_attributes(data)
  end

  def conversation_push_event_data
    {
      assignee_id: conversation.assignee_id,
      unread_count: conversation.unread_incoming_messages.count,
      last_activity_at: conversation.last_activity_at.to_i,
      contact_inbox: { source_id: conversation.contact_inbox.source_id }
    }
  end

  # TODO: We will be removing this code after instagram_manage_insights is implemented
  # Better logic is to listen to webhook and remove stories proactively rather than trying
  # a fetch every time a message is returned
  def validate_instagram_story
    inbox.channel.fetch_instagram_story_link(self)
    # we want to reload the message in case the story has expired and data got removed
    reload
  end

  def merge_sender_attributes(data)
    data[:sender] = sender.push_event_data if sender && !sender.is_a?(AgentBot)
    data[:sender] = sender.push_event_data(inbox) if sender.is_a?(AgentBot)
    data
  end

  def webhook_data
    data = {
      account: account.webhook_data,
      additional_attributes: additional_attributes,
      content_attributes: content_attributes,
      content_type: content_type,
      content: content,
      conversation: conversation.webhook_data,
      created_at: created_at,
      id: id,
      inbox: inbox.webhook_data,
      message_type: message_type,
      private: private,
      sender: sender.try(:webhook_data),
      source_id: source_id
    }
    data[:attachments] = attachments.map(&:push_event_data) if attachments.present?
    data
  end

  def content
    # move this to a presenter
    return self[:content] if !input_csat? || inbox.web_widget?

    I18n.t('conversations.survey.response', link: "#{ENV.fetch('FRONTEND_URL', nil)}/survey/responses/#{conversation.uuid}")
  end

  def email_notifiable_message?
    return false if private?
    return false if %w[outgoing template].exclude?(message_type)
    return false if template? && %w[input_csat text].exclude?(content_type)

    true
  end

  def valid_first_reply?
    return false unless outgoing? && human_response? && !private?
    return false if conversation.first_reply_created_at.present?
    return false if conversation.messages.outgoing
                                .where.not(sender_type: 'AgentBot')
                                .where.not(private: true)
                                .where("(additional_attributes->'campaign_id') is null").count > 1

    true
  end

  def save_story_info(story_info)
    self.content_attributes = content_attributes.merge(
      {
        story_id: story_info['id'],
        story_sender: inbox.channel.instagram_id,
        story_url: story_info['url']
      }
    )
    save!
  end

  private

  def prevent_message_flooding
    # Added this to cover the validation specs in messages
    # We can revisit and see if we can remove this later
    return if conversation.blank?

    # there are cases where automations can result in message loops, we need to prevent such cases.
    if conversation.messages.where('created_at >= ?', 1.minute.ago).count >= Limits.conversation_message_per_minute_limit
      Rails.logger.error "Too many message: Account Id - #{account_id} : Conversation id - #{conversation_id}"
      errors.add(:base, 'Too many messages')
    end
  end

  def ensure_processed_message_content
    text_content_quoted = content_attributes.dig(:email, :text_content, :quoted)
    html_content_quoted = content_attributes.dig(:email, :html_content, :quoted)

    message_content = text_content_quoted || html_content_quoted || content
    self.processed_message_content = message_content&.truncate(150_000)
  end

  # fetch the in_reply_to message and set the external id
  def ensure_in_reply_to
    in_reply_to = content_attributes[:in_reply_to]
    in_reply_to_external_id = content_attributes[:in_reply_to_external_id]

    Messages::InReplyToMessageBuilder.new(
      message: self,
      in_reply_to: in_reply_to,
      in_reply_to_external_id: in_reply_to_external_id
    ).perform
  end

  def ensure_content_type
    self.content_type ||= Message.content_types[:text]
  end

  def execute_after_create_commit_callbacks
    # rails issue with order of active record callbacks being executed https://github.com/rails/rails/issues/20911
    reopen_conversation
    notify_via_mail
    set_conversation_activity
    dispatch_create_events
    send_reply
    execute_message_template_hooks
    update_contact_activity
  end

  def update_contact_activity
    sender.update(last_activity_at: DateTime.now) if sender.is_a?(Contact)
  end

  def update_waiting_since
    if human_response? && !private && conversation.waiting_since.present?
      Rails.configuration.dispatcher.dispatch(
        REPLY_CREATED, Time.zone.now, waiting_since: conversation.waiting_since, message: self
      )
      conversation.update(waiting_since: nil)
    end
    conversation.update(waiting_since: created_at) if incoming? && conversation.waiting_since.blank?
  end

  def human_response?
    # if the sender is not a user, it's not a human response
    # if automation rule id is present, it's not a human response
    # if campaign id is present, it's not a human response
    outgoing? &&
      content_attributes['automation_rule_id'].blank? &&
      additional_attributes['campaign_id'].blank? &&
      sender.is_a?(User)
  end

  def dispatch_create_events
    Rails.configuration.dispatcher.dispatch(MESSAGE_CREATED, Time.zone.now, message: self, performed_by: Current.executed_by)

    if valid_first_reply?
      Rails.configuration.dispatcher.dispatch(FIRST_REPLY_CREATED, Time.zone.now, message: self, performed_by: Current.executed_by)
      conversation.update(first_reply_created_at: created_at, waiting_since: nil)
    else
      update_waiting_since
    end
  end

  def dispatch_update_event
    # ref: https://github.com/rails/rails/issues/44500
    # we want to skip the update event if the message is not updated
    return if previous_changes.blank?

    Rails.configuration.dispatcher.dispatch(MESSAGE_UPDATED, Time.zone.now, message: self, performed_by: Current.executed_by,
                                                                            previous_changes: previous_changes)
  end

  def send_reply
    # FIXME: Giving it few seconds for the attachment to be uploaded to the service
    # active storage attaches the file only after commit
    attachments.blank? ? ::SendReplyJob.perform_later(id) : ::SendReplyJob.set(wait: 2.seconds).perform_later(id)
  end

  def reopen_conversation
    return if conversation.muted?
    return unless incoming?

    conversation.open! if conversation.snoozed?

    reopen_resolved_conversation if conversation.resolved?
  end

  def reopen_resolved_conversation
    # mark resolved bot conversation as pending to be reopened by bot processor service
    if conversation.inbox.active_bot?
      conversation.pending!
    elsif conversation.inbox.api?
      Current.executed_by = sender if reopened_by_contact?
      conversation.open!
    else
      conversation.open!
    end
  end

  def reopened_by_contact?
    incoming? && !private? && Current.user.class != sender.class && sender.instance_of?(Contact)
  end

  def execute_message_template_hooks
    ::MessageTemplates::HookExecutionService.new(message: self).perform
  end

  def email_notifiable_webwidget?
    inbox.web_widget? && inbox.channel.continuity_via_email
  end

  def email_notifiable_api_channel?
    inbox.api? && inbox.account.feature_enabled?('email_continuity_on_api_channel')
  end

  def email_notifiable_channel?
    email_notifiable_webwidget? || %w[Email].include?(inbox.inbox_type) || email_notifiable_api_channel?
  end

  def can_notify_via_mail?
    return unless email_notifiable_message?
    return unless email_notifiable_channel?
    return if conversation.contact.email.blank?

    true
  end

  def notify_via_mail
    return unless can_notify_via_mail?

    trigger_notify_via_mail
  end

  def trigger_notify_via_mail
    return EmailReplyWorker.perform_in(1.second, id) if inbox.inbox_type == 'Email'

    # will set a redis key for the conversation so that we don't need to send email for every new message
    # last few messages coupled together is sent every 2 minutes rather than one email for each message
    # if redis key exists there is an unprocessed job that will take care of delivering the email
    return if Redis::Alfred.get(conversation_mail_key).present?

    Redis::Alfred.setex(conversation_mail_key, id)
    ConversationReplyEmailWorker.perform_in(2.minutes, conversation.id, id)
  end

  def conversation_mail_key
    format(::Redis::Alfred::CONVERSATION_MAILER_KEY, conversation_id: conversation.id)
  end

  def validate_attachments_limit(_attachment)
    errors.add(:attachments, message: 'exceeded maximum allowed') if attachments.size >= NUMBER_OF_PERMITTED_ATTACHMENTS
  end

  def set_conversation_activity
    # rubocop:disable Rails/SkipsModelValidations
    conversation.update_columns(last_activity_at: created_at)
    # rubocop:enable Rails/SkipsModelValidations
  end
end

Message.prepend_mod_with('Message')

================
File: models/note.rb
================
# == Schema Information
#
# Table name: notes
#
#  id         :bigint           not null, primary key
#  content    :text             not null
#  created_at :datetime         not null
#  updated_at :datetime         not null
#  account_id :bigint           not null
#  contact_id :bigint           not null
#  user_id    :bigint
#
# Indexes
#
#  index_notes_on_account_id  (account_id)
#  index_notes_on_contact_id  (contact_id)
#  index_notes_on_user_id     (user_id)
#
class Note < ApplicationRecord
  before_validation :ensure_account_id
  validates :content, presence: true
  validates :account_id, presence: true
  validates :contact_id, presence: true

  belongs_to :account
  belongs_to :contact
  belongs_to :user, optional: true

  scope :latest, -> { order(created_at: :desc) }

  private

  def ensure_account_id
    self.account_id = contact&.account_id
  end
end

================
File: models/notification_setting.rb
================
# == Schema Information
#
# Table name: notification_settings
#
#  id          :bigint           not null, primary key
#  email_flags :integer          default(0), not null
#  push_flags  :integer          default(0), not null
#  created_at  :datetime         not null
#  updated_at  :datetime         not null
#  account_id  :integer
#  user_id     :integer
#
# Indexes
#
#  by_account_user  (account_id,user_id) UNIQUE
#

class NotificationSetting < ApplicationRecord
  # used for single column multi flags
  include FlagShihTzu

  belongs_to :account
  belongs_to :user

  DEFAULT_QUERY_SETTING = {
    flag_query_mode: :bit_operator,
    check_for_column: false
  }.freeze

  EMAIL_NOTIFICATION_FLAGS = ::Notification::NOTIFICATION_TYPES.transform_keys { |key| "email_#{key}".to_sym }.invert.freeze
  PUSH_NOTIFICATION_FLAGS = ::Notification::NOTIFICATION_TYPES.transform_keys { |key| "push_#{key}".to_sym }.invert.freeze

  has_flags EMAIL_NOTIFICATION_FLAGS.merge(column: 'email_flags').merge(DEFAULT_QUERY_SETTING)
  has_flags PUSH_NOTIFICATION_FLAGS.merge(column: 'push_flags').merge(DEFAULT_QUERY_SETTING)
end

================
File: models/notification_subscription.rb
================
# == Schema Information
#
# Table name: notification_subscriptions
#
#  id                      :bigint           not null, primary key
#  identifier              :text
#  subscription_attributes :jsonb            not null
#  subscription_type       :integer          not null
#  created_at              :datetime         not null
#  updated_at              :datetime         not null
#  user_id                 :bigint           not null
#
# Indexes
#
#  index_notification_subscriptions_on_identifier  (identifier) UNIQUE
#  index_notification_subscriptions_on_user_id     (user_id)
#

class NotificationSubscription < ApplicationRecord
  belongs_to :user
  validates :identifier, presence: true

  SUBSCRIPTION_TYPES = {
    browser_push: 1,
    fcm: 2
  }.freeze

  enum subscription_type: SUBSCRIPTION_TYPES
end

================
File: models/notification.rb
================
# == Schema Information
#
# Table name: notifications
#
#  id                   :bigint           not null, primary key
#  last_activity_at     :datetime
#  meta                 :jsonb
#  notification_type    :integer          not null
#  primary_actor_type   :string           not null
#  read_at              :datetime
#  secondary_actor_type :string
#  snoozed_until        :datetime
#  created_at           :datetime         not null
#  updated_at           :datetime         not null
#  account_id           :bigint           not null
#  primary_actor_id     :bigint           not null
#  secondary_actor_id   :bigint
#  user_id              :bigint           not null
#
# Indexes
#
#  index_notifications_on_account_id               (account_id)
#  index_notifications_on_last_activity_at         (last_activity_at)
#  index_notifications_on_user_id                  (user_id)
#  uniq_primary_actor_per_account_notifications    (primary_actor_type,primary_actor_id)
#  uniq_secondary_actor_per_account_notifications  (secondary_actor_type,secondary_actor_id)
#

class Notification < ApplicationRecord
  include MessageFormatHelper
  belongs_to :account
  belongs_to :user

  belongs_to :primary_actor, polymorphic: true
  belongs_to :secondary_actor, polymorphic: true, optional: true

  NOTIFICATION_TYPES = {
    conversation_creation: 1,
    conversation_assignment: 2,
    assigned_conversation_new_message: 3,
    conversation_mention: 4,
    participating_conversation_new_message: 5,
    sla_missed_first_response: 6,
    sla_missed_next_response: 7,
    sla_missed_resolution: 8
  }.freeze

  enum notification_type: NOTIFICATION_TYPES

  before_create :set_last_activity_at
  after_create_commit :process_notification_delivery, :dispatch_create_event
  after_destroy_commit :dispatch_destroy_event
  after_update_commit :dispatch_update_event

  PRIMARY_ACTORS = ['Conversation'].freeze

  def push_event_data
    # Secondary actor could be nil for cases like system assigning conversation
    payload = {
      id: id,
      notification_type: notification_type,
      primary_actor_type: primary_actor_type,
      primary_actor_id: primary_actor_id,
      read_at: read_at,
      secondary_actor: secondary_actor&.push_event_data,
      user: user&.push_event_data,
      created_at: created_at.to_i,
      last_activity_at: last_activity_at.to_i,
      snoozed_until: snoozed_until,
      meta: meta,
      account_id: account_id
    }
    payload.merge!(primary_actor_data) if primary_actor.present?
    payload
  end

  def fcm_push_data
    {
      id: id,
      notification_type: notification_type,
      primary_actor_id: primary_actor_id,
      primary_actor_type: primary_actor_type,
      primary_actor: primary_actor.push_event_data.with_indifferent_access.slice('conversation_id', 'id')
    }
  end

  # rubocop:disable Metrics/MethodLength
  def push_message_title
    notification_title_map = {
      'conversation_creation' => 'notifications.notification_title.conversation_creation',
      'conversation_assignment' => 'notifications.notification_title.conversation_assignment',
      'assigned_conversation_new_message' => 'notifications.notification_title.assigned_conversation_new_message',
      'participating_conversation_new_message' => 'notifications.notification_title.assigned_conversation_new_message',
      'conversation_mention' => 'notifications.notification_title.conversation_mention',
      'sla_missed_first_response' => 'notifications.notification_title.sla_missed_first_response',
      'sla_missed_next_response' => 'notifications.notification_title.sla_missed_next_response',
      'sla_missed_resolution' => 'notifications.notification_title.sla_missed_resolution'
    }

    i18n_key = notification_title_map[notification_type]
    return '' unless i18n_key

    if notification_type == 'conversation_creation'
      I18n.t(i18n_key, display_id: conversation.display_id, inbox_name: primary_actor.inbox.name)
    elsif %w[conversation_assignment assigned_conversation_new_message participating_conversation_new_message
             conversation_mention].include?(notification_type)
      I18n.t(i18n_key, display_id: conversation.display_id)
    else
      I18n.t(i18n_key, display_id: primary_actor.display_id)
    end
  end
  # rubocop:enable Metrics/MethodLength

  def push_message_body
    case notification_type
    when 'conversation_creation', 'sla_missed_first_response'
      message_body(conversation.messages.first)
    when 'assigned_conversation_new_message', 'participating_conversation_new_message', 'conversation_mention'
      message_body(secondary_actor)
    when 'conversation_assignment', 'sla_missed_next_response', 'sla_missed_resolution'
      message_body((conversation.messages.incoming.last || conversation.messages.outgoing.last))
    else
      ''
    end
  end

  def conversation
    primary_actor
  end

  private

  def message_body(actor)
    sender_name = sender_name(actor)
    content = message_content(actor)
    "#{sender_name}: #{content}"
  end

  def sender_name(actor)
    actor.try(:sender)&.name || ''
  end

  def message_content(actor)
    content = actor.try(:content)
    attachments = actor.try(:attachments)

    if content.present?
      transform_user_mention_content(content.truncate_words(10))
    else
      attachments.present? ? I18n.t('notifications.attachment') : I18n.t('notifications.no_content')
    end
  end

  def process_notification_delivery
    Notification::PushNotificationJob.perform_later(self) if user_subscribed_to_notification?('push')

    # Should we do something about the case where user subscribed to both push and email ?
    # In future, we could probably add condition here to enqueue the job for 30 seconds later
    # when push enabled and then check in email job whether notification has been read already.
    Notification::EmailNotificationJob.perform_later(self) if user_subscribed_to_notification?('email')

    Notification::RemoveDuplicateNotificationJob.perform_later(self)
  end

  def user_subscribed_to_notification?(delivery_type)
    notification_setting = user.notification_settings.find_by(account_id: account.id)
    return false if notification_setting.blank?

    # Check if the user has subscribed to the specified type of notification
    notification_setting.public_send("#{delivery_type}_#{notification_type}?")
  end

  def dispatch_create_event
    Rails.configuration.dispatcher.dispatch(NOTIFICATION_CREATED, Time.zone.now, notification: self)
  end

  def dispatch_update_event
    Rails.configuration.dispatcher.dispatch(NOTIFICATION_UPDATED, Time.zone.now, notification: self)
  end

  def dispatch_destroy_event
    Rails.configuration.dispatcher.dispatch(NOTIFICATION_DELETED, Time.zone.now, notification: self)
  end

  def set_last_activity_at
    self.last_activity_at = created_at
  end

  def primary_actor_data
    {
      primary_actor: primary_actor&.push_event_data,
      # TODO: Rename push_message_title to push_message_body
      push_message_title: push_message_body,
      push_message_body: push_message_body
    }
  end
end

================
File: models/platform_app_permissible.rb
================
# == Schema Information
#
# Table name: platform_app_permissibles
#
#  id               :bigint           not null, primary key
#  permissible_type :string           not null
#  created_at       :datetime         not null
#  updated_at       :datetime         not null
#  permissible_id   :bigint           not null
#  platform_app_id  :bigint           not null
#
# Indexes
#
#  index_platform_app_permissibles_on_permissibles     (permissible_type,permissible_id)
#  index_platform_app_permissibles_on_platform_app_id  (platform_app_id)
#  unique_permissibles_index                           (platform_app_id,permissible_id,permissible_type) UNIQUE
#
class PlatformAppPermissible < ApplicationRecord
  validates :platform_app, presence: true
  validates :platform_app_id, uniqueness: { scope: [:permissible_id, :permissible_type] }

  belongs_to :platform_app
  belongs_to :permissible, polymorphic: true
end

================
File: models/platform_app.rb
================
# == Schema Information
#
# Table name: platform_apps
#
#  id         :bigint           not null, primary key
#  name       :string           not null
#  created_at :datetime         not null
#  updated_at :datetime         not null
#
class PlatformApp < ApplicationRecord
  include AccessTokenable

  validates :name, presence: true

  has_many :platform_app_permissibles, dependent: :destroy_async
end

================
File: models/portal_member.rb
================
# == Schema Information
#
# Table name: portal_members
#
#  id         :bigint           not null, primary key
#  created_at :datetime         not null
#  updated_at :datetime         not null
#  portal_id  :bigint
#  user_id    :bigint
#
# Indexes
#
#  index_portal_members_on_portal_id_and_user_id  (portal_id,user_id) UNIQUE
#  index_portal_members_on_user_id_and_portal_id  (user_id,portal_id) UNIQUE
#
class PortalMember < ApplicationRecord
  belongs_to :portal, class_name: 'Portal'
  belongs_to :user, class_name: 'User'
  validates :user_id, uniqueness: { scope: :portal_id }
end

================
File: models/portal.rb
================
# == Schema Information
#
# Table name: portals
#
#  id                    :bigint           not null, primary key
#  archived              :boolean          default(FALSE)
#  color                 :string
#  config                :jsonb
#  custom_domain         :string
#  header_text           :text
#  homepage_link         :string
#  name                  :string           not null
#  page_title            :string
#  slug                  :string           not null
#  created_at            :datetime         not null
#  updated_at            :datetime         not null
#  account_id            :integer          not null
#  channel_web_widget_id :bigint
#
# Indexes
#
#  index_portals_on_channel_web_widget_id  (channel_web_widget_id)
#  index_portals_on_custom_domain          (custom_domain) UNIQUE
#  index_portals_on_slug                   (slug) UNIQUE
#
class Portal < ApplicationRecord
  include Rails.application.routes.url_helpers

  belongs_to :account
  has_many :categories, dependent: :destroy_async
  has_many :folders,  through: :categories
  has_many :articles, dependent: :destroy_async
  has_many :portal_members,
           class_name: :PortalMember,
           dependent: :destroy_async
  has_many :members,
           through: :portal_members,
           class_name: :User,
           dependent: :nullify,
           source: :user
  has_one_attached :logo
  has_many :inboxes, dependent: :nullify
  belongs_to :channel_web_widget, class_name: 'Channel::WebWidget', optional: true

  before_validation -> { normalize_empty_string_to_nil(%i[custom_domain homepage_link]) }
  validates :account_id, presence: true
  validates :name, presence: true
  validates :slug, presence: true, uniqueness: true
  validates :custom_domain, uniqueness: true, allow_nil: true
  validate :config_json_format

  accepts_nested_attributes_for :members

  scope :active, -> { where(archived: false) }

  CONFIG_JSON_KEYS = %w[allowed_locales default_locale website_token].freeze

  def file_base_data
    {
      id: logo.id,
      portal_id: id,
      file_type: logo.content_type,
      account_id: account_id,
      file_url: url_for(logo),
      blob_id: logo.blob_id,
      filename: logo.filename.to_s
    }
  end

  def default_locale
    config['default_locale'] || 'en'
  end

  private

  def config_json_format
    config['default_locale'] = default_locale
    denied_keys = config.keys - CONFIG_JSON_KEYS
    errors.add(:cofig, "in portal on #{denied_keys.join(',')} is not supported.") if denied_keys.any?
  end
end

================
File: models/related_category.rb
================
# == Schema Information
#
# Table name: related_categories
#
#  id                  :bigint           not null, primary key
#  created_at          :datetime         not null
#  updated_at          :datetime         not null
#  category_id         :bigint
#  related_category_id :bigint
#
# Indexes
#
#  index_related_categories_on_category_id_and_related_category_id  (category_id,related_category_id) UNIQUE
#  index_related_categories_on_related_category_id_and_category_id  (related_category_id,category_id) UNIQUE
#
class RelatedCategory < ApplicationRecord
  belongs_to :related_category, class_name: 'Category'
  belongs_to :category, class_name: 'Category'
end

================
File: models/reporting_event.rb
================
# == Schema Information
#
# Table name: reporting_events
#
#  id                      :bigint           not null, primary key
#  event_end_time          :datetime
#  event_start_time        :datetime
#  name                    :string
#  value                   :float
#  value_in_business_hours :float
#  created_at              :datetime         not null
#  updated_at              :datetime         not null
#  account_id              :integer
#  conversation_id         :integer
#  inbox_id                :integer
#  user_id                 :integer
#
# Indexes
#
#  index_reporting_events_on_account_id            (account_id)
#  index_reporting_events_on_conversation_id       (conversation_id)
#  index_reporting_events_on_created_at            (created_at)
#  index_reporting_events_on_inbox_id              (inbox_id)
#  index_reporting_events_on_name                  (name)
#  index_reporting_events_on_user_id               (user_id)
#  reporting_events__account_id__name__created_at  (account_id,name,created_at)
#

class ReportingEvent < ApplicationRecord
  validates :account_id, presence: true
  validates :name, presence: true
  validates :value, presence: true

  belongs_to :account
  belongs_to :user, optional: true
  belongs_to :inbox, optional: true
  belongs_to :conversation, optional: true
end

================
File: models/super_admin.rb
================
# == Schema Information
#
# Table name: users
#
#  id                     :integer          not null, primary key
#  availability           :integer          default("online")
#  confirmation_sent_at   :datetime
#  confirmation_token     :string
#  confirmed_at           :datetime
#  current_sign_in_at     :datetime
#  current_sign_in_ip     :string
#  custom_attributes      :jsonb
#  display_name           :string
#  email                  :string
#  encrypted_password     :string           default(""), not null
#  last_sign_in_at        :datetime
#  last_sign_in_ip        :string
#  message_signature      :text
#  name                   :string           not null
#  provider               :string           default("email"), not null
#  pubsub_token           :string
#  remember_created_at    :datetime
#  reset_password_sent_at :datetime
#  reset_password_token   :string
#  sign_in_count          :integer          default(0), not null
#  tokens                 :json
#  type                   :string
#  ui_settings            :jsonb
#  uid                    :string           default(""), not null
#  unconfirmed_email      :string
#  created_at             :datetime         not null
#  updated_at             :datetime         not null
#
# Indexes
#
#  index_users_on_email                 (email)
#  index_users_on_pubsub_token          (pubsub_token) UNIQUE
#  index_users_on_reset_password_token  (reset_password_token) UNIQUE
#  index_users_on_uid_and_provider      (uid,provider) UNIQUE
#
class SuperAdmin < User
end

================
File: models/team_member.rb
================
# == Schema Information
#
# Table name: team_members
#
#  id         :bigint           not null, primary key
#  created_at :datetime         not null
#  updated_at :datetime         not null
#  team_id    :bigint           not null
#  user_id    :bigint           not null
#
# Indexes
#
#  index_team_members_on_team_id              (team_id)
#  index_team_members_on_team_id_and_user_id  (team_id,user_id) UNIQUE
#  index_team_members_on_user_id              (user_id)
#
class TeamMember < ApplicationRecord
  belongs_to :user
  belongs_to :team
  validates :user_id, uniqueness: { scope: :team_id }
end

TeamMember.include_mod_with('Audit::TeamMember')

================
File: models/team.rb
================
# == Schema Information
#
# Table name: teams
#
#  id                :bigint           not null, primary key
#  allow_auto_assign :boolean          default(TRUE)
#  description       :text
#  name              :string           not null
#  created_at        :datetime         not null
#  updated_at        :datetime         not null
#  account_id        :bigint           not null
#
# Indexes
#
#  index_teams_on_account_id           (account_id)
#  index_teams_on_name_and_account_id  (name,account_id) UNIQUE
#
class Team < ApplicationRecord
  include AccountCacheRevalidator

  belongs_to :account
  has_many :team_members, dependent: :destroy_async
  has_many :members, through: :team_members, source: :user
  has_many :conversations, dependent: :nullify

  validates :name,
            presence: { message: I18n.t('errors.validations.presence') },
            uniqueness: { scope: :account_id }

  before_validation do
    self.name = name.downcase if attribute_present?('name')
  end

  # Adds multiple members to the team
  # @param user_ids [Array<Integer>] Array of user IDs to add as members
  # @return [Array<User>] Array of newly added members
  def add_members(user_ids)
    team_members_to_create = user_ids.map { |user_id| { user_id: user_id } }
    created_members = team_members.create(team_members_to_create)
    added_users = created_members.filter_map(&:user)

    update_account_cache
    added_users
  end

  # Removes multiple members from the team
  # @param user_ids [Array<Integer>] Array of user IDs to remove
  # @return [void]
  def remove_members(user_ids)
    team_members.where(user_id: user_ids).destroy_all
    update_account_cache
  end

  def messages
    account.messages.where(conversation_id: conversations.pluck(:id))
  end

  def reporting_events
    account.reporting_events.where(conversation_id: conversations.pluck(:id))
  end

  def push_event_data
    {
      id: id,
      name: name
    }
  end
end

Team.include_mod_with('Audit::Team')

================
File: models/telegram_bot.rb
================
# == Schema Information
#
# Table name: telegram_bots
#
#  id         :integer          not null, primary key
#  auth_key   :string
#  name       :string
#  created_at :datetime         not null
#  updated_at :datetime         not null
#  account_id :integer
#

class TelegramBot < ApplicationRecord
  belongs_to :account
  has_one :inbox, as: :channel, dependent: :destroy_async
  validates :auth_key, uniqueness: { scope: :account_id }
end

================
File: models/user.rb
================
# == Schema Information
#
# Table name: users
#
#  id                     :integer          not null, primary key
#  availability           :integer          default("online")
#  confirmation_sent_at   :datetime
#  confirmation_token     :string
#  confirmed_at           :datetime
#  current_sign_in_at     :datetime
#  current_sign_in_ip     :string
#  custom_attributes      :jsonb
#  display_name           :string
#  email                  :string
#  encrypted_password     :string           default(""), not null
#  last_sign_in_at        :datetime
#  last_sign_in_ip        :string
#  message_signature      :text
#  name                   :string           not null
#  provider               :string           default("email"), not null
#  pubsub_token           :string
#  remember_created_at    :datetime
#  reset_password_sent_at :datetime
#  reset_password_token   :string
#  sign_in_count          :integer          default(0), not null
#  tokens                 :json
#  type                   :string
#  ui_settings            :jsonb
#  uid                    :string           default(""), not null
#  unconfirmed_email      :string
#  created_at             :datetime         not null
#  updated_at             :datetime         not null
#
# Indexes
#
#  index_users_on_email                 (email)
#  index_users_on_pubsub_token          (pubsub_token) UNIQUE
#  index_users_on_reset_password_token  (reset_password_token) UNIQUE
#  index_users_on_uid_and_provider      (uid,provider) UNIQUE
#

class User < ApplicationRecord
  include AccessTokenable
  include Avatarable
  # Include default devise modules.
  include DeviseTokenAuth::Concerns::User
  include Pubsubable
  include Rails.application.routes.url_helpers
  include Reportable
  include SsoAuthenticatable
  include UserAttributeHelpers

  devise :database_authenticatable,
         :registerable,
         :recoverable,
         :rememberable,
         :trackable,
         :validatable,
         :confirmable,
         :password_has_required_content,
         :omniauthable, omniauth_providers: [:google_oauth2]

  # TODO: remove in a future version once online status is moved to account users
  # remove the column availability from users
  enum availability: { online: 0, offline: 1, busy: 2 }

  # The validation below has been commented out as it does not
  # work because :validatable in devise overrides this.
  # validates_uniqueness_of :email, scope: :account_id

  validates :email, presence: true

  has_many :account_users, dependent: :destroy_async
  has_many :accounts, through: :account_users
  accepts_nested_attributes_for :account_users

  has_many :assigned_conversations, foreign_key: 'assignee_id', class_name: 'Conversation', dependent: :nullify, inverse_of: :assignee
  alias_attribute :conversations, :assigned_conversations
  has_many :csat_survey_responses, foreign_key: 'assigned_agent_id', dependent: :nullify, inverse_of: :assigned_agent
  has_many :conversation_participants, dependent: :destroy_async
  has_many :participating_conversations, through: :conversation_participants, source: :conversation

  has_many :inbox_members, dependent: :destroy_async
  has_many :inboxes, through: :inbox_members, source: :inbox
  has_many :messages, as: :sender, dependent: :nullify
  has_many :invitees, through: :account_users, class_name: 'User', foreign_key: 'inviter_id', source: :inviter, dependent: :nullify

  has_many :custom_filters, dependent: :destroy_async
  has_many :dashboard_apps, dependent: :nullify
  has_many :mentions, dependent: :destroy_async
  has_many :notes, dependent: :nullify
  has_many :notification_settings, dependent: :destroy_async
  has_many :notification_subscriptions, dependent: :destroy_async
  has_many :notifications, dependent: :destroy_async
  has_many :team_members, dependent: :destroy_async
  has_many :teams, through: :team_members
  has_many :articles, foreign_key: 'author_id', dependent: :nullify, inverse_of: :author
  has_many :portal_members, class_name: :PortalMember, dependent: :destroy_async
  has_many :portals, through: :portal_members, source: :portal,
                     class_name: :Portal,
                     dependent: :nullify
  # rubocop:disable Rails/HasManyOrHasOneDependent
  # we are handling this in `remove_macros` callback
  has_many :macros, foreign_key: 'created_by_id', inverse_of: :created_by
  # rubocop:enable Rails/HasManyOrHasOneDependent

  before_validation :set_password_and_uid, on: :create
  after_destroy :remove_macros

  scope :order_by_full_name, -> { order('lower(name) ASC') }

  before_validation do
    self.email = email.try(:downcase)
  end

  def send_devise_notification(notification, *args)
    devise_mailer.with(account: Current.account).send(notification, self, *args).deliver_later
  end

  def set_password_and_uid
    self.uid = email
  end

  def assigned_inboxes
    administrator? ? Current.account.inboxes : inboxes.where(account_id: Current.account.id)
  end

  def serializable_hash(options = nil)
    super(options).merge(confirmed: confirmed?)
  end

  def push_event_data
    {
      id: id,
      name: name,
      available_name: available_name,
      avatar_url: avatar_url,
      type: 'user',
      availability_status: availability_status,
      thumbnail: avatar_url
    }
  end

  def webhook_data
    {
      id: id,
      name: name,
      email: email,
      type: 'user'
    }
  end

  # https://github.com/lynndylanhurley/devise_token_auth/blob/6d7780ee0b9750687e7e2871b9a1c6368f2085a9/app/models/devise_token_auth/concerns/user.rb#L45
  # Since this method is overriden in devise_token_auth it breaks the email reconfirmation flow.
  def will_save_change_to_email?
    mutations_from_database.changed?('email')
  end

  def self.from_email(email)
    find_by(email: email&.downcase)
  end

  private

  def remove_macros
    macros.personal.destroy_all
  end
end

User.include_mod_with('Audit::User')
User.include_mod_with('Concerns::User')

================
File: models/webhook.rb
================
# == Schema Information
#
# Table name: webhooks
#
#  id            :bigint           not null, primary key
#  subscriptions :jsonb
#  url           :string
#  webhook_type  :integer          default("account_type")
#  created_at    :datetime         not null
#  updated_at    :datetime         not null
#  account_id    :integer
#  inbox_id      :integer
#
# Indexes
#
#  index_webhooks_on_account_id_and_url  (account_id,url) UNIQUE
#

class Webhook < ApplicationRecord
  belongs_to :account
  belongs_to :inbox, optional: true

  validates :account_id, presence: true
  validates :url, uniqueness: { scope: [:account_id] }, format: URI::DEFAULT_PARSER.make_regexp(%w[http https])
  validate :validate_webhook_subscriptions
  enum webhook_type: { account_type: 0, inbox_type: 1 }

  ALLOWED_WEBHOOK_EVENTS = %w[conversation_status_changed conversation_updated conversation_created contact_created contact_updated
                              message_created message_updated webwidget_triggered inbox_created inbox_updated].freeze

  private

  def validate_webhook_subscriptions
    invalid_subscriptions = !subscriptions.instance_of?(Array) ||
                            subscriptions.blank? ||
                            (subscriptions.uniq - ALLOWED_WEBHOOK_EVENTS).length.positive?
    errors.add(:subscriptions, I18n.t('errors.webhook.invalid')) if invalid_subscriptions
  end
end

Webhook.include_mod_with('Audit::Webhook')

================
File: models/working_hour.rb
================
# == Schema Information
#
# Table name: working_hours
#
#  id             :bigint           not null, primary key
#  close_hour     :integer
#  close_minutes  :integer
#  closed_all_day :boolean          default(FALSE)
#  day_of_week    :integer          not null
#  open_all_day   :boolean          default(FALSE)
#  open_hour      :integer
#  open_minutes   :integer
#  created_at     :datetime         not null
#  updated_at     :datetime         not null
#  account_id     :bigint
#  inbox_id       :bigint
#
# Indexes
#
#  index_working_hours_on_account_id  (account_id)
#  index_working_hours_on_inbox_id    (inbox_id)
#
class WorkingHour < ApplicationRecord
  belongs_to :inbox

  before_validation :ensure_open_all_day_hours
  before_save :assign_account

  validates :open_hour,     presence: true, unless: :closed_all_day?
  validates :open_minutes,  presence: true, unless: :closed_all_day?
  validates :close_hour,    presence: true, unless: :closed_all_day?
  validates :close_minutes, presence: true, unless: :closed_all_day?

  validates :open_hour,     inclusion: 0..23, unless: :closed_all_day?
  validates :close_hour,    inclusion: 0..23, unless: :closed_all_day?
  validates :open_minutes,  inclusion: 0..59, unless: :closed_all_day?
  validates :close_minutes, inclusion: 0..59, unless: :closed_all_day?

  validate :close_after_open, unless: :closed_all_day?
  validate :open_all_day_and_closed_all_day

  def self.today
    # While getting the day of the week, consider the timezone as well. `first` would
    # return the first working hour from the list of working hours available per week.
    inbox = first.inbox
    find_by(day_of_week: Time.zone.now.in_time_zone(inbox.timezone).to_date.wday)
  end

  def open_at?(time)
    return false if closed_all_day?

    open_time = Time.zone.now.in_time_zone(inbox.timezone).change({ hour: open_hour, min: open_minutes })
    close_time = Time.zone.now.in_time_zone(inbox.timezone).change({ hour: close_hour, min: close_minutes })

    time.between?(open_time, close_time)
  end

  def open_now?
    inbox_time = Time.zone.now.in_time_zone(inbox.timezone)
    open_at?(inbox_time)
  end

  def closed_now?
    !open_now?
  end

  private

  def assign_account
    self.account_id = inbox.account_id
  end

  def close_after_open
    return unless open_hour.hours + open_minutes.minutes >= close_hour.hours + close_minutes.minutes

    errors.add(:close_hour, 'Closing time cannot be before opening time')
  end

  def ensure_open_all_day_hours
    return unless open_all_day?

    self.open_hour = 0
    self.open_minutes = 0
    self.close_hour = 23
    self.close_minutes = 59
  end

  def open_all_day_and_closed_all_day
    return unless open_all_day? && closed_all_day?

    errors.add(:base, 'open_all_day and closed_all_day cannot be true at the same time')
  end
end

================
File: policies/account_policy.rb
================
class AccountPolicy < ApplicationPolicy
  def show?
    @account_user.administrator? || @account_user.agent?
  end

  def cache_keys?
    @account_user.administrator? || @account_user.agent?
  end

  def limits?
    @account_user.administrator?
  end

  def update?
    @account_user.administrator?
  end

  def update_active_at?
    true
  end

  def subscription?
    @account_user.administrator?
  end

  def checkout?
    @account_user.administrator?
  end
end

================
File: policies/agent_bot_policy.rb
================
class AgentBotPolicy < ApplicationPolicy
  def index?
    @account_user.administrator? || @account_user.agent?
  end

  def update?
    @account_user.administrator?
  end

  def show?
    @account_user.administrator? || @account_user.agent?
  end

  def create?
    @account_user.administrator?
  end

  def destroy?
    @account_user.administrator?
  end

  def avatar?
    @account_user.administrator?
  end
end

================
File: policies/application_policy.rb
================
class ApplicationPolicy
  attr_reader :user_context, :user, :record, :account, :account_user

  def initialize(user_context, record)
    @user_context = user_context
    @user = user_context[:user]
    @account = user_context[:account]
    @account_user = user_context[:account_user]
    @record = record
  end

  def index?
    false
  end

  def show?
    scope.exists?(id: record.id)
  end

  def create?
    false
  end

  def new?
    create?
  end

  def update?
    false
  end

  def edit?
    update?
  end

  def destroy?
    false
  end

  def scope
    Pundit.policy_scope!(user_context, record.class)
  end

  class Scope
    attr_reader :user_context, :user, :scope, :account, :account_user

    def initialize(user_context, scope)
      @user_context = user_context
      @user = user_context[:user]
      @account = user_context[:account]
      @account_user = user_context[:account_user]
      @scope = scope
    end

    def resolve
      scope
    end
  end
end

================
File: policies/article_policy.rb
================
class ArticlePolicy < ApplicationPolicy
  def index?
    @account_user.administrator? || @account.users.include?(@user)
  end

  def update?
    @account_user.administrator? || portal_member?
  end

  def show?
    @account_user.administrator? || portal_member?
  end

  def edit?
    @account_user.administrator? || portal_member?
  end

  def create?
    @account_user.administrator? || portal_member?
  end

  def destroy?
    @account_user.administrator? || portal_member?
  end

  def reorder?
    @account_user.administrator? || portal_member?
  end

  private

  def portal_member?
    @record.first.portal.members.include?(@user)
  end
end

ArticlePolicy.prepend_mod_with('Enterprise::ArticlePolicy')

================
File: policies/automation_rule_policy.rb
================
class AutomationRulePolicy < ApplicationPolicy
  def index?
    @account_user.administrator?
  end

  def create?
    @account_user.administrator?
  end

  def show?
    @account_user.administrator?
  end

  def update?
    @account_user.administrator?
  end

  def clone?
    @account_user.administrator?
  end

  def destroy?
    @account_user.administrator?
  end
end

================
File: policies/campaign_policy.rb
================
class CampaignPolicy < ApplicationPolicy
  def index?
    @account_user.administrator?
  end

  def update?
    @account_user.administrator?
  end

  def show?
    @account_user.administrator?
  end

  def create?
    @account_user.administrator?
  end

  def destroy?
    @account_user.administrator?
  end
end

================
File: policies/category_policy.rb
================
class CategoryPolicy < ApplicationPolicy
  def index?
    @account_user.administrator? || @account.users.include?(@user)
  end

  def update?
    @account_user.administrator? || portal_member?
  end

  def show?
    @account_user.administrator? || portal_member?
  end

  def edit?
    @account_user.administrator? || portal_member?
  end

  def create?
    @account_user.administrator? || portal_member?
  end

  def destroy?
    @account_user.administrator? || portal_member?
  end

  private

  def portal_member?
    @record.first.portal.members.include?(@user)
  end
end

CategoryPolicy.prepend_mod_with('Enterprise::CategoryPolicy')

================
File: policies/contact_policy.rb
================
class ContactPolicy < ApplicationPolicy
  def index?
    true
  end

  def active?
    true
  end

  def import?
    @account_user.administrator?
  end

  def export?
    @account_user.administrator?
  end

  def search?
    true
  end

  def filter?
    true
  end

  def update?
    true
  end

  def contactable_inboxes?
    true
  end

  def destroy_custom_attributes?
    true
  end

  def show?
    true
  end

  def create?
    true
  end

  def avatar?
    true
  end

  def destroy?
    @account_user.administrator?
  end
end

================
File: policies/conversation_policy.rb
================
class ConversationPolicy < ApplicationPolicy
  def index?
    true
  end
end

================
File: policies/csat_survey_response_policy.rb
================
class CsatSurveyResponsePolicy < ApplicationPolicy
  def index?
    @account_user.administrator?
  end

  def metrics?
    @account_user.administrator?
  end

  def download?
    @account_user.administrator?
  end
end

================
File: policies/custom_filter_policy.rb
================
class CustomFilterPolicy < ApplicationPolicy
  def create?
    @account_user.administrator? || @account_user.agent?
  end

  def show?
    @account_user.administrator? || @account_user.agent?
  end

  def index?
    @account_user.administrator? || @account_user.agent?
  end

  def update?
    @account_user.administrator? || @account_user.agent?
  end

  def destroy?
    @account_user.administrator? || @account_user.agent?
  end
end

================
File: policies/hook_policy.rb
================
class HookPolicy < ApplicationPolicy
  def create?
    @account_user.administrator?
  end

  def update?
    @account_user.administrator?
  end

  def process_event?
    true
  end

  def destroy?
    @account_user.administrator?
  end
end

================
File: policies/inbox_policy.rb
================
class InboxPolicy < ApplicationPolicy
  class Scope
    attr_reader :user_context, :user, :scope, :account, :account_user

    def initialize(user_context, scope)
      @user_context = user_context
      @user = user_context[:user]
      @account = user_context[:account]
      @account_user = user_context[:account_user]
      @scope = scope
    end

    def resolve
      user.assigned_inboxes
    end
  end

  def index?
    true
  end

  def show?
    # FIXME: for agent bots, lets bring this validation to policies as well in future
    return true if @user.is_a?(AgentBot)

    Current.user.assigned_inboxes.include? record
  end

  def assignable_agents?
    true
  end

  def agent_bot?
    true
  end

  def campaigns?
    @account_user.administrator?
  end

  def create?
    @account_user.administrator?
  end

  def update?
    @account_user.administrator?
  end

  def destroy?
    @account_user.administrator?
  end

  def set_agent_bot?
    @account_user.administrator?
  end

  def avatar?
    @account_user.administrator?
  end
end

================
File: policies/label_policy.rb
================
class LabelPolicy < ApplicationPolicy
  def index?
    @account_user.administrator? || @account_user.agent?
  end

  def update?
    @account_user.administrator?
  end

  def show?
    @account_user.administrator?
  end

  def create?
    @account_user.administrator?
  end

  def destroy?
    @account_user.administrator?
  end
end

================
File: policies/macro_policy.rb
================
class MacroPolicy < ApplicationPolicy
  def index?
    true
  end

  def create?
    true
  end

  def show?
    @record.global? || author?
  end

  def update?
    author? || (@account_user.administrator? && @record.global?)
  end

  def destroy?
    author? || orphan_record?
  end

  def execute?
    @record.global? || author?
  end

  private

  def author?
    @record.created_by == @account_user.user
  end

  def orphan_record?
    return @account_user.administrator? if @record.created_by.nil? && @record.global?

    false
  end
end

================
File: policies/portal_policy.rb
================
class PortalPolicy < ApplicationPolicy
  def index?
    @account_user.administrator? || @account.users.include?(@user)
  end

  def update?
    @account_user.administrator?
  end

  def show?
    @account_user.administrator? || portal_member?
  end

  def edit?
    @account_user.administrator?
  end

  def create?
    @account_user.administrator?
  end

  def destroy?
    @account_user.administrator?
  end

  def add_members?
    @account_user.administrator?
  end

  def logo?
    @account_user.administrator?
  end

  private

  def portal_member?
    @record.first.members.include?(@user)
  end
end

PortalPolicy.prepend_mod_with('Enterprise::PortalPolicy')

================
File: policies/report_policy.rb
================
class ReportPolicy < ApplicationPolicy
  def view?
    @account_user.administrator?
  end
end

ReportPolicy.prepend_mod_with('Enterprise::ReportPolicy')

================
File: policies/team_member_policy.rb
================
class TeamMemberPolicy < ApplicationPolicy
  def index?
    true
  end

  def create?
    @account_user.administrator?
  end

  def destroy?
    @account_user.administrator?
  end

  def update?
    @account_user.administrator?
  end
end

================
File: policies/team_policy.rb
================
class TeamPolicy < ApplicationPolicy
  def index?
    true
  end

  def update?
    @account_user.administrator?
  end

  def show?
    true
  end

  def create?
    @account_user.administrator?
  end

  def destroy?
    @account_user.administrator?
  end
end

================
File: policies/user_policy.rb
================
class UserPolicy < ApplicationPolicy
  def index?
    true
  end

  def create?
    @account_user.administrator?
  end

  def update?
    @account_user.administrator?
  end

  def destroy?
    @account_user.administrator?
  end

  def bulk_create?
    @account_user.administrator?
  end
end

================
File: policies/webhook_policy.rb
================
class WebhookPolicy < ApplicationPolicy
  def index?
    @account_user.administrator?
  end

  def update?
    @account_user.administrator?
  end

  def destroy?
    @account_user.administrator?
  end

  def create?
    @account_user.administrator?
  end
end

================
File: presenters/conversations/event_data_presenter.rb
================
class Conversations::EventDataPresenter < SimpleDelegator
  def push_data
    {
      additional_attributes: additional_attributes,
      can_reply: can_reply?,
      channel: inbox.try(:channel_type),
      contact_inbox: contact_inbox,
      id: display_id,
      inbox_id: inbox_id,
      messages: push_messages,
      labels: label_list,
      meta: push_meta,
      status: status,
      custom_attributes: custom_attributes,
      snoozed_until: snoozed_until,
      unread_count: unread_incoming_messages.count,
      first_reply_created_at: first_reply_created_at,
      priority: priority,
      waiting_since: waiting_since.to_i,
      **push_timestamps
    }
  end

  private

  def push_messages
    [messages.chat.last&.push_event_data].compact
  end

  def push_meta
    {
      sender: contact.push_event_data,
      assignee: assignee&.push_event_data,
      team: team&.push_event_data,
      hmac_verified: contact_inbox&.hmac_verified
    }
  end

  def push_timestamps
    {
      agent_last_seen_at: agent_last_seen_at.to_i,
      contact_last_seen_at: contact_last_seen_at.to_i,
      last_activity_at: last_activity_at.to_i,
      timestamp: last_activity_at.to_i,
      created_at: created_at.to_i,
      updated_at: updated_at.to_f
    }
  end
end
Conversations::EventDataPresenter.prepend_mod_with('Conversations::EventDataPresenter')

================
File: presenters/inbox/event_data_presenter.rb
================
class Inbox::EventDataPresenter < SimpleDelegator
  def push_data
    {
      # Conversation thread config
      allow_messages_after_resolved: allow_messages_after_resolved,
      lock_to_single_conversation: lock_to_single_conversation,

      # Auto Assignment config
      auto_assignment_config: auto_assignment_config,
      enable_auto_assignment: enable_auto_assignment,

      # Feature flag for message events
      enable_email_collect: enable_email_collect,
      greeting_enabled: greeting_enabled,
      greeting_message: greeting_message,
      csat_survey_enabled: csat_survey_enabled,

      # Outbound email sender config
      business_name: business_name,
      sender_name_type: sender_name_type,

      # Business hour config
      timezone: timezone,
      out_of_office_message: out_of_office_message,
      working_hours_enabled: working_hours_enabled,
      working_hours: working_hours,

      created_at: created_at,
      updated_at: updated_at,

      # Associated channel attributes
      channel: channel
    }
  end
end

================
File: presenters/reports/time_format_presenter.rb
================
class Reports::TimeFormatPresenter
  include ActionView::Helpers::TextHelper

  attr_reader :seconds

  def initialize(seconds = nil)
    @seconds = seconds.to_i if seconds.present?
  end

  def format
    return 'N/A' if seconds.nil? || seconds.zero?

    days, remainder = seconds.divmod(86_400)
    hours, remainder = remainder.divmod(3600)
    minutes, seconds = remainder.divmod(60)

    format_components(days: days, hours: hours, minutes: minutes, seconds: seconds)
  end

  private

  def format_components(components)
    formatted_components = components.filter_map do |unit, value|
      next if value.zero?

      I18n.t("time_units.#{unit}", count: value)
    end

    return I18n.t('time_units.seconds', count: 0) if formatted_components.empty?

    formatted_components.first(2).join(' ')
  end
end

================
File: presenters/agent_bot_presenter.rb
================
class AgentBotPresenter < SimpleDelegator
  def access_token
    return if account_id.blank?

    Current.account.id == account_id ? super&.token : nil
  end
end

================
File: presenters/html_parser.rb
================
class HtmlParser
  def self.parse_reply(raw_body)
    new(raw_body).filtered_text
  end

  attr_reader :raw_body

  def initialize(raw_body)
    @raw_body = raw_body
  end

  def document
    @document ||= Nokogiri::HTML(raw_body)
  end

  def filter_replies!
    document.xpath('//blockquote').each { |n| n.replace('&gt; ') }
  end

  def filtered_html
    @filtered_html ||= begin
      filter_replies!
      document.inner_html
    end
  end

  def filtered_text
    @filtered_text ||= Html2Text.convert(filtered_html)
  end
end

================
File: presenters/mail_presenter.rb
================
class MailPresenter < SimpleDelegator
  attr_accessor :mail

  def initialize(mail, account = nil)
    super(mail)
    @mail = mail
    @account = account
  end

  def subject
    encode_to_unicode(@mail.subject)
  end

  # encode decoded mail text_part or html_part if mail is multipart email
  # encode decoded mail raw bodyt if mail is not multipart email but the body content is text/html
  def mail_content(mail_part)
    if multipart_mail_body?
      decoded_multipart_mail(mail_part)
    else
      text_html_mail(mail_part)
    end
  end

  # encodes mail if mail.parts is present
  # encodes mail content type is multipart
  def decoded_multipart_mail(mail_part)
    encoded = encode_to_unicode(mail_part&.decoded)

    encoded if text_mail_body? || html_mail_body?
  end

  # encodes mail raw body if mail.parts is empty
  # encodes mail raw body if mail.content_type is plain/text
  # encodes mail raw body if mail.content_type is html/text
  def text_html_mail(mail_part)
    decoded = mail_part&.decoded || @mail.decoded
    encoded = encode_to_unicode(decoded)

    encoded if html_mail_body? || text_mail_body?
  end

  def text_content
    @decoded_text_content = mail_content(text_part) || ''

    encoding = @decoded_text_content.encoding

    body = EmailReplyTrimmer.trim(@decoded_text_content)

    return {} if @decoded_text_content.blank? || !text_mail_body?

    @text_content ||= {
      full: mail_content(text_part),
      reply: @decoded_text_content,
      quoted: body.force_encoding(encoding).encode('UTF-8')
    }
  end

  def html_content
    encoded = mail_content(html_part) || ''
    @decoded_html_content = ::HtmlParser.parse_reply(encoded)

    return {} if @decoded_html_content.blank? || !html_mail_body?

    body = EmailReplyTrimmer.trim(@decoded_html_content)

    @html_content ||= {
      full: mail_content(html_part),
      reply: @decoded_html_content,
      quoted: body
    }
  end

  # check content disposition check
  # if inline, upload to AWS and and take the URL
  def attachments
    # ref : https://github.com/gorails-screencasts/action-mailbox-action-text/blob/master/app/mailboxes/posts_mailbox.rb
    mail.attachments.map do |attachment|
      blob = ActiveStorage::Blob.create_and_upload!(
        io: StringIO.new(attachment.body.to_s),
        filename: attachment.filename.presence || "attachment_#{SecureRandom.hex(4)}",
        content_type: attachment.content_type
      )
      { original: attachment, blob: blob }
    end
  end

  def number_of_attachments
    mail.attachments.count
  end

  def serialized_data
    {
      bcc: bcc,
      cc: cc,
      content_type: content_type,
      date: date,
      from: from,
      html_content: html_content,
      in_reply_to: in_reply_to,
      message_id: message_id,
      multipart: multipart?,
      number_of_attachments: number_of_attachments,
      subject: subject,
      text_content: text_content,
      to: to
    }
  end

  def in_reply_to
    return if @mail.in_reply_to.blank?

    # Although the "in_reply_to" field in the email can potentially hold multiple values,
    # our current system does not have the capability to handle this.
    # FIX ME: Address this issue by returning the complete results and utilizing them for querying conversations.
    @mail.in_reply_to.is_a?(Array) ? @mail.in_reply_to.first : @mail.in_reply_to
  end

  def from
    # changing to downcase to avoid case mismatch while finding contact
    (@mail.reply_to.presence || @mail.from).map(&:downcase)
  end

  def sender_name
    Mail::Address.new((@mail[:reply_to] || @mail[:from]).value).name
  end

  def original_sender
    from_email_address(@mail[:reply_to].try(:value)) || @mail['X-Original-Sender'].try(:value) || from_email_address(from.first)
  end

  def from_email_address(email)
    Mail::Address.new(email).address
  end

  def email_forwarded_for
    @mail['X-Forwarded-For'].try(:value)
  end

  def mail_receiver
    if @mail.to.blank?
      return [email_forwarded_for] if email_forwarded_for.present?

      []
    else
      @mail.to
    end
  end

  def auto_reply?
    auto_submitted? || x_auto_reply?
  end

  def notification_email_from_chatwoot?
    # notification emails are send via mailer sender email address. so it should match
    original_sender == Mail::Address.new(ENV.fetch('MAILER_SENDER_EMAIL', 'Chatwoot <accounts@chatwoot.com>')).address
  end

  private

  def auto_submitted?
    @mail['Auto-Submitted'].present? && @mail['Auto-Submitted'].value != 'no'
  end

  def x_auto_reply?
    @mail['X-Autoreply'].present? && @mail['X-Autoreply'].value == 'yes'
  end

  # forcing the encoding of the content to UTF-8 so as to be compatible with database and serializers
  def encode_to_unicode(str)
    return '' if str.blank?

    current_encoding = str.encoding.name
    return str if current_encoding == 'UTF-8'

    str.encode(current_encoding, 'UTF-8', invalid: :replace, undef: :replace, replace: '?')
  rescue StandardError
    ''
  end

  def html_mail_body?
    ((mail.content_type || '').include? 'text/html') || @mail.html_part&.content_type&.include?('text/html')
  end

  def text_mail_body?
    ((mail.content_type || '').include? 'text/plain') || @mail.text_part&.content_type&.include?('text/plain')
  end

  def multipart_mail_body?
    ((mail.content_type || '').include? 'multipart') || @mail.parts.any?
  end
end

================
File: services/agent_bots/validate_bot_service.rb
================
class AgentBots::ValidateBotService
  pattr_initialize [:agent_bot]
  def perform
    return true unless agent_bot.bot_type == 'csml'

    validate_csml_bot
  end

  private

  def csml_client
    @csml_client ||= CsmlEngine.new
  end

  def csml_bot_payload
    {
      id: agent_bot[:name],
      name: agent_bot[:name],
      default_flow: 'Default',
      flows: [
        {
          id: SecureRandom.uuid,
          name: 'Default',
          content: agent_bot.bot_config['csml_content'],
          commands: []
        }
      ]
    }
  end

  def validate_csml_bot
    response = csml_client.validate(csml_bot_payload)
    response.blank? || response['valid']
  rescue StandardError => e
    ChatwootExceptionTracker.new(e, account: agent_bot&.account).capture_exception
    false
  end
end

================
File: services/auto_assignment/agent_assignment_service.rb
================
class AutoAssignment::AgentAssignmentService
  # Allowed agent ids: array
  # This is the list of agents from which an agent can be assigned to this conversation
  # examples: Agents with assignment capacity, Agents who are members of a team etc
  pattr_initialize [:conversation!, :allowed_agent_ids!]

  def find_assignee
    round_robin_manage_service.available_agent(allowed_agent_ids: allowed_online_agent_ids)
  end

  def perform
    new_assignee = find_assignee
    conversation.update(assignee: new_assignee) if new_assignee
  end

  private

  def online_agent_ids
    online_agents = OnlineStatusTracker.get_available_users(conversation.account_id)
    online_agents.select { |_key, value| value.eql?('online') }.keys if online_agents.present?
  end

  def allowed_online_agent_ids
    # We want to perform roundrobin only over online agents
    # Hence taking an intersection of online agents and allowed member ids

    # the online user ids are string, since its from redis, allowed member ids are integer, since its from active record
    @allowed_online_agent_ids ||= online_agent_ids & allowed_agent_ids&.map(&:to_s)
  end

  def round_robin_manage_service
    @round_robin_manage_service ||= AutoAssignment::InboxRoundRobinService.new(inbox: conversation.inbox)
  end

  def round_robin_key
    format(::Redis::Alfred::ROUND_ROBIN_AGENTS, inbox_id: conversation.inbox_id)
  end
end

================
File: services/auto_assignment/inbox_round_robin_service.rb
================
class AutoAssignment::InboxRoundRobinService
  pattr_initialize [:inbox!]

  # called on inbox delete
  def clear_queue
    ::Redis::Alfred.delete(round_robin_key)
  end

  # called on inbox member create
  def add_agent_to_queue(user_id)
    ::Redis::Alfred.lpush(round_robin_key, user_id)
  end

  # called on inbox member delete
  def remove_agent_from_queue(user_id)
    ::Redis::Alfred.lrem(round_robin_key, user_id)
  end

  def reset_queue
    clear_queue
    add_agent_to_queue(inbox.inbox_members.map(&:user_id))
  end

  # end of queue management functions

  # allowed member ids = [assignable online agents supplied by the assignment service]
  # the values of allowed member ids should be in string format
  def available_agent(allowed_agent_ids: [])
    reset_queue unless validate_queue?
    user_id = get_member_from_allowed_agent_ids(allowed_agent_ids)
    inbox.inbox_members.find_by(user_id: user_id)&.user if user_id.present?
  end

  private

  def get_member_from_allowed_agent_ids(allowed_agent_ids)
    return nil if allowed_agent_ids.blank?

    user_id = queue.intersection(allowed_agent_ids).pop
    pop_push_to_queue(user_id)
    user_id
  end

  def pop_push_to_queue(user_id)
    return if user_id.blank?

    remove_agent_from_queue(user_id)
    add_agent_to_queue(user_id)
  end

  def validate_queue?
    return true if inbox.inbox_members.map(&:user_id).sort == queue.map(&:to_i).sort
  end

  def queue
    ::Redis::Alfred.lrange(round_robin_key)
  end

  def round_robin_key
    format(::Redis::Alfred::ROUND_ROBIN_AGENTS, inbox_id: inbox.id)
  end
end

================
File: services/automation_rules/action_service.rb
================
class AutomationRules::ActionService < ActionService
  def initialize(rule, account, conversation)
    super(conversation)
    @rule = rule
    @account = account
    Current.executed_by = rule
  end

  def perform
    @rule.actions.each do |action|
      @conversation.reload
      action = action.with_indifferent_access
      begin
        send(action[:action_name], action[:action_params])
      rescue StandardError => e
        ChatwootExceptionTracker.new(e, account: @account).capture_exception
      end
    end
  ensure
    Current.reset
  end

  private

  def send_attachment(blob_ids)
    return if conversation_a_tweet?

    return unless @rule.files.attached?

    blobs = ActiveStorage::Blob.where(id: blob_ids)

    return if blobs.blank?

    params = { content: nil, private: false, attachments: blobs }
    Messages::MessageBuilder.new(nil, @conversation, params).perform
  end

  def send_webhook_event(webhook_url)
    payload = @conversation.webhook_data.merge(event: "automation_event.#{@rule.event_name}")
    WebhookJob.perform_later(webhook_url[0], payload)
  end

  def send_message(message)
    return if conversation_a_tweet?

    params = { content: message[0], private: false, content_attributes: { automation_rule_id: @rule.id } }
    Messages::MessageBuilder.new(nil, @conversation, params).perform
  end

  def send_email_to_team(params)
    teams = Team.where(id: params[0][:team_ids])

    teams.each do |team|
      TeamNotifications::AutomationNotificationMailer.conversation_creation(@conversation, team, params[0][:message])&.deliver_now
    end
  end
end

================
File: services/automation_rules/condition_validation_service.rb
================
class AutomationRules::ConditionValidationService
  ATTRIBUTE_MODEL = 'conversation_attribute'.freeze

  def initialize(rule)
    @rule = rule
    @account = rule.account

    file = File.read('./lib/filters/filter_keys.yml')
    @filters = YAML.safe_load(file)

    @conversation_filters = @filters['conversations']
    @contact_filters = @filters['contacts']
    @message_filters = @filters['messages']
  end

  def perform
    @rule.conditions.each do |condition|
      return false unless valid_condition?(condition) && valid_query_operator?(condition)
    end

    true
  end

  private

  def valid_query_operator?(condition)
    query_operator = condition['query_operator']

    return true if query_operator.nil?
    return true if query_operator.empty?

    %w[AND OR].include?(query_operator.upcase)
  end

  def valid_condition?(condition)
    key = condition['attribute_key']

    conversation_filter = @conversation_filters[key]
    contact_filter = @contact_filters[key]
    message_filter = @message_filters[key]

    if conversation_filter || contact_filter || message_filter
      operation_valid?(condition, conversation_filter || contact_filter || message_filter)
    else
      custom_attribute_present?(key, condition['custom_attribute_type'])
    end
  end

  def operation_valid?(condition, filter)
    filter_operator = condition['filter_operator']

    # attribute changed is a special case
    return true if filter_operator == 'attribute_changed'

    filter['filter_operators'].include?(filter_operator)
  end

  def custom_attribute_present?(attribute_key, attribute_model)
    attribute_model = attribute_model.presence || self.class::ATTRIBUTE_MODEL

    @account.custom_attribute_definitions.where(
      attribute_model: attribute_model
    ).find_by(attribute_key: attribute_key).present?
  end
end

================
File: services/automation_rules/conditions_filter_service.rb
================
require 'json'

class AutomationRules::ConditionsFilterService < FilterService
  ATTRIBUTE_MODEL = 'contact_attribute'.freeze

  def initialize(rule, conversation = nil, options = {})
    super([], nil)
    # assign rule, conversation and account to instance variables
    @rule = rule
    @conversation = conversation
    @account = conversation.account

    # setup filters from json file
    file = File.read('./lib/filters/filter_keys.yml')
    @filters = YAML.safe_load(file)

    @conversation_filters = @filters['conversations']
    @contact_filters = @filters['contacts']
    @message_filters = @filters['messages']

    @options = options
    @changed_attributes = options[:changed_attributes]
  end

  def perform
    return false unless rule_valid?

    @attribute_changed_query_filter = []

    @rule.conditions.each_with_index do |query_hash, current_index|
      @attribute_changed_query_filter << query_hash and next if query_hash['filter_operator'] == 'attribute_changed'

      apply_filter(query_hash, current_index)
    end

    records = base_relation.where(@query_string, @filter_values.with_indifferent_access)
    records = perform_attribute_changed_filter(records) if @attribute_changed_query_filter.any?

    records.any?
  rescue StandardError => e
    Rails.logger.error "Error in AutomationRules::ConditionsFilterService: #{e.message}"
    Rails.logger.info "AutomationRules::ConditionsFilterService failed while processing rule #{@rule.id} for conversation #{@conversation.id}"
    false
  end

  def rule_valid?
    is_valid = AutomationRules::ConditionValidationService.new(@rule).perform
    Rails.logger.info "Automation rule condition validation failed for rule id: #{@rule.id}" unless is_valid
    @rule.authorization_error! unless is_valid

    is_valid
  end

  def filter_operation(query_hash, current_index)
    if query_hash[:filter_operator] == 'starts_with'
      @filter_values["value_#{current_index}"] = "#{string_filter_values(query_hash)}%"
      like_filter_string(query_hash[:filter_operator], current_index)
    else
      super
    end
  end

  def apply_filter(query_hash, current_index)
    conversation_filter = @conversation_filters[query_hash['attribute_key']]
    contact_filter = @contact_filters[query_hash['attribute_key']]
    message_filter = @message_filters[query_hash['attribute_key']]

    if conversation_filter
      @query_string += conversation_query_string('conversations', conversation_filter, query_hash.with_indifferent_access, current_index)
    elsif contact_filter
      @query_string += contact_query_string(contact_filter, query_hash.with_indifferent_access, current_index)
    elsif message_filter
      @query_string += message_query_string(message_filter, query_hash.with_indifferent_access, current_index)
    elsif custom_attribute(query_hash['attribute_key'], @account, query_hash['custom_attribute_type'])
      # send table name according to attribute key right now we are supporting contact based custom attribute filter
      @query_string += custom_attribute_query(query_hash.with_indifferent_access, query_hash['custom_attribute_type'], current_index)
    end
  end

  # If attribute_changed type filter is present perform this against array
  def perform_attribute_changed_filter(records)
    @attribute_changed_records = []
    current_attribute_changed_record = base_relation
    filter_based_on_attribute_change(records, current_attribute_changed_record)

    @attribute_changed_records.uniq
  end

  # Loop through attribute_changed_query_filter
  def filter_based_on_attribute_change(records, current_attribute_changed_record)
    @attribute_changed_query_filter.each do |filter|
      @changed_attributes = @changed_attributes.with_indifferent_access
      changed_attribute = @changed_attributes[filter['attribute_key']].presence

      if changed_attribute[0].in?(filter['values']['from']) && changed_attribute[1].in?(filter['values']['to'])
        @attribute_changed_records = attribute_changed_filter_query(filter, records, current_attribute_changed_record)
      end
      current_attribute_changed_record = @attribute_changed_records
    end
  end

  # We intersect with the record if query_operator-AND is present and union if query_operator-OR is present
  def attribute_changed_filter_query(filter, records, current_attribute_changed_record)
    if filter['query_operator'] == 'AND'
      @attribute_changed_records + (current_attribute_changed_record & records)
    else
      @attribute_changed_records + (current_attribute_changed_record | records)
    end
  end

  def message_query_string(current_filter, query_hash, current_index)
    attribute_key = query_hash['attribute_key']
    query_operator = query_hash['query_operator']

    attribute_key = 'processed_message_content' if attribute_key == 'content'

    filter_operator_value = filter_operation(query_hash, current_index)

    case current_filter['attribute_type']
    when 'standard'
      if current_filter['data_type'] == 'text'
        " LOWER(messages.#{attribute_key}) #{filter_operator_value} #{query_operator} "
      else
        " messages.#{attribute_key} #{filter_operator_value} #{query_operator} "
      end
    end
  end

  # This will be used in future for contact automation rule
  def contact_query_string(current_filter, query_hash, current_index)
    attribute_key = query_hash['attribute_key']
    query_operator = query_hash['query_operator']

    filter_operator_value = filter_operation(query_hash, current_index)

    case current_filter['attribute_type']
    when 'additional_attributes'
      " contacts.additional_attributes ->> '#{attribute_key}' #{filter_operator_value} #{query_operator} "
    when 'standard'
      " contacts.#{attribute_key} #{filter_operator_value} #{query_operator} "
    end
  end

  def conversation_query_string(table_name, current_filter, query_hash, current_index)
    attribute_key = query_hash['attribute_key']
    query_operator = query_hash['query_operator']
    filter_operator_value = filter_operation(query_hash, current_index)

    case current_filter['attribute_type']
    when 'additional_attributes'
      " #{table_name}.additional_attributes ->> '#{attribute_key}' #{filter_operator_value} #{query_operator} "
    when 'standard'
      if attribute_key == 'labels'
        " tags.id #{filter_operator_value} #{query_operator} "
      else
        " #{table_name}.#{attribute_key} #{filter_operator_value} #{query_operator} "
      end
    end
  end

  private

  def base_relation
    records = Conversation.where(id: @conversation.id).joins(
      'LEFT OUTER JOIN contacts on conversations.contact_id = contacts.id'
    ).joins(
      'LEFT OUTER JOIN messages on messages.conversation_id = conversations.id'
    )
    records = records.where(messages: { id: @options[:message].id }) if @options[:message].present?
    records
  end
end

================
File: services/base/send_on_channel_service.rb
================
#######################################
# To create an external channel reply service
# - Inherit this as the base class.
# - Implement `channel_class` method in your child class.
# - Implement `perform_reply` method in your child class.
# - Implement additional custom logic for your `perform_reply` method.
# - When required override the validation_methods.
# - Use Childclass.new.perform.
######################################
class Base::SendOnChannelService
  pattr_initialize [:message!]

  def perform
    validate_target_channel
    return unless outgoing_message?
    return if invalid_message?

    perform_reply
  end

  private

  delegate :conversation, to: :message
  delegate :contact, :contact_inbox, :inbox, to: :conversation
  delegate :channel, to: :inbox

  def channel_class
    raise 'Overwrite this method in child class'
  end

  def perform_reply
    raise 'Overwrite this method in child class'
  end

  def outgoing_message_originated_from_channel?
    # TODO: we need to refactor this logic as more integrations comes by
    # chatwoot messages won't have source id at the moment
    # TODO: migrate source_ids to external_source_ids and check the source id relevant to specific channel
    message.source_id.present?
  end

  def outgoing_message?
    message.outgoing? || message.template?
  end

  def invalid_message?
    # private notes aren't send to the channels
    # we should also avoid the case of message loops, when outgoing messages are created from channel
    message.private? || outgoing_message_originated_from_channel?
  end

  def validate_target_channel
    raise 'Invalid channel service was called' if inbox.channel.class != channel_class
  end
end

================
File: services/contacts/contactable_inboxes_service.rb
================
class Contacts::ContactableInboxesService
  pattr_initialize [:contact!]

  def get
    account = contact.account
    account.inboxes.filter_map { |inbox| get_contactable_inbox(inbox) }
  end

  private

  def get_contactable_inbox(inbox)
    case inbox.channel_type
    when 'Channel::TwilioSms'
      twilio_contactable_inbox(inbox)
    when 'Channel::Whatsapp'
      whatsapp_contactable_inbox(inbox)
    when 'Channel::Sms'
      sms_contactable_inbox(inbox)
    when 'Channel::Email'
      email_contactable_inbox(inbox)
    when 'Channel::Api'
      api_contactable_inbox(inbox)
    when 'Channel::WebWidget'
      website_contactable_inbox(inbox)
    end
  end

  def website_contactable_inbox(inbox)
    latest_contact_inbox = inbox.contact_inboxes.where(contact: @contact).last
    return unless latest_contact_inbox
    # FIXME : change this when multiple conversations comes in
    return if latest_contact_inbox.conversations.present?

    { source_id: latest_contact_inbox.source_id, inbox: inbox }
  end

  def api_contactable_inbox(inbox)
    latest_contact_inbox = inbox.contact_inboxes.where(contact: @contact).last
    source_id = latest_contact_inbox&.source_id || SecureRandom.uuid

    { source_id: source_id, inbox: inbox }
  end

  def email_contactable_inbox(inbox)
    return unless @contact.email

    { source_id: @contact.email, inbox: inbox }
  end

  def whatsapp_contactable_inbox(inbox)
    return unless @contact.phone_number

    # Remove the plus since thats the format 360 dialog uses
    { source_id: @contact.phone_number.delete('+'), inbox: inbox }
  end

  def sms_contactable_inbox(inbox)
    return unless @contact.phone_number

    { source_id: @contact.phone_number, inbox: inbox }
  end

  def twilio_contactable_inbox(inbox)
    return if @contact.phone_number.blank?

    case inbox.channel.medium
    when 'sms'
      { source_id: @contact.phone_number, inbox: inbox }
    when 'whatsapp'
      { source_id: "whatsapp:#{@contact.phone_number}", inbox: inbox }
    end
  end
end

================
File: services/contacts/filter_service.rb
================
class Contacts::FilterService < FilterService
  ATTRIBUTE_MODEL = 'contact_attribute'.freeze

  def initialize(account, user, params)
    @account = account
    # TODO: Change the order of arguments in FilterService maybe?
    # account, user, params makes more sense
    super(params, user)
  end

  def perform
    validate_query_operator
    @contacts = query_builder(@filters['contacts'])

    {
      contacts: @contacts,
      count: @contacts.count
    }
  end

  def filter_values(query_hash)
    current_val = query_hash['values'][0]
    if query_hash['attribute_key'] == 'phone_number'
      "+#{current_val}"
    elsif query_hash['attribute_key'] == 'country_code'
      current_val.downcase
    else
      current_val.is_a?(String) ? current_val.downcase : current_val
    end
  end

  # TODO: @account.contacts.resolved_contacts ? to stay consistant with the behavior in ui
  def base_relation
    @account.contacts
  end

  def filter_config
    {
      entity: 'Contact',
      table_name: 'contacts'
    }
  end

  private

  def equals_to_filter_string(filter_operator, current_index)
    return "= :value_#{current_index}" if filter_operator == 'equal_to'

    "!= :value_#{current_index}"
  end
end

================
File: services/contacts/sync_attributes.rb
================
class Contacts::SyncAttributes
  attr_reader :contact

  def initialize(contact)
    @contact = contact
  end

  def perform
    update_contact_location_and_country_code
    set_contact_type
  end

  private

  def update_contact_location_and_country_code
    # Ensure that location and country_code are updated from additional_attributes.
    # TODO: Remove this once all contacts are updated and both the location and country_code fields are standardized throughout the app.
    @contact.location = @contact.additional_attributes['city']
    @contact.country_code = @contact.additional_attributes['country']
  end

  def set_contact_type
    #  If the contact is already a lead or customer then do not change the contact type
    return unless @contact.contact_type == 'visitor'
    # If the contact has an email or phone number or social details( facebook_user_id, instagram_user_id, etc) then it is a lead
    # If contact is from external channel like facebook, instagram, whatsapp, etc then it is a lead
    return unless @contact.email.present? || @contact.phone_number.present? || social_details_present?

    @contact.contact_type = 'lead'
  end

  def social_details_present?
    @contact.additional_attributes.keys.any? do |key|
      key.start_with?('social_') && @contact.additional_attributes[key].present?
    end
  end
end

================
File: services/conversations/filter_service.rb
================
class Conversations::FilterService < FilterService
  ATTRIBUTE_MODEL = 'conversation_attribute'.freeze

  def initialize(params, user, filter_account = nil)
    @account = filter_account || Current.account
    super(params, user)
  end

  def perform
    validate_query_operator
    @conversations = query_builder(@filters['conversations'])
    mine_count, unassigned_count, all_count, = set_count_for_all_conversations
    assigned_count = all_count - unassigned_count

    {
      conversations: conversations,
      count: {
        mine_count: mine_count,
        assigned_count: assigned_count,
        unassigned_count: unassigned_count,
        all_count: all_count
      }
    }
  end

  def base_relation
    @account.conversations.includes(
      :taggings, :inbox, { assignee: { avatar_attachment: [:blob] } }, { contact: { avatar_attachment: [:blob] } }, :team, :messages, :contact_inbox
    )
  end

  def current_page
    @params[:page] || 1
  end

  def filter_config
    {
      entity: 'Conversation',
      table_name: 'conversations'
    }
  end

  def conversations
    @conversations.sort_on_last_activity_at.page(current_page)
  end
end

================
File: services/conversations/typing_status_manager.rb
================
class Conversations::TypingStatusManager
  include Events::Types

  attr_reader :conversation, :user, :params

  def initialize(conversation, user, params)
    @conversation = conversation
    @user = user
    @params = params
  end

  def trigger_typing_event(event, is_private)
    user = @user.presence || @resource
    Rails.configuration.dispatcher.dispatch(event, Time.zone.now, conversation: @conversation, user: user, is_private: is_private)
  end

  def toggle_typing_status
    case params[:typing_status]
    when 'on'
      trigger_typing_event(CONVERSATION_TYPING_ON, params[:is_private])
    when 'off'
      trigger_typing_event(CONVERSATION_TYPING_OFF, params[:is_private])
    end
    # Return the head :ok response from the controller
  end
end

================
File: services/data_import/contact_manager.rb
================
class DataImport::ContactManager
  def initialize(account)
    @account = account
  end

  def build_contact(params)
    contact = find_or_initialize_contact(params)
    update_contact_attributes(params, contact)
    contact
  end

  def find_or_initialize_contact(params)
    contact = find_existing_contact(params)
    contact_params = params.slice(:email, :identifier, :phone_number)
    contact_params[:phone_number] = format_phone_number(contact_params[:phone_number]) if contact_params[:phone_number].present?
    contact ||= @account.contacts.new(contact_params)
    contact
  end

  def find_existing_contact(params)
    contact = find_contact_by_identifier(params)
    contact ||= find_contact_by_email(params)
    contact ||= find_contact_by_phone_number(params)

    update_contact_with_merged_attributes(params, contact) if contact.present? && contact.valid?
    contact
  end

  def find_contact_by_identifier(params)
    return unless params[:identifier]

    @account.contacts.find_by(identifier: params[:identifier])
  end

  def find_contact_by_email(params)
    return unless params[:email]

    @account.contacts.from_email(params[:email])
  end

  def find_contact_by_phone_number(params)
    return unless params[:phone_number]

    @account.contacts.find_by(phone_number: format_phone_number(params[:phone_number]))
  end

  def format_phone_number(phone_number)
    phone_number.start_with?('+') ? phone_number : "+#{phone_number}"
  end

  def update_contact_with_merged_attributes(params, contact)
    contact.identifier = params[:identifier] if params[:identifier].present?
    contact.email = params[:email] if params[:email].present?
    contact.phone_number = format_phone_number(params[:phone_number]) if params[:phone_number].present?
    update_contact_attributes(params, contact)
    contact.save
  end

  private

  def update_contact_attributes(params, contact)
    contact.name = params[:name] if params[:name].present?
    contact.additional_attributes ||= {}
    contact.additional_attributes[:company] = params[:company] if params[:company].present?
    contact.additional_attributes[:city] = params[:city] if params[:city].present?
    contact.assign_attributes(custom_attributes: contact.custom_attributes.merge(params.except(:identifier, :email, :name, :phone_number)))
  end
end

================
File: services/email_templates/db_resolver_service.rb
================
# Code is heavily inspired by panaromic gem
# https://github.com/andreapavoni/panoramic
# We will try to find layouts and content from database
# layout will be rendered with erb and other content in html format
# Further processing in liquid is implemented in mailers

# NOTE: rails resolver looks for templates in cache first
# which we don't want to happen here
# so we are overriding find_all method in action view resolver
# If anything breaks - look into rails : actionview/lib/action_view/template/resolver.rb

class ::EmailTemplates::DbResolverService < ActionView::Resolver
  require 'singleton'
  include Singleton

  # Instantiate Resolver by passing a model.
  def self.using(model, options = {})
    class_variable_set(:@@model, model)
    class_variable_set(:@@resolver_options, options)
    instance
  end

  # Since rails picks up files from cache. lets override the method
  # Normalizes the arguments and passes it on to find_templates.
  # rubocop:disable Metrics/ParameterLists
  def find_all(name, prefix = nil, partial = false, details = {}, key = nil, locals = [])
    locals = locals.map(&:to_s).sort!.freeze
    _find_all(name, prefix, partial, details, key, locals)
  end
  # rubocop:enable Metrics/ParameterLists

  # the function has to accept(name, prefix, partial, _details, _locals = [])
  # _details contain local info which we can leverage in future
  # cause of codeclimate issue with 4 args, relying on (*args)
  def find_templates(name, prefix, partial, *_args)
    @template_name = name
    @template_type = prefix.include?('layout') ? 'layout' : 'content'
    @db_template = find_db_template

    return [] if @db_template.blank?

    path = build_path(prefix)
    handler = ActionView::Template.registered_template_handler(:liquid)

    template_details = {
      locals: [],
      format: Mime['html'].to_sym,
      virtual_path: virtual_path(path, partial)
    }

    [ActionView::Template.new(@db_template.body, "DB Template - #{@db_template.id}", handler, **template_details)]
  end

  private

  def find_db_template
    find_account_template || find_installation_template
  end

  def find_account_template
    return unless Current.account

    @@model.find_by(name: @template_name, template_type: @template_type, account: Current.account)
  end

  def find_installation_template
    @@model.find_by(name: @template_name, template_type: @template_type, account: nil)
  end

  # Build path with eventual prefix
  def build_path(prefix)
    prefix.present? ? "#{prefix}/#{@template_name}" : @template_name
  end

  # returns a path depending if its a partial or template
  # params path: path/to/file.ext  partial: true/false
  # the function appends _to make the file name _file.ext if partial: true
  def virtual_path(path, partial)
    return path unless partial

    if (index = path.rindex('/'))
      path.insert(index + 1, '_')
    else
      "_#{path}"
    end
  end
end

================
File: services/facebook/send_on_facebook_service.rb
================
class Facebook::SendOnFacebookService < Base::SendOnChannelService
  private

  def channel_class
    Channel::FacebookPage
  end

  def perform_reply
    send_message_to_facebook fb_text_message_params if message.content.present?

    if message.attachments.present?
      message.attachments.each do |attachment|
        send_message_to_facebook fb_attachment_message_params(attachment)
      end
    end
  rescue Facebook::Messenger::FacebookError => e
    # TODO : handle specific errors or else page will get disconnected
    handle_facebook_error(e)
    message.update!(status: :failed, external_error: e.message)
  end

  def send_message_to_facebook(delivery_params)
    parsed_result = deliver_message(delivery_params)
    return if parsed_result.nil?

    if parsed_result['error'].present?
      message.update!(status: :failed, external_error: external_error(parsed_result))
      Rails.logger.info "Facebook::SendOnFacebookService: Error sending message to Facebook : Page - #{channel.page_id} : #{parsed_result}"
    end

    message.update!(source_id: parsed_result['message_id']) if parsed_result['message_id'].present?
  end

  def deliver_message(delivery_params)
    result = Facebook::Messenger::Bot.deliver(delivery_params, page_id: channel.page_id)
    JSON.parse(result)
  rescue JSON::ParserError
    message.update!(status: :failed, external_error: 'Facebook was unable to process this request')
    Rails.logger.error "Facebook::SendOnFacebookService: Error parsing JSON response from Facebook : Page - #{channel.page_id} : #{result}"
    nil
  rescue Net::OpenTimeout
    message.update!(status: :failed, external_error: 'Request timed out, please try again later')
    Rails.logger.error "Facebook::SendOnFacebookService: Timeout error sending message to Facebook : Page - #{channel.page_id}"
    nil
  end

  def fb_text_message_params
    {
      recipient: { id: contact.get_source_id(inbox.id) },
      message: { text: message.content },
      messaging_type: 'MESSAGE_TAG',
      tag: 'ACCOUNT_UPDATE'
    }
  end

  def external_error(response)
    # https://developers.facebook.com/docs/graph-api/guides/error-handling/
    error_message = response['error']['message']
    error_code = response['error']['code']

    "#{error_code} - #{error_message}"
  end

  def fb_attachment_message_params(attachment)
    {
      recipient: { id: contact.get_source_id(inbox.id) },
      message: {
        attachment: {
          type: attachment_type(attachment),
          payload: {
            url: attachment.download_url
          }
        }
      },
      messaging_type: 'MESSAGE_TAG',
      tag: 'ACCOUNT_UPDATE'
    }
  end

  def attachment_type(attachment)
    return attachment.file_type if %w[image audio video file].include? attachment.file_type

    'file'
  end

  def sent_first_outgoing_message_after_24_hours?
    # we can send max 1 message after 24 hour window
    conversation.messages.outgoing.where('id > ?', conversation.last_incoming_message.id).count == 1
  end

  def handle_facebook_error(exception)
    # Refer: https://github.com/jgorset/facebook-messenger/blob/64fe1f5cef4c1e3fca295b205037f64dfebdbcab/lib/facebook/messenger/error.rb
    return unless exception.to_s.include?('The session has been invalidated') || exception.to_s.include?('Error validating access token')

    channel.authorization_error!
  end
end

================
File: services/geocoder/setup_service.rb
================
require 'rubygems/package'

class Geocoder::SetupService
  def perform
    return if File.exist?(GeocoderConfiguration::LOOK_UP_DB)

    ip_lookup_api_key = ENV.fetch('IP_LOOKUP_API_KEY', nil)
    if ip_lookup_api_key.blank?
      log_info('IP_LOOKUP_API_KEY empty. Skipping geoip database setup')
      return
    end

    log_info('Fetch GeoLite2-City database')
    fetch_and_extract_database(ip_lookup_api_key)
  end

  private

  def fetch_and_extract_database(api_key)
    base_url = ENV.fetch('IP_LOOKUP_BASE_URL', 'https://download.maxmind.com/app/geoip_download')
    source_file = Down.download("#{base_url}?edition_id=GeoLite2-City&suffix=tar.gz&license_key=#{api_key}")

    extract_tar_file(source_file)
    log_info('Fetch complete')
  rescue StandardError => e
    log_error(e.message)
  end

  def extract_tar_file(source_file)
    tar_extract = Gem::Package::TarReader.new(Zlib::GzipReader.open(source_file))
    tar_extract.rewind

    tar_extract.each do |entry|
      next unless entry.full_name.include?('GeoLite2-City.mmdb') && entry.file?

      File.open GeocoderConfiguration::LOOK_UP_DB, 'wb' do |f|
        f.print entry.read
      end
    end
  end

  def log_info(message)
    Rails.logger.info "[rake ip_lookup:setup] #{message}"
  end

  def log_error(message)
    Rails.logger.error "[rake ip_lookup:setup] #{message}"
  end
end

================
File: services/google/refresh_oauth_token_service.rb
================
# Refer: https://learn.microsoft.com/en-us/entra/identity-platform/configurable-token-lifetimes
class Google::RefreshOauthTokenService < BaseRefreshOauthTokenService
  private

  # Builds the OAuth strategy for Microsoft Graph
  def build_oauth_strategy
    app_id = GlobalConfigService.load('GOOGLE_OAUTH_CLIENT_ID', nil)
    app_secret = GlobalConfigService.load('GOOGLE_OAUTH_CLIENT_SECRET', nil)

    OmniAuth::Strategies::GoogleOauth2.new(nil, app_id, app_secret)
  end
end

================
File: services/imap/base_fetch_email_service.rb
================
require 'net/imap'

class Imap::BaseFetchEmailService
  pattr_initialize [:channel!, :interval]

  def fetch_emails
    # Override this method
  end

  def perform
    inbound_emails = fetch_emails
    terminate_imap_connection

    inbound_emails
  end

  private

  def authentication_type
    # Override this method
  end

  def imap_password
    # Override this method
  end

  def imap_client
    @imap_client ||= build_imap_client
  end

  def mail_info_logger(inbound_mail, seq_no)
    return if Rails.env.test?

    Rails.logger.info("
      #{channel.provider} Email id: #{inbound_mail.from} - message_source_id: #{inbound_mail.message_id} - sequence id: #{seq_no}")
  end

  def email_already_present?(channel, message_id)
    channel.inbox.messages.find_by(source_id: message_id).present?
  end

  def fetch_mail_for_channel
    message_ids_with_seq = fetch_message_ids_with_sequence
    message_ids_with_seq.filter_map do |message_id_with_seq|
      process_message_id(message_id_with_seq)
    end
  end

  def process_message_id(message_id_with_seq)
    seq_no, message_id = message_id_with_seq

    if message_id.blank?
      Rails.logger.info "[IMAP::FETCH_EMAIL_SERVICE] Empty message id for #{channel.email} with seq no. <#{seq_no}>."
      return
    end

    return if email_already_present?(channel, message_id)

    # Fetch the original mail content using the sequence no
    mail_str = imap_client.fetch(seq_no, 'RFC822')[0].attr['RFC822']

    if mail_str.blank?
      Rails.logger.info "[IMAP::FETCH_EMAIL_SERVICE] Fetch failed for #{channel.email} with message-id <#{message_id}>."
      return
    end

    inbound_mail = build_mail_from_string(mail_str)
    mail_info_logger(inbound_mail, seq_no)
    inbound_mail
  end

  # Sends a FETCH command to retrieve data associated with a message in the mailbox.
  # You can send batches of message sequence number in `.fetch` method.
  def fetch_message_ids_with_sequence
    seq_nums = fetch_available_mail_sequence_numbers

    Rails.logger.info "[IMAP::FETCH_EMAIL_SERVICE] Fetching mails from #{channel.email}, found #{seq_nums.length}."

    message_ids_with_seq = []
    seq_nums.each_slice(10).each do |batch|
      # Fetch only message-id only without mail body or contents.
      batch_message_ids = imap_client.fetch(batch, 'BODY.PEEK[HEADER]')

      # .fetch returns an array of Net::IMAP::FetchData or nil
      # (instead of an empty array) if there is no matching message.
      # Check
      if batch_message_ids.blank?
        Rails.logger.info "[IMAP::FETCH_EMAIL_SERVICE] Fetching the batch failed for #{channel.email}."
        next
      end

      batch_message_ids.each do |data|
        message_id = build_mail_from_string(data.attr['BODY[HEADER]']).message_id
        message_ids_with_seq.push([data.seqno, message_id])
      end
    end

    message_ids_with_seq
  end

  # Sends a SEARCH command to search the mailbox for messages that were
  # created between yesterday (or given date) and today and returns message sequence numbers.
  # Return <message set>
  def fetch_available_mail_sequence_numbers
    imap_client.search(['SINCE', since])
  end

  def build_imap_client
    imap = Net::IMAP.new(channel.imap_address, port: channel.imap_port, ssl: true)
    imap.authenticate(authentication_type, channel.imap_login, imap_password)
    imap.select('INBOX')
    imap
  end

  def terminate_imap_connection
    imap_client.logout
  rescue Net::IMAP::Error => e
    Rails.logger.info "Logout failed for #{channel.email} - #{e.message}."
    imap_client.disconnect
  end

  def build_mail_from_string(raw_email_content)
    Mail.read_from_string(raw_email_content)
  end

  def since
    previous_day = Time.zone.today - (interval || 1).to_i
    previous_day.strftime('%d-%b-%Y')
  end
end

================
File: services/imap/fetch_email_service.rb
================
class Imap::FetchEmailService < Imap::BaseFetchEmailService
  def fetch_emails
    fetch_mail_for_channel
  end

  private

  def authentication_type
    'PLAIN'
  end

  def imap_password
    channel.imap_password
  end
end

================
File: services/imap/google_fetch_email_service.rb
================
class Imap::GoogleFetchEmailService < Imap::BaseFetchEmailService
  def fetch_emails
    return if channel.provider_config['access_token'].blank?

    fetch_mail_for_channel
  end

  private

  def authentication_type
    'XOAUTH2'
  end

  def imap_password
    Google::RefreshOauthTokenService.new(channel: channel).access_token
  end
end

================
File: services/imap/microsoft_fetch_email_service.rb
================
class Imap::MicrosoftFetchEmailService < Imap::BaseFetchEmailService
  def fetch_emails
    return if channel.provider_config['access_token'].blank?

    fetch_mail_for_channel
  end

  private

  def authentication_type
    'XOAUTH2'
  end

  def imap_password
    Microsoft::RefreshOauthTokenService.new(channel: channel).access_token
  end
end

================
File: services/instagram/message_text.rb
================
class Instagram::MessageText < Instagram::WebhooksBaseService
  include HTTParty

  attr_reader :messaging

  base_uri 'https://graph.facebook.com/v11.0/'

  def initialize(messaging)
    super()
    @messaging = messaging
  end

  def perform
    create_test_text
    instagram_id, contact_id = instagram_and_contact_ids
    inbox_channel(instagram_id)
    # person can connect the channel and then delete the inbox
    return if @inbox.blank?

    # This channel might require reauthorization, may be owner might have changed the fb password
    if @inbox.channel.reauthorization_required?
      Rails.logger.info("Skipping message processing as reauthorization is required for inbox #{@inbox.id}")
      return
    end

    return unsend_message if message_is_deleted?

    ensure_contact(contact_id) if contacts_first_message?(contact_id)

    create_message
  end

  private

  def instagram_and_contact_ids
    if agent_message_via_echo?
      [@messaging[:sender][:id], @messaging[:recipient][:id]]
    else
      [@messaging[:recipient][:id], @messaging[:sender][:id]]
    end
  end

  # rubocop:disable Metrics/AbcSize
  def ensure_contact(ig_scope_id)
    begin
      k = Koala::Facebook::API.new(@inbox.channel.page_access_token) if @inbox.facebook?
      result = k.get_object(ig_scope_id) || {}
    rescue Koala::Facebook::AuthenticationError => e
      @inbox.channel.authorization_error!
      Rails.logger.warn("Authorization error for account #{@inbox.account_id} for inbox #{@inbox.id}")
      ChatwootExceptionTracker.new(e, account: @inbox.account).capture_exception
    rescue StandardError, Koala::Facebook::ClientError => e
      Rails.logger.warn("[FacebookUserFetchClientError]: account_id #{@inbox.account_id} inbox_id #{@inbox.id}")
      Rails.logger.warn("[FacebookUserFetchClientError]: #{e.message}")
      ChatwootExceptionTracker.new(e, account: @inbox.account).capture_exception
    end

    find_or_create_contact(result) if defined?(result) && result.present?
  end
  # rubocop:enable Metrics/AbcSize

  def agent_message_via_echo?
    @messaging[:message][:is_echo].present?
  end

  def message_is_deleted?
    @messaging[:message][:is_deleted].present?
  end

  # if contact was present before find out contact_inbox to create message
  def contacts_first_message?(ig_scope_id)
    @contact_inbox = @inbox.contact_inboxes.where(source_id: ig_scope_id).last
    @contact_inbox.blank? && @inbox.channel.instagram_id.present?
  end

  def sent_via_test_webhook?
    @messaging[:sender][:id] == '12334' && @messaging[:recipient][:id] == '23245'
  end

  def unsend_message
    message_to_delete = @inbox.messages.find_by(
      source_id: @messaging[:message][:mid]
    )
    return if message_to_delete.blank?

    message_to_delete.attachments.destroy_all
    message_to_delete.update!(content: I18n.t('conversations.messages.deleted'), deleted: true)
  end

  def create_message
    return unless @contact_inbox

    Messages::Instagram::MessageBuilder.new(@messaging, @inbox, outgoing_echo: agent_message_via_echo?).perform
  end

  def create_test_text
    return unless sent_via_test_webhook?

    Rails.logger.info('Probably Test data.')

    messenger_channel = Channel::FacebookPage.last
    @inbox = ::Inbox.find_by(channel: messenger_channel)
    return unless @inbox

    @contact = create_test_contact

    @conversation ||= create_test_conversation(conversation_params)

    @message = @conversation.messages.create!(test_message_params)
  end

  def create_test_contact
    @contact_inbox = @inbox.contact_inboxes.where(source_id: @messaging[:sender][:id]).first
    unless @contact_inbox
      @contact_inbox ||= @inbox.channel.create_contact_inbox(
        'sender_username', 'sender_username'
      )
    end

    @contact_inbox.contact
  end

  def create_test_conversation(conversation_params)
    Conversation.find_by(conversation_params) || build_conversation(conversation_params)
  end

  def test_message_params
    {
      account_id: @conversation.account_id,
      inbox_id: @conversation.inbox_id,
      message_type: 'incoming',
      source_id: @messaging[:message][:mid],
      content: @messaging[:message][:text],
      sender: @contact
    }
  end

  def build_conversation(conversation_params)
    Conversation.create!(
      conversation_params.merge(
        contact_inbox_id: @contact_inbox.id
      )
    )
  end

  def conversation_params
    {
      account_id: @inbox.account_id,
      inbox_id: @inbox.id,
      contact_id: @contact.id,
      additional_attributes: {
        type: 'instagram_direct_message'
      }
    }
  end
end

================
File: services/instagram/read_status_service.rb
================
class Instagram::ReadStatusService
  pattr_initialize [:params!]

  def perform
    return if instagram_channel.blank?

    ::Conversations::UpdateMessageStatusJob.perform_later(message.conversation.id, message.created_at) if message.present?
  end

  def instagram_id
    params[:recipient][:id]
  end

  def instagram_channel
    @instagram_channel ||= Channel::FacebookPage.find_by(instagram_id: instagram_id)
  end

  def message
    return unless params[:read][:mid]

    @message ||= @instagram_channel.inbox.messages.find_by(source_id: params[:read][:mid])
  end
end

================
File: services/instagram/send_on_instagram_service.rb
================
class Instagram::SendOnInstagramService < Base::SendOnChannelService
  include HTTParty

  pattr_initialize [:message!]

  base_uri 'https://graph.facebook.com/v11.0/me'

  private

  delegate :additional_attributes, to: :contact

  def channel_class
    Channel::FacebookPage
  end

  def perform_reply
    if message.attachments.present?
      message.attachments.each do |attachment|
        send_to_facebook_page attachment_message_params(attachment)
      end
    end

    send_to_facebook_page message_params if message.content.present?
  rescue StandardError => e
    ChatwootExceptionTracker.new(e, account: message.account, user: message.sender).capture_exception
    # TODO : handle specific errors or else page will get disconnected
    # channel.authorization_error!
  end

  def message_params
    params = {
      recipient: { id: contact.get_source_id(inbox.id) },
      message: {
        text: message.content
      }
    }

    merge_human_agent_tag(params)
  end

  def attachment_message_params(attachment)
    params = {
      recipient: { id: contact.get_source_id(inbox.id) },
      message: {
        attachment: {
          type: attachment_type(attachment),
          payload: {
            url: attachment.download_url
          }
        }
      }
    }

    merge_human_agent_tag(params)
  end

  # Deliver a message with the given payload.
  # @see https://developers.facebook.com/docs/messenger-platform/instagram/features/send-message
  def send_to_facebook_page(message_content)
    access_token = channel.page_access_token
    app_secret_proof = calculate_app_secret_proof(GlobalConfigService.load('FB_APP_SECRET', ''), access_token)
    query = { access_token: access_token }
    query[:appsecret_proof] = app_secret_proof if app_secret_proof

    # url = "https://graph.facebook.com/v11.0/me/messages?access_token=#{access_token}"

    response = HTTParty.post(
      'https://graph.facebook.com/v11.0/me/messages',
      body: message_content,
      query: query
    )

    handle_response(response, message_content)
  end

  def handle_response(response, message_content)
    parsed_response = response.parsed_response
    if response.success? && parsed_response['error'].blank?
      message.update!(source_id: parsed_response['message_id'])

      parsed_response
    else
      external_error = external_error(parsed_response)
      Rails.logger.error("Instagram response: #{external_error} : #{message_content}")
      message.update!(status: :failed, external_error: external_error)

      nil
    end
  end

  def external_error(response)
    # https://developers.facebook.com/docs/instagram-api/reference/error-codes/
    error_message = response.dig('error', 'message')
    error_code = response.dig('error', 'code')

    "#{error_code} - #{error_message}"
  end

  def calculate_app_secret_proof(app_secret, access_token)
    Facebook::Messenger::Configuration::AppSecretProofCalculator.call(
      app_secret, access_token
    )
  end

  def attachment_type(attachment)
    return attachment.file_type if %w[image audio video file].include? attachment.file_type

    'file'
  end

  def conversation_type
    conversation.additional_attributes['type']
  end

  def sent_first_outgoing_message_after_24_hours?
    # we can send max 1 message after 24 hour window
    conversation.messages.outgoing.where('id > ?', conversation.last_incoming_message.id).count == 1
  end

  def config
    Facebook::Messenger.config
  end

  def merge_human_agent_tag(params)
    global_config = GlobalConfig.get('ENABLE_MESSENGER_CHANNEL_HUMAN_AGENT')

    return params unless global_config['ENABLE_MESSENGER_CHANNEL_HUMAN_AGENT']

    params[:messaging_type] = 'MESSAGE_TAG'
    params[:tag] = 'HUMAN_AGENT'
    params
  end
end

================
File: services/instagram/webhooks_base_service.rb
================
class Instagram::WebhooksBaseService
  private

  def inbox_channel(instagram_id)
    messenger_channel = Channel::FacebookPage.where(instagram_id: instagram_id)
    @inbox = ::Inbox.find_by(channel: messenger_channel)
  end

  def find_or_create_contact(user)
    @contact_inbox = @inbox.contact_inboxes.where(source_id: user['id']).first
    @contact = @contact_inbox.contact if @contact_inbox

    update_instagram_profile_link(user) && return if @contact

    @contact_inbox = @inbox.channel.create_contact_inbox(
      user['id'], user['name']
    )

    @contact = @contact_inbox.contact
    update_instagram_profile_link(user)
    Avatar::AvatarFromUrlJob.perform_later(@contact, user['profile_pic']) if user['profile_pic']
  end

  def update_instagram_profile_link(user)
    return unless user['username']

    # TODO: Remove this once we show the social_instagram_user_name in the UI instead of the username
    @contact.additional_attributes = @contact.additional_attributes.merge({ 'social_profiles': { 'instagram': user['username'] } })
    @contact.additional_attributes = @contact.additional_attributes.merge({ 'social_instagram_user_name': user['username'] })
    @contact.save
  end
end

================
File: services/internal/remove_stale_contact_inboxes_service.rb
================
class Internal::RemoveStaleContactInboxesService
  def perform
    return unless remove_stale_contact_inbox_job_enabled?

    time_period = 90.days.ago
    contact_inboxes_to_delete = stale_contact_inboxes(time_period)

    log_stale_contact_inboxes_deletion(contact_inboxes_to_delete, time_period)

    # Since the number of records to delete is very high,
    # delete_all would be faster than destroy_all since it operates at database level
    # and avoid loading all the records in memory
    # Transaction and batching is used to avoid deadlock and memory issues
    ContactInbox.transaction do
      contact_inboxes_to_delete
        .find_in_batches(batch_size: 10_000) do |group|
          ContactInbox.where(id: group.map(&:id)).delete_all
        end
    end
  end

  private

  def remove_stale_contact_inbox_job_enabled?
    job_status = ENV.fetch('REMOVE_STALE_CONTACT_INBOX_JOB_STATUS', false)
    return false unless ActiveModel::Type::Boolean.new.cast(job_status)

    true
  end

  def stale_contact_inboxes(time_period)
    ContactInbox.stale_without_conversations(time_period)
  end

  def log_stale_contact_inboxes_deletion(contact_inboxes, time_period)
    count = contact_inboxes.count
    Rails.logger.info "Deleting #{count} stale contact inboxes older than #{time_period}"

    # Log the SQL query without executing it
    sql_query = contact_inboxes.to_sql
    Rails.logger.info("SQL Query: #{sql_query}")
  end
end

================
File: services/internal/remove_stale_redis_keys_service.rb
================
class Internal::RemoveStaleRedisKeysService
  pattr_initialize [:account_id!]

  def perform
    Rails.logger.info "Removing redis stale keys for account #{@account_id}"
    range_start = (Time.zone.now - OnlineStatusTracker::PRESENCE_DURATION).to_i
    # exclusive minimum score is specified by prefixing (
    # we are clearing old records because this could clogg up the sorted set
    ::Redis::Alfred.zremrangebyscore(
      OnlineStatusTracker.presence_key(@account_id, 'Contact'),
      '-inf',
      "(#{range_start}"
    )
  end
end

================
File: services/labels/update_service.rb
================
class Labels::UpdateService
  pattr_initialize [:new_label_title!, :old_label_title!, :account_id!]

  def perform
    tagged_conversations.find_in_batches do |conversation_batch|
      conversation_batch.each do |conversation|
        conversation.label_list.remove(old_label_title)
        conversation.label_list.add(new_label_title)
        conversation.save!
      end
    end

    tagged_contacts.find_in_batches do |contact_batch|
      contact_batch.each do |contact|
        contact.label_list.remove(old_label_title)
        contact.label_list.add(new_label_title)
        contact.save!
      end
    end
  end

  private

  def tagged_conversations
    account.conversations.tagged_with(old_label_title)
  end

  def tagged_contacts
    account.contacts.tagged_with(old_label_title)
  end

  def account
    @account ||= Account.find(account_id)
  end
end

================
File: services/line/incoming_message_service.rb
================
# ref : https://developers.line.biz/en/docs/messaging-api/receiving-messages/#webhook-event-types
# https://developers.line.biz/en/reference/messaging-api/#message-event

class Line::IncomingMessageService
  include ::FileTypeHelper
  pattr_initialize [:inbox!, :params!]
  LINE_STICKER_IMAGE_URL = 'https://stickershop.line-scdn.net/stickershop/v1/sticker/%s/android/sticker.png'.freeze

  def perform
    # probably test events
    return if params[:events].blank?

    line_contact_info
    return if line_contact_info['userId'].blank?

    set_contact
    set_conversation
    parse_events
  end

  private

  def parse_events
    params[:events].each do |event|
      next unless message_created? event

      attach_files event['message']
      @message.save!
    end
  end

  def message_created?(event)
    return unless event_type_message?(event)

    @message = @conversation.messages.build(
      content: message_content(event),
      account_id: @inbox.account_id,
      content_type: message_content_type(event),
      inbox_id: @inbox.id,
      message_type: :incoming,
      sender: @contact,
      source_id: event['message']['id'].to_s
    )
    @message
  end

  def message_content(event)
    message_type = event.dig('message', 'type')
    case message_type
    when 'text'
      event.dig('message', 'text')
    when 'sticker'
      sticker_id = event.dig('message', 'stickerId')
      sticker_image_url(sticker_id)
    end
  end

  # Currently, Chatwoot doesn't support stickers. As a temporary solution,
  # we're displaying stickers as images using the sticker ID in markdown format.
  # This is subject to change in the future. We've chosen not to download and display the sticker as an image because the sticker's information
  # and images are the property of the creator or legal owner. We aim to avoid storing it on our server without their consent.
  # If there are any permission or rendering issues, the URL may break, and we'll display the sticker ID as text instead.
  # Ref: https://developers.line.biz/en/reference/messaging-api/#wh-sticker
  def sticker_image_url(sticker_id)
    "![sticker-#{sticker_id}](#{LINE_STICKER_IMAGE_URL % sticker_id})"
  end

  def message_content_type(event)
    return 'sticker' if event['message']['type'] == 'sticker'

    'text'
  end

  def attach_files(message)
    return unless message_type_non_text?(message['type'])

    response = inbox.channel.client.get_message_content(message['id'])

    file_name = "media-#{message['id']}.#{response.content_type.split('/')[1]}"
    temp_file = Tempfile.new(file_name)
    temp_file.binmode
    temp_file << response.body
    temp_file.rewind

    @message.attachments.new(
      account_id: @message.account_id,
      file_type: file_content_type(response),
      file: {
        io: temp_file,
        filename: file_name,
        content_type: response.content_type
      }
    )
  end

  def event_type_message?(event)
    event['type'] == 'message' || event['type'] == 'sticker'
  end

  def message_type_non_text?(type)
    [Line::Bot::Event::MessageType::Video, Line::Bot::Event::MessageType::Audio, Line::Bot::Event::MessageType::Image].include?(type)
  end

  def account
    @account ||= inbox.account
  end

  def line_contact_info
    @line_contact_info ||= JSON.parse(inbox.channel.client.get_profile(params[:events].first['source']['userId']).body)
  end

  def set_contact
    contact_inbox = ::ContactInboxWithContactBuilder.new(
      source_id: line_contact_info['userId'],
      inbox: inbox,
      contact_attributes: contact_attributes
    ).perform

    @contact_inbox = contact_inbox
    @contact = contact_inbox.contact
  end

  def conversation_params
    {
      account_id: @inbox.account_id,
      inbox_id: @inbox.id,
      contact_id: @contact.id,
      contact_inbox_id: @contact_inbox.id
    }
  end

  def set_conversation
    @conversation = @contact_inbox.conversations.first
    return if @conversation

    @conversation = ::Conversation.create!(conversation_params)
  end

  def contact_attributes
    {
      name: line_contact_info['displayName'],
      avatar_url: line_contact_info['pictureUrl'],
      additional_attributes: additional_attributes
    }
  end

  def additional_attributes
    {
      social_line_user_id: line_contact_info['userId']
    }
  end

  def file_content_type(file_content)
    file_type(file_content.content_type)
  end
end

================
File: services/line/send_on_line_service.rb
================
class Line::SendOnLineService < Base::SendOnChannelService
  private

  def channel_class
    Channel::Line
  end

  def perform_reply
    response = channel.client.push_message(message.conversation.contact_inbox.source_id, build_payload)

    return if response.blank?

    parsed_json = JSON.parse(response.body)

    if response.code == '200'
      # If the request is successful, update the message status to delivered
      message.update!(status: :delivered)
    else
      # If the request is not successful, update the message status to failed and save the external error
      message.update!(status: :failed, external_error: external_error(parsed_json))
    end
  end

  def build_payload
    if message.content && message.attachments.any?
      [text_message, *attachments]
    elsif message.content.nil? && message.attachments.any?
      attachments
    else
      text_message
    end
  end

  def attachments
    message.attachments.map do |attachment|
      # Support only image and video for now, https://developers.line.biz/en/reference/messaging-api/#image-message
      next unless attachment.file_type == 'image' || attachment.file_type == 'video'

      {
        type: attachment.file_type,
        originalContentUrl: attachment.download_url,
        previewImageUrl: attachment.download_url
      }
    end
  end

  # https://developers.line.biz/en/reference/messaging-api/#text-message
  def text_message
    {
      type: 'text',
      text: message.content
    }
  end

  # https://developers.line.biz/en/reference/messaging-api/#error-responses
  def external_error(error)
    # Message containing information about the error. See https://developers.line.biz/en/reference/messaging-api/#error-messages
    message = error['message']
    # An array of error details. If the array is empty, this property will not be included in the response.
    details = error['details']

    return message if details.blank?

    detail_messages = details.map { |detail| "#{detail['property']}: #{detail['message']}" }
    [message, detail_messages].join(', ')
  end
end

================
File: services/llm_formatter/contact_llm_formatter.rb
================
class LlmFormatter::ContactLlmFormatter < LlmFormatter::DefaultLlmFormatter
  def format
    sections = []
    sections << "Contact ID: ##{@record.id}"
    sections << 'Contact Attributes:'
    sections << build_attributes
    sections << 'Contact Notes:'
    sections << if @record.notes.any?
                  build_notes
                else
                  'No notes for this contact'
                end

    sections.join("\n")
  end

  private

  def build_notes
    @record.notes.all.map { |note| " - #{note.content}" }.join("\n")
  end

  def build_attributes
    attributes = []
    attributes << "Name: #{@record.name}"
    attributes << "Email: #{@record.email}"
    attributes << "Phone: #{@record.phone_number}"
    attributes << "Location: #{@record.location}"
    attributes << "Country Code: #{@record.country_code}"
    @record.account.custom_attribute_definitions.with_attribute_model('contact_attribute').each do |attribute|
      attributes << "#{attribute.attribute_display_name}: #{@record.custom_attributes[attribute.attribute_key]}"
    end
    attributes.join("\n")
  end
end

================
File: services/llm_formatter/conversation_llm_formatter.rb
================
class LlmFormatter::ConversationLlmFormatter < LlmFormatter::DefaultLlmFormatter
  def format
    sections = []
    sections << "Conversation ID: ##{@record.display_id}"
    sections << "Channel: #{@record.inbox.channel.name}"
    sections << 'Message History:'
    sections << if @record.messages.any?
                  build_messages
                else
                  'No messages in this conversation'
                end

    sections.join("\n")
  end

  private

  def build_messages
    return "No messages in this conversation\n" if @record.messages.empty?

    message_text = ''
    @record.messages.chat.order(created_at: :asc).each do |message|
      message_text << format_message(message)
    end
    message_text
  end

  def format_message(message)
    sender = message.message_type == 'incoming' ? 'User' : 'Support agent'
    "#{sender}: #{message.content}\n"
  end
end

================
File: services/llm_formatter/default_llm_formatter.rb
================
class LlmFormatter::DefaultLlmFormatter
  def initialize(record)
    @record = record
  end

  def format
    # override this
  end
end

================
File: services/llm_formatter/llm_text_formatter_service.rb
================
class LlmFormatter::LlmTextFormatterService
  def initialize(record)
    @record = record
  end

  def format
    formatter_class = find_formatter
    formatter_class.new(@record).format
  end

  private

  def find_formatter
    formatter_name = "LlmFormatter::#{@record.class.name}LlmFormatter"
    formatter_class = formatter_name.safe_constantize
    raise FormatterNotFoundError, "No formatter found for #{@record.class.name}" unless formatter_class

    formatter_class
  end
end

================
File: services/macros/execution_service.rb
================
class Macros::ExecutionService < ActionService
  def initialize(macro, conversation, user)
    super(conversation)
    @macro = macro
    @account = macro.account
    @user = user
    Current.user = user
  end

  def perform
    @macro.actions.each do |action|
      action = action.with_indifferent_access
      begin
        send(action[:action_name], action[:action_params])
      rescue StandardError => e
        ChatwootExceptionTracker.new(e, account: @account).capture_exception
      end
    end
  ensure
    Current.reset
  end

  private

  def assign_agent(agent_ids)
    agent_ids = agent_ids.map { |id| id == 'self' ? @user.id : id }
    super(agent_ids)
  end

  def add_private_note(message)
    return if conversation_a_tweet?

    params = { content: message[0], private: true }

    # Added reload here to ensure conversation us persistent with the latest updates
    mb = Messages::MessageBuilder.new(@user, @conversation.reload, params)
    mb.perform
  end

  def send_message(message)
    return if conversation_a_tweet?

    params = { content: message[0], private: false }

    # Added reload here to ensure conversation us persistent with the latest updates
    mb = Messages::MessageBuilder.new(@user, @conversation.reload, params)
    mb.perform
  end

  def send_attachment(blob_ids)
    return if conversation_a_tweet?

    return unless @macro.files.attached?

    blobs = ActiveStorage::Blob.where(id: blob_ids)

    return if blobs.blank?

    params = { content: nil, private: false, attachments: blobs }

    # Added reload here to ensure conversation us persistent with the latest updates
    mb = Messages::MessageBuilder.new(@user, @conversation.reload, params)
    mb.perform
  end
end

================
File: services/message_templates/template/csat_survey.rb
================
class MessageTemplates::Template::CsatSurvey
  pattr_initialize [:conversation!]

  def perform
    ActiveRecord::Base.transaction do
      conversation.messages.create!(csat_survey_message_params)
    end
  end

  private

  delegate :contact, :account, to: :conversation
  delegate :inbox, to: :message

  def csat_survey_message_params
    {
      account_id: @conversation.account_id,
      inbox_id: @conversation.inbox_id,
      message_type: :template,
      content_type: :input_csat,
      content: I18n.t('conversations.templates.csat_input_message_body')
    }
  end
end

================
File: services/message_templates/template/email_collect.rb
================
class MessageTemplates::Template::EmailCollect
  pattr_initialize [:conversation!]

  def perform
    ActiveRecord::Base.transaction do
      conversation.messages.create!(ways_to_reach_you_message_params)
      conversation.messages.create!(email_input_box_template_message_params)
    end
  rescue StandardError => e
    ChatwootExceptionTracker.new(e, account: conversation.account).capture_exception
    true
  end

  private

  delegate :contact, :account, to: :conversation
  delegate :inbox, to: :message

  def ways_to_reach_you_message_params
    content = I18n.t('conversations.templates.ways_to_reach_you_message_body',
                     account_name: account.name)

    {
      account_id: @conversation.account_id,
      inbox_id: @conversation.inbox_id,
      message_type: :template,
      content: content
    }
  end

  def email_input_box_template_message_params
    content = I18n.t('conversations.templates.email_input_box_message_body',
                     account_name: account.name)

    {
      account_id: @conversation.account_id,
      inbox_id: @conversation.inbox_id,
      message_type: :template,
      content_type: :input_email,
      content: content
    }
  end
end

================
File: services/message_templates/template/greeting.rb
================
class MessageTemplates::Template::Greeting
  pattr_initialize [:conversation!]

  def perform
    ActiveRecord::Base.transaction do
      conversation.messages.create!(greeting_message_params)
    end
  rescue StandardError => e
    ChatwootExceptionTracker.new(e, account: conversation.account).capture_exception
    true
  end

  private

  delegate :contact, :account, to: :conversation
  delegate :inbox, to: :message

  def greeting_message_params
    content = @conversation.inbox&.greeting_message

    {
      account_id: @conversation.account_id,
      inbox_id: @conversation.inbox_id,
      message_type: :template,
      content: content
    }
  end
end

================
File: services/message_templates/template/out_of_office.rb
================
class MessageTemplates::Template::OutOfOffice
  pattr_initialize [:conversation!]

  def perform
    ActiveRecord::Base.transaction do
      conversation.messages.create!(out_of_office_message_params)
    end
  rescue StandardError => e
    ChatwootExceptionTracker.new(e, account: conversation.account).capture_exception
    true
  end

  private

  delegate :contact, :account, to: :conversation
  delegate :inbox, to: :message

  def out_of_office_message_params
    content = @conversation.inbox&.out_of_office_message

    {
      account_id: @conversation.account_id,
      inbox_id: @conversation.inbox_id,
      message_type: :template,
      content: content
    }
  end
end

================
File: services/message_templates/hook_execution_service.rb
================
class MessageTemplates::HookExecutionService
  pattr_initialize [:message!]

  def perform
    return if conversation.campaign.present?
    return if conversation.last_incoming_message.blank?

    trigger_templates
  end

  private

  delegate :inbox, :conversation, to: :message
  delegate :contact, to: :conversation

  def trigger_templates
    ::MessageTemplates::Template::OutOfOffice.new(conversation: conversation).perform if should_send_out_of_office_message?
    ::MessageTemplates::Template::Greeting.new(conversation: conversation).perform if should_send_greeting?
    ::MessageTemplates::Template::EmailCollect.new(conversation: conversation).perform if inbox.enable_email_collect && should_send_email_collect?
    ::MessageTemplates::Template::CsatSurvey.new(conversation: conversation).perform if should_send_csat_survey?
  end

  def should_send_out_of_office_message?
    # should not send if its a tweet message
    return false if conversation.tweet?
    # should not send for outbound messages
    return false unless message.incoming?

    inbox.out_of_office? && conversation.messages.today.template.empty? && inbox.out_of_office_message.present?
  end

  def first_message_from_contact?
    conversation.messages.outgoing.count.zero? && conversation.messages.template.count.zero?
  end

  def should_send_greeting?
    # should not send if its a tweet message
    return false if conversation.tweet?

    first_message_from_contact? && inbox.greeting_enabled? && inbox.greeting_message.present?
  end

  def email_collect_was_sent?
    conversation.messages.where(content_type: 'input_email').present?
  end

  # TODO: we should be able to reduce this logic once we have a toggle for email collect messages
  def should_send_email_collect?
    !contact_has_email? && inbox.web_widget? && !email_collect_was_sent?
  end

  def contact_has_email?
    contact.email
  end

  def csat_enabled_conversation?
    return false unless conversation.resolved?
    # should not sent since the link will be public
    return false if conversation.tweet?
    return false unless inbox.csat_survey_enabled?

    true
  end

  def should_send_csat_survey?
    return unless csat_enabled_conversation?

    # only send CSAT once in a conversation
    return if conversation.messages.where(content_type: :input_csat).present?

    true
  end
end
MessageTemplates::HookExecutionService.prepend_mod_with('MessageTemplates::HookExecutionService')

================
File: services/messages/in_reply_to_message_builder.rb
================
class Messages::InReplyToMessageBuilder
  pattr_initialize [:message!, :in_reply_to!, :in_reply_to_external_id!]

  delegate :conversation, to: :message

  def perform
    set_in_reply_to_attribute if @in_reply_to.present? || @in_reply_to_external_id.present?
  end

  private

  def set_in_reply_to_attribute
    @message.content_attributes[:in_reply_to_external_id] = in_reply_to_message.try(:source_id)
    @message.content_attributes[:in_reply_to] = in_reply_to_message.try(:id)
  end

  def in_reply_to_message
    return conversation.messages.find_by(id: @in_reply_to) if @in_reply_to.present?

    return conversation.messages.find_by(source_id: @in_reply_to_external_id) if @in_reply_to_external_id

    nil
  end
end

================
File: services/messages/mention_service.rb
================
class Messages::MentionService
  pattr_initialize [:message!]

  def perform
    return unless valid_mention_message?(message)

    validated_mentioned_ids = filter_mentioned_ids_by_inbox
    return if validated_mentioned_ids.blank?

    Conversations::UserMentionJob.perform_later(validated_mentioned_ids, message.conversation.id, message.account.id)
    generate_notifications_for_mentions(validated_mentioned_ids)
    add_mentioned_users_as_participants(validated_mentioned_ids)
  end

  private

  def valid_mention_message?(message)
    message.private? && message.content.present? && mentioned_ids.present?
  end

  def mentioned_ids
    @mentioned_ids ||= message.content.scan(%r{\(mention://(user|team)/(\d+)/(.+?)\)}).map(&:second).uniq
  end

  def filter_mentioned_ids_by_inbox
    inbox = message.inbox
    valid_mentionable_ids = inbox.account.administrators.map(&:id) + inbox.members.map(&:id)
    # Intersection of ids
    mentioned_ids & valid_mentionable_ids.uniq.map(&:to_s)
  end

  def generate_notifications_for_mentions(validated_mentioned_ids)
    validated_mentioned_ids.each do |user_id|
      NotificationBuilder.new(
        notification_type: 'conversation_mention',
        user: User.find(user_id),
        account: message.account,
        primary_actor: message.conversation,
        secondary_actor: message
      ).perform
    end
  end

  def add_mentioned_users_as_participants(validated_mentioned_ids)
    validated_mentioned_ids.each do |user_id|
      message.conversation.conversation_participants.find_or_create_by(user_id: user_id)
    end
  end
end

================
File: services/messages/new_message_notification_service.rb
================
class Messages::NewMessageNotificationService
  pattr_initialize [:message!]

  def perform
    return unless message.notifiable?

    notify_conversation_assignee
    notify_participating_users
  end

  private

  delegate :conversation, :sender, :account, to: :message

  def notify_conversation_assignee
    return if conversation.assignee.blank?
    return if already_notified?(conversation.assignee)
    return if conversation.assignee == sender

    NotificationBuilder.new(
      notification_type: 'assigned_conversation_new_message',
      user: conversation.assignee,
      account: account,
      primary_actor: message.conversation,
      secondary_actor: message
    ).perform
  end

  def notify_participating_users
    participating_users = conversation.conversation_participants.map(&:user)
    participating_users -= [sender] if sender.is_a?(User)

    participating_users.uniq.each do |participant|
      next if already_notified?(participant)

      NotificationBuilder.new(
        notification_type: 'participating_conversation_new_message',
        user: participant,
        account: account,
        primary_actor: message.conversation,
        secondary_actor: message
      ).perform
    end
  end

  # The user could already have been notified via a mention or via assignment
  # So we don't need to notify them again
  def already_notified?(user)
    conversation.notifications.exists?(user: user, secondary_actor: message)
  end
end

================
File: services/microsoft/refresh_oauth_token_service.rb
================
# Refer: https://learn.microsoft.com/en-us/entra/identity-platform/configurable-token-lifetimes
class Microsoft::RefreshOauthTokenService < BaseRefreshOauthTokenService
  private

  # Builds the OAuth strategy for Microsoft Graph
  def build_oauth_strategy
    ::MicrosoftGraphAuth.new(nil, GlobalConfigService.load('AZURE_APP_ID', ''), GlobalConfigService.load('AZURE_APP_SECRET', ''))
  end
end

================
File: services/notification/email_notification_service.rb
================
class Notification::EmailNotificationService
  pattr_initialize [:notification!]

  def perform
    # don't send emails if user read the push notification already
    return if notification.read_at.present?
    # don't send emails if user is not confirmed
    return if notification.user.confirmed_at.nil?
    return unless user_subscribed_to_notification?

    # TODO : Clean up whatever happening over here
    # Segregate the mailers properly
    AgentNotifications::ConversationNotificationsMailer.with(account: notification.account).public_send(notification
      .notification_type.to_s, notification.primary_actor, notification.user, notification.secondary_actor).deliver_later
  end

  private

  def user_subscribed_to_notification?
    notification_setting = notification.user.notification_settings.find_by(account_id: notification.account.id)
    return true if notification_setting.public_send("email_#{notification.notification_type}?")

    false
  end
end

================
File: services/notification/fcm_service.rb
================
class Notification::FcmService
  SCOPES = ['https://www.googleapis.com/auth/firebase.messaging'].freeze

  def initialize(project_id, credentials)
    @project_id = project_id
    @credentials = credentials
    @token_info = nil
  end

  def fcm_client
    FCM.new(current_token, credentials_path, @project_id)
  end

  private

  def current_token
    @token_info = generate_token if @token_info.nil? || token_expired?
    @token_info[:token]
  end

  def token_expired?
    Time.zone.now >= @token_info[:expires_at]
  end

  def generate_token
    authorizer = Google::Auth::ServiceAccountCredentials.make_creds(
      json_key_io: credentials_path,
      scope: SCOPES
    )
    token = authorizer.fetch_access_token!
    {
      token: token['access_token'],
      expires_at: Time.zone.now + token['expires_in'].to_i
    }
  end

  def credentials_path
    StringIO.new(@credentials)
  end
end

================
File: services/notification/push_notification_service.rb
================
class Notification::PushNotificationService
  include Rails.application.routes.url_helpers

  pattr_initialize [:notification!]

  def perform
    return unless user_subscribed_to_notification?

    notification_subscriptions.each do |subscription|
      send_browser_push(subscription)
      send_fcm_push(subscription)
      send_push_via_chatwoot_hub(subscription)
    end
  end

  private

  delegate :user, to: :notification
  delegate :notification_subscriptions, to: :user
  delegate :notification_settings, to: :user

  def user_subscribed_to_notification?
    notification_setting = notification_settings.find_by(account_id: notification.account.id)
    return true if notification_setting.public_send("push_#{notification.notification_type}?")

    false
  end

  def conversation
    @conversation ||= notification.conversation
  end

  def push_message
    {
      title: notification.push_message_title,
      tag: "#{notification.notification_type}_#{conversation.display_id}_#{notification.id}",
      url: push_url
    }
  end

  def push_url
    app_account_conversation_url(account_id: conversation.account_id, id: conversation.display_id)
  end

  def can_send_browser_push?(subscription)
    VapidService.public_key && subscription.browser_push?
  end

  def browser_push_payload(subscription)
    {
      message: JSON.generate(push_message),
      endpoint: subscription.subscription_attributes['endpoint'],
      p256dh: subscription.subscription_attributes['p256dh'],
      auth: subscription.subscription_attributes['auth'],
      vapid: {
        subject: push_url,
        public_key: VapidService.public_key,
        private_key: VapidService.private_key
      },
      ssl_timeout: 5,
      open_timeout: 5,
      read_timeout: 5
    }
  end

  def send_browser_push(subscription)
    return unless can_send_browser_push?(subscription)

    WebPush.payload_send(**browser_push_payload(subscription))
    Rails.logger.info("Browser push sent to #{user.email} with title #{push_message[:title]}")
  rescue WebPush::ExpiredSubscription, WebPush::InvalidSubscription, WebPush::Unauthorized => e
    Rails.logger.info "WebPush subscription expired: #{e.message}"
    subscription.destroy!
  rescue Errno::ECONNRESET, Net::OpenTimeout, Net::ReadTimeout => e
    Rails.logger.error "WebPush operation error: #{e.message}"
  rescue StandardError => e
    ChatwootExceptionTracker.new(e, account: notification.account).capture_exception
    true
  end

  def send_fcm_push(subscription)
    return unless firebase_credentials_present?
    return unless subscription.fcm?

    fcm_service = Notification::FcmService.new(
      GlobalConfigService.load('FIREBASE_PROJECT_ID', nil), GlobalConfigService.load('FIREBASE_CREDENTIALS', nil)
    )
    fcm = fcm_service.fcm_client
    response = fcm.send_v1(fcm_options(subscription))
    remove_subscription_if_error(subscription, response)
  end

  def send_push_via_chatwoot_hub(subscription)
    return if firebase_credentials_present?
    return unless chatwoot_hub_enabled?
    return unless subscription.fcm?

    ChatwootHub.send_push(fcm_options(subscription))
  end

  def firebase_credentials_present?
    GlobalConfigService.load('FIREBASE_PROJECT_ID', nil) && GlobalConfigService.load('FIREBASE_CREDENTIALS', nil)
  end

  def chatwoot_hub_enabled?
    ActiveModel::Type::Boolean.new.cast(ENV.fetch('ENABLE_PUSH_RELAY_SERVER', true))
  end

  def remove_subscription_if_error(subscription, response)
    if JSON.parse(response[:body])['results']&.first&.keys&.include?('error')
      subscription.destroy!
    else
      Rails.logger.info("FCM push sent to #{user.email} with title #{push_message[:title]}")
    end
  end

  def fcm_options(subscription)
    {
      'token': subscription.subscription_attributes['push_token'],
      'data': fcm_data,
      'notification': fcm_notification,
      'android': fcm_android_options,
      'apns': fcm_apns_options,
      'fcm_options': {
        analytics_label: 'Label'
      }
    }
  end

  def fcm_data
    {
      payload: {
        data: {
          notification: notification.fcm_push_data
        }
      }.to_json
    }
  end

  def fcm_notification
    {
      title: notification.push_message_title,
      body: notification.push_message_body
    }
  end

  def fcm_android_options
    {
      priority: 'high'
    }
  end

  def fcm_apns_options
    {
      payload: {
        aps: {
          sound: 'default',
          category: Time.zone.now.to_i.to_s
        }
      }
    }
  end
end

================
File: services/sms/delivery_status_service.rb
================
class Sms::DeliveryStatusService
  pattr_initialize [:inbox!, :params!]

  def perform
    return unless supported_status?

    process_status if message.present?
  end

  private

  def process_status
    @message.status = status
    @message.external_error = external_error if error_occurred?
    @message.save!
  end

  def supported_status?
    %w[message-delivered message-failed].include?(params[:type])
  end

  # Relevant documentation:
  # https://dev.bandwidth.com/docs/mfa/webhooks/international/message-delivered
  # https://dev.bandwidth.com/docs/mfa/webhooks/international/message-failed
  def status
    type_mapping = {
      'message-delivered' => 'delivered',
      'message-failed' => 'failed'
    }

    type_mapping[params[:type]]
  end

  def external_error
    return nil unless error_occurred?

    error_message = params[:description]
    error_code = params[:errorCode]

    "#{error_code} - #{error_message}"
  end

  def error_occurred?
    params[:errorCode] && params[:type] == 'message-failed'
  end

  def message
    return unless params[:message][:id]

    @message ||= inbox.messages.find_by(source_id: params[:message][:id])
  end
end

================
File: services/sms/incoming_message_service.rb
================
class Sms::IncomingMessageService
  include ::FileTypeHelper

  pattr_initialize [:inbox!, :params!]

  def perform
    set_contact
    set_conversation
    @message = @conversation.messages.create!(
      content: params[:text],
      account_id: @inbox.account_id,
      inbox_id: @inbox.id,
      message_type: :incoming,
      sender: @contact,
      source_id: params[:id]
    )
    attach_files
    @message.save!
  end

  private

  def account
    @account ||= @inbox.account
  end

  def channel
    @channel ||= @inbox.channel
  end

  def phone_number
    params[:from]
  end

  def formatted_phone_number
    TelephoneNumber.parse(phone_number).international_number
  end

  def set_contact
    contact_inbox = ::ContactInboxWithContactBuilder.new(
      source_id: params[:from],
      inbox: @inbox,
      contact_attributes: contact_attributes
    ).perform

    @contact_inbox = contact_inbox
    @contact = contact_inbox.contact
  end

  def conversation_params
    {
      account_id: @inbox.account_id,
      inbox_id: @inbox.id,
      contact_id: @contact.id,
      contact_inbox_id: @contact_inbox.id
    }
  end

  def set_conversation
    # if lock to single conversation is disabled, we will create a new conversation if previous conversation is resolved
    @conversation = if @inbox.lock_to_single_conversation
                      @contact_inbox.conversations.last
                    else
                      @contact_inbox.conversations.where
                                    .not(status: :resolved).last
                    end
    return if @conversation

    @conversation = ::Conversation.create!(conversation_params)
  end

  def contact_attributes
    {
      name: formatted_phone_number,
      phone_number: phone_number
    }
  end

  def attach_files
    return if params[:media].blank?

    params[:media].each do |media_url|
      # we don't need to process this files since chatwoot doesn't support it
      next if media_url.end_with?('.smil', '.xml')

      attachment_file = Down.download(
        media_url,
        http_basic_authentication: [channel.provider_config['api_key'], channel.provider_config['api_secret']]
      )

      @message.attachments.new(
        account_id: @message.account_id,
        file_type: file_type(attachment_file.content_type),
        file: {
          io: attachment_file,
          filename: attachment_file.original_filename,
          content_type: attachment_file.content_type
        }
      )
    end
  end
end

================
File: services/sms/oneoff_sms_campaign_service.rb
================
class Sms::OneoffSmsCampaignService
  pattr_initialize [:campaign!]

  def perform
    raise "Invalid campaign #{campaign.id}" if campaign.inbox.inbox_type != 'Sms' || !campaign.one_off?
    raise 'Completed Campaign' if campaign.completed?

    # marks campaign completed so that other jobs won't pick it up
    campaign.completed!

    audience_label_ids = campaign.audience.select { |audience| audience['type'] == 'Label' }.pluck('id')
    audience_labels = campaign.account.labels.where(id: audience_label_ids).pluck(:title)
    process_audience(audience_labels)
  end

  private

  delegate :inbox, to: :campaign
  delegate :channel, to: :inbox

  def process_audience(audience_labels)
    campaign.account.contacts.tagged_with(audience_labels, any: true).each do |contact|
      next if contact.phone_number.blank?

      send_message(to: contact.phone_number, content: campaign.message)
    end
  end

  def send_message(to:, content:)
    channel.send_text_message(to, content)
  end
end

================
File: services/sms/send_on_sms_service.rb
================
class Sms::SendOnSmsService < Base::SendOnChannelService
  private

  def channel_class
    Channel::Sms
  end

  def perform_reply
    send_on_sms
  end

  def send_on_sms
    message_id = channel.send_message(message.conversation.contact_inbox.source_id, message)
    message.update!(source_id: message_id) if message_id.present?
  end
end

================
File: services/telegram/incoming_message_service.rb
================
# Find the various telegram payload samples here: https://core.telegram.org/bots/webhooks#testing-your-bot-with-updates
# https://core.telegram.org/bots/api#available-types

class Telegram::IncomingMessageService
  include ::FileTypeHelper
  include ::Telegram::ParamHelpers
  pattr_initialize [:inbox!, :params!]

  def perform
    # chatwoot doesn't support group conversations at the moment
    return unless private_message?

    set_contact
    update_contact_avatar
    set_conversation
    @message = @conversation.messages.build(
      content: telegram_params_message_content,
      account_id: @inbox.account_id,
      inbox_id: @inbox.id,
      message_type: :incoming,
      sender: @contact,
      content_attributes: telegram_params_content_attributes,
      source_id: telegram_params_message_id.to_s
    )

    process_message_attachments if message_params?
    @message.save!
  end

  private

  def set_contact
    contact_inbox = ::ContactInboxWithContactBuilder.new(
      source_id: telegram_params_from_id,
      inbox: inbox,
      contact_attributes: contact_attributes
    ).perform

    @contact_inbox = contact_inbox
    @contact = contact_inbox.contact
  end

  def process_message_attachments
    attach_location
    attach_files
    attach_contact
  end

  def update_contact_avatar
    return if @contact.avatar.attached?

    avatar_url = inbox.channel.get_telegram_profile_image(telegram_params_from_id)
    ::Avatar::AvatarFromUrlJob.perform_later(@contact, avatar_url) if avatar_url
  end

  def conversation_params
    {
      account_id: @inbox.account_id,
      inbox_id: @inbox.id,
      contact_id: @contact.id,
      contact_inbox_id: @contact_inbox.id,
      additional_attributes: conversation_additional_attributes
    }
  end

  def set_conversation
    @conversation = @contact_inbox.conversations.first
    return if @conversation

    @conversation = ::Conversation.create!(conversation_params)
  end

  def contact_attributes
    {
      name: "#{telegram_params_first_name} #{telegram_params_last_name}",
      additional_attributes: additional_attributes
    }
  end

  def additional_attributes
    {
      # TODO: Remove this once we show the social_telegram_user_name in the UI instead of the username
      username: telegram_params_username,
      language_code: telegram_params_language_code,
      social_telegram_user_id: telegram_params_from_id,
      social_telegram_user_name: telegram_params_username
    }
  end

  def conversation_additional_attributes
    {
      chat_id: telegram_params_chat_id
    }
  end

  def file_content_type
    return :image if params[:message][:photo].present? || params.dig(:message, :sticker, :thumb).present?
    return :audio if params[:message][:voice].present? || params[:message][:audio].present?
    return :video if params[:message][:video].present?

    file_type(params[:message][:document][:mime_type])
  end

  def attach_files
    return unless file

    file_download_path = inbox.channel.get_telegram_file_path(file[:file_id])
    if file_download_path.blank?
      Rails.logger.info "Telegram file download path is blank for #{file[:file_id]} : inbox_id: #{inbox.id}"
      return
    end

    attachment_file = Down.download(
      inbox.channel.get_telegram_file_path(file[:file_id])
    )

    @message.attachments.new(
      account_id: @message.account_id,
      file_type: file_content_type,
      file: {
        io: attachment_file,
        filename: attachment_file.original_filename,
        content_type: attachment_file.content_type
      }
    )
  end

  def attach_location
    return unless location

    @message.attachments.new(
      account_id: @message.account_id,
      file_type: :location,
      fallback_title: location_fallback_title,
      coordinates_lat: location['latitude'],
      coordinates_long: location['longitude']
    )
  end

  def attach_contact
    return unless contact_card

    @message.attachments.new(
      account_id: @message.account_id,
      file_type: :contact,
      fallback_title: contact_card['phone_number'].to_s,
      meta: {
        first_name: contact_card['first_name'],
        last_name: contact_card['last_name']
      }
    )
  end

  def file
    @file ||= visual_media_params || params[:message][:voice].presence || params[:message][:audio].presence || params[:message][:document].presence
  end

  def location_fallback_title
    return '' if venue.blank?

    venue[:title] || ''
  end

  def venue
    @venue ||= params.dig(:message, :venue).presence
  end

  def location
    @location ||= params.dig(:message, :location).presence
  end

  def contact_card
    @contact_card ||= params.dig(:message, :contact).presence
  end

  def visual_media_params
    params[:message][:photo].presence&.last || params.dig(:message, :sticker, :thumb).presence || params[:message][:video].presence
  end
end

================
File: services/telegram/param_helpers.rb
================
module Telegram::ParamHelpers
  # ensures that message is from a private chat and not a group chat
  def private_message?
    return true if callback_query_params?

    params.dig(:message, :chat, :type) == 'private'
  end

  def telegram_params_content_attributes
    reply_to = params.dig(:message, :reply_to_message, :message_id)
    return { 'in_reply_to_external_id' => reply_to } if reply_to

    {}
  end

  def message_params?
    params[:message].present?
  end

  def callback_query_params?
    params[:callback_query].present?
  end

  def telegram_params_base_object
    if callback_query_params?
      params[:callback_query]
    else
      params[:message]
    end
  end

  def telegram_params_from_id
    telegram_params_base_object[:from][:id]
  end

  def telegram_params_first_name
    telegram_params_base_object[:from][:first_name]
  end

  def telegram_params_last_name
    telegram_params_base_object[:from][:last_name]
  end

  def telegram_params_username
    telegram_params_base_object[:from][:username]
  end

  def telegram_params_language_code
    telegram_params_base_object[:from][:language_code]
  end

  def telegram_params_chat_id
    if callback_query_params?
      params[:callback_query][:message][:chat][:id]
    else
      telegram_params_base_object[:chat][:id]
    end
  end

  def telegram_params_message_content
    if callback_query_params?
      params[:callback_query][:data]
    else
      params[:message][:text].presence || params[:message][:caption]
    end
  end

  def telegram_params_message_id
    if callback_query_params?
      params[:callback_query][:id]
    else
      params[:message][:message_id]
    end
  end
end

================
File: services/telegram/send_attachments_service.rb
================
# Telegram Attachment APIs: ref: https://core.telegram.org/bots/api#inputfile

# Media attachments like photos, videos can be clubbed together and sent as a media group
# Audio can be clubbed together and send as a media group, but can't be mixed with other types
# Documents are sent individually

# We are using `HTTP URL` to send media attachments, telegram will directly download the media from the URL and send it to the user.
# But for documents, we need to send the file as a multipart request. as telegram only support pdf and zip for the download from the URL option.

# ref: `In sendDocument, sending by URL will currently only work for GIF, PDF and ZIP files.`
# ref: `https://core.telegram.org/bots/api#senddocument`
# ref: `https://core.telegram.org/bots/api#sendmediaGroup

# The service will terminate if any of the attachment requests fail when the message has multiple attachments
# We will create multiple messages in telegram if the message has multiple attachments (if its documents or mixed media).
class Telegram::SendAttachmentsService
  pattr_initialize [:message!]

  def perform
    attachment_message_id = nil

    group_attachments_by_type.each do |type, attachments|
      attachment_message_id = process_attachments_by_type(type, attachments)
      break if attachment_message_id.nil?
    end

    attachment_message_id
  end

  private

  def process_attachments_by_type(type, attachments)
    response = send_attachments(type, attachments)
    return extract_attachment_message_id(response) if handle_response(response)

    nil
  end

  def send_attachments(type, attachments)
    if [:media, :audio].include?(type)
      media_group_request(channel.chat_id(message), attachments, channel.reply_to_message_id(message))
    else
      send_individual_attachments(attachments)
    end
  end

  def group_attachments_by_type
    attachments_by_type = { media: [], audio: [], document: [] }

    message.attachments.each do |attachment|
      type = attachment_type(attachment[:file_type])
      attachment_data = { type: type, media: attachment.download_url, attachment: attachment }
      case type
      when 'document'
        attachments_by_type[:document] << attachment_data
      when 'audio'
        attachments_by_type[:audio] << attachment_data
      when 'photo', 'video'
        attachments_by_type[:media] << attachment_data
      end
    end

    attachments_by_type.reject { |_, v| v.empty? }
  end

  def attachment_type(file_type)
    { 'audio' => 'audio', 'image' => 'photo', 'file' => 'document', 'video' => 'video' }[file_type] || 'document'
  end

  def media_group_request(chat_id, attachments, reply_to_message_id)
    HTTParty.post("#{channel.telegram_api_url}/sendMediaGroup",
                  body: {
                    chat_id: chat_id,
                    media: attachments.map { |hash| hash.except(:attachment) }.to_json,
                    reply_to_message_id: reply_to_message_id
                  })
  end

  def send_individual_attachments(attachments)
    response = nil
    attachments.map do |attachment|
      response = document_request(channel.chat_id(message), attachment, channel.reply_to_message_id(message))
      break unless handle_response(response)
    end
    response
  end

  def document_request(chat_id, attachment, reply_to_message_id)
    temp_file_path = save_attachment_to_tempfile(attachment[:attachment])
    response = send_file(chat_id, temp_file_path, reply_to_message_id)
    File.delete(temp_file_path)
    response
  end

  # Telegram picks up the file name from original field name, so we need to save the file with the original name.
  # Hence not using Tempfile here.
  def save_attachment_to_tempfile(attachment)
    raw_data = attachment.file.download
    temp_dir = Rails.root.join('tmp/uploads')
    FileUtils.mkdir_p(temp_dir)
    temp_file_path = File.join(temp_dir, attachment.file.filename.to_s)
    File.write(temp_file_path, raw_data, mode: 'wb')
    temp_file_path
  end

  def send_file(chat_id, file_path, reply_to_message_id)
    File.open(file_path, 'rb') do |file|
      HTTParty.post("#{channel.telegram_api_url}/sendDocument",
                    body: {
                      chat_id: chat_id,
                      document: file,
                      reply_to_message_id: reply_to_message_id
                    },
                    multipart: true)
    end
  end

  def handle_response(response)
    return true if response.success?

    Rails.logger.error "Message Id: #{message.id}  - Error sending attachment to telegram:  #{response.parsed_response}"
    channel.process_error(message, response)
    false
  end

  def extract_attachment_message_id(response)
    return unless response.success?

    result = response.parsed_response['result']
    # response will be an array if the request for media group
    # response will be a hash if the request for document
    result.is_a?(Array) ? result.first['message_id'] : result['message_id']
  end

  def channel
    @channel ||= message.inbox.channel
  end
end

================
File: services/telegram/send_on_telegram_service.rb
================
class Telegram::SendOnTelegramService < Base::SendOnChannelService
  private

  def channel_class
    Channel::Telegram
  end

  def perform_reply
    ## send reply to telegram message api
    # https://core.telegram.org/bots/api#sendmessage
    message_id = channel.send_message_on_telegram(message)
    message.update!(source_id: message_id) if message_id.present?
  end

  def inbox
    @inbox ||= message.inbox
  end

  def channel
    @channel ||= inbox.channel
  end
end

================
File: services/telegram/update_message_service.rb
================
# Find the various telegram payload samples here: https://core.telegram.org/bots/webhooks#testing-your-bot-with-updates
# https://core.telegram.org/bots/api#available-types

class Telegram::UpdateMessageService
  pattr_initialize [:inbox!, :params!]

  def perform
    find_contact_inbox
    find_conversation
    find_message
    update_message
  rescue StandardError => e
    Rails.logger.error "Error while processing telegram message update #{e.message}"
  end

  private

  def find_contact_inbox
    @contact_inbox = inbox.contact_inboxes.find_by!(source_id: params[:edited_message][:chat][:id])
  end

  def find_conversation
    @conversation = @contact_inbox.conversations.last
  end

  def find_message
    @message = @conversation.messages.find_by(source_id: params[:edited_message][:message_id])
  end

  def update_message
    edited_message = params[:edited_message]

    if edited_message[:text].present?
      @message.update!(content: edited_message[:text])
    elsif edited_message[:caption].present?
      @message.update!(content: edited_message[:caption])
    end
  end
end

================
File: services/twilio/delivery_status_service.rb
================
class Twilio::DeliveryStatusService
  pattr_initialize [:params!]
  # Reference: https://www.twilio.com/docs/messaging/api/message-resource#message-status-values

  def perform
    return if twilio_channel.blank?

    return unless supported_status?

    process_statuses if message.present?
  end

  private

  def process_statuses
    @message.status = status
    @message.external_error = external_error if error_occurred?
    @message.save!
  end

  def supported_status?
    %w[sent delivered read failed undelivered].include?(params[:MessageStatus])
  end

  def status
    params[:MessageStatus] == 'undelivered' ? 'failed' : params[:MessageStatus]
  end

  def external_error
    return nil unless error_occurred?

    error_message = params[:ErrorMessage].presence
    error_code = params[:ErrorCode]

    if error_message.present?
      "#{error_code} - #{error_message}"
    elsif error_code.present?
      I18n.t('conversations.messages.delivery_status.error_code', error_code: error_code)
    end
  end

  def error_occurred?
    params[:ErrorCode].present? && %w[failed undelivered].include?(params[:MessageStatus])
  end

  def twilio_channel
    @twilio_channel ||= if params[:MessagingServiceSid].present?
                          ::Channel::TwilioSms.find_by(messaging_service_sid: params[:MessagingServiceSid])
                        elsif params[:AccountSid].present? && params[:From].present?
                          ::Channel::TwilioSms.find_by!(account_sid: params[:AccountSid], phone_number: params[:From])
                        end
  end

  def message
    return unless params[:MessageSid]

    @message ||= twilio_channel.inbox.messages.find_by(source_id: params[:MessageSid])
  end
end

================
File: services/twilio/incoming_message_service.rb
================
class Twilio::IncomingMessageService
  include ::FileTypeHelper

  pattr_initialize [:params!]

  def perform
    return if twilio_channel.blank?

    set_contact
    set_conversation
    @message = @conversation.messages.build(
      content: message_body,
      account_id: @inbox.account_id,
      inbox_id: @inbox.id,
      message_type: :incoming,
      sender: @contact,
      source_id: params[:SmsSid]
    )
    attach_files
    @message.save!
  end

  private

  def twilio_channel
    @twilio_channel ||= ::Channel::TwilioSms.find_by(messaging_service_sid: params[:MessagingServiceSid]) if params[:MessagingServiceSid].present?
    if params[:AccountSid].present? && params[:To].present?
      @twilio_channel ||= ::Channel::TwilioSms.find_by!(account_sid: params[:AccountSid],
                                                        phone_number: params[:To])
    end
    @twilio_channel
  end

  def inbox
    @inbox ||= twilio_channel.inbox
  end

  def account
    @account ||= inbox.account
  end

  def phone_number
    twilio_channel.sms? ? params[:From] : params[:From].gsub('whatsapp:', '')
  end

  def formatted_phone_number
    TelephoneNumber.parse(phone_number).international_number
  end

  def message_body
    params[:Body]&.delete("\u0000")
  end

  def set_contact
    contact_inbox = ::ContactInboxWithContactBuilder.new(
      source_id: params[:From],
      inbox: inbox,
      contact_attributes: contact_attributes
    ).perform

    @contact_inbox = contact_inbox
    @contact = contact_inbox.contact
  end

  def conversation_params
    {
      account_id: @inbox.account_id,
      inbox_id: @inbox.id,
      contact_id: @contact.id,
      contact_inbox_id: @contact_inbox.id,
      additional_attributes: additional_attributes
    }
  end

  def set_conversation
    # if lock to single conversation is disabled, we will create a new conversation if previous conversation is resolved
    @conversation = if @inbox.lock_to_single_conversation
                      @contact_inbox.conversations.last
                    else
                      @contact_inbox.conversations.where
                                    .not(status: :resolved).last
                    end
    return if @conversation

    @conversation = ::Conversation.create!(conversation_params)
  end

  def contact_attributes
    {
      name: formatted_phone_number,
      phone_number: phone_number,
      additional_attributes: additional_attributes
    }
  end

  def additional_attributes
    if twilio_channel.sms?
      {
        from_zip_code: params[:FromZip],
        from_country: params[:FromCountry],
        from_state: params[:FromState]
      }
    else
      {}
    end
  end

  def attach_files
    return if params[:MediaUrl0].blank?

    attachment_file = download_attachment_file

    return if attachment_file.blank?

    @message.attachments.new(
      account_id: @message.account_id,
      file_type: file_type(params[:MediaContentType0]),
      file: {
        io: attachment_file,
        filename: attachment_file.original_filename,
        content_type: attachment_file.content_type
      }
    )
  end

  def download_attachment_file
    download_with_auth
  rescue Down::Error, Down::ClientError => e
    handle_download_attachment_error(e)
  end

  def download_with_auth
    Down.download(
      params[:MediaUrl0],
      # https://support.twilio.com/hc/en-us/articles/223183748-Protect-Media-Access-with-HTTP-Basic-Authentication-for-Programmable-Messaging
      http_basic_authentication: [twilio_channel.account_sid, twilio_channel.auth_token || twilio_channel.api_key_sid]
    )
  end

  # This is just a temporary workaround since some users have not yet enabled media protection. We will remove this in the future.
  def handle_download_attachment_error(error)
    Rails.logger.info "Error downloading attachment from Twilio: #{error.message}: Retrying"
    Down.download(params[:MediaUrl0])
  rescue StandardError => e
    Rails.logger.info "Error downloading attachment from Twilio: #{e.message}: Skipping"
    nil
  end
end

================
File: services/twilio/oneoff_sms_campaign_service.rb
================
class Twilio::OneoffSmsCampaignService
  pattr_initialize [:campaign!]

  def perform
    raise "Invalid campaign #{campaign.id}" if campaign.inbox.inbox_type != 'Twilio SMS' || !campaign.one_off?
    raise 'Completed Campaign' if campaign.completed?

    # marks campaign completed so that other jobs won't pick it up
    campaign.completed!

    audience_label_ids = campaign.audience.select { |audience| audience['type'] == 'Label' }.pluck('id')
    audience_labels = campaign.account.labels.where(id: audience_label_ids).pluck(:title)
    process_audience(audience_labels)
  end

  private

  delegate :inbox, to: :campaign
  delegate :channel, to: :inbox

  def process_audience(audience_labels)
    campaign.account.contacts.tagged_with(audience_labels, any: true).each do |contact|
      next if contact.phone_number.blank?

      channel.send_message(to: contact.phone_number, body: campaign.message)
    end
  end
end

================
File: services/twilio/send_on_twilio_service.rb
================
class Twilio::SendOnTwilioService < Base::SendOnChannelService
  private

  def channel_class
    Channel::TwilioSms
  end

  def perform_reply
    begin
      twilio_message = channel.send_message(**message_params)
    rescue Twilio::REST::TwilioError, Twilio::REST::RestError => e
      message.update!(status: :failed, external_error: e.message)
    end
    message.update!(source_id: twilio_message.sid) if twilio_message
  end

  def message_params
    {
      body: message.content,
      to: contact_inbox.source_id,
      media_url: attachments
    }
  end

  def attachments
    message.attachments.map(&:download_url)
  end

  def inbox
    @inbox ||= message.inbox
  end

  def channel
    @channel ||= inbox.channel
  end

  def outgoing_message?
    message.outgoing? || message.template?
  end
end

================
File: services/twilio/webhook_setup_service.rb
================
class Twilio::WebhookSetupService
  include Rails.application.routes.url_helpers

  pattr_initialize [:inbox!]

  def perform
    if channel.messaging_service_sid?
      update_messaging_service
    else
      update_phone_number
    end
  end

  private

  def update_messaging_service
    twilio_client
      .messaging.services(channel.messaging_service_sid)
      .update(
        inbound_method: 'POST',
        inbound_request_url: twilio_callback_index_url,
        use_inbound_webhook_on_number: false
      )
  end

  def update_phone_number
    if phone_numbers.empty?
      Rails.logger.warn "TWILIO_PHONE_NUMBER_NOT_FOUND: #{channel.phone_number}"
    else
      twilio_client
        .incoming_phone_numbers(phonenumber_sid)
        .update(sms_method: 'POST', sms_url: twilio_callback_index_url)
    end
  end

  def phonenumber_sid
    phone_numbers.first.sid
  end

  def phone_numbers
    @phone_numbers ||= twilio_client.incoming_phone_numbers.list(phone_number: channel.phone_number)
  end

  def channel
    @channel ||= inbox.channel
  end

  def twilio_client
    @twilio_client ||= ::Twilio::REST::Client.new(channel.account_sid, channel.auth_token)
  end
end

================
File: services/twitter/direct_message_parser_service.rb
================
class Twitter::DirectMessageParserService < Twitter::WebhooksBaseService
  pattr_initialize [:payload]

  def perform
    return if source_app_id == parent_app_id

    set_inbox
    ensure_contacts
    set_conversation
    @message = @conversation.messages.create!(
      content: message_create_data['message_data']['text'],
      account_id: @inbox.account_id,
      inbox_id: @inbox.id,
      message_type: outgoing_message? ? :outgoing : :incoming,
      sender: @contact,
      source_id: direct_message_data['id']
    )
    attach_files
  end

  private

  def attach_files
    return if message_create_data['message_data']['attachment'].blank?

    save_media
    @message
  end

  def save_media_urls(file)
    @message.content_attributes[:media_url] = file['media_url']
    @message.content_attributes[:display_url] = file['display_url']
    @message.save!
  end

  def direct_message_events_params
    payload['direct_message_events']
  end

  def direct_message_data
    direct_message_events_params.first
  end

  def message_create_data
    direct_message_data['message_create']
  end

  def source_app_id
    message_create_data['source_app_id']
  end

  def parent_app_id
    ENV.fetch('TWITTER_APP_ID', '')
  end

  def media
    message_create_data['message_data']['attachment']['media']
  end

  def users
    payload[:users]
  end

  def ensure_contacts
    users.each do |key, user|
      next if key == profile_id

      find_or_create_contact(user)
    end
  end

  def conversation_params
    {
      account_id: @inbox.account_id,
      inbox_id: @inbox.id,
      contact_id: @contact.id,
      contact_inbox_id: @contact_inbox.id,
      additional_attributes: {
        type: 'direct_message'
      }
    }
  end

  def set_conversation
    @conversation = @contact_inbox.conversations.where("additional_attributes ->> 'type' = 'direct_message'").first
    return if @conversation

    @conversation = ::Conversation.create!(conversation_params)
  end

  def outgoing_message?
    message_create_data['sender_id'] == @inbox.channel.profile_id
  end

  def api_client
    @api_client ||= begin
      consumer = OAuth::Consumer.new(ENV.fetch('TWITTER_CONSUMER_KEY', nil), ENV.fetch('TWITTER_CONSUMER_SECRET', nil),
                                     { site: 'https://api.twitter.com' })
      token = { oauth_token: @inbox.channel.twitter_access_token, oauth_token_secret: @inbox.channel.twitter_access_token_secret }
      OAuth::AccessToken.from_hash(consumer, token)
    end
  end

  def save_media
    save_media_urls(media)
    response = api_client.get(media['media_url'], [])

    temp_file = Tempfile.new('twitter_attachment')
    temp_file.binmode
    temp_file << response.body
    temp_file.rewind

    return unless media['type'] == 'photo'

    @message.attachments.new(
      account_id: @inbox.account_id,
      file_type: 'image',
      file: {
        io: temp_file,
        filename: 'twitter_attachment',
        content_type: media['type']
      }
    )
    @message.save!
  end
end

================
File: services/twitter/send_on_twitter_service.rb
================
class Twitter::SendOnTwitterService < Base::SendOnChannelService
  pattr_initialize [:message!]

  private

  delegate :additional_attributes, to: :contact

  def channel_class
    Channel::TwitterProfile
  end

  def perform_reply
    conversation_type == 'tweet' ? send_tweet_reply : send_direct_message
  end

  def twitter_client
    Twitty::Facade.new do |config|
      config.consumer_key = ENV.fetch('TWITTER_CONSUMER_KEY', nil)
      config.consumer_secret = ENV.fetch('TWITTER_CONSUMER_SECRET', nil)
      config.access_token = channel.twitter_access_token
      config.access_token_secret = channel.twitter_access_token_secret
      config.base_url = 'https://api.twitter.com'
      config.environment = ENV.fetch('TWITTER_ENVIRONMENT', '')
    end
  end

  def conversation_type
    conversation.additional_attributes['type']
  end

  def screen_name
    return "@#{reply_to_message.inbox.name}" if reply_to_message.outgoing?

    "@#{reply_to_message.sender&.additional_attributes.try(:[], 'screen_name') || ''}"
  end

  def send_direct_message
    twitter_client.send_direct_message(
      recipient_id: contact_inbox.source_id,
      message: message.content
    )
  end

  def reply_to_message
    @reply_to_message ||= if message.in_reply_to
                            conversation.messages.find(message.in_reply_to)
                          else
                            conversation.messages.incoming.last
                          end
  end

  def send_tweet_reply
    response = twitter_client.send_tweet_reply(
      reply_to_tweet_id: reply_to_message.source_id,
      tweet: "#{screen_name} #{message.content}"
    )
    if response.status == '200'
      tweet_data = response.body
      message.update!(source_id: tweet_data['id_str'])
    else
      Rails.logger.error "TWITTER_TWEET_REPLY_ERROR #{response.body}"
    end
  end
end

================
File: services/twitter/tweet_parser_service.rb
================
class Twitter::TweetParserService < Twitter::WebhooksBaseService
  pattr_initialize [:payload]

  def perform
    set_inbox

    return if !tweets_enabled? || message_already_exist? || user_has_blocked?

    create_message
  end

  private

  def message_type
    user['id'] == profile_id ? :outgoing : :incoming
  end

  def tweet_text
    tweet_data['truncated'] ? tweet_data['extended_tweet']['full_text'] : tweet_data['text']
  end

  def tweet_create_events_params
    payload['tweet_create_events']
  end

  def tweet_data
    tweet_create_events_params.first
  end

  def user
    tweet_data['user']
  end

  def tweet_id
    tweet_data['id'].to_s
  end

  def user_has_blocked?
    payload['user_has_blocked'] == true
  end

  def tweets_enabled?
    @inbox.channel.tweets_enabled?
  end

  def parent_tweet_id
    tweet_data['in_reply_to_status_id_str'].nil? ? tweet_data['id'].to_s : tweet_data['in_reply_to_status_id_str']
  end

  def conversation_params
    {
      account_id: @inbox.account_id,
      inbox_id: @inbox.id,
      contact_id: @contact.id,
      contact_inbox_id: @contact_inbox.id,
      additional_attributes: {
        type: 'tweet',
        tweet_id: parent_tweet_id,
        tweet_source: tweet_data['source']
      }
    }
  end

  def set_conversation
    tweet_conversations = @contact_inbox.conversations.where("additional_attributes ->> 'tweet_id' = ?", parent_tweet_id)
    @conversation = tweet_conversations.first
    return if @conversation

    tweet_message = @inbox.messages.find_by(source_id: parent_tweet_id)
    @conversation = tweet_message.conversation if tweet_message
    return if @conversation

    @conversation = ::Conversation.create!(conversation_params)
  end

  def message_already_exist?
    @inbox.messages.find_by(source_id: tweet_id)
  end

  def create_message
    find_or_create_contact(user)
    set_conversation
    @conversation.messages.create!(
      account_id: @inbox.account_id,
      sender: @contact,
      content: tweet_text,
      inbox_id: @inbox.id,
      message_type: message_type,
      source_id: tweet_id
    )
  end
end

================
File: services/twitter/webhook_subscribe_service.rb
================
class Twitter::WebhookSubscribeService
  include Rails.application.routes.url_helpers

  pattr_initialize [:inbox_id]

  def perform
    ensure_webhook
    unless subscription?
      subscribe_response = twitter_client.create_subscription
      raise StandardError, 'Twitter Subscription Failed' unless subscribe_response.status == '204'
    end

    true
  end

  private

  delegate :channel, to: :inbox
  delegate :twitter_client, to: :channel

  def inbox
    Inbox.find(inbox_id)
  end

  def twitter_url
    webhooks_twitter_url(protocol: 'https')
  end

  def ensure_webhook
    webhooks = fetch_webhooks
    return true if webhooks&.first&.try(:[], 'url') == twitter_url

    # twitter supports only one webhook url per environment
    # so we will delete the existing one if its not chatwoot
    unregister_webhook(webhooks.first) if webhooks&.first
    register_webhook
  end

  def unregister_webhook(webhook)
    unregister_response = twitter_client.unregister_webhook(id: webhook.try(:[], 'id'))
    Rails.logger.info "TWITTER_UNREGISTER_WEBHOOK: #{unregister_response.body}"
  end

  def register_webhook
    register_response = twitter_client.register_webhook(url: twitter_url)
    Rails.logger.info "TWITTER_REGISTER_WEBHOOK: #{register_response.body}"
  end

  def subscription?
    response = twitter_client.fetch_subscriptions
    response.status == '204'
  end

  def fetch_webhooks
    twitter_client.fetch_webhooks.body
  end
end

================
File: services/twitter/webhooks_base_service.rb
================
class Twitter::WebhooksBaseService
  private

  def profile_id
    payload[:for_user_id]
  end

  def additional_contact_attributes(user)
    {
      screen_name: user['screen_name'],
      location: user['location'],
      url: user['url'],
      description: user['description'],
      followers_count: user['followers_count'],
      friends_count: user['friends_count']
    }
  end

  def set_inbox
    twitter_profile = ::Channel::TwitterProfile.find_by(profile_id: profile_id)
    @inbox = ::Inbox.find_by!(channel: twitter_profile)
  end

  def find_or_create_contact(user)
    @contact_inbox = @inbox.contact_inboxes.where(source_id: user['id']).first
    @contact = @contact_inbox.contact if @contact_inbox
    return if @contact

    @contact_inbox = @inbox.channel.create_contact_inbox(
      user['id'], user['name'], additional_contact_attributes(user)
    )
    @contact = @contact_inbox.contact
    Avatar::AvatarFromUrlJob.perform_later(@contact, user['profile_image_url']) if user['profile_image_url']
  end
end

================
File: services/whatsapp/providers/base_service.rb
================
#######################################
# To create a whatsapp provider
# - Inherit this as the base class.
# - Implement `send_message` method in your child class.
# - Implement `send_template_message` method in your child class.
# - Implement `sync_templates` method in your child class.
# - Implement `validate_provider_config` method in your child class.
# - Use Childclass.new(whatsapp_channel: channel).perform.
######################################

class Whatsapp::Providers::BaseService
  pattr_initialize [:whatsapp_channel!]

  def send_message(_phone_number, _message)
    raise 'Overwrite this method in child class'
  end

  def send_template(_phone_number, _template_info)
    raise 'Overwrite this method in child class'
  end

  def sync_template
    raise 'Overwrite this method in child class'
  end

  def validate_provider_config
    raise 'Overwrite this method in child class'
  end

  def error_message
    raise 'Overwrite this method in child class'
  end

  def process_response(response)
    parsed_response = response.parsed_response
    if response.success? && parsed_response['error'].blank?
      parsed_response['messages'].first['id']
    else
      handle_error(response)
      nil
    end
  end

  def handle_error(response)
    Rails.logger.error response.body
    return if @message.blank?

    # https://developers.facebook.com/docs/whatsapp/cloud-api/support/error-codes/#sample-response
    error_message = error_message(response)
    return if error_message.blank?

    @message.external_error = error_message
    @message.status = :failed
    @message.save!
  end

  def create_buttons(items)
    buttons = []
    items.each do |item|
      button = { :type => 'reply', 'reply' => { 'id' => item['value'], 'title' => item['title'] } }
      buttons << button
    end
    buttons
  end

  def create_rows(items)
    rows = []
    items.each do |item|
      row = { 'id' => item['value'], 'title' => item['title'] }
      rows << row
    end
    rows
  end

  def create_payload(type, message_content, action)
    {
      'type': type,
      'body': {
        'text': message_content
      },
      'action': action
    }
  end

  def create_payload_based_on_items(message)
    if message.content_attributes['items'].length <= 3
      create_button_payload(message)
    else
      create_list_payload(message)
    end
  end

  def create_button_payload(message)
    buttons = create_buttons(message.content_attributes['items'])
    json_hash = { 'buttons' => buttons }
    create_payload('button', message.content, JSON.generate(json_hash))
  end

  def create_list_payload(message)
    rows = create_rows(message.content_attributes['items'])
    section1 = { 'rows' => rows }
    sections = [section1]
    json_hash = { :button => 'Choose an item', 'sections' => sections }
    create_payload('list', message.content, JSON.generate(json_hash))
  end
end

================
File: services/whatsapp/providers/whatsapp_360_dialog_service.rb
================
class Whatsapp::Providers::Whatsapp360DialogService < Whatsapp::Providers::BaseService
  def send_message(phone_number, message)
    @message = message
    if message.attachments.present?
      send_attachment_message(phone_number, message)
    elsif message.content_type == 'input_select'
      send_interactive_text_message(phone_number, message)
    else
      send_text_message(phone_number, message)
    end
  end

  def send_template(phone_number, template_info)
    response = HTTParty.post(
      "#{api_base_path}/messages",
      headers: api_headers,
      body: {
        to: phone_number,
        template: template_body_parameters(template_info),
        type: 'template'
      }.to_json
    )

    process_response(response)
  end

  def sync_templates
    # ensuring that channels with wrong provider config wouldn't keep trying to sync templates
    whatsapp_channel.mark_message_templates_updated
    response = HTTParty.get("#{api_base_path}/configs/templates", headers: api_headers)
    whatsapp_channel.update(message_templates: response['waba_templates'], message_templates_last_updated: Time.now.utc) if response.success?
  end

  def validate_provider_config?
    response = HTTParty.post(
      "#{api_base_path}/configs/webhook",
      headers: { 'D360-API-KEY': whatsapp_channel.provider_config['api_key'], 'Content-Type': 'application/json' },
      body: {
        url: "#{ENV.fetch('FRONTEND_URL', nil)}/webhooks/whatsapp/#{whatsapp_channel.phone_number}"
      }.to_json
    )
    response.success?
  end

  def api_headers
    { 'D360-API-KEY' => whatsapp_channel.provider_config['api_key'], 'Content-Type' => 'application/json' }
  end

  def media_url(media_id)
    "#{api_base_path}/media/#{media_id}"
  end

  private

  def api_base_path
    # provide the environment variable when testing against sandbox : 'https://waba-sandbox.360dialog.io/v1'
    ENV.fetch('360DIALOG_BASE_URL', 'https://waba.360dialog.io/v1')
  end

  def send_text_message(phone_number, message)
    response = HTTParty.post(
      "#{api_base_path}/messages",
      headers: api_headers,
      body: {
        to: phone_number,
        text: { body: message.content },
        type: 'text'
      }.to_json
    )

    process_response(response)
  end

  def send_attachment_message(phone_number, message)
    attachment = message.attachments.first
    type = %w[image audio video].include?(attachment.file_type) ? attachment.file_type : 'document'
    type_content = {
      'link': attachment.download_url
    }
    type_content['caption'] = message.content unless %w[audio sticker].include?(type)
    type_content['filename'] = attachment.file.filename if type == 'document'

    response = HTTParty.post(
      "#{api_base_path}/messages",
      headers: api_headers,
      body: {
        'to' => phone_number,
        'type' => type,
        type.to_s => type_content
      }.to_json
    )

    process_response(response)
  end

  def error_message(response)
    # {"meta": {"success": false, "http_code": 400, "developer_message": "errro-message", "360dialog_trace_id": "someid"}}
    response.parsed_response.dig('meta', 'developer_message')
  end

  def template_body_parameters(template_info)
    {
      name: template_info[:name],
      namespace: template_info[:namespace],
      language: {
        policy: 'deterministic',
        code: template_info[:lang_code]
      },
      components: [{
        type: 'body',
        parameters: template_info[:parameters]
      }]
    }
  end

  def send_interactive_text_message(phone_number, message)
    payload = create_payload_based_on_items(message)

    response = HTTParty.post(
      "#{api_base_path}/messages",
      headers: api_headers,
      body: {
        to: phone_number,
        interactive: payload,
        type: 'interactive'
      }.to_json
    )

    process_response(response)
  end
end

================
File: services/whatsapp/providers/whatsapp_cloud_service.rb
================
class Whatsapp::Providers::WhatsappCloudService < Whatsapp::Providers::BaseService
  def send_message(phone_number, message)
    @message = message

    if message.attachments.present?
      send_attachment_message(phone_number, message)
    elsif message.content_type == 'input_select'
      send_interactive_text_message(phone_number, message)
    else
      send_text_message(phone_number, message)
    end
  end

  def send_template(phone_number, template_info)
    response = HTTParty.post(
      "#{phone_id_path}/messages",
      headers: api_headers,
      body: {
        messaging_product: 'whatsapp',
        to: phone_number,
        template: template_body_parameters(template_info),
        type: 'template'
      }.to_json
    )

    process_response(response)
  end

  def sync_templates
    # ensuring that channels with wrong provider config wouldn't keep trying to sync templates
    whatsapp_channel.mark_message_templates_updated
    templates = fetch_whatsapp_templates("#{business_account_path}/message_templates?access_token=#{whatsapp_channel.provider_config['api_key']}")
    whatsapp_channel.update(message_templates: templates, message_templates_last_updated: Time.now.utc) if templates.present?
  end

  def fetch_whatsapp_templates(url)
    response = HTTParty.get(url)
    return [] unless response.success?

    next_url = next_url(response)

    return response['data'] + fetch_whatsapp_templates(next_url) if next_url.present?

    response['data']
  end

  def next_url(response)
    response['paging'] ? response['paging']['next'] : ''
  end

  def validate_provider_config?
    response = HTTParty.get("#{business_account_path}/message_templates?access_token=#{whatsapp_channel.provider_config['api_key']}")
    response.success?
  end

  def api_headers
    { 'Authorization' => "Bearer #{whatsapp_channel.provider_config['api_key']}", 'Content-Type' => 'application/json' }
  end

  def media_url(media_id)
    "#{api_base_path}/v13.0/#{media_id}"
  end

  def api_base_path
    ENV.fetch('WHATSAPP_CLOUD_BASE_URL', 'https://graph.facebook.com')
  end

  # TODO: See if we can unify the API versions and for both paths and make it consistent with out facebook app API versions
  def phone_id_path
    "#{api_base_path}/v13.0/#{whatsapp_channel.provider_config['phone_number_id']}"
  end

  def business_account_path
    "#{api_base_path}/v14.0/#{whatsapp_channel.provider_config['business_account_id']}"
  end

  def send_text_message(phone_number, message)
    response = HTTParty.post(
      "#{phone_id_path}/messages",
      headers: api_headers,
      body: {
        messaging_product: 'whatsapp',
        context: whatsapp_reply_context(message),
        to: phone_number,
        text: { body: message.content },
        type: 'text'
      }.to_json
    )

    process_response(response)
  end

  def send_attachment_message(phone_number, message)
    attachment = message.attachments.first
    type = %w[image audio video].include?(attachment.file_type) ? attachment.file_type : 'document'
    type_content = {
      'link': attachment.download_url
    }
    type_content['caption'] = message.content unless %w[audio sticker].include?(type)
    type_content['filename'] = attachment.file.filename if type == 'document'
    response = HTTParty.post(
      "#{phone_id_path}/messages",
      headers: api_headers,
      body: {
        :messaging_product => 'whatsapp',
        :context => whatsapp_reply_context(message),
        'to' => phone_number,
        'type' => type,
        type.to_s => type_content
      }.to_json
    )

    process_response(response)
  end

  def error_message(response)
    # https://developers.facebook.com/docs/whatsapp/cloud-api/support/error-codes/#sample-response
    response.parsed_response&.dig('error', 'message')
  end

  def template_body_parameters(template_info)
    {
      name: template_info[:name],
      language: {
        policy: 'deterministic',
        code: template_info[:lang_code]
      },
      components: [{
        type: 'body',
        parameters: template_info[:parameters]
      }]
    }
  end

  def whatsapp_reply_context(message)
    reply_to = message.content_attributes[:in_reply_to_external_id]
    return nil if reply_to.blank?

    {
      message_id: reply_to
    }
  end

  def send_interactive_text_message(phone_number, message)
    payload = create_payload_based_on_items(message)

    response = HTTParty.post(
      "#{phone_id_path}/messages",
      headers: api_headers,
      body: {
        messaging_product: 'whatsapp',
        to: phone_number,
        interactive: payload,
        type: 'interactive'
      }.to_json
    )

    process_response(response)
  end
end

================
File: services/whatsapp/incoming_message_base_service.rb
================
# Mostly modeled after the intial implementation of the service based on 360 Dialog
# https://docs.360dialog.com/whatsapp-api/whatsapp-api/media
# https://developers.facebook.com/docs/whatsapp/api/media/
class Whatsapp::IncomingMessageBaseService
  include ::Whatsapp::IncomingMessageServiceHelpers

  pattr_initialize [:inbox!, :params!]

  def perform
    processed_params

    if processed_params.try(:[], :statuses).present?
      process_statuses
    elsif processed_params.try(:[], :messages).present?
      process_messages
    end
  end

  private

  def process_messages
    # We don't support reactions & ephemeral message now, we need to skip processing the message
    # if the webhook event is a reaction or an ephermal message or an unsupported message.
    return if unprocessable_message_type?(message_type)

    # Multiple webhook event can be received against the same message due to misconfigurations in the Meta
    # business manager account. While we have not found the core reason yet, the following line ensure that
    # there are no duplicate messages created.
    return if find_message_by_source_id(@processed_params[:messages].first[:id]) || message_under_process?

    cache_message_source_id_in_redis
    set_contact
    return unless @contact

    set_conversation
    create_messages
    clear_message_source_id_from_redis
  end

  def process_statuses
    return unless find_message_by_source_id(@processed_params[:statuses].first[:id])

    update_message_with_status(@message, @processed_params[:statuses].first)
  rescue ArgumentError => e
    Rails.logger.error "Error while processing whatsapp status update #{e.message}"
  end

  def update_message_with_status(message, status)
    message.status = status[:status]
    if status[:status] == 'failed' && status[:errors].present?
      error = status[:errors]&.first
      message.external_error = "#{error[:code]}: #{error[:title]}"
    end
    message.save!
  end

  def create_messages
    message = @processed_params[:messages].first
    log_error(message) && return if error_webhook_event?(message)

    process_in_reply_to(message)

    message_type == 'contacts' ? create_contact_messages(message) : create_regular_message(message)
  end

  def create_contact_messages(message)
    message['contacts'].each do |contact|
      create_message(contact)
      attach_contact(contact)
      @message.save!
    end
  end

  def create_regular_message(message)
    create_message(message)
    attach_files
    attach_location if message_type == 'location'
    @message.save!
  end

  def set_contact
    contact_params = @processed_params[:contacts]&.first
    return if contact_params.blank?

    waid = processed_waid(contact_params[:wa_id])

    contact_inbox = ::ContactInboxWithContactBuilder.new(
      source_id: waid,
      inbox: inbox,
      contact_attributes: { name: contact_params.dig(:profile, :name), phone_number: "+#{@processed_params[:messages].first[:from]}" }
    ).perform

    @contact_inbox = contact_inbox
    @contact = contact_inbox.contact
  end

  def set_conversation
    # if lock to single conversation is disabled, we will create a new conversation if previous conversation is resolved
    @conversation = if @inbox.lock_to_single_conversation
                      @contact_inbox.conversations.last
                    else
                      @contact_inbox.conversations
                                    .where.not(status: :resolved).last
                    end
    return if @conversation

    @conversation = ::Conversation.create!(conversation_params)
  end

  def attach_files
    return if %w[text button interactive location contacts].include?(message_type)

    attachment_payload = @processed_params[:messages].first[message_type.to_sym]
    @message.content ||= attachment_payload[:caption]

    attachment_file = download_attachment_file(attachment_payload)
    return if attachment_file.blank?

    @message.attachments.new(
      account_id: @message.account_id,
      file_type: file_content_type(message_type),
      file: {
        io: attachment_file,
        filename: attachment_file.original_filename,
        content_type: attachment_file.content_type
      }
    )
  end

  def attach_location
    location = @processed_params[:messages].first['location']
    location_name = location['name'] ? "#{location['name']}, #{location['address']}" : ''
    @message.attachments.new(
      account_id: @message.account_id,
      file_type: file_content_type(message_type),
      coordinates_lat: location['latitude'],
      coordinates_long: location['longitude'],
      fallback_title: location_name,
      external_url: location['url']
    )
  end

  def create_message(message)
    @message = @conversation.messages.build(
      content: message_content(message),
      account_id: @inbox.account_id,
      inbox_id: @inbox.id,
      message_type: :incoming,
      sender: @contact,
      source_id: message[:id].to_s,
      in_reply_to_external_id: @in_reply_to_external_id
    )
  end

  def attach_contact(contact)
    phones = contact[:phones]
    phones = [{ phone: 'Phone number is not available' }] if phones.blank?

    phones.each do |phone|
      @message.attachments.new(
        account_id: @message.account_id,
        file_type: file_content_type(message_type),
        fallback_title: phone[:phone].to_s
      )
    end
  end
end

================
File: services/whatsapp/incoming_message_service_helpers.rb
================
module Whatsapp::IncomingMessageServiceHelpers
  def download_attachment_file(attachment_payload)
    Down.download(inbox.channel.media_url(attachment_payload[:id]), headers: inbox.channel.api_headers)
  end

  def conversation_params
    {
      account_id: @inbox.account_id,
      inbox_id: @inbox.id,
      contact_id: @contact.id,
      contact_inbox_id: @contact_inbox.id
    }
  end

  def processed_params
    @processed_params ||= params
  end

  def account
    @account ||= inbox.account
  end

  def message_type
    @processed_params[:messages].first[:type]
  end

  def message_content(message)
    # TODO: map interactive messages back to button messages in chatwoot
    message.dig(:text, :body) ||
      message.dig(:button, :text) ||
      message.dig(:interactive, :button_reply, :title) ||
      message.dig(:interactive, :list_reply, :title) ||
      message.dig(:name, :formatted_name)
  end

  def file_content_type(file_type)
    return :image if %w[image sticker].include?(file_type)
    return :audio if %w[audio voice].include?(file_type)
    return :video if ['video'].include?(file_type)
    return :location if ['location'].include?(file_type)
    return :contact if ['contacts'].include?(file_type)

    :file
  end

  def unprocessable_message_type?(message_type)
    %w[reaction ephemeral unsupported request_welcome].include?(message_type)
  end

  def brazil_phone_number?(phone_number)
    phone_number.match(/^55/)
  end

  # ref: https://github.com/chatwoot/chatwoot/issues/5840
  def normalised_brazil_mobile_number(phone_number)
    # DDD : Area codes in Brazil are popularly known as "DDD codes" (cdigos DDD) or simply "DDD", from the initials of "direct distance dialing"
    # https://en.wikipedia.org/wiki/Telephone_numbers_in_Brazil
    ddd = phone_number[2, 2]
    # Remove country code and DDD to obtain the number
    number = phone_number[4, phone_number.length - 4]
    normalised_number = "55#{ddd}#{number}"
    # insert 9 to convert the number to the new mobile number format
    normalised_number = "55#{ddd}9#{number}" if normalised_number.length != 13
    normalised_number
  end

  def processed_waid(waid)
    # in case of Brazil, we need to do additional processing
    # https://github.com/chatwoot/chatwoot/issues/5840
    if brazil_phone_number?(waid)
      # check if there is an existing contact inbox with the normalised waid
      # We will create conversation against it
      contact_inbox = inbox.contact_inboxes.find_by(source_id: normalised_brazil_mobile_number(waid))

      # if there is no contact inbox with the waid without 9,
      # We will create contact inboxes and contacts with the number 9 added
      waid = contact_inbox.source_id if contact_inbox.present?
    end
    waid
  end

  def error_webhook_event?(message)
    message.key?('errors')
  end

  def log_error(message)
    Rails.logger.warn "Whatsapp Error: #{message['errors'][0]['title']} - contact: #{message['from']}"
  end

  def process_in_reply_to(message)
    @in_reply_to_external_id = message['context']&.[]('id')
  end

  def find_message_by_source_id(source_id)
    return unless source_id

    @message = Message.find_by(source_id: source_id)
  end

  def message_under_process?
    key = format(Redis::RedisKeys::MESSAGE_SOURCE_KEY, id: @processed_params[:messages].first[:id])
    Redis::Alfred.get(key)
  end

  def cache_message_source_id_in_redis
    return if @processed_params.try(:[], :messages).blank?

    key = format(Redis::RedisKeys::MESSAGE_SOURCE_KEY, id: @processed_params[:messages].first[:id])
    ::Redis::Alfred.setex(key, true)
  end

  def clear_message_source_id_from_redis
    key = format(Redis::RedisKeys::MESSAGE_SOURCE_KEY, id: @processed_params[:messages].first[:id])
    ::Redis::Alfred.delete(key)
  end
end

================
File: services/whatsapp/incoming_message_service.rb
================
# https://docs.360dialog.com/whatsapp-api/whatsapp-api/media
# https://developers.facebook.com/docs/whatsapp/api/media/

class Whatsapp::IncomingMessageService < Whatsapp::IncomingMessageBaseService
end

================
File: services/whatsapp/incoming_message_whatsapp_cloud_service.rb
================
# https://docs.360dialog.com/whatsapp-api/whatsapp-api/media
# https://developers.facebook.com/docs/whatsapp/api/media/

class Whatsapp::IncomingMessageWhatsappCloudService < Whatsapp::IncomingMessageBaseService
  private

  def processed_params
    @processed_params ||= params[:entry].try(:first).try(:[], 'changes').try(:first).try(:[], 'value')
  end

  def download_attachment_file(attachment_payload)
    url_response = HTTParty.get(inbox.channel.media_url(attachment_payload[:id]), headers: inbox.channel.api_headers)
    # This url response will be failure if the access token has expired.
    inbox.channel.authorization_error! if url_response.unauthorized?
    Down.download(url_response.parsed_response['url'], headers: inbox.channel.api_headers) if url_response.success?
  end
end

================
File: services/whatsapp/send_on_whatsapp_service.rb
================
class Whatsapp::SendOnWhatsappService < Base::SendOnChannelService
  private

  def channel_class
    Channel::Whatsapp
  end

  def perform_reply
    should_send_template_message = template_params.present? || !message.conversation.can_reply?
    if should_send_template_message
      send_template_message
    else
      send_session_message
    end
  end

  def send_template_message
    name, namespace, lang_code, processed_parameters = processable_channel_message_template

    return if name.blank?

    message_id = channel.send_template(message.conversation.contact_inbox.source_id, {
                                         name: name,
                                         namespace: namespace,
                                         lang_code: lang_code,
                                         parameters: processed_parameters
                                       })
    message.update!(source_id: message_id) if message_id.present?
  end

  # rubocop:disable Metrics/CyclomaticComplexity
  def processable_channel_message_template
    if template_params.present?
      return [
        template_params['name'],
        template_params['namespace'],
        template_params['language'],
        template_params['processed_params']&.map { |_, value| { type: 'text', text: value } }
      ]
    end

    # Delete the following logic once the update for template_params is stable
    # see if we can match the message content to a template
    # An example template may look like "Your package has been shipped. It will be delivered in {{1}} business days.
    # We want to iterate over these templates with our message body and see if we can fit it to any of the templates
    # Then we use regex to parse the template varibles and convert them into the proper payload
    channel.message_templates&.each do |template|
      match_obj = template_match_object(template)
      next if match_obj.blank?

      # we have a match, now we need to parse the template variables and convert them into the wa recommended format
      processed_parameters = match_obj.captures.map { |x| { type: 'text', text: x } }

      # no need to look up further end the search
      return [template['name'], template['namespace'], template['language'], processed_parameters]
    end
    [nil, nil, nil, nil]
  end
  # rubocop:enable Metrics/CyclomaticComplexity

  def template_match_object(template)
    body_object = validated_body_object(template)
    return if body_object.blank?

    template_match_regex = build_template_match_regex(body_object['text'])
    message.content.match(template_match_regex)
  end

  def build_template_match_regex(template_text)
    # Converts the whatsapp template to a comparable regex string to check against the message content
    # the variables are of the format {{num}} ex:{{1}}

    # transform the template text into a regex string
    # we need to replace the {{num}} with matchers that can be used to capture the variables
    template_text = template_text.gsub(/{{\d}}/, '(.*)')
    # escape if there are regex characters in the template text
    template_text = Regexp.escape(template_text)
    # ensuring only the variables remain as capture groups
    template_text = template_text.gsub(Regexp.escape('(.*)'), '(.*)')

    template_match_string = "^#{template_text}$"
    Regexp.new template_match_string
  end

  def validated_body_object(template)
    # we don't care if its not approved template
    return if template['status'] != 'approved'

    # we only care about text body object in template. if not present we discard the template
    # we don't support other forms of templates
    template['components'].find { |obj| obj['type'] == 'BODY' && obj.key?('text') }
  end

  def send_session_message
    message_id = channel.send_message(message.conversation.contact_inbox.source_id, message)
    message.update!(source_id: message_id) if message_id.present?
  end

  def template_params
    message.additional_attributes && message.additional_attributes['template_params']
  end
end

================
File: services/widget/token_service.rb
================
class Widget::TokenService
  pattr_initialize [:payload, :token]

  def generate_token
    JWT.encode payload, secret_key, 'HS256'
  end

  def decode_token
    JWT.decode(
      token, secret_key, true, algorithm: 'HS256'
    ).first.symbolize_keys
  rescue StandardError
    {}
  end

  private

  def secret_key
    Rails.application.secret_key_base
  end
end

================
File: services/action_service.rb
================
class ActionService
  include EmailHelper

  def initialize(conversation)
    @conversation = conversation.reload
    @account = @conversation.account
  end

  def mute_conversation(_params)
    @conversation.mute!
  end

  def snooze_conversation(_params)
    @conversation.snoozed!
  end

  def resolve_conversation(_params)
    @conversation.resolved!
  end

  def change_status(status)
    @conversation.update!(status: status[0])
  end

  def change_priority(priority)
    @conversation.update!(priority: (priority[0] == 'nil' ? nil : priority[0]))
  end

  def add_label(labels)
    return if labels.empty?

    @conversation.reload.add_labels(labels)
  end

  def assign_agent(agent_ids = [])
    return @conversation.update!(assignee_id: nil) if agent_ids[0] == 'nil'

    return unless agent_belongs_to_inbox?(agent_ids)

    @agent = @account.users.find_by(id: agent_ids)

    @conversation.update!(assignee_id: @agent.id) if @agent.present?
  end

  def remove_label(labels)
    return if labels.empty?

    labels = @conversation.label_list - labels
    @conversation.update(label_list: labels)
  end

  def assign_team(team_ids = [])
    # FIXME: The explicit checks for zero or nil (string) is bad. Move
    # this to a separate unassign action.
    should_unassign = team_ids.blank? || %w[nil 0].include?(team_ids[0].to_s)
    return @conversation.update!(team_id: nil) if should_unassign

    # check if team belongs to account only if team_id is present
    # if team_id is nil, then it means that the team is being unassigned
    return unless !team_ids[0].nil? && team_belongs_to_account?(team_ids)

    @conversation.update!(team_id: team_ids[0])
  end

  def remove_assigned_team(_params)
    @conversation.update!(team_id: nil)
  end

  def send_email_transcript(emails)
    emails = emails[0].gsub(/\s+/, '').split(',')

    emails.each do |email|
      email = parse_email_variables(@conversation, email)
      ConversationReplyMailer.with(account: @conversation.account).conversation_transcript(@conversation, email)&.deliver_later
    end
  end

  private

  def agent_belongs_to_inbox?(agent_ids)
    member_ids = @conversation.inbox.members.pluck(:user_id)
    assignable_agent_ids = member_ids + @account.administrators.ids

    assignable_agent_ids.include?(agent_ids[0])
  end

  def team_belongs_to_account?(team_ids)
    @account.team_ids.include?(team_ids[0])
  end

  def conversation_a_tweet?
    return false if @conversation.additional_attributes.blank?

    @conversation.additional_attributes['type'] == 'tweet'
  end
end

ActionService.include_mod_with('ActionService')

================
File: services/base_refresh_oauth_token_service.rb
================
class BaseRefreshOauthTokenService
  pattr_initialize [:channel!]

  # Additional references: https://gitlab.com/gitlab-org/ruby/gems/gitlab-mail_room/-/blob/master/lib/mail_room/microsoft_graph/connection.rb
  def access_token
    return provider_config[:access_token] unless access_token_expired?

    refreshed_tokens = refresh_tokens
    refreshed_tokens[:access_token]
  end

  def access_token_expired?
    expiry = provider_config[:expires_on]

    return true if expiry.blank?

    # Adding a 5 minute window to expiry check to avoid any race
    # conditions during the fetch operation. This would assure that the
    # tokens are updated when we fetch the emails.
    Time.current.utc >= DateTime.parse(expiry) - 5.minutes
  end

  # Refresh the access tokens using the refresh token
  # Refer: https://github.com/microsoftgraph/msgraph-sample-rubyrailsapp/tree/b4a6869fe4a438cde42b161196484a929f1bee46
  def refresh_tokens
    oauth_strategy = build_oauth_strategy
    token_service = build_token_service(oauth_strategy)

    new_tokens = token_service.refresh!.to_hash.slice(:access_token, :refresh_token, :expires_at)

    update_channel_provider_config(new_tokens)
    channel.reload.provider_config
  end

  def update_channel_provider_config(new_tokens)
    channel.provider_config = {
      access_token: new_tokens[:access_token],
      refresh_token: new_tokens[:refresh_token],
      expires_on: Time.at(new_tokens[:expires_at]).utc.to_s
    }
    channel.save!
  end

  private

  def build_oauth_strategy
    raise NotImplementedError
  end

  def provider_config
    @provider_config ||= channel.provider_config.with_indifferent_access
  end

  # Builds the token service using OAuth2
  def build_token_service(oauth_strategy)
    OAuth2::AccessToken.new(
      oauth_strategy.client,
      provider_config[:access_token],
      refresh_token: provider_config[:refresh_token]
    )
  end
end

================
File: services/filter_service.rb
================
require 'json'

class FilterService
  include Filters::FilterHelper
  include CustomExceptions::CustomFilter

  ATTRIBUTE_MODEL = 'conversation_attribute'.freeze
  ATTRIBUTE_TYPES = {
    date: 'date', text: 'text', number: 'numeric', link: 'text', list: 'text', checkbox: 'boolean'
  }.with_indifferent_access

  def initialize(params, user)
    @params = params
    @user = user
    file = File.read('./lib/filters/filter_keys.yml')
    @filters = YAML.safe_load(file)
    @query_string = ''
    @filter_values = {}
  end

  def perform; end

  def filter_operation(query_hash, current_index)
    case query_hash[:filter_operator]
    when 'equal_to', 'not_equal_to'
      @filter_values["value_#{current_index}"] = filter_values(query_hash)
      equals_to_filter_string(query_hash[:filter_operator], current_index)
    when 'contains', 'does_not_contain'
      @filter_values["value_#{current_index}"] = values_for_ilike(query_hash)
      ilike_filter_string(query_hash[:filter_operator], current_index)
    when 'is_present'
      @filter_values["value_#{current_index}"] = 'IS NOT NULL'
    when 'is_not_present'
      @filter_values["value_#{current_index}"] = 'IS NULL'
    when 'is_greater_than', 'is_less_than'
      @filter_values["value_#{current_index}"] = lt_gt_filter_values(query_hash)
    when 'days_before'
      @filter_values["value_#{current_index}"] = days_before_filter_values(query_hash)
    else
      @filter_values["value_#{current_index}"] = filter_values(query_hash).to_s
      "= :value_#{current_index}"
    end
  end

  def filter_values(query_hash)
    attribute_key = query_hash['attribute_key']
    values = query_hash['values']

    return conversation_status_values(values) if attribute_key == 'status'
    return conversation_priority_values(values) if attribute_key == 'priority'
    return message_type_values(values) if attribute_key == 'message_type'
    return downcase_array_values(values) if attribute_key == 'content'

    case_insensitive_values(query_hash)
  end

  def downcase_array_values(values)
    values.map(&:downcase)
  end

  def case_insensitive_values(query_hash)
    if @custom_attribute_type.present? && query_hash['values'][0].is_a?(String)
      string_filter_values(query_hash)
    else
      query_hash['values']
    end
  end

  def values_for_ilike(query_hash)
    if query_hash['values'].is_a?(Array)
      query_hash['values']
        .map { |item| "%#{item.strip}%" }
    else
      ["%#{query_hash['values'].strip}%"]
    end
  end

  def string_filter_values(query_hash)
    return query_hash['values'][0].downcase if query_hash['values'].is_a?(Array)

    query_hash['values'].downcase
  end

  def lt_gt_filter_values(query_hash)
    attribute_key = query_hash[:attribute_key]
    attribute_model = query_hash['custom_attribute_type'].presence || self.class::ATTRIBUTE_MODEL
    attribute_type = custom_attribute(attribute_key, @account, attribute_model).try(:attribute_display_type)
    attribute_data_type = self.class::ATTRIBUTE_TYPES[attribute_type]
    value = query_hash['values'][0]
    operator = query_hash['filter_operator'] == 'is_less_than' ? '<' : '>'
    "#{operator} '#{value}'::#{attribute_data_type}"
  end

  def days_before_filter_values(query_hash)
    date = Time.zone.today - query_hash['values'][0].to_i.days
    query_hash['values'] = [date.strftime]
    query_hash['filter_operator'] = 'is_less_than'
    lt_gt_filter_values(query_hash)
  end

  def set_count_for_all_conversations
    [
      @conversations.assigned_to(@user).count,
      @conversations.unassigned.count,
      @conversations.count
    ]
  end

  def tag_filter_query(query_hash, current_index)
    model_name = filter_config[:entity]
    table_name = filter_config[:table_name]
    query_operator = query_hash[:query_operator]
    @filter_values["value_#{current_index}"] = filter_values(query_hash)

    tag_model_relation_query =
      "SELECT * FROM taggings WHERE taggings.taggable_id = #{table_name}.id AND taggings.taggable_type = '#{model_name}'"
    tag_query =
      "AND taggings.tag_id IN (SELECT tags.id FROM tags WHERE tags.name IN (:value_#{current_index}))"

    case query_hash[:filter_operator]
    when 'equal_to'
      "EXISTS (#{tag_model_relation_query} #{tag_query}) #{query_operator}"
    when 'not_equal_to'
      "NOT EXISTS (#{tag_model_relation_query} #{tag_query}) #{query_operator}"
    when 'is_present'
      "EXISTS (#{tag_model_relation_query}) #{query_operator}"
    when 'is_not_present'
      "NOT EXISTS (#{tag_model_relation_query}) #{query_operator}"
    end
  end

  def custom_attribute_query(query_hash, custom_attribute_type, current_index)
    @attribute_key = query_hash[:attribute_key]
    @custom_attribute_type = custom_attribute_type
    attribute_data_type
    return '' if @custom_attribute.blank?

    build_custom_attr_query(query_hash, current_index)
  end

  private

  def attribute_model
    @attribute_model = @custom_attribute_type.presence || self.class::ATTRIBUTE_MODEL
  end

  def attribute_data_type
    attribute_type = custom_attribute(@attribute_key, @account, attribute_model).try(:attribute_display_type)
    @attribute_data_type = self.class::ATTRIBUTE_TYPES[attribute_type]
  end

  def build_custom_attr_query(query_hash, current_index)
    filter_operator_value = filter_operation(query_hash, current_index)
    query_operator = query_hash[:query_operator]
    table_name = attribute_model == 'conversation_attribute' ? 'conversations' : 'contacts'

    query = if attribute_data_type == 'text'
              "LOWER(#{table_name}.custom_attributes ->> '#{@attribute_key}')::#{attribute_data_type} #{filter_operator_value} #{query_operator} "
            else
              "(#{table_name}.custom_attributes ->> '#{@attribute_key}')::#{attribute_data_type} #{filter_operator_value} #{query_operator} "
            end

    query + not_in_custom_attr_query(table_name, query_hash, attribute_data_type)
  end

  def custom_attribute(attribute_key, account, custom_attribute_type)
    current_account = account || Current.account
    attribute_model = custom_attribute_type.presence || self.class::ATTRIBUTE_MODEL
    @custom_attribute = current_account.custom_attribute_definitions.where(
      attribute_model: attribute_model
    ).find_by(attribute_key: attribute_key)
  end

  def not_in_custom_attr_query(table_name, query_hash, attribute_data_type)
    return '' unless query_hash[:filter_operator] == 'not_equal_to'

    " OR (#{table_name}.custom_attributes ->> '#{@attribute_key}')::#{attribute_data_type} IS NULL "
  end

  def equals_to_filter_string(filter_operator, current_index)
    return  "IN (:value_#{current_index})" if filter_operator == 'equal_to'

    "NOT IN (:value_#{current_index})"
  end

  def ilike_filter_string(filter_operator, current_index)
    return "ILIKE ANY (ARRAY[:value_#{current_index}])" if %w[contains].include?(filter_operator)

    "NOT ILIKE ALL (ARRAY[:value_#{current_index}])"
  end

  def like_filter_string(filter_operator, current_index)
    return "LIKE :value_#{current_index}" if %w[contains starts_with].include?(filter_operator)

    "NOT LIKE :value_#{current_index}"
  end

  def query_builder(model_filters)
    @params[:payload].each_with_index do |query_hash, current_index|
      @query_string += " #{build_condition_query(model_filters, query_hash, current_index).strip}"
    end
    base_relation.where(@query_string, @filter_values.with_indifferent_access)
  end

  def validate_query_operator
    @params[:payload].each do |query_hash|
      validate_single_condition(query_hash)
    end
  end
end

================
File: services/ip_lookup_service.rb
================
class IpLookupService
  def perform(ip_address)
    return if ip_address.blank? || !ip_database_available?

    Geocoder.search(ip_address).first
  rescue Errno::ETIMEDOUT => e
    Rails.logger.warn "Exception: IP resolution failed :#{e.message}"
  end

  private

  def ip_database_available?
    File.exist?(GeocoderConfiguration::LOOK_UP_DB)
  end
end

================
File: services/search_service.rb
================
class SearchService
  pattr_initialize [:current_user!, :current_account!, :params!, :search_type!]

  def perform
    case search_type
    when 'Message'
      { messages: filter_messages }
    when 'Conversation'
      { conversations: filter_conversations }
    when 'Contact'
      { contacts: filter_contacts }
    else
      { contacts: filter_contacts, messages: filter_messages, conversations: filter_conversations }
    end
  end

  private

  def accessable_inbox_ids
    @accessable_inbox_ids ||= @current_user.assigned_inboxes.pluck(:id)
  end

  def search_query
    @search_query ||= params[:q].to_s.strip
  end

  def filter_conversations
    @conversations = current_account.conversations.where(inbox_id: accessable_inbox_ids)
                                    .joins('INNER JOIN contacts ON conversations.contact_id = contacts.id')
                                    .where("cast(conversations.display_id as text) ILIKE :search OR contacts.name ILIKE :search OR contacts.email
                            ILIKE :search OR contacts.phone_number ILIKE :search OR contacts.identifier ILIKE :search", search: "%#{search_query}%")
                                    .order('conversations.created_at DESC')
                                    .page(params[:page])
                                    .per(15)
  end

  def filter_messages
    @messages = current_account.messages.where(inbox_id: accessable_inbox_ids)
                               .where('messages.content ILIKE :search', search: "%#{search_query}%")
                               .where('created_at >= ?', 3.months.ago)
                               .reorder('created_at DESC')
                               .page(params[:page])
                               .per(15)
  end

  def filter_contacts
    @contacts = current_account.contacts.where(
      "name ILIKE :search OR email ILIKE :search OR phone_number
      ILIKE :search OR identifier ILIKE :search", search: "%#{search_query}%"
    ).resolved_contacts.order_on_last_activity_at('desc').page(params[:page]).per(15)
  end
end

================
File: views/android_app/assetlinks.json.erb
================
[
  {
    "relation": ["delegate_permission/common.handle_all_urls"],
    "target": {
      "namespace": "android_app",
      "package_name": "<%= ENV['ANDROID_BUNDLE_ID'] %>",
      "sha256_cert_fingerprints": [
        "<%= ENV['ANDROID_SHA256_CERT_FINGERPRINT'] %>"
      ]
    }
  }
]

================
File: views/api/v1/accounts/actions/contact_merges/create.json.jbuilder
================
json.partial! 'api/v1/models/contact', formats: [:json], resource: @base_contact

================
File: views/api/v1/accounts/agent_bots/avatar.json.jbuilder
================
json.partial! 'api/v1/models/agent_bot', formats: [:json], resource: AgentBotPresenter.new(@agent_bot)

================
File: views/api/v1/accounts/agent_bots/create.json.jbuilder
================
json.partial! 'api/v1/models/agent_bot', formats: [:json], resource: AgentBotPresenter.new(@agent_bot)

================
File: views/api/v1/accounts/agent_bots/index.json.jbuilder
================
json.array! @agent_bots do |agent_bot|
  json.partial! 'api/v1/models/agent_bot', formats: [:json], resource: AgentBotPresenter.new(agent_bot)
end

================
File: views/api/v1/accounts/agent_bots/show.json.jbuilder
================
json.partial! 'api/v1/models/agent_bot', formats: [:json], resource: AgentBotPresenter.new(@agent_bot)

================
File: views/api/v1/accounts/agent_bots/update.json.jbuilder
================
json.partial! 'api/v1/models/agent_bot', formats: [:json], resource: AgentBotPresenter.new(@agent_bot)

================
File: views/api/v1/accounts/agents/create.json.jbuilder
================
json.partial! 'api/v1/models/agent', formats: [:json], resource: @agent

================
File: views/api/v1/accounts/agents/index.json.jbuilder
================
json.array! @agents do |agent|
  json.partial! 'api/v1/models/agent', formats: [:json], resource: agent
end

================
File: views/api/v1/accounts/agents/update.json.jbuilder
================
json.partial! 'api/v1/models/agent', formats: [:json], resource: @agent

================
File: views/api/v1/accounts/articles/_article.json.jbuilder
================
json.id article.id
json.slug article.slug
json.title article.title
json.content article.content
json.description article.description
json.status article.status
json.position article.position
json.account_id article.account_id
json.updated_at article.updated_at.to_i
json.meta article.meta

json.category do
  json.id article.category_id
  json.name article.category&.name
  json.slug article.category&.slug
  json.locale article.category&.locale
end

json.views article.views

if article.author.present?
  json.author do
    json.partial! 'api/v1/models/agent', formats: [:json], resource: article.author
  end
end

json.associated_articles do
  if article.associated_articles.any?
    json.array! article.associated_articles.each do |associated_article|
      json.partial! 'api/v1/accounts/articles/associated_article', formats: [:json], article: associated_article
    end
  end
end

================
File: views/api/v1/accounts/articles/_associated_article.json.jbuilder
================
json.id article.id
json.category_id article.category_id
json.title article.title
json.content article.content
json.description article.description
json.status article.status
json.account_id article.account_id

if article.portal.present?
  json.portal do
    json.partial! 'api/v1/accounts/portals/portal', formats: [:json], portal: article.portal, articles: []
  end
end

json.views article.views

if article.author.present?
  json.author do
    json.partial! 'api/v1/models/agent', formats: [:json], resource: article.author
  end
end

================
File: views/api/v1/accounts/articles/create.json.jbuilder
================
json.payload do
  json.partial! 'article', article: @article
end

================
File: views/api/v1/accounts/articles/edit.json.jbuilder
================
json.payload do
  json.partial! 'article', article: @article
end

================
File: views/api/v1/accounts/articles/index.json.jbuilder
================
json.payload do
  json.array! @articles, partial: 'article', as: :article
end

json.meta do
  json.all_articles_count @portal_articles.size
  json.archived_articles_count @archived_articles_count
  json.articles_count @articles_count
  json.current_page @current_page
  json.draft_articles_count @draft_articles_count
  json.mine_articles_count @mine_articles_count
  json.published_count @published_articles_count
end

================
File: views/api/v1/accounts/articles/show.json.jbuilder
================
json.payload do
  json.partial! 'article', article: @article
end

================
File: views/api/v1/accounts/articles/update.json.jbuilder
================
json.payload do
  json.partial! 'article', article: @article
end

================
File: views/api/v1/accounts/assignable_agents/index.json.jbuilder
================
json.payload do
  json.array! @assignable_agents do |agent|
    json.partial! 'api/v1/models/agent', formats: [:json], resource: agent
  end
end

================
File: views/api/v1/accounts/automation_rules/partials/_automation_rule.json.jbuilder
================
json.id automation_rule.id
json.account_id automation_rule.account_id
json.name automation_rule.name
json.description automation_rule.description
json.event_name automation_rule.event_name
json.conditions automation_rule.conditions
json.actions automation_rule.actions
json.created_on automation_rule.created_at.to_i
json.active automation_rule.active?
json.files automation_rule.file_base_data if automation_rule.files.any?

================
File: views/api/v1/accounts/automation_rules/clone.json.jbuilder
================
json.payload do
  json.partial! 'api/v1/accounts/automation_rules/partials/automation_rule', formats: [:json], automation_rule: @automation_rule
end

================
File: views/api/v1/accounts/automation_rules/create.json.jbuilder
================
json.partial! 'api/v1/accounts/automation_rules/partials/automation_rule', formats: [:json], automation_rule: @automation_rule

================
File: views/api/v1/accounts/automation_rules/index.json.jbuilder
================
json.payload do
  json.array! @automation_rules do |automation_rule|
    json.partial! 'api/v1/accounts/automation_rules/partials/automation_rule', formats: [:json], automation_rule: automation_rule
  end
end

================
File: views/api/v1/accounts/automation_rules/show.json.jbuilder
================
json.payload do
  json.partial! 'api/v1/accounts/automation_rules/partials/automation_rule', formats: [:json], automation_rule: @automation_rule
end

================
File: views/api/v1/accounts/automation_rules/update.json.jbuilder
================
json.payload do
  json.partial! 'api/v1/accounts/automation_rules/partials/automation_rule', formats: [:json], automation_rule: @automation_rule
end

================
File: views/api/v1/accounts/callbacks/facebook_pages.json.jbuilder
================
json.data do
  json.page_details @page_details
  json.user_access_token @user_access_token
end

================
File: views/api/v1/accounts/callbacks/reauthorize_page.json.jbuilder
================
json.data do
  json.partial! 'api/v1/models/inbox', formats: [:json], resource: @inbox
end

================
File: views/api/v1/accounts/callbacks/register_facebook_page.json.jbuilder
================
json.id @facebook_inbox.id
json.channel_id @facebook_inbox.channel_id
json.name @facebook_inbox.name
json.channel_type @facebook_inbox.channel_type
json.avatar_url @facebook_inbox.try(:avatar_url)
json.page_id @facebook_inbox.channel.try(:page_id)
json.enable_auto_assignment @facebook_inbox.enable_auto_assignment

================
File: views/api/v1/accounts/campaigns/create.json.jbuilder
================
json.partial! 'api/v1/models/campaign', formats: [:json], resource: @campaign

================
File: views/api/v1/accounts/campaigns/index.json.jbuilder
================
json.array! @campaigns do |campaign|
  json.partial! 'api/v1/models/campaign', formats: [:json], resource: campaign
end

================
File: views/api/v1/accounts/campaigns/show.json.jbuilder
================
json.partial! 'api/v1/models/campaign', formats: [:json], resource: @campaign

================
File: views/api/v1/accounts/campaigns/update.json.jbuilder
================
json.partial! 'api/v1/models/campaign', formats: [:json], resource: @campaign

================
File: views/api/v1/accounts/categories/_associated_category.json.jbuilder
================
json.id category.id
json.name category.name
json.slug category.slug
json.locale category.locale
json.description category.description
json.position category.position
json.account_id category.account_id

================
File: views/api/v1/accounts/categories/_category.json.jbuilder
================
json.id category.id
json.name category.name
json.slug category.slug
json.locale category.locale
json.description category.description
json.position category.position
json.account_id category.account_id
json.icon category.icon

json.related_categories do
  if category.related_categories.any?
    json.array! category.related_categories.each do |related_category|
      json.partial! 'api/v1/accounts/categories/associated_category', formats: [:json], category: related_category
    end
  end
end

if category.parent_category.present?
  json.parent_category do
    json.partial! 'api/v1/accounts/categories/associated_category', formats: [:json], category: category.parent_category
  end
end

if category.root_category.present?
  json.root_category do
    json.partial! 'api/v1/accounts/categories/associated_category', formats: [:json], category: category.root_category
  end
end

json.meta do
  json.articles_count category.articles.search(locale: @current_locale).size
end

================
File: views/api/v1/accounts/categories/create.json.jbuilder
================
json.payload do
  json.partial! 'category', category: @category
end

================
File: views/api/v1/accounts/categories/index.json.jbuilder
================
json.payload do
  json.array! @categories, partial: 'category', as: :category
end

json.meta do
  json.current_page @current_page
  json.categories_count @categories.size
end

================
File: views/api/v1/accounts/categories/show.json.jbuilder
================
json.payload do
  json.partial! 'category', category: @category
end

================
File: views/api/v1/accounts/categories/update.json.jbuilder
================
json.payload do
  json.partial! 'category', category: @category
end

================
File: views/api/v1/accounts/channels/twilio_channels/create.json.jbuilder
================
json.partial! 'api/v1/models/inbox', formats: [:json], resource: @inbox

================
File: views/api/v1/accounts/contact_inboxes/filter.json.jbuilder
================
json.partial! 'api/v1/models/contact', formats: [:json], resource: @contact, with_contact_inboxes: true

================
File: views/api/v1/accounts/contacts/contact_inboxes/create.json.jbuilder
================
json.partial! 'api/v1/models/contact_inbox', formats: [:json], resource: @contact_inbox

================
File: views/api/v1/accounts/contacts/conversations/index.json.jbuilder
================
json.payload do
  json.array! @conversations do |conversation|
    json.partial! 'api/v1/conversations/partials/conversation', formats: [:json], conversation: conversation
  end
end

================
File: views/api/v1/accounts/contacts/labels/create.json.jbuilder
================
json.payload @labels

================
File: views/api/v1/accounts/contacts/labels/index.json.jbuilder
================
json.payload @labels

================
File: views/api/v1/accounts/contacts/notes/create.json.jbuilder
================
json.partial! 'api/v1/models/note', formats: [:json], resource: @note

================
File: views/api/v1/accounts/contacts/notes/index.json.jbuilder
================
json.array! @notes do |note|
  json.partial! 'api/v1/models/note', formats: [:json], resource: note
end

================
File: views/api/v1/accounts/contacts/notes/show.json.jbuilder
================
json.partial! 'api/v1/models/note', formats: [:json], resource: @note

================
File: views/api/v1/accounts/contacts/notes/update.json.jbuilder
================
json.partial! 'api/v1/models/note', formats: [:json], resource: @note

================
File: views/api/v1/accounts/contacts/active.json.jbuilder
================
json.meta do
  json.count @contacts_count
  json.current_page @current_page
end

json.payload do
  json.array! @contacts do |contact|
    json.partial! 'api/v1/models/contact', formats: [:json], resource: contact, with_contact_inboxes: true
  end
end

================
File: views/api/v1/accounts/contacts/avatar.json.jbuilder
================
json.payload do
  json.partial! 'api/v1/models/contact', formats: [:json], resource: @contact, with_contact_inboxes: false
end

================
File: views/api/v1/accounts/contacts/contactable_inboxes.json.jbuilder
================
json.payload do
  json.array! @contactable_inboxes do |contactable_inbox|
    json.inbox do
      json.partial! 'api/v1/models/inbox_slim', formats: [:json], resource: contactable_inbox[:inbox]
    end
    json.source_id contactable_inbox[:source_id]
  end
end

================
File: views/api/v1/accounts/contacts/create.json.jbuilder
================
json.payload do
  json.contact do
    json.partial! 'api/v1/models/contact', formats: [:json], resource: @contact, with_contact_inboxes: true
  end
  json.contact_inbox do
    json.inbox @contact_inbox&.inbox
    json.source_id @contact_inbox&.source_id
  end
end

================
File: views/api/v1/accounts/contacts/destroy_custom_attributes.json.jbuilder
================
json.payload do
  json.partial! 'api/v1/models/contact', formats: [:json], resource: @contact, with_contact_inboxes: true
end

================
File: views/api/v1/accounts/contacts/filter.json.jbuilder
================
json.meta do
  json.count @contacts_count
  json.current_page @current_page
end

json.payload do
  json.array! @contacts do |contact|
    json.partial! 'api/v1/models/contact', formats: [:json], resource: contact, with_contact_inboxes: @include_contact_inboxes
  end
end

================
File: views/api/v1/accounts/contacts/index.json.jbuilder
================
json.meta do
  json.count @contacts_count
  json.current_page @current_page
end

json.payload do
  json.array! @contacts do |contact|
    json.partial! 'api/v1/models/contact', formats: [:json], resource: contact, with_contact_inboxes: @include_contact_inboxes
  end
end

================
File: views/api/v1/accounts/contacts/search.json.jbuilder
================
json.meta do
  json.count @contacts_count
  json.current_page @current_page
end

json.payload do
  json.array! @contacts do |contact|
    json.partial! 'api/v1/models/contact', formats: [:json], resource: contact, with_contact_inboxes: @include_contact_inboxes
  end
end

================
File: views/api/v1/accounts/contacts/show.json.jbuilder
================
json.payload do
  json.partial! 'api/v1/models/contact', formats: [:json], resource: @contact, with_contact_inboxes: @include_contact_inboxes
end

================
File: views/api/v1/accounts/contacts/update.json.jbuilder
================
json.payload do
  json.partial! 'api/v1/models/contact', formats: [:json], resource: @contact, with_contact_inboxes: @include_contact_inboxes
end

================
File: views/api/v1/accounts/conversations/assignments/create.json.jbuilder
================
json.payload do
  json.assignee @conversation.assignee
  json.conversation_id @conversation.display_id
end

================
File: views/api/v1/accounts/conversations/labels/create.json.jbuilder
================
json.payload @labels

================
File: views/api/v1/accounts/conversations/labels/index.json.jbuilder
================
json.payload @labels

================
File: views/api/v1/accounts/conversations/messages/create.json.jbuilder
================
json.partial! 'api/v1/models/message', message: @message

================
File: views/api/v1/accounts/conversations/messages/destroy.json.jbuilder
================
json.partial! 'api/v1/models/message', message: @message

================
File: views/api/v1/accounts/conversations/messages/index.json.jbuilder
================
json.meta do
  json.labels @conversation.cached_label_list_array
  json.additional_attributes @conversation.additional_attributes
  json.contact @conversation.contact.push_event_data
  json.assignee @conversation.assignee.push_event_data if @conversation.assignee.present?
  json.agent_last_seen_at @conversation.agent_last_seen_at
  json.assignee_last_seen_at @conversation.assignee_last_seen_at
end

json.payload do
  json.array! @messages do |message|
    json.partial! 'api/v1/models/message', message: message
  end
end

================
File: views/api/v1/accounts/conversations/messages/retry.json.jbuilder
================
json.partial! 'api/v1/models/message', message: @message

================
File: views/api/v1/accounts/conversations/participants/create.json.jbuilder
================
json.array! @participants do |participant|
  json.partial! 'api/v1/models/agent', format: :json, resource: participant.user
end

================
File: views/api/v1/accounts/conversations/participants/show.json.jbuilder
================
json.array! @participants do |participant|
  json.partial! 'api/v1/models/agent', format: :json, resource: participant.user
end

================
File: views/api/v1/accounts/conversations/attachments.json.jbuilder
================
json.meta do
  json.total_count @attachments_count
end

json.payload @attachments do |attachment|
  json.message_id attachment.push_event_data[:message_id]
  json.thumb_url attachment.push_event_data[:thumb_url]
  json.data_url attachment.push_event_data[:data_url]
  json.file_size attachment.push_event_data[:file_size]
  json.file_type attachment.push_event_data[:file_type]
  json.extension attachment.push_event_data[:extension]
  json.width attachment.push_event_data[:width]
  json.height attachment.push_event_data[:height]
  json.created_at attachment.message.created_at.to_i
  json.sender attachment.message.sender.push_event_data if attachment.message.sender
end

================
File: views/api/v1/accounts/conversations/create.json.jbuilder
================
json.partial! 'api/v1/conversations/partials/conversation', formats: [:json], conversation: @conversation

================
File: views/api/v1/accounts/conversations/custom_attributes.json.jbuilder
================
json.custom_attributes @conversation.custom_attributes

================
File: views/api/v1/accounts/conversations/filter.json.jbuilder
================
json.meta do
  json.mine_count @conversations_count[:mine_count]
  json.unassigned_count @conversations_count[:unassigned_count]
  json.all_count @conversations_count[:all_count]
end
json.payload do
  json.array! @conversations do |conversation|
    json.partial! 'api/v1/conversations/partials/conversation', formats: [:json], conversation: conversation
  end
end

================
File: views/api/v1/accounts/conversations/index.json.jbuilder
================
json.data do
  json.meta do
    json.mine_count @conversations_count[:mine_count]
    json.assigned_count @conversations_count[:assigned_count]
    json.unassigned_count @conversations_count[:unassigned_count]
    json.all_count @conversations_count[:all_count]
  end
  json.payload do
    json.array! @conversations do |conversation|
      json.partial! 'api/v1/conversations/partials/conversation', formats: [:json], conversation: conversation
    end
  end
end

================
File: views/api/v1/accounts/conversations/meta.json.jbuilder
================
json.meta do
  json.mine_count @conversations_count[:mine_count]
  json.assigned_count @conversations_count[:assigned_count]
  json.unassigned_count @conversations_count[:unassigned_count]
  json.all_count @conversations_count[:all_count]
end

================
File: views/api/v1/accounts/conversations/search.json.jbuilder
================
json.meta do
  json.mine_count @conversations_count[:mine_count]
  json.unassigned_count @conversations_count[:unassigned_count]
  json.all_count @conversations_count[:all_count]
end
json.payload do
  json.array! @conversations do |conversation|
    json.partial! 'api/v1/models/conversation', formats: [:json], conversation: conversation
  end
end

================
File: views/api/v1/accounts/conversations/show.json.jbuilder
================
json.partial! 'api/v1/conversations/partials/conversation', formats: [:json], conversation: @conversation

================
File: views/api/v1/accounts/conversations/toggle_status.json.jbuilder
================
json.meta do
end

json.payload do
  json.success @status
  json.conversation_id @conversation.display_id
  json.current_status @conversation.status
  json.snoozed_until @conversation.snoozed_until
end

================
File: views/api/v1/accounts/conversations/unread.json.jbuilder
================
json.partial! 'api/v1/conversations/partials/conversation', formats: [:json], conversation: @conversation

================
File: views/api/v1/accounts/conversations/update_last_seen.json.jbuilder
================
json.partial! 'api/v1/conversations/partials/conversation', formats: [:json], conversation: @conversation

================
File: views/api/v1/accounts/conversations/update.json.jbuilder
================
json.partial! 'api/v1/conversations/partials/conversation', formats: [:json], conversation: @conversation

================
File: views/api/v1/accounts/csat_survey_responses/download.csv.erb
================
<%=
  CSV.generate_line([
    I18n.t('reports.csat.headers.agent_name'),
    I18n.t('reports.csat.headers.rating'),
    I18n.t('reports.csat.headers.feedback'),
    I18n.t('reports.csat.headers.contact_name'),
    I18n.t('reports.csat.headers.contact_email_address'),
    I18n.t('reports.csat.headers.contact_phone_number'),
    I18n.t('reports.csat.headers.link_to_the_conversation'),
    I18n.t('reports.csat.headers.recorded_at')
  ])
-%>
<% @csat_survey_responses.each do |csat_response| %>
<% assigned_agent = csat_response.assigned_agent %>
<% contact = csat_response.contact %>
<% conversation = csat_response.conversation %>
<%=
  CSV.generate_line([
    assigned_agent ? "#{assigned_agent.name} (#{assigned_agent.email})" : nil,
    csat_response.rating,
    csat_response.feedback_message.present? ? csat_response.feedback_message : nil,
    contact&.name.present? ? contact&.name: nil,
    contact&.email.present? ? contact&.email: nil,
    contact&.phone_number.present? ? contact&.phone_number: nil,
    conversation ? app_account_conversation_url(account_id: Current.account.id, id: conversation.display_id): nil,
    csat_response.created_at,
]).html_safe
-%>
<% end %>
<%=
  CSV.generate_line([
    I18n.t(
      'reports.period',
      since: Date.strptime(params[:since], '%s'),
      until: Date.strptime(params[:until], '%s')
    )
  ])
-%>

================
File: views/api/v1/accounts/csat_survey_responses/index.json.jbuilder
================
json.array! @csat_survey_responses do |csat_survey_response|
  json.partial! 'api/v1/models/csat_survey_response', formats: [:json], resource: csat_survey_response
end

================
File: views/api/v1/accounts/csat_survey_responses/metrics.json.jbuilder
================
json.total_count @total_count
json.ratings_count @ratings_count
json.total_sent_messages_count @total_sent_messages_count

================
File: views/api/v1/accounts/custom_attribute_definitions/create.json.jbuilder
================
json.partial! 'api/v1/models/custom_attribute_definition', formats: [:json], resource: @custom_attribute_definition

================
File: views/api/v1/accounts/custom_attribute_definitions/index.json.jbuilder
================
json.array! @custom_attribute_definitions do |custom_attribute_definition|
  json.partial! 'api/v1/models/custom_attribute_definition', formats: [:json], resource: custom_attribute_definition
end

================
File: views/api/v1/accounts/custom_attribute_definitions/show.json.jbuilder
================
json.partial! 'api/v1/models/custom_attribute_definition', formats: [:json], resource: @custom_attribute_definition

================
File: views/api/v1/accounts/custom_attribute_definitions/update.json.jbuilder
================
json.partial! 'api/v1/models/custom_attribute_definition', formats: [:json], resource: @custom_attribute_definition

================
File: views/api/v1/accounts/custom_filters/create.json.jbuilder
================
json.partial! 'api/v1/models/custom_filter', formats: [:json], resource: @custom_filter

================
File: views/api/v1/accounts/custom_filters/index.json.jbuilder
================
json.array! @custom_filters do |custom_filter|
  json.partial! 'api/v1/models/custom_filter', formats: [:json], resource: custom_filter
end

================
File: views/api/v1/accounts/custom_filters/show.json.jbuilder
================
json.partial! 'api/v1/models/custom_filter', formats: [:json], resource: @custom_filter

================
File: views/api/v1/accounts/custom_filters/update.json.jbuilder
================
json.partial! 'api/v1/models/custom_filter', formats: [:json], resource: @custom_filter

================
File: views/api/v1/accounts/dashboard_apps/create.json.jbuilder
================
json.partial! 'api/v1/models/dashboard_app', formats: [:json], resource: @dashboard_app

================
File: views/api/v1/accounts/dashboard_apps/index.json.jbuilder
================
json.array! @dashboard_apps do |dashboard_app|
  json.partial! 'api/v1/models/dashboard_app', formats: [:json], resource: dashboard_app
end

================
File: views/api/v1/accounts/dashboard_apps/show.json.jbuilder
================
json.partial! 'api/v1/models/dashboard_app', formats: [:json], resource: @dashboard_app

================
File: views/api/v1/accounts/dashboard_apps/update.json.jbuilder
================
json.partial! 'api/v1/models/dashboard_app', formats: [:json], resource: @dashboard_app

================
File: views/api/v1/accounts/inbox_members/create.json.jbuilder
================
json.payload do
  json.array! @agents do |agent|
    json.partial! 'api/v1/models/agent', formats: [:json], resource: agent
  end
end

================
File: views/api/v1/accounts/inbox_members/show.json.jbuilder
================
json.payload do
  json.array! @agents do |agent|
    json.partial! 'api/v1/models/agent', formats: [:json], resource: agent
  end
end

================
File: views/api/v1/accounts/inbox_members/update.json.jbuilder
================
json.payload do
  json.array! @agents do |agent|
    json.partial! 'api/v1/models/agent', formats: [:json], resource: agent
  end
end

================
File: views/api/v1/accounts/inboxes/agent_bot.json.jbuilder
================
json.agent_bot do
  json.partial! 'api/v1/models/agent_bot', formats: [:json], resource: @agent_bot if @agent_bot.present?
end

================
File: views/api/v1/accounts/inboxes/assignable_agents.json.jbuilder
================
json.payload do
  json.array! @assignable_agents do |agent|
    json.partial! 'api/v1/models/agent', formats: [:json], resource: agent
  end
end

================
File: views/api/v1/accounts/inboxes/campaigns.json.jbuilder
================
json.array! @campaigns do |campaign|
  json.partial! 'api/v1/models/campaign', formats: [:json], resource: campaign
end

================
File: views/api/v1/accounts/inboxes/create.json.jbuilder
================
json.partial! 'api/v1/models/inbox', formats: [:json], resource: @inbox

================
File: views/api/v1/accounts/inboxes/index.json.jbuilder
================
json.payload do
  json.array! @inboxes do |inbox|
    json.partial! 'api/v1/models/inbox', formats: [:json], resource: inbox
  end
end

================
File: views/api/v1/accounts/inboxes/show.json.jbuilder
================
json.partial! 'api/v1/models/inbox', formats: [:json], resource: @inbox

================
File: views/api/v1/accounts/inboxes/update.json.jbuilder
================
json.partial! 'api/v1/models/inbox', formats: [:json], resource: @inbox

================
File: views/api/v1/accounts/integrations/apps/index.json.jbuilder
================
json.payload do
  json.array! @apps do |app|
    json.partial! 'api/v1/models/app', formats: [:json], resource: app
  end
end

================
File: views/api/v1/accounts/integrations/apps/show.json.jbuilder
================
json.partial! 'api/v1/models/app', formats: [:json], resource: @app

================
File: views/api/v1/accounts/integrations/hooks/create.json.jbuilder
================
json.partial! 'api/v1/models/hook', formats: [:json], resource: @hook

================
File: views/api/v1/accounts/integrations/hooks/update.json.jbuilder
================
json.partial! 'api/v1/models/hook', formats: [:json], resource: @hook

================
File: views/api/v1/accounts/integrations/linear/create.json.jbuilder
================
json.partial! 'api/v1/models/app', formats: [:json], resource: @hook.app

================
File: views/api/v1/accounts/integrations/slack/create.json.jbuilder
================
json.partial! 'api/v1/models/app', formats: [:json], resource: @hook.app

================
File: views/api/v1/accounts/integrations/slack/list_all_channels.json.jbuilder
================
json.array! @channels do |channel|
  json.id channel['id']
  json.name channel['name']
end

================
File: views/api/v1/accounts/integrations/slack/update.json.jbuilder
================
json.partial! 'api/v1/models/app', formats: [:json], resource: @hook.app

================
File: views/api/v1/accounts/labels/create.json.jbuilder
================
json.id @label.id
json.title @label.title
json.description @label.description
json.color @label.color
json.show_on_sidebar @label.show_on_sidebar

================
File: views/api/v1/accounts/labels/index.json.jbuilder
================
json.payload do
  json.array! @labels do |label|
    json.id label.id
    json.title label.title
    json.description label.description
    json.color label.color
    json.show_on_sidebar label.show_on_sidebar
  end
end

================
File: views/api/v1/accounts/labels/show.json.jbuilder
================
json.id @label.id
json.title @label.title
json.description @label.description
json.color @label.color
json.show_on_sidebar @label.show_on_sidebar

================
File: views/api/v1/accounts/labels/update.json.jbuilder
================
json.id @label.id
json.title @label.title
json.description @label.description
json.color @label.color
json.show_on_sidebar @label.show_on_sidebar

================
File: views/api/v1/accounts/macros/create.json.jbuilder
================
json.payload do
  json.partial! 'api/v1/models/macro', formats: [:json], macro: @macro
end

================
File: views/api/v1/accounts/macros/index.json.jbuilder
================
json.payload do
  json.array! @macros do |macro|
    json.partial! 'api/v1/models/macro', formats: [:json], macro: macro
  end
end

================
File: views/api/v1/accounts/macros/show.json.jbuilder
================
json.payload do
  json.partial! 'api/v1/models/macro', formats: [:json], macro: @macro
end

================
File: views/api/v1/accounts/macros/update.json.jbuilder
================
json.payload do
  json.partial! 'api/v1/models/macro', formats: [:json], macro: @macro
end

================
File: views/api/v1/accounts/notification_settings/show.json.jbuilder
================
json.id @notification_setting.id
json.user_id @notification_setting.user_id
json.account_id @notification_setting.account_id
json.all_email_flags @notification_setting.all_email_flags
json.selected_email_flags @notification_setting.selected_email_flags
json.all_push_flags @notification_setting.all_push_flags
json.selected_push_flags @notification_setting.selected_push_flags

================
File: views/api/v1/accounts/notifications/index.json.jbuilder
================
json.data do
  json.meta do
    json.unread_count @unread_count
    json.count @count
    json.current_page @current_page
  end

  json.payload do
    json.array! @notifications do |notification|
      json.id notification.id
      json.notification_type notification.notification_type
      json.push_message_title notification.push_message_title
      json.push_message_body notification.push_message_body
      # TODO: front end assumes primary actor to be conversation. should fix in future
      json.primary_actor_type notification.primary_actor_type
      json.primary_actor_id notification.primary_actor_id
      json.primary_actor notification.primary_actor.push_event_data
      json.read_at notification.read_at
      # Secondary actor could be nil for cases like system assigning conversation
      json.secondary_actor notification.secondary_actor&.push_event_data
      json.user notification.user.push_event_data
      json.created_at notification.created_at.to_i
      json.last_activity_at notification.last_activity_at.to_i
      json.snoozed_until notification.snoozed_until
      json.meta notification.meta
    end
  end
end

================
File: views/api/v1/accounts/portals/_portal.json.jbuilder
================
json.id portal.id
json.color portal.color
json.custom_domain portal.custom_domain
json.header_text portal.header_text
json.homepage_link portal.homepage_link
json.name portal.name
json.page_title portal.page_title
json.slug portal.slug
json.archived portal.archived
json.account_id portal.account_id

json.config do
  json.allowed_locales do
    json.array! portal.config['allowed_locales'].each do |locale|
      json.partial! 'api/v1/models/portal_config', formats: [:json], locale: locale, portal: portal
    end
  end
end

if portal.channel_web_widget
  json.inbox do
    json.partial! 'api/v1/models/inbox', formats: [:json], resource: portal.channel_web_widget.inbox
  end
end

json.logo portal.file_base_data if portal.logo.present?

json.portal_members do
  if portal.members.any?
    json.array! portal.members.each do |member|
      json.partial! 'api/v1/models/agent', formats: [:json], resource: member
    end
  end
end

json.meta do
  json.all_articles_count articles.try(:size)
  json.archived_articles_count articles.try(:archived).try(:size)
  json.published_count articles.try(:published).try(:size)
  json.draft_articles_count articles.try(:draft).try(:size)
  json.mine_articles_count articles.search_by_author(current_user.id).try(:size) if current_user.present? && articles.any?
  json.categories_count portal.categories.try(:size)
  json.default_locale portal.default_locale
end

================
File: views/api/v1/accounts/portals/add_members.json.jbuilder
================
json.partial! 'portal', portal: @portal, articles: []

================
File: views/api/v1/accounts/portals/create.json.jbuilder
================
json.partial! 'portal', portal: @portal, articles: []

================
File: views/api/v1/accounts/portals/index.json.jbuilder
================
json.payload do
  json.array! @portals.each do |portal|
    json.partial! 'portal', formats: [:json], portal: portal, articles: []
  end
end

json.meta do
  json.current_page @current_page
  json.portals_count @portals.size
end

================
File: views/api/v1/accounts/portals/show.json.jbuilder
================
json.partial! 'portal', portal: @portal, articles: @articles

================
File: views/api/v1/accounts/portals/update.json.jbuilder
================
json.partial! 'portal', portal: @portal, articles: []

================
File: views/api/v1/accounts/search/_agent.json.jbuilder
================
json.id agent.id
json.available_name agent.available_name
json.email agent.email
json.name agent.name
json.role agent.role

================
File: views/api/v1/accounts/search/_contact.json.jbuilder
================
json.email contact.email
json.id contact.id
json.name contact.name
json.phone_number contact.phone_number
json.identifier contact.identifier

================
File: views/api/v1/accounts/search/_inbox.json.jbuilder
================
json.id inbox.id
json.channel_id inbox.channel_id
json.name inbox.name
json.channel_type inbox.channel_type

================
File: views/api/v1/accounts/search/_message.json.jbuilder
================
json.id message.id
json.content message.content
json.message_type message.message_type_before_type_cast
json.content_type message.content_type
json.source_id message.source_id
json.inbox_id message.inbox_id
json.conversation_id message.conversation.try(:display_id)
json.created_at message.created_at.to_i
json.sender message.sender.push_event_data if message.sender
json.inbox do
  json.partial! 'inbox', formats: [:json], inbox: message.inbox if message.inbox.present? && message.try(:inbox).present?
end

================
File: views/api/v1/accounts/search/contacts.json.jbuilder
================
json.payload do
  json.contacts do
    json.array! @result[:contacts] do |contact|
      json.partial! 'contact', formats: [:json], contact: contact
    end
  end
end

================
File: views/api/v1/accounts/search/conversations.json.jbuilder
================
json.payload do
  json.conversations do
    json.array! @result[:conversations] do |conversation|
      json.id conversation.display_id
      json.account_id conversation.account_id
      json.created_at conversation.created_at.to_i
      json.message do
        json.partial! 'message', formats: [:json], message: conversation.messages.try(:first)
      end
      json.contact do
        json.partial! 'contact', formats: [:json], contact: conversation.contact if conversation.try(:contact).present?
      end
      json.inbox do
        json.partial! 'inbox', formats: [:json], inbox: conversation.inbox if conversation.try(:inbox).present?
      end
      json.agent do
        json.partial! 'agent', formats: [:json], agent: conversation.assignee if conversation.try(:assignee).present?
      end

      json.additional_attributes conversation.additional_attributes
    end
  end
end

================
File: views/api/v1/accounts/search/index.json.jbuilder
================
json.payload do
  json.conversations do
    json.array! @result[:conversations] do |conversation|
      json.id conversation.display_id
      json.account_id conversation.account_id
      json.created_at conversation.created_at.to_i
      json.message do
        json.partial! 'message', formats: [:json], message: conversation.messages.try(:first)
      end
      json.contact do
        json.partial! 'contact', formats: [:json], contact: conversation.contact if conversation.try(:contact).present?
      end
      json.inbox do
        json.partial! 'inbox', formats: [:json], inbox: conversation.inbox if conversation.try(:inbox).present?
      end
      json.agent do
        json.partial! 'agent', formats: [:json], agent: conversation.assignee if conversation.try(:assignee).present?
      end
    end
  end
  json.contacts do
    json.array! @result[:contacts] do |contact|
      json.partial! 'contact', formats: [:json], contact: contact
    end
  end

  json.messages do
    json.array! @result[:messages] do |message|
      json.partial! 'message', formats: [:json], message: message
    end
  end
end

================
File: views/api/v1/accounts/search/messages.json.jbuilder
================
json.payload do
  json.messages do
    json.array! @result[:messages] do |message|
      json.partial! 'message', formats: [:json], message: message
    end
  end
end

================
File: views/api/v1/accounts/team_members/create.json.jbuilder
================
json.array! @team_members do |team_member|
  json.partial! 'api/v1/models/agent', formats: [:json], resource: team_member
end

================
File: views/api/v1/accounts/team_members/index.json.jbuilder
================
json.array! @team_members do |team_member|
  json.partial! 'api/v1/models/agent', formats: [:json], resource: team_member
end

================
File: views/api/v1/accounts/teams/create.json.jbuilder
================
json.partial! 'api/v1/models/team', formats: [:json], resource: @team

================
File: views/api/v1/accounts/teams/index.json.jbuilder
================
json.array! @teams do |team|
  json.partial! 'api/v1/models/team', formats: [:json], resource: team
end

================
File: views/api/v1/accounts/teams/show.json.jbuilder
================
json.partial! 'api/v1/models/team', formats: [:json], resource: @team

================
File: views/api/v1/accounts/teams/update.json.jbuilder
================
json.partial! 'api/v1/models/team', formats: [:json], resource: @team

================
File: views/api/v1/accounts/webhooks/_webhook.json.jbuilder
================
json.id webhook.id
json.url webhook.url
json.account_id webhook.account_id
json.subscriptions webhook.subscriptions
if webhook.inbox
  json.inbox do
    json.id webhook.inbox.id
    json.name webhook.inbox.name
  end
end

================
File: views/api/v1/accounts/webhooks/create.json.jbuilder
================
json.payload do
  json.webhook do
    json.partial! 'webhook', webhook: @webhook
  end
end

================
File: views/api/v1/accounts/webhooks/index.json.jbuilder
================
json.payload do
  json.webhooks do
    json.array! @webhooks, partial: 'webhook', as: :webhook
  end
end

================
File: views/api/v1/accounts/webhooks/update.json.jbuilder
================
json.payload do
  json.webhook do
    json.partial! 'webhook', webhook: @webhook
  end
end

================
File: views/api/v1/accounts/create.json.jbuilder
================
json.data do
  json.id resource.id
  json.provider resource.provider
  json.uid resource.uid
  json.name resource.name
  json.display_name resource.display_name
  json.email resource.email
  json.account_id @account.id
  json.created_at resource.created_at
  json.pubsub_token resource.pubsub_token
  json.role resource.active_account_user&.role
  json.inviter_id resource.active_account_user&.inviter_id
  json.confirmed resource.confirmed?
  json.avatar_url resource.avatar_url
  json.access_token resource.access_token.token
  json.accounts do
    json.array! resource.account_users do |account_user|
      json.id account_user.account_id
      json.name account_user.account.name
      json.active_at account_user.active_at
      json.role account_user.role
      json.locale account_user.account.locale
    end
  end
end

================
File: views/api/v1/accounts/show.json.jbuilder
================
json.partial! 'api/v1/models/account', formats: [:json], resource: @account
json.latest_chatwoot_version @latest_chatwoot_version
json.partial! 'enterprise/api/v1/accounts/partials/account', account: @account if ChatwootApp.enterprise?

================
File: views/api/v1/accounts/update.json.jbuilder
================
json.partial! 'api/v1/models/account', formats: [:json], resource: @account

================
File: views/api/v1/conversations/partials/_conversation.json.jbuilder
================
# TODO: Move this into models jbuilder
# Currently the file there is used only for search endpoint.
# Everywhere else we use conversation builder in partials folder

json.meta do
  json.sender do
    json.partial! 'api/v1/models/contact', formats: [:json], resource: conversation.contact
  end
  json.channel conversation.inbox.try(:channel_type)
  if conversation.assignee&.account
    json.assignee do
      json.partial! 'api/v1/models/agent', formats: [:json], resource: conversation.assignee
    end
  end
  if conversation.team.present?
    json.team do
      json.partial! 'api/v1/models/team', formats: [:json], resource: conversation.team
    end
  end
  json.hmac_verified conversation.contact_inbox&.hmac_verified
end

json.id conversation.display_id
if conversation.messages.where(account_id: conversation.account_id).last.blank?
  json.messages []
else
  json.messages [
    conversation.messages.where(account_id: conversation.account_id)
                .includes([{ attachments: [{ file_attachment: [:blob] }] }]).last.try(:push_event_data)
  ]
end

json.account_id conversation.account_id
json.uuid conversation.uuid
json.additional_attributes conversation.additional_attributes
json.agent_last_seen_at conversation.agent_last_seen_at.to_i
json.assignee_last_seen_at conversation.assignee_last_seen_at.to_i
json.can_reply conversation.can_reply?
json.contact_last_seen_at conversation.contact_last_seen_at.to_i
json.custom_attributes conversation.custom_attributes
json.inbox_id conversation.inbox_id
json.labels conversation.cached_label_list_array
json.muted conversation.muted?
json.snoozed_until conversation.snoozed_until
json.status conversation.status
json.created_at conversation.created_at.to_i
json.updated_at conversation.updated_at.to_f
json.timestamp conversation.last_activity_at.to_i
json.first_reply_created_at conversation.first_reply_created_at.to_i
json.unread_count conversation.unread_incoming_messages.count
json.last_non_activity_message conversation.messages.where(account_id: conversation.account_id).non_activity_messages.first.try(:push_event_data)
json.last_activity_at conversation.last_activity_at.to_i
json.priority conversation.priority
json.waiting_since conversation.waiting_since.to_i.to_i
json.sla_policy_id conversation.sla_policy_id
json.partial! 'enterprise/api/v1/conversations/partials/conversation', conversation: conversation if ChatwootApp.enterprise?

================
File: views/api/v1/models/_account.json.jbuilder
================
json.auto_resolve_duration resource.auto_resolve_duration
json.created_at resource.created_at
if resource.custom_attributes.present?
  json.custom_attributes do
    json.plan_name resource.custom_attributes['plan_name']
    json.subscribed_quantity resource.custom_attributes['subscribed_quantity']
    json.subscription_status resource.custom_attributes['subscription_status']
    json.subscription_ends_on resource.custom_attributes['subscription_ends_on']
    json.industry resource.custom_attributes['industry'] if resource.custom_attributes['industry'].present?
    json.company_size resource.custom_attributes['company_size'] if resource.custom_attributes['company_size'].present?
    json.timezone resource.custom_attributes['timezone'] if resource.custom_attributes['timezone'].present?
    json.logo resource.custom_attributes['logo'] if resource.custom_attributes['logo'].present?
    json.onboarding_step resource.custom_attributes['onboarding_step'] if resource.custom_attributes['onboarding_step'].present?
  end
end
json.domain @account.domain
json.features @account.enabled_features
json.id @account.id
json.locale @account.locale
json.name @account.name
json.support_email @account.support_email
json.status @account.status
json.cache_keys @account.cache_keys

================
File: views/api/v1/models/_agent_bot.json.jbuilder
================
json.id resource.id
json.name resource.name
json.description resource.description
json.outgoing_url resource.outgoing_url
json.bot_type resource.bot_type
json.bot_config resource.bot_config
json.account_id resource.account_id
json.access_token resource.access_token if resource.access_token.present?

================
File: views/api/v1/models/_agent.json.jbuilder
================
json.id resource.id
# could be nil for a deleted agent hence the safe operator before account id
json.account_id Current.account&.id
json.availability_status resource.availability_status
json.auto_offline resource.auto_offline
json.confirmed resource.confirmed?
json.email resource.email
json.available_name resource.available_name
json.custom_attributes resource.custom_attributes if resource.custom_attributes.present?
json.name resource.name
json.role resource.role
json.thumbnail resource.avatar_url
json.custom_role_id resource.current_account_user&.custom_role_id if ChatwootApp.enterprise?

================
File: views/api/v1/models/_app.json.jbuilder
================
json.id resource.id
json.name resource.name
json.description resource.description
json.enabled resource.enabled?(@current_account)

if Current.account_user&.administrator?
  json.call(resource.params, *resource.params.keys)
  json.action resource.action
  json.button resource.action
end

json.hooks do
  json.array! @current_account.hooks.where(app_id: resource.id) do |hook|
    json.partial! 'api/v1/models/hook', formats: [:json], resource: hook
  end
end

================
File: views/api/v1/models/_campaign.json.jbuilder
================
json.id resource.display_id
json.title resource.title
json.description resource.description
json.account_id resource.account_id
json.inbox do
  json.partial! 'api/v1/models/inbox', formats: [:json], resource: resource.inbox
end
json.sender do
  json.partial! 'api/v1/models/agent', formats: [:json], resource: resource.sender if resource.sender.present?
end
json.message resource.message
json.campaign_status resource.campaign_status
json.enabled resource.enabled
json.campaign_type resource.campaign_type
if resource.campaign_type == 'one_off'
  json.scheduled_at resource.scheduled_at.to_i
  json.audience resource.audience
end
json.trigger_rules resource.trigger_rules
json.trigger_only_during_business_hours resource.trigger_only_during_business_hours
json.created_at resource.created_at
json.updated_at resource.updated_at

================
File: views/api/v1/models/_contact_inbox.json.jbuilder
================
json.source_id resource.source_id
json.inbox do
  json.partial! 'api/v1/models/inbox_slim', formats: [:json], resource: resource.inbox
end

================
File: views/api/v1/models/_contact.json.jbuilder
================
json.additional_attributes resource.additional_attributes
json.availability_status resource.availability_status
json.email resource.email
json.id resource.id
json.name resource.name
json.phone_number resource.phone_number
json.blocked resource.blocked
json.identifier resource.identifier
json.thumbnail resource.avatar_url
json.custom_attributes resource.custom_attributes
json.last_activity_at resource.last_activity_at.to_i if resource[:last_activity_at].present?
json.created_at resource.created_at.to_i if resource[:created_at].present?
# we only want to output contact inbox when its /contacts endpoints
if defined?(with_contact_inboxes) && with_contact_inboxes.present?
  json.contact_inboxes do
    json.array! resource.contact_inboxes do |contact_inbox|
      json.partial! 'api/v1/models/contact_inbox', formats: [:json], resource: contact_inbox
    end
  end
end

================
File: views/api/v1/models/_conversation.json.jbuilder
================
# This file is used to render conversation data search API response.

json.id conversation.display_id
json.uuid conversation.uuid
json.created_at conversation.created_at.to_i
json.contact do
  json.id conversation.contact.id
  json.name conversation.contact.name
end
json.inbox do
  json.id conversation.inbox.id
  json.name conversation.inbox.name
  json.channel_type conversation.inbox.channel_type
end
json.messages do
  json.array! conversation.messages do |message|
    json.content message.content
    json.id message.id
    json.sender_name message.sender.name if message.sender
    json.message_type message.message_type_before_type_cast
    json.created_at message.created_at.to_i
  end
end
json.account_id conversation.account_id

================
File: views/api/v1/models/_csat_survey_response.json.jbuilder
================
json.id resource.id
json.rating resource.rating
json.feedback_message resource.feedback_message
json.account_id resource.account_id
json.message_id resource.message_id
if resource.contact
  json.contact do
    json.partial! 'api/v1/models/contact', formats: [:json], resource: resource.contact
  end
end
json.conversation_id resource.conversation.display_id
if resource.assigned_agent
  json.assigned_agent do
    json.partial! 'api/v1/models/agent', formats: [:json], resource: resource.assigned_agent
  end
end
json.created_at resource.created_at.to_i

================
File: views/api/v1/models/_custom_attribute_definition.json.jbuilder
================
json.id resource.id
json.attribute_display_name resource.attribute_display_name
json.attribute_display_type resource.attribute_display_type
json.attribute_description resource.attribute_description
json.attribute_key resource.attribute_key
json.regex_pattern resource.regex_pattern
json.regex_cue resource.regex_cue
json.attribute_values resource.attribute_values
json.attribute_model resource.attribute_model
json.default_value resource.default_value
json.created_at resource.created_at
json.updated_at resource.updated_at

================
File: views/api/v1/models/_custom_filter.json.jbuilder
================
json.id resource.id
json.name resource.name
json.filter_type resource.filter_type
json.query resource.query
json.created_at resource.created_at
json.updated_at resource.updated_at

================
File: views/api/v1/models/_dashboard_app.json.jbuilder
================
json.id resource.id
json.title resource.title
json.content resource.content
json.created_at resource.created_at

================
File: views/api/v1/models/_hook.json.jbuilder
================
json.id resource.id
json.app_id resource.app_id
json.status resource.enabled?
json.inbox resource.inbox&.slice(:id, :name)
json.account_id resource.account_id
json.hook_type resource.hook_type

json.settings resource.settings if Current.account_user&.administrator?
json.reference_id resource.reference_id if Current.account_user&.administrator?

================
File: views/api/v1/models/_inbox_slim.json.jbuilder
================
json.id resource.id
json.avatar_url resource.try(:avatar_url)
json.channel_id resource.channel_id
json.name resource.name
json.channel_type resource.channel_type
json.provider resource.channel.try(:provider)

================
File: views/api/v1/models/_inbox.json.jbuilder
================
json.id resource.id
json.avatar_url resource.try(:avatar_url)
json.channel_id resource.channel_id
json.name resource.name
json.channel_type resource.channel_type
json.greeting_enabled resource.greeting_enabled
json.greeting_message resource.greeting_message
json.working_hours_enabled resource.working_hours_enabled
json.enable_email_collect resource.enable_email_collect
json.csat_survey_enabled resource.csat_survey_enabled
json.enable_auto_assignment resource.enable_auto_assignment
json.auto_assignment_config resource.auto_assignment_config
json.out_of_office_message resource.out_of_office_message
json.working_hours resource.weekly_schedule
json.timezone resource.timezone
json.callback_webhook_url resource.callback_webhook_url
json.allow_messages_after_resolved resource.allow_messages_after_resolved
json.lock_to_single_conversation resource.lock_to_single_conversation
json.sender_name_type resource.sender_name_type
json.business_name resource.business_name

if resource.portal.present?
  json.help_center do
    json.name resource.portal.name
    json.slug resource.portal.slug
  end
end

## Channel specific settings
## TODO : Clean up and move the attributes into channel sub section

json.tweets_enabled resource.channel.try(:tweets_enabled) if resource.twitter?

## WebWidget Attributes
json.widget_color resource.channel.try(:widget_color)
json.website_url resource.channel.try(:website_url)
json.hmac_mandatory resource.channel.try(:hmac_mandatory)
json.welcome_title resource.channel.try(:welcome_title)
json.welcome_tagline resource.channel.try(:welcome_tagline)
json.web_widget_script resource.channel.try(:web_widget_script)
json.website_token resource.channel.try(:website_token)
json.selected_feature_flags resource.channel.try(:selected_feature_flags)
json.reply_time resource.channel.try(:reply_time)
if resource.web_widget?
  json.hmac_token resource.channel.try(:hmac_token) if Current.account_user&.administrator?
  json.pre_chat_form_enabled resource.channel.try(:pre_chat_form_enabled)
  json.pre_chat_form_options resource.channel.try(:pre_chat_form_options)
  json.continuity_via_email resource.channel.try(:continuity_via_email)
end

## Facebook Attributes
if resource.facebook?
  json.page_id resource.channel.try(:page_id)
  json.reauthorization_required resource.channel.try(:reauthorization_required?)
end

## Twilio Attributes
json.messaging_service_sid resource.channel.try(:messaging_service_sid)
json.phone_number resource.channel.try(:phone_number)
json.medium resource.channel.try(:medium) if resource.twilio?

if resource.email?
  ## Email Channel Attributes
  json.forward_to_email resource.channel.try(:forward_to_email)
  json.email resource.channel.try(:email)

  ## IMAP
  if Current.account_user&.administrator?
    json.imap_login resource.channel.try(:imap_login)
    json.imap_password resource.channel.try(:imap_password)
    json.imap_address resource.channel.try(:imap_address)
    json.imap_port resource.channel.try(:imap_port)
    json.imap_enabled resource.channel.try(:imap_enabled)
    json.imap_enable_ssl resource.channel.try(:imap_enable_ssl)

    if resource.channel.try(:microsoft?) || resource.channel.try(:google?) || resource.channel.try(:legacy_google?)
      json.reauthorization_required resource.channel.try(:provider_config).empty? || resource.channel.try(:reauthorization_required?)
    end
  end

  ## SMTP
  if Current.account_user&.administrator?
    json.smtp_login resource.channel.try(:smtp_login)
    json.smtp_password resource.channel.try(:smtp_password)
    json.smtp_address resource.channel.try(:smtp_address)
    json.smtp_port resource.channel.try(:smtp_port)
    json.smtp_enabled resource.channel.try(:smtp_enabled)
    json.smtp_domain resource.channel.try(:smtp_domain)
    json.smtp_enable_ssl_tls resource.channel.try(:smtp_enable_ssl_tls)
    json.smtp_enable_starttls_auto resource.channel.try(:smtp_enable_starttls_auto)
    json.smtp_openssl_verify_mode resource.channel.try(:smtp_openssl_verify_mode)
    json.smtp_authentication resource.channel.try(:smtp_authentication)
  end
end

## API Channel Attributes
if resource.api?
  json.hmac_token resource.channel.try(:hmac_token) if Current.account_user&.administrator?
  json.webhook_url resource.channel.try(:webhook_url)
  json.inbox_identifier resource.channel.try(:identifier)
  json.additional_attributes resource.channel.try(:additional_attributes)
end

json.provider resource.channel.try(:provider)

### WhatsApp Channel
if resource.whatsapp?
  json.message_templates resource.channel.try(:message_templates)
  json.provider_config resource.channel.try(:provider_config) if Current.account_user&.administrator?
end

================
File: views/api/v1/models/_macro.json.jbuilder
================
json.id macro.id
json.name macro.name
json.visibility macro.visibility

if macro.created_by.present?
  json.created_by do
    json.partial! 'api/v1/models/agent', formats: [:json], resource: macro.created_by
  end
end

if macro.updated_by.present?
  json.updated_by do
    json.partial! 'api/v1/models/agent', formats: [:json], resource: macro.updated_by
  end
end

json.account_id macro.account_id
json.actions macro.actions
json.files macro.file_base_data if macro.files.any?

================
File: views/api/v1/models/_message.json.jbuilder
================
json.id message.id
json.content message.content
json.inbox_id message.inbox_id
json.echo_id message.echo_id if message.echo_id
json.conversation_id message.conversation.display_id
json.message_type message.message_type_before_type_cast
json.content_type message.content_type
json.status message.status
json.content_attributes message.content_attributes
json.created_at message.created_at.to_i
json.private message.private
json.source_id message.source_id
json.sender message.sender.push_event_data if message.sender
json.attachments message.attachments.map(&:push_event_data) if message.attachments.present?

================
File: views/api/v1/models/_note.json.jbuilder
================
json.id resource.id
json.content resource.content
json.account_id json.account_id
json.contact_id json.contact_id
if resource.user.present?
  json.user do
    json.partial! 'api/v1/models/agent', formats: [:json], resource: resource.user
  end
end
json.created_at resource.created_at.to_i
json.updated_at resource.updated_at.to_i

================
File: views/api/v1/models/_portal_config.json.jbuilder
================
json.code locale
json.articles_count portal.articles.search({ locale: locale }).size
json.categories_count portal.categories.search_by_locale(locale).size

================
File: views/api/v1/models/_team.json.jbuilder
================
json.id resource.id
json.name resource.name
json.description resource.description
json.allow_auto_assign resource.allow_auto_assign
json.account_id resource.account_id
json.is_member Current.user.teams.include?(resource)

================
File: views/api/v1/models/_user.json.jbuilder
================
json.access_token resource.access_token.token
json.account_id resource.active_account_user&.account_id
json.available_name resource.available_name
json.avatar_url resource.avatar_url
json.confirmed resource.confirmed?
json.display_name resource.display_name
json.message_signature resource.message_signature
json.email resource.email
json.hmac_identifier resource.hmac_identifier if GlobalConfig.get('CHATWOOT_INBOX_HMAC_KEY')['CHATWOOT_INBOX_HMAC_KEY'].present?
json.id resource.id
json.inviter_id resource.active_account_user&.inviter_id
json.name resource.name
json.provider resource.provider
json.pubsub_token resource.pubsub_token
json.custom_attributes resource.custom_attributes if resource.custom_attributes.present?
json.role resource.active_account_user&.role
json.ui_settings resource.ui_settings
json.uid resource.uid
json.type resource.type
json.accounts do
  json.array! resource.account_users do |account_user|
    json.id account_user.account_id
    json.name account_user.account.name
    json.status account_user.account.status
    json.active_at account_user.active_at
    json.role account_user.role
    json.permissions account_user.permissions
    # the actual availability user has configured
    json.availability account_user.availability
    # availability derived from presence
    json.availability_status account_user.availability_status
    json.auto_offline account_user.auto_offline
    json.partial! 'api/v1/models/account_user', account_user: account_user if ChatwootApp.enterprise?
  end
end

================
File: views/api/v1/models/_widget_message.json.jbuilder
================
json.id resource.id
json.content resource.content
json.message_type resource.message_type_before_type_cast
json.content_type resource.content_type
json.content_attributes resource.content_attributes
json.created_at resource.created_at.to_i
json.conversation_id resource.conversation.display_id
json.attachments resource.attachments.map(&:push_event_data) if resource.attachments.present?
json.sender resource.sender.push_event_data if resource.sender

================
File: views/api/v1/profiles/auto_offline.jbuilder
================
json.partial! 'api/v1/models/user', formats: [:json], resource: @user

================
File: views/api/v1/profiles/availability.jbuilder
================
json.partial! 'api/v1/models/user', formats: [:json], resource: @user

================
File: views/api/v1/profiles/avatar.json.jbuilder
================
json.partial! 'api/v1/models/user', formats: [:json], resource: @user

================
File: views/api/v1/profiles/show.json.jbuilder
================
json.partial! 'api/v1/models/user', formats: [:json], resource: @user

================
File: views/api/v1/profiles/update.json.jbuilder
================
json.partial! 'api/v1/models/user', formats: [:json], resource: @user

================
File: views/api/v1/widget/campaigns/index.json.jbuilder
================
json.array! @campaigns do |campaign|
  json.id campaign.display_id
  json.trigger_rules campaign.trigger_rules
  json.trigger_only_during_business_hours campaign.trigger_only_during_business_hours
  json.message campaign.message
  json.sender campaign.sender&.push_event_data
end

================
File: views/api/v1/widget/configs/create.json.jbuilder
================
json.website_channel_config do
  json.allow_messages_after_resolved @web_widget.inbox.allow_messages_after_resolved
  json.api_host ENV.fetch('FRONTEND_URL', nil)
  json.auth_token @token
  json.avatar_url @web_widget.inbox.avatar_url
  json.csat_survey_enabled @web_widget.inbox.csat_survey_enabled
  json.disable_branding @web_widget.inbox.account.feature_enabled?('disable_branding')
  json.enabled_features @web_widget.selected_feature_flags
  json.enabled_languages available_locales_with_name
  json.locale @web_widget.account.locale
  json.out_of_office_message @web_widget.inbox.out_of_office_message
  json.portal @web_widget.inbox.portal
  json.pre_chat_form_enabled @web_widget.pre_chat_form_enabled
  json.pre_chat_form_options @web_widget.pre_chat_form_options
  json.reply_time @web_widget.reply_time
  json.timezone @web_widget.inbox.timezone
  json.utc_off_set ActiveSupport::TimeZone[@web_widget.inbox.timezone].now.formatted_offset
  json.website_name @web_widget.inbox.name
  json.website_token @web_widget.website_token
  json.welcome_tagline @web_widget.welcome_tagline
  json.welcome_title @web_widget.welcome_title
  json.widget_color @web_widget.widget_color
  json.working_hours @web_widget.inbox.working_hours
  json.working_hours_enabled @web_widget.inbox.working_hours_enabled
end

json.contact do
  json.email @contact.email
  json.id @contact.id
  json.identifier @contact.identifier
  json.name @contact.name
  json.phone_number @contact.phone_number
  json.pubsub_token @contact_inbox.pubsub_token
end

json.global_config @global_config

================
File: views/api/v1/widget/contacts/set_user.json.jbuilder
================
json.id @contact.id
json.has_email @contact.email.present?
json.has_name @contact.name.present?
json.has_phone_number @contact.phone_number.present?
json.widget_auth_token @widget_auth_token if @widget_auth_token.present?

================
File: views/api/v1/widget/contacts/show.json.jbuilder
================
json.id @contact.id
json.has_email @contact.email.present?
json.has_name @contact.name.present?
json.has_phone_number @contact.phone_number.present?
json.identifier @contact.identifier

================
File: views/api/v1/widget/contacts/update.json.jbuilder
================
json.id @contact.id
json.has_email @contact.email.present?
json.has_name @contact.name.present?
json.has_phone_number @contact.phone_number.present?

================
File: views/api/v1/widget/conversations/create.json.jbuilder
================
json.id @conversation.display_id
json.inbox_id @conversation.inbox_id
json.contact_last_seen_at @conversation.contact_last_seen_at.to_i
json.status @conversation.status
json.messages do
  json.array! @conversation.messages do |message|
    json.partial! 'api/v1/models/widget_message', resource: message
  end
end
json.custom_attributes @conversation.custom_attributes
json.contact @conversation.contact

================
File: views/api/v1/widget/conversations/index.json.jbuilder
================
if @conversation
  json.id @conversation.display_id
  json.inbox_id @conversation.inbox_id
  json.contact_last_seen_at @conversation.contact_last_seen_at.to_i
  json.status @conversation.status
end

================
File: views/api/v1/widget/inbox_members/index.json.jbuilder
================
json.payload do
  json.array! @inbox_members do |inbox_member|
    json.id inbox_member.user.id
    json.name inbox_member.user.available_name
    json.avatar_url inbox_member.user.avatar_url
    json.availability_status inbox_member.user.account_users.find_by(account_id: @current_account.id).availability_status
  end
end

================
File: views/api/v1/widget/messages/create.json.jbuilder
================
json.id @message.id
json.content @message.content
json.inbox_id @message.inbox_id
json.conversation_id @message.conversation.display_id
json.message_type @message.message_type_before_type_cast
json.created_at @message.created_at.to_i
json.private @message.private
json.source_id @message.source_id
json.content_attributes @message.content_attributes
json.attachments @message.attachments.map(&:push_event_data) if @message.attachments.present?
json.sender @message.sender.push_event_data if @message.sender

================
File: views/api/v1/widget/messages/index.json.jbuilder
================
json.payload do
  json.array! @messages do |message|
    json.id message.id
    json.content message.content
    json.message_type message.message_type_before_type_cast
    json.content_type message.content_type
    json.content_attributes message.content_attributes
    json.created_at message.created_at.to_i
    json.conversation_id message.conversation.display_id
    json.attachments message.attachments.map(&:push_event_data) if message.attachments.present?
    json.sender message.sender.push_event_data if message.sender
  end
end
json.meta do
  json.contact_last_seen_at @conversation.contact_last_seen_at.to_i if @conversation.present?
end

================
File: views/api/v1/widget/messages/update.json.jbuilder
================
json.contact @contact if @contact

================
File: views/api/v2/accounts/reports/agents.csv.erb
================
<%= CSVSafe.generate_line [I18n.t('reports.period', since: Date.strptime(params[:since], '%s'), until: Date.strptime(params[:until], '%s'))] %>

<% headers = [
    I18n.t('reports.agent_csv.agent_name'),
    I18n.t('reports.agent_csv.conversations_count'),
    I18n.t('reports.agent_csv.avg_first_response_time'),
    I18n.t('reports.agent_csv.avg_resolution_time'),
    I18n.t('reports.agent_csv.avg_customer_waiting_time'),
    I18n.t('reports.agent_csv.resolution_count')
  ]
%>
<%= CSVSafe.generate_line headers -%>
<% @report_data.each do |row| %>
<%= CSVSafe.generate_line row -%>
<% end %>

================
File: views/api/v2/accounts/reports/conversation_traffic.erb
================
<%= CSV.generate_line [I18n.t('reports.conversation_traffic_csv.timezone'), @timezone] %>

<% @report_data.each do |row| %>
<%= CSVSafe.generate_line row -%>
<% end %>

================
File: views/api/v2/accounts/reports/inboxes.csv.erb
================
<%= CSVSafe.generate_line [I18n.t('reports.period', since: Date.strptime(params[:since], '%s'), until: Date.strptime(params[:until], '%s'))] %>

<% headers = [
    I18n.t('reports.inbox_csv.inbox_name'),
    I18n.t('reports.inbox_csv.inbox_type'),
    I18n.t('reports.inbox_csv.conversations_count'),
    I18n.t('reports.inbox_csv.avg_first_response_time'),
    I18n.t('reports.inbox_csv.avg_resolution_time')
  ]
%>
<%= CSVSafe.generate_line headers -%>
<% @report_data.each do |row| %>
<%= CSVSafe.generate_line row -%>
<% end %>

================
File: views/api/v2/accounts/reports/labels.csv.erb
================
<%= CSVSafe.generate_line [I18n.t('reports.period', since: Date.strptime(params[:since], '%s'), until: Date.strptime(params[:until], '%s'))] %>

<% headers = [
    I18n.t('reports.label_csv.label_title'),
    I18n.t('reports.label_csv.conversations_count'),
    I18n.t('reports.label_csv.avg_first_response_time'),
    I18n.t('reports.label_csv.avg_resolution_time')
  ]
%>
<%= CSVSafe.generate_line headers -%>
<% @report_data.each do |row| %>
<%= CSVSafe.generate_line row -%>
<% end %>

================
File: views/api/v2/accounts/reports/teams.csv.erb
================
<%= CSVSafe.generate_line [I18n.t('reports.period', since: Date.strptime(params[:since], '%s'), until: Date.strptime(params[:until], '%s'))] %>

<% headers = [
    I18n.t('reports.team_csv.team_name'),
    I18n.t('reports.team_csv.conversations_count'),
    I18n.t('reports.team_csv.avg_first_response_time'),
    I18n.t('reports.team_csv.avg_resolution_time'),
    I18n.t('reports.team_csv.avg_customer_waiting_time'),
    I18n.t('reports.team_csv.resolution_count')
  ]
%>
<%= CSVSafe.generate_line headers -%>
<% @report_data.each do |row| %>
<%= CSVSafe.generate_line row -%>
<% end %>

================
File: views/apple_app/site_association.html.erb
================
{
    "applinks": {
        "apps": [],
        "details": [
            {
                "appID": "<%= ENV['IOS_APP_ID'] %>",
                "paths": [ "/app/accounts/*/conversations/*"]
            }
        ]
    }
}

================
File: views/devise/mailer/confirmation_instructions.html.erb
================
<p>Hi <%= @resource.name %>,</p>

<% account_user = @resource&.account_users&.first %>

<% if account_user&.inviter.present? && @resource.unconfirmed_email.blank? %>
  <p><%= account_user.inviter.name %>, with <%= account_user.account.name %>, has invited you to try out <%= global_config['BRAND_NAME'] || 'Chatwoot' %>.</p>
<% end %>

<% if @resource.confirmed? %>
  <p>You can login to your <%= global_config['BRAND_NAME'] || 'Chatwoot' %> account through the link below:</p>
<% else %>
  <% if account_user&.inviter.blank? %>
  <p>
    Welcome to <%= global_config['BRAND_NAME'] || 'Chatwoot' %>! We have a suite of powerful tools ready for you to explore. Before that we quickly need to verify your email address to know it's really you.
  </p>
  <% end %>
  <p>Please take a moment and click the link below and activate your account.</p>
<% end %>


<% if @resource.unconfirmed_email.present? %>
  <p><%= link_to 'Confirm my account', frontend_url('auth/confirmation', confirmation_token: @token) %></p>
<% elsif @resource.confirmed? %>
  <p><%= link_to 'Login to my account', frontend_url('auth/sign_in') %></p>
<% elsif account_user&.inviter.present? %>
  <p><%= link_to 'Confirm my account', frontend_url('auth/password/edit', reset_password_token: @resource.send(:set_reset_password_token)) %></p>
<% else %>
  <p><%= link_to 'Confirm my account', frontend_url('auth/confirmation', confirmation_token: @token) %></p>
<% end %>

================
File: views/devise/mailer/password_change.html.erb
================
<p>Hello <%= @resource.email %>!</p>

<p>We're contacting you to notify you that your password has been changed.</p>

================
File: views/devise/mailer/reset_password_instructions.html.erb
================
<p>Hello <%= @resource.email %>!</p>

<p>Someone has requested a link to change your password. You can do this through the link below.</p>

<p><%= link_to 'Change my password', frontend_url('auth/password/edit', reset_password_token: @token) %></p>

<p>If you didn't request this, please ignore this email.</p>
<p>Your password won't change until you access the link above and create a new one.</p>

================
File: views/devise/mailer/unlock_instructions.html.erb
================
<p>Hello <%= @resource.email %>!</p>

<p>Your account has been locked due to an excessive number of unsuccessful sign in attempts.</p>

<p>Click the link below to unlock your account:</p>

<p><%= link_to 'Unlock my account', unlock_url(@resource, unlock_token: @token) %></p>

================
File: views/devise/_auth.json.jbuilder
================
json.data do
  json.partial! 'api/v1/models/user', formats: [:json], resource: resource
end

================
File: views/devise/token.json.jbuilder
================
json.payload do
  json.success true
  json.partial! 'auth', formats: [:json], resource: @resource
  json.data do
    json.created_at @resource.created_at
  end
end

================
File: views/fields/account_features_field/_form.html.erb
================
<div class="field-unit__label">
  <%= f.label field.attribute %>
</div>
<div class="field-unit__field feature-container">
  <% regular_features, premium_features = SuperAdmin::AccountFeaturesHelper.filtered_features(field.data).partition { |key_array, _val| !SuperAdmin::AccountFeaturesHelper.account_premium_features.include?(key_array.first) } %>

  <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
    <% regular_features.each do |key_array, val| %>
      <% feature_key, display_name = key_array %>
      <div class="flex items-center justify-between p-3 bg-white rounded-lg shadow-sm outline outline-1 outline-n-container">
        <span class="text-sm text-slate-700"><%= display_name %></span>
        <span><%= check_box "enabled_features", "feature_#{feature_key}", { checked: val, class: "h-4 w-4 rounded border-slate-300 text-indigo-600 focus:ring-indigo-600" }, true, false %></span>
      </div>
    <% end %>
  </div>

  <hr class="my-8 boshadow-sm outline outline-1 outline-n-container">

  <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
    <% premium_features.each do |key_array, val| %>
      <% feature_key, display_name = key_array %>
      <div class="flex items-center justify-between p-3 bg-white rounded-lg shadow-sm outline outline-1 outline-n-container">
        <div class="flex items-center gap-2">
          <span class="text-amber-500">
            <svg class="h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M480 224l-186.828 7.487L401.688 64l-59.247-32L256 208 169.824 32l-59.496 32 108.5 167.487L32 224v64l185.537-10.066L113.65 448l55.969 32L256 304l86.381 176 55.949-32-103.867-170.066L480 288z" fill="currentColor"/></svg>
          </span>
          <span class="text-sm text-slate-700"><%= display_name %></span>
        </div>
        <% should_disable = ChatwootHub.pricing_plan == 'community' %>
        <span><%= check_box "enabled_features", "feature_#{feature_key}", { checked: val, disabled: should_disable, class: "h-4 w-4 rounded border-slate-300 text-indigo-600 focus:ring-indigo-600" }, true, false %></span>
      </div>
    <% end %>
  </div>
</div>

================
File: views/fields/account_features_field/_show.html.erb
================
<div class="w-full">
  <% regular_features, premium_features = SuperAdmin::AccountFeaturesHelper.partition_features(field.data) %>

  <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
    <% regular_features.each do |key_array, val| %>
      <% feature_key, display_name = key_array %>
      <div class="flex items-center justify-between p-3 bg-white rounded-md outline outline-n-container outline-1 shadow-sm">
        <span class="text-sm text-n-slate-12"><%= display_name %></span>
        <span class="<%= val.present? ? 'bg-green-400 text-white': 'bg-slate-50 text-slate-800' %> rounded-full p-1 inline-flex right-4 top-5">
          <svg width="12" height="12"><use xlink:href="#icon-tick-line" /></svg>
        </span>
      </div>
    <% end %>
  </div>

  <hr class="my-8 border-t border-n-weak">

  <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
    <% premium_features.each do |key_array, val| %>
      <% feature_key, display_name = key_array %>
      <div class="flex items-center justify-between p-3 bg-white rounded-md outline outline-n-container outline-1 shadow-sm">
        <div class="flex items-center gap-2">
          <span class="bg-n-amber-3 text-n-amber-12 rounded-full p-1 inline-flex right-4 top-5">
            <svg width="12" height="12"><use xlink:href="#icon-lock-line" /></svg>
          </span>
          <span class="text-sm text-n-slate-12"><%= display_name %></span>
        </div>
        <span class="<%= val.present? ? 'bg-green-400 text-white': 'bg-slate-50 text-slate-800' %> rounded-full p-1 inline-flex right-4 top-5">
          <svg width="12" height="12"><use xlink:href="#icon-tick-line" /></svg>
        </span>
      </div>
    <% end %>
  </div>
</div>

================
File: views/fields/account_limits_field/_form.html.erb
================
<div class="field-unit__label">
  <%= f.label field.attribute %>
</div>
<div class="field-unit__field">

  <% JSON.parse(field.to_s).each do |key,val| %>
    <%= key %>: <%= number_field "account[limits]", key, value: val %> </br>
  <% end %>
</div>

================
File: views/fields/account_limits_field/_index.html.erb
================
<%= field.to_s %>

================
File: views/fields/account_limits_field/_show.html.erb
================
<% JSON.parse(field.to_s).each do |k,v| %>
<%= k %>: <%= v %> </br>
<% end %>

================
File: views/fields/avatar_field/_index.html.erb
================
<%= image_tag field.avatar_url if field.avatar_url.present? %>

================
File: views/fields/avatar_field/_show.html.erb
================
<%= image_tag field.avatar_url if field.avatar_url.present? %>

================
File: views/fields/belongs_to/_form.html.erb
================
<%#
# BelongsTo Form Partial

This partial renders an input element for belongs_to relationships.
By default, the input is a collection select box
that displays all possible records to associate with.

## Local variables:

- `f`:
  A Rails form generator, used to help create the appropriate input fields.
- `field`:
  An instance of [Administrate::Field::BelongsTo][1].
  Contains helper methods for displaying a collection select box.

[1]: http://www.rubydoc.info/gems/administrate/Administrate/Field/BelongsTo
%>

<div class="field-unit__label">
  <%= f.label field.permitted_attribute %>
</div>
<div class="field-unit__field">
  <%= f.select(field.permitted_attribute,
               options_for_select(field.associated_resource_options, field.selected_option),
               include_blank: field.include_blank_option) %>
</div>

================
File: views/fields/belongs_to/_index.html.erb
================
<%#
# BelongsTo Index Partial

This partial renders a belongs_to relationship,
to be displayed on a resource's index page.

By default, the relationship is rendered as a link to the associated object.

## Local variables:

- `field`:
  An instance of [Administrate::Field::BelongsTo][1].
  A wrapper around the belongs_to relationship pulled from the database.

[1]: http://www.rubydoc.info/gems/administrate/Administrate/Field/BelongsTo
%>

<% if field.data %>
  <% if field.data.is_a? User %>
    <%= link_to(
      field.display_associated_resource,
      super_admin_user_path(field.data),
    ) %>
  <% elsif existing_action?(field.associated_class, :show) %>
    <%= link_to(
      field.display_associated_resource,
      [namespace, field.data],
    ) %>
  <% else %>
    <%= field.display_associated_resource %>
  <% end %>
<% end %>

================
File: views/fields/belongs_to/_show.html.erb
================
<%#
# BelongsTo Show Partial

This partial renders a belongs_to relationship,
to be displayed on a resource's show page.

By default, the relationship is rendered as a link to the associated object.

## Local variables:

- `field`:
  An instance of [Administrate::Field::BelongsTo][1].
  A wrapper around the belongs_to relationship pulled from the database.

[1]: http://www.rubydoc.info/gems/administrate/Administrate/Field/BelongsTo
%>

<% if field.data %>
  <% if existing_action?(field.associated_class, :show) %>
    <%= link_to(
      field.display_associated_resource,
      [namespace, field.data],
    ) %>
  <% else %>
    <%= field.display_associated_resource %>
  <% end %>
<% end %>

================
File: views/fields/belongs_to_search/_index.html.erb
================
<%#
# BelongsToSearch Index Partial

This partial renders a belongs_to relationship,
to be displayed on a resource's index page.

By default, the relationship is rendered as a link to the associated object.

## Local variables:

- `field`:
  An instance of Administrate::Field::BelongsToSearch.
  A wrapper around the belongs_to relationship pulled from the database.
%>

<% if field.data %>
  <% if field.data.is_a? User %>
    <%= link_to(
      field.display_associated_resource,
      super_admin_user_path(field.data),
    ) %>
  <% elsif existing_action?(field.associated_class, :show) %>
    <%= link_to(
      field.display_associated_resource,
      [namespace, field.data],
    ) %>
  <% end %>
<% end %>

================
File: views/fields/count_field/_index.html.erb
================
<%= field.to_s %>

================
File: views/fields/count_field/_show.html.erb
================
<%= field.to_s %>

================
File: views/fields/polymorphic/_form.html.erb
================
<%#
# Polymorphic Form Partial

This partial renders an input element for polymorphic relationships.

## Local variables:

- `f`:
  A Rails form generator, used to help create the appropriate input fields.
- `field`:
  An instance of [Administrate::Field::Polymorphic][1].
  A wrapper around the polymorphic belongs_to relationship
  pulled from the database.

[1]: http://www.rubydoc.info/gems/administrate/Administrate/Field/Polymorphic
%>

<%= f.fields_for field.attribute do |pf| %>
  <div class="field-unit__label">
    <%= pf.label :value, field.name.humanize %>
  </div>

  <div class="field-unit__field">
    <%= pf.hidden_field(:type, value: field.class.name) %>
    <%= pf.select(:value) do %>
      <%= grouped_options_for_select(field.associated_resource_grouped_options, field.selected_global_id, prompt: true) %>
    <% end %>
  </div>
<% end %>

================
File: views/fields/polymorphic/_index.html.erb
================
<%#
# Polymorphic Index Partial

This partial renders a polymorphic relationship,
to be displayed on a resource's index page.

By default, the relationship is rendered as a link to the associated object.

## Local variables:

- `field`:
  An instance of [Administrate::Field::Polymorphic][1].
  A wrapper around the polymorphic belongs_to relationship
  pulled from the database.

[1]: http://www.rubydoc.info/gems/administrate/Administrate/Field/Polymorphic
%>

<% if field.data %>
  <% if field.data.is_a? User %>
    <%= link_to(
      "User ##{field.data.id}",
      super_admin_user_path(field.data)
    ) %>
  <% else %>
    <%= link_to(
      field.display_associated_resource,
      [namespace, field.data]
    ) %>
  <% end %>
<% end %>

================
File: views/fields/polymorphic/_show.html.erb
================
<%#
# Polymorphic Show Partial

This partial renders a polymorphic relationship,
to be displayed on a resource's show page.

By default, the relationship is rendered as a link to the associated object.

## Local variables:

- `field`:
  An instance of [Administrate::Field::Polymorphic][1].
  A wrapper around the polymorphic belongs_to relationship
  pulled from the database.

[1]: http://www.rubydoc.info/gems/administrate/Administrate/Field/Polymorphic
%>

<% if field.data %>
  <% if existing_action?(field.data.class, :show) %>
    <%= link_to(
      field.display_associated_resource,
      [namespace, field.data],
    ) %>
  <% else %>
    <%= field.display_associated_resource %>
  <% end %>
<% end %>

================
File: views/fields/secret_field/_index.html.erb
================
<%#
# SecretField Index Partial
%>
<%= javascript_include_tag "secretField" %>
<div data-secret-text="<%= field.data %>" class="cell-data__secret-field">
  <span data-secret-masked="true"></span>
  <button onclick="toggleSecretField(event)" data-secret-toggler>
    <svg width="20" height="20">
      <use xlink:href="#eye-show" />
    </svg>
  </button>
  <button onclick="copySecretField(event)" data-secret-copier>
    <svg width="20" height="20">
      <use xlink:href="#icon-copy" />
    </svg>
  </button>
</div>

================
File: views/fields/secret_field/_show.html.erb
================
<%#
# SecretField Show Partial
%>
<%= javascript_include_tag "secretField" %>

<div data-secret-text="<%= field.data %>" class="cell-data__secret-field">
  <span data-secret-masked="true"></span>
  <button onclick="toggleSecretField(event)" data-secret-toggler>
    <svg width="20" height="20">
      <use xlink:href="#eye-show" />
    </svg>
  </button>
  <button onclick="copySecretField(event)" data-secret-copier>
    <svg width="20" height="20">
      <use xlink:href="#icon-copy" />
    </svg>
  </button>
</div>

================
File: views/fields/serialized_field/_form.html.erb
================
<div class="field-unit field-unit--string">
  <%= f.label field.attribute, class: "field-unit__label" %>
  <div class="field-unit__field">
    <% if field.array? %>
      <% field.data.each do |sub_field| %>
        <%= f.fields_for "#{field.attribute}[]", field.resource do |values_form| %>
          <div class="field-unit">
            <% sub_field.each do |sf_key, sf_value| %>
              <%= values_form.label sf_key %>
              <%= values_form.text_field sf_key, value: sf_value, disabled: true %>
            <% end %>
          </div>
        <% end %>
      <% end %>
    <% else %>
      <%= f.text_field field.attribute %>
    <% end %>
  </div>
</div>

================
File: views/fields/serialized_field/_index.html.erb
================
<% if field.array? %>
  <% field.data.each do |sub_field| %>
    <div> 
      <%= sub_field.to_s %>
    </div>
  <% end %>
<% else %>
  <%= field.to_s %>
<% end %>

================
File: views/fields/serialized_field/_show.html.erb
================
<% if field.array? %>
  <% field.data.each do |sub_field| %>
    <div> 
      <%= sub_field.to_s %>
    </div>
  <% end %>
<% else %>
  <%= field.to_s %>
<% end %>

================
File: views/icons/_check-mark.html.erb
================
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M12.2121 5L5.87879 11.3333L3 8.45455" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>

================
File: views/icons/_chevron-down.html.erb
================
<svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M3 4.5L6 7.5L9 4.5" stroke-linecap="round" stroke-linejoin="round"/>
</svg>

================
File: views/icons/_chevron-right.html.erb
================
<svg
  class="w-4 h-4 fill-current text-slate-500 dark:text-slate-400"
  width="24"
  height="24"
  fill="none"
  viewBox="0 0 24 24"
  xmlns="http://www.w3.org/2000/svg">
    <path
      d="M8.47 4.22a.75.75 0 0 0 0 1.06L15.19 12l-6.72 6.72a.75.75 0 1 0 1.06 1.06l7.25-7.25a.75.75 0 0 0 0-1.06L9.53 4.22a.75.75 0 0 0-1.06 0Z"
    />
</svg>

================
File: views/icons/_globe.html.erb
================
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M8.00062 13.5557C11.0689 13.5557 13.5562 11.0684 13.5562 8.00014C13.5562 4.93189 11.0689 2.44458 8.00062 2.44458C4.93237 2.44458 2.44507 4.93189 2.44507 8.00014C2.44507 11.0684 4.93237 13.5557 8.00062 13.5557Z" stroke-width="1.11111" stroke-linecap="round" stroke-linejoin="round"/>
<path d="M2.44507 8H13.5562" stroke-width="1.11111" stroke-linecap="round" stroke-linejoin="round"/>
<path d="M8.00054 2.44458C9.39014 3.96589 10.1798 5.94015 10.2228 8.00014C10.1798 10.0601 9.39014 12.0344 8.00054 13.5557C6.61094 12.0344 5.82124 10.0601 5.77832 8.00014C5.82124 5.94015 6.61094 3.96589 8.00054 2.44458Z" stroke-width="1.11111" stroke-linecap="round" stroke-linejoin="round"/>
</svg>

================
File: views/icons/_monitor.html.erb
================
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M12 4H4C3.44772 4 3 4.44773 3 5.00002V10.0001C3 10.5524 3.44772 11.0002 4 11.0002H12C12.5523 11.0002 13 10.5524 13 10.0001V5.00002C13 4.44773 12.5523 4 12 4Z" stroke-width="1.00001" stroke-linecap="round" stroke-linejoin="round"/>
<path d="M6 13H10" stroke-width="1.00001" stroke-linecap="round" stroke-linejoin="round"/>
<path d="M8 11V13" stroke-width="1.00001" stroke-linecap="round" stroke-linejoin="round"/>
</svg>

================
File: views/icons/_moon.html.erb
================
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M8 3C7.33696 3.66304 6.96447 4.56232 6.96447 5.5C6.96447 6.43768 7.33696 7.33696 8 8C8.66304 8.66304 9.56232 9.03553 10.5 9.03553C11.4377 9.03553 12.337 8.66304 13 8C13 8.9889 12.7068 9.9556 12.1573 10.7778C11.6079 11.6001 10.827 12.241 9.91342 12.6194C8.99979 12.9978 7.99446 13.0969 7.02455 12.9039C6.05465 12.711 5.16373 12.2348 4.46447 11.5355C3.76521 10.8363 3.289 9.94535 3.09608 8.97545C2.90315 8.00555 3.00217 7.00021 3.3806 6.08658C3.75904 5.17295 4.39991 4.39206 5.22215 3.84265C6.0444 3.29324 7.01109 3 8 3Z" stroke-width="1.11111" stroke-linecap="round" stroke-linejoin="round"/>
</svg>

================
File: views/icons/_palette.html.erb
================
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M8.90217 5.00111C9.06792 5.00111 9.20229 4.86675 9.20229 4.701C9.20229 4.53525 9.06792 4.40088 8.90217 4.40088C8.73642 4.40088 8.60205 4.53525 8.60205 4.701C8.60205 4.86675 8.73642 5.00111 8.90217 5.00111Z" stroke-width="1.20047" stroke-linecap="round" stroke-linejoin="round"/>
<path d="M11.3035 7.40199C11.4693 7.40199 11.6037 7.26763 11.6037 7.10188C11.6037 6.93612 11.4693 6.80176 11.3035 6.80176C11.1378 6.80176 11.0034 6.93612 11.0034 7.10188C11.0034 7.26763 11.1378 7.40199 11.3035 7.40199Z" stroke-width="1.20047" stroke-linecap="round" stroke-linejoin="round"/>
<path d="M5.90119 5.60121C6.06694 5.60121 6.20131 5.46684 6.20131 5.30109C6.20131 5.13534 6.06694 5.00098 5.90119 5.00098C5.73544 5.00098 5.60107 5.13534 5.60107 5.30109C5.60107 5.46684 5.73544 5.60121 5.90119 5.60121Z" stroke-width="1.20047" stroke-linecap="round" stroke-linejoin="round"/>
<path d="M4.701 8.60268C4.86675 8.60268 5.00111 8.46831 5.00111 8.30256C5.00111 8.13681 4.86675 8.00244 4.701 8.00244C4.53525 8.00244 4.40088 8.13681 4.40088 8.30256C4.40088 8.46831 4.53525 8.60268 4.701 8.60268Z" stroke-width="1.20047" stroke-linecap="round" stroke-linejoin="round"/>
<path d="M8.00235 2C4.70106 2 2 4.70106 2 8.00234C2 11.3036 4.70106 14.0047 8.00235 14.0047C8.55816 14.0047 8.99153 13.5569 8.99153 12.9915C8.99153 12.7292 8.88349 12.4903 8.72923 12.3162C8.55516 12.1428 8.46633 11.9249 8.46633 11.641C8.46405 11.5089 8.48839 11.3776 8.5379 11.2552C8.58741 11.1327 8.66107 11.0214 8.7545 10.9279C8.84793 10.8345 8.9592 10.7609 9.0817 10.7114C9.2042 10.6618 9.33541 10.6375 9.46752 10.6398H10.6656C12.4969 10.6398 13.9999 9.13739 13.9999 7.30607C13.9837 4.40814 11.2802 2 8.00235 2Z" stroke-width="1.20047" stroke-linecap="round" stroke-linejoin="round"/>
</svg>

================
File: views/icons/_redirect.html.erb
================
<svg width="15" height="16" viewBox="0 0 15 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M6.5 3H3.5C2.94772 3 2.5 3.44772 2.5 4V12C2.5 12.5523 2.94772 13 3.5 13H11.5C12.0523 13 12.5 12.5523 12.5 12V9" stroke-width="1.2" stroke-linecap="round"/>
<path d="M9.5 3H12.3C12.4105 3 12.5 3.08954 12.5 3.2V6" stroke-linecap="round"/>
<path d="M12 3.5L6 9.5" stroke-width="1.2" stroke-linecap="round"/>
</svg>

================
File: views/icons/_sun.html.erb
================
<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M8.0001 10.3998C9.32559 10.3998 10.4001 9.32529 10.4001 7.99982C10.4001 6.67436 9.32559 5.59985 8.0001 5.59985C6.67462 5.59985 5.6001 6.67436 5.6001 7.99982C5.6001 9.32529 6.67462 10.3998 8.0001 10.3998Z" stroke-width="1.19999" stroke-linecap="round" stroke-linejoin="round"/>
<path d="M8 2V3.19998" stroke-width="1.19999" stroke-linecap="round" stroke-linejoin="round"/>
<path d="M8 12.8V14" stroke-width="1.19999" stroke-linecap="round" stroke-linejoin="round"/>
<path d="M3.75806 3.75781L4.60406 4.6038" stroke-width="1.19999" stroke-linecap="round" stroke-linejoin="round"/>
<path d="M11.396 11.3958L12.242 12.2417" stroke-width="1.19999" stroke-linecap="round" stroke-linejoin="round"/>
<path d="M2 7.99976H3.2" stroke-width="1.19999" stroke-linecap="round" stroke-linejoin="round"/>
<path d="M12.8 7.99976H14.0001" stroke-width="1.19999" stroke-linecap="round" stroke-linejoin="round"/>
<path d="M4.60406 11.3958L3.75806 12.2417" stroke-width="1.19999" stroke-linecap="round" stroke-linejoin="round"/>
<path d="M12.242 3.75781L11.396 4.6038" stroke-width="1.19999" stroke-linecap="round" stroke-linejoin="round"/>
</svg>

================
File: views/icons/_user.html.erb
================
<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 12 12"><path fill="" d="M6 1a2 2 0 1 0 0 4a2 2 0 0 0 0-4Zm2.5 5h-5A1.5 1.5 0 0 0 2 7.5c0 1.116.459 2.01 1.212 2.615C3.953 10.71 4.947 11 6 11c1.053 0 2.047-.29 2.788-.885C9.54 9.51 10 8.616 10 7.5A1.5 1.5 0 0 0 8.5 6Z"/></svg>

================
File: views/installation/onboarding/index.html.erb
================
<!DOCTYPE html>
<html>
  <head>
    <title>SuperAdmin | Chatwoot</title>
    <%= vite_client_tag %>
    <%= vite_javascript_tag 'superadmin' %>
  </head>
  <body>
    <div class="h-full w-full antialiased">
      <main class="flex flex-col bg-woot-25 min-h-screen w-full py-20 sm:px-6 lg:px-8 dark:bg-slate-900">
        <section class="max-w-5xl mx-auto">
          <img src="/brand-assets/logo.svg" alt="Chatwoot" class="mx-auto h-8 w-auto block dark:hidden">
          <img src="/brand-assets/logo_dark.svg" alt="Chatwoot" class="mx-auto h-8 w-auto hidden dark:block">
          <h2 class="mt-6 text-center text-3xl font-medium text-slate-900 dark:text-woot-50">
            Howdy, Welcome to Chatwoot 
          </h2>
        </section>
        <section class="bg-white shadow sm:mx-auto mt-11 sm:w-full sm:max-w-lg dark:bg-slate-800 p-11 sm:shadow-lg sm:rounded-lg mb-8 mt-15">
          <div>
            <%= form_tag('/installation/onboarding') do %>
            <div class="space-y-5">
              <% if flash[:error].present? %>
                <div class="rounded-md bg-red-500 p-4 text-white text-sm mb-5"><%= flash[:error] %></div>
              <% end %>

              <div>
                <label for="name" class="flex justify-between text-sm font-medium leading-6 text-slate-900 dark:text-white">
                  Name
                </label>
                <div class="mt-1">
                  <%= text_field :user, :name, placeholder: "Enter your full name. eg: Bruce Wayne", required: true, class: "block w-full rounded-md border-0 px-3 py-3 appearance-none shadow-sm ring-1 ring-inset text-slate-900 dark:text-slate-100 placeholder:text-slate-400 focus:ring-2 focus:ring-inset focus:ring-woot-500 sm:text-sm sm:leading-6 outline-none dark:bg-slate-700 dark:ring-slate-600 dark:focus:ring-woot-500 ring-slate-200" %>
                </div>
              </div>

              <div>
                <label for="name" class="flex justify-between text-sm font-medium leading-6 text-slate-900 dark:text-white">
                  Company Name
                </label>
                <div class="mt-1">
                  <%= text_field :user, :company, placeholder: "Enter your company name. eg: Wayne Enterprises", required: true, class: "block w-full rounded-md border-0 px-3 py-3 appearance-none shadow-sm ring-1 ring-inset text-slate-900 dark:text-slate-100 placeholder:text-slate-400 focus:ring-2 focus:ring-inset focus:ring-woot-500 sm:text-sm sm:leading-6 outline-none dark:bg-slate-700 dark:ring-slate-600 dark:focus:ring-woot-500 ring-slate-200" %>
                </div>
              </div>

              <div>
                <label for="name" class="flex justify-between text-sm font-medium leading-6 text-slate-900 dark:text-white">
                  Work Email
                </label>
                <div class="mt-1">
                  <%= email_field :user, :email, placeholder: "Enter your work email address. eg: bruce@wayne.enterprises", required: true, class: "block w-full rounded-md border-0 px-3 py-3 appearance-none shadow-sm ring-1 ring-inset text-slate-900 dark:text-slate-100 placeholder:text-slate-400 focus:ring-2 focus:ring-inset focus:ring-woot-500 sm:text-sm sm:leading-6 outline-none dark:bg-slate-700 dark:ring-slate-600 dark:focus:ring-woot-500 ring-slate-200" %>
                </div>
              </div>

              <div>
                <label for="name" class="flex justify-between text-sm font-medium leading-6 text-slate-900 dark:text-white">
                  Password
                </label>
                <div class="mt-1">
                  <%= password_field :user, :password, placeholder: "Enter a password with 6 characters or more.", required: true, class: "block w-full rounded-md border-0 px-3 py-3 appearance-none shadow-sm ring-1 ring-inset text-slate-900 dark:text-slate-100 placeholder:text-slate-400 focus:ring-2 focus:ring-inset focus:ring-woot-500 sm:text-sm sm:leading-6 outline-none dark:bg-slate-700 dark:ring-slate-600 dark:focus:ring-woot-500 ring-slate-200" %>
                </div>
              </div>

              <div class="text-sm text-slate-900">
                <%= check_box_tag "subscribe_to_updates", 'true', true %>
                <label class="ml-2" for="subscribe_to_updates">
                  Subscribe to release notes, newsletters & product feedback surveys.
                </label>
              </div>

              <button type="submit" class="flex items-center w-full justify-center rounded-md bg-woot-500 py-3 px-3 text-base font-medium text-white shadow-sm hover:bg-woot-600 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-woot-500 cursor-pointer">
                Finish Setup
              </button>
            </div>
            <% end %>
          </div>
        </section>
      </main>
    </div>
  </body>
</html>

================
File: views/layouts/mailer/base.liquid
================
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; box-sizing: border-box; font-size: 14px; margin: 0;">
  <head>
    <meta name="viewport" content="width=device-width" />
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title></title>
    <style type="text/css">
      img {
        max-width: 100%;
      }

      body {
        -webkit-font-smoothing: antialiased;
        -webkit-text-size-adjust: none;
        height: 100%;
        line-height: 1.6em;
        width: 100% !important;
      }

      body {
        background-color: #F8FAFC;
      }

      @media only screen and (max-width: 640px) {
        body {
          padding: 0 !important;
        }
        h1 {
          font-size: 22px !important;
          font-weight: 800 !important;
          margin: 20px 0 5px !important;
        }
        h2 {
          font-size: 18px !important;
          font-weight: 800 !important;
          margin: 20px 0 5px !important;
        }
        h3 {
          font-size: 16px !important;
          font-weight: 800 !important;
          margin: 20px 0 5px !important;
        }
        h4 {
          font-weight: 800 !important;
          margin: 20px 0 5px !important;
        }
        .container {
          padding: 0 !important;
          width: 100% !important;
        }
        .content {
          padding: 0 !important;
        }
        .content-wrap {
          padding: 10px !important;
        }
      }
    </style>
  </head>

  <body itemscope itemtype="http://schema.org/EmailMessage" style="font-size: 14px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto,Helvetica,Arial,sans-serif; box-sizing: border-box; font-size: 14px; -webkit-font-smoothing: antialiased; -webkit-text-size-adjust: none; width: 100% !important; height: 100%; line-height: 1.6em; background-color: #F8FAFC; margin: 0;" bgcolor="#F8FAFC">
    <table class="body-wrap" style="width: 100%; background-color: #F8FAFC; margin: 0;" bgcolor="#F8FAFC">
      <tr style="margin: 0;">
        <td class="container" width="600" style="display: block !important; max-width: 600px !important; clear: both !important; margin: 0 auto;" valign="top">
          <div class="content" style="display: block; margin: 0 auto; padding: 20px; text-align:center;">
            <table class="main" width="100%" cellpadding="0" cellspacing="0" itemprop="action" itemscope itemtype="http://schema.org/ConfirmAction" style="border-radius: 6px;  background-color: #fff; text-align:left; margin: 0; border: 1px solid #e9e9e9; border-top:3px solid #0080f8;" bgcolor="#fff">
              <tr style="margin: 0;">
                <td class="content-wrap" style="vertical-align: top; margin: 0; padding: 20px; font-family: -apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Helvetica,Arial,sans-serif;" valign="top">
                  <table width="100%" cellpadding="0" cellspacing="0" style="margin: 0;">
                    {{ content_for_layout }}
                  </table>
                </td>
              </tr>
            </table>
          </div>
          <div class="footer" style="color: #93AFC8; margin: 0; padding: 0 20px 40px; text-align: center">
            <table width="100%" style="margin: 0;">
              <tr style="margin: 0;">
                {% if global_config['BRAND_NAME'] != '' %}
                  <td class="content-block" style="font-family: -apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Helvetica,Arial,sans-serif; vertical-align: top; margin: 0; padding: 0 0 20px;" valign="top">
                    Powered by
                    <a href="{{ global_config['BRAND_URL'] }}" style="vertical-align: top; color: #93AFC8; text-align: center; margin: 0; padding: 0 0 20px;" align="center" valign="top">
                      {{ global_config['BRAND_NAME'] }}
                    </a>
                  </td>
                {% endif %}
              </tr>
            </table>
          </div>
        </td>
      </tr>
    </table>
  </body>
</html>

================
File: views/layouts/super_admin/application.html.erb
================
<%#
# Application Layout

This view template is used as the layout
for every page that Administrate generates.

By default, it renders:
- Navigation
- Content for a search bar
  (if provided by a `content_for` block in a nested page)
- Flashes
- Links to stylesheets and JavaScripts
%>

<!DOCTYPE html>
<html lang="<%= I18n.locale %>" class="w-full h-full">
<head>
  <meta charset="utf-8">
  <meta name="ROBOTS" content="NOODP">
  <meta name="viewport" content="initial-scale=1">
  <title>
    <%= content_for(:title) %> - <%= application_title %>
  </title>
  <%= render "stylesheet" %>
  <%= vite_client_tag %>
  <%= vite_javascript_tag 'superadmin' %>
  <%= csrf_meta_tags %>
</head>
<body class="antialiased w-full h-full">
  <%= render "icons" %>
  <div class="flex w-full h-full">
    <%= render "navigation" -%>
    <main class="w-full overflow-auto" role="main">
      <%= render "flashes" -%>
      <%= yield %>
    </main>
  </div>
  <%= render "javascript" %>
</body>
</html>

================
File: views/layouts/portal.html.erb
================
<%#
# Application Layout

This view template is used as the layout
for every page that Administrate generates.

By default, it renders:
- Navigation
- Content for a search bar
  (if provided by a `content_for` block in a nested page)
- Flashes
- Links to stylesheets and JavaScripts
- The appearance dropdown styles are added to the top to prevent FOUC
%>

<!DOCTYPE html>
<html lang="<%= I18n.locale %>">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="initial-scale=1">
    <meta name= "turbolinks-cache-control" content= "no-cache">
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <%= vite_client_tag %>
    <%= vite_javascript_tag 'portal' %>
    <style>
      #appearance-dropdown[data-current-theme="system"] .check-mark-icon.light-theme,
      #appearance-dropdown[data-current-theme="system"] .check-mark-icon.dark-theme,
      #appearance-dropdown[data-current-theme="dark"] .check-mark-icon.light-theme,
      #appearance-dropdown[data-current-theme="dark"] .check-mark-icon.system-theme,
      #appearance-dropdown[data-current-theme="light"] .check-mark-icon.dark-theme,
      #appearance-dropdown[data-current-theme="light"] .check-mark-icon.system-theme {
        display: none;
      }
    </style>
    <%= csrf_meta_tags %>
    <% if content_for?(:head) %>
      <%= yield(:head) %>
    <% else %>
      <title><%= @portal.page_title%></title>
    <% end %>

    <% unless @theme_from_params.blank? %>
    <%# this adds the theme from params, ensuring that there a localstorage value set %>
    <%# this will further trigger the next script to ensure color mode is toggled without a FOUC %>
    <script>localStorage.theme = '<%= @theme_from_params %>';</script>
    <% end %>

    <script>
      if (localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
        // we can use document.body here but that would mean pushing this script inside the body
        // since the body is not created yet. This is done to avoid FOUC, at a tiny cost of Time to Interactive
        document.documentElement.classList.add('dark')
      } else {
        document.documentElement.classList.remove('dark')
        document.documentElement.classList.add('light')
      }
    </script>
  </head>
  <body>
    <div id="portal" class="antialiased">
      <main class="flex flex-col min-h-screen bg-white main-content dark:bg-slate-900" role="main">
        <% if !@is_plain_layout_enabled %>
          <%= render "public/api/v1/portals/header", portal: @portal %>
        <% end %>
        <%= yield %>
        <% if !(@is_plain_layout_enabled || @portal.account.feature_enabled?('disable_branding')) %>
          <%= render "public/api/v1/portals/footer" %>
        <% end %>
      </main>
    </div>
  </body>
  <style>
  html.dark {
    --dynamic-portal-bg: <%= generate_portal_bg(@portal.color, 'dark') %>;
    --dynamic-portal-bg-gradient: <%= generate_gradient_to_bottom('dark') %>;
    --dynamic-hover-bg-color: <%= generate_portal_hover_color(@portal.color , 'dark') %>;
  }

  html.light {
    --dynamic-portal-bg: <%= generate_portal_bg(@portal.color, 'light') %>;
    --dynamic-portal-bg-gradient: <%= generate_gradient_to_bottom('light') %>;
    --dynamic-hover-bg-color: <%= generate_portal_hover_color(@portal.color , 'light') %>;
  }

  /* Portal background */
  #portal-bg {
    background: var(--dynamic-portal-bg);
  }
  /* Portal background gradient */
  #portal-bg-gradient {
    background-image: var(--dynamic-portal-bg-gradient);
  }
  /* Category block item hover color */
  #category-item:hover {
    background-color: var(--dynamic-hover-bg-color);
  }

  /* Header section */
  #header-action-button:hover,
  #toggle-appearance:hover,
  #toggle-theme-button:hover {
    color: var(--dynamic-hover-color);
    stroke: var(--dynamic-hover-color);
  }
  #category-block:hover {
    border-color: var(--dynamic-hover-color);
  }
  #category-block:hover #category-name  {
    color: var(--dynamic-hover-color);
  }
  </style>

  <script>
    window.portalConfig = {
      portalSlug: '<%= @portal.slug %>',
      portalColor: '<%= @portal.color %>',
      theme: '<%= @theme_from_params %>',
      customDomain: '<%= @portal.custom_domain %>',
      hostURL: '<%= ENV.fetch('FRONTEND_URL', '') %>',
      localeCode: '<%= @locale %>',
      searchTranslations: {
        searchPlaceholder: '<%= I18n.t('public_portal.search.search_placeholder') %>',
        emptyPlaceholder: '<%= I18n.t('public_portal.search.empty_placeholder') %>',
        loadingPlaceholder: '<%= I18n.t('public_portal.search.loading_placeholder') %>',
        resultsTitle: '<%= I18n.t('public_portal.search.results_title') %>',
      },
      isPlainLayoutEnabled: '<%= @is_plain_layout_enabled %>',
      tocHeader: '<%= I18n.t('public_portal.toc_header') %>'
    };
  </script>
  <% if @portal.channel_web_widget.present? && !@is_plain_layout_enabled %>
  <%= @portal.channel_web_widget.web_widget_script.html_safe %>
  <% end %>
</html>

================
File: views/layouts/vueapp.html.erb
================
<!DOCTYPE html>
<html>
  <head>
    <title>
      <%= @global_config['INSTALLATION_NAME'] %>
    </title>
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no, user-scalable=0"/>
    <% if @global_config['DISPLAY_MANIFEST'] %>
      <meta name="msapplication-TileColor" content="#1f93ff">
      <meta name="msapplication-TileImage" content="/ms-icon-144x144.png">
      <meta name="theme-color" content="#1f93ff">
      <meta name="description" content="Chatwoot is a customer support solution that helps companies engage customers over Messenger, Twitter, Telegram, WeChat, Whatsapp. Simply connect your channels and converse with your customers from a single place. Easily add new agents to your system and have them own and resolve conversations with customers.Chatwoot also gives you real-time reports to measure your team's performance, canned responses to easily respond to frequently asked questions and private notes for agents to collaborate among themselves.">
      <% if ENV['IOS_APP_IDENTIFIER'].present? %>
        <meta name="apple-itunes-app" content='app-id=<%= ENV['IOS_APP_IDENTIFIER'] %>'>
      <% end %>
      <link rel="apple-touch-icon" sizes="57x57" href="/apple-icon-57x57.png">
      <link rel="apple-touch-icon" sizes="60x60" href="/apple-icon-60x60.png">
      <link rel="apple-touch-icon" sizes="72x72" href="/apple-icon-72x72.png">
      <link rel="apple-touch-icon" sizes="76x76" href="/apple-icon-76x76.png">
      <link rel="apple-touch-icon" sizes="114x114" href="/apple-icon-114x114.png">
      <link rel="apple-touch-icon" sizes="120x120" href="/apple-icon-120x120.png">
      <link rel="apple-touch-icon" sizes="144x144" href="/apple-icon-144x144.png">
      <link rel="apple-touch-icon" sizes="152x152" href="/apple-icon-152x152.png">
      <link rel="apple-touch-icon" sizes="180x180" href="/apple-icon-180x180.png">
      <link rel="icon" type="image/png" sizes="192x192"  href="/android-icon-192x192.png">
      <link class="favicon" rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
      <link class="favicon" rel="icon" type="image/png" sizes="96x96" href="/favicon-96x96.png">
      <link class="favicon" rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
      <link rel="manifest" href="/manifest.json">
    <% end %>
    <link rel="icon" type="image/png" sizes="512x512" href="<%= @global_config['LOGO_THUMBNAIL'] %>">
    <%= csrf_meta_tags %>
    <script>
      window.chatwootConfig = {
        hostURL: '<%= ENV.fetch('FRONTEND_URL', '') %>',
        helpCenterURL: '<%= ENV.fetch('HELPCENTER_URL', '') %>',
        fbAppId: '<%= @global_config['FB_APP_ID'] %>',
        googleOAuthClientId: '<%= ENV.fetch('GOOGLE_OAUTH_CLIENT_ID', nil) %>',
        googleOAuthCallbackUrl: '<%= ENV.fetch('GOOGLE_OAUTH_CALLBACK_URL', nil) %>',
        fbApiVersion: '<%= @global_config['FACEBOOK_API_VERSION'] %>',
        signupEnabled: '<%= @global_config['ENABLE_ACCOUNT_SIGNUP'] %>',
        isEnterprise: '<%= @global_config['IS_ENTERPRISE'] %>',
        <% if @global_config['IS_ENTERPRISE'] %>
        enterprisePlanName: '<%= @global_config['INSTALLATION_PRICING_PLAN'] %>',
        <% end %>
        <% if @global_config['VAPID_PUBLIC_KEY'] %>
        vapidPublicKey: new Uint8Array(<%= Base64.urlsafe_decode64(@global_config['VAPID_PUBLIC_KEY']).bytes %>),
        <% end %>
        enabledLanguages: <%= available_locales_with_name.to_json.html_safe %>,
        helpUrls: <%= feature_help_urls.to_json.html_safe %>,
        selectedLocale: '<%= I18n.locale %>'
      }
      window.globalConfig = <%= raw @global_config.to_json %>
      window.browserConfig = {
        browser_name: '<%= browser.name %>',
      }
      window.errorLoggingConfig = '<%= ENV.fetch('SENTRY_FRONTEND_DSN', '') || ENV.fetch('SENTRY_DSN', '') %>'
    </script>
    <% if @global_config['ANALYTICS_TOKEN'].present? %>
    <script>
      window.analyticsConfig = {
        token: '<%= @global_config['ANALYTICS_TOKEN'] %>',
      }
    </script>
    <% end %>
    <%= vite_client_tag %>
    <%= vite_javascript_tag @application_pack %>
  </head>
  <body class="text-slate-600">
    <div id="app"></div>
    <noscript id="noscript">This app works best with JavaScript enabled.</noscript>
    <%= yield %>
    <% if @dashboard_scripts.present? %>
      <%= @dashboard_scripts.html_safe %>
    <% end %>
  </body>
</html>

================
File: views/mailers/administrator_notifications/channel_notifications_mailer/automation_rule_disabled.liquid
================
<p>Hello there,</p>

<p>The automation rule <b>{{meta['rule_name']}}</b> has been disabled becuase it has invalid conditions.</p>
<p>This typically happens when you delete any custom attributes which are still being used in automation rules.</p>

<p>
Click <a href="{{action_url}}">here</a> to update the conditions.
</p>

================
File: views/mailers/administrator_notifications/channel_notifications_mailer/contact_export_complete.liquid
================
<p>Hi</p>


<p>Your contact export file is ready to download.</p>

<p>
Click <a href="{{ action_url }}">here</a> to download the export file.
</p>

================
File: views/mailers/administrator_notifications/channel_notifications_mailer/contact_import_complete.liquid
================
<p>Hello,</p>

<p>Your contact import has been completed. Please check the contacts tab to view the imported contacts.</p>

<p>Number of records imported: {{meta['imported_contacts']}}</p>

<p>Number of records failed: {{meta['failed_contacts']}}</p>

{% if meta['failed_contacts'] == 0 %}
  <p>
    Click <a href="{{action_url}}">here</a> to view the imported contacts.
  </p>
{% else %}
  <p>
  Click <a href="{{ action_url }}" target="_blank">here</a> to view failed records.
  </p>
{% endif %}

================
File: views/mailers/administrator_notifications/channel_notifications_mailer/contact_import_failed.liquid
================
<p>Hello,</p>

<p>Your contact import has failed. It appears that the CSV file you uploaded may not be valid. We kindly request that you review the file and ensure it complies with the required format.<p/>

================
File: views/mailers/administrator_notifications/channel_notifications_mailer/dialogflow_disconnect.liquid
================
<p>Hello there,</p>

<p>Your Dialogflow integration was disconnected because of permission issues. To resolve this, please delete the integration from the admin dashboard and reconnect it using new credentials.</p>

================
File: views/mailers/administrator_notifications/channel_notifications_mailer/email_disconnect.liquid
================
<p>Hello,</p>

<p>Your email inbox has been disconnected due to configuration errors. </p>
<p>Please update it to continue receiving messages.</p>

<p>
Click <a href="{{action_url}}">here</a> to re-connect.
</p>

================
File: views/mailers/administrator_notifications/channel_notifications_mailer/facebook_disconnect.liquid
================
<p>Hello,</p>

<p>Your Facebook Inbox Access has expired. </p>
<p>Please reconnect Facebook Page to continue receiving messages.</p>

<p>
Click <a href="{{action_url}}">here</a> to re-connect.
</p>

================
File: views/mailers/administrator_notifications/channel_notifications_mailer/slack_disconnect.liquid
================
<p>Hello,</p>

<p>Your Slack integration has expired. To continue receiving messages on Slack, please delete the integration and connect your workspace again. </p>

<p>
Click <a href="{{action_url}}">here</a> to re-connect.
</p>

================
File: views/mailers/administrator_notifications/channel_notifications_mailer/whatsapp_disconnect.liquid
================
<p>Hello,</p>

<p>Your Whatsapp Access has expired. </p>
<p>Please reconnect Whatsapp to continue receiving messages.</p>

<p>
Click <a href="{{action_url}}">here</a> to re-connect.
</p>

================
File: views/mailers/agent_notifications/conversation_notifications_mailer/assigned_conversation_new_message.liquid
================
<p>Hi {{user.available_name}},</p>

<p>You have received a new message in your assigned conversation.</p>

<p>
Click <a href="{{action_url}}">here</a> to get cracking.
</p>

================
File: views/mailers/agent_notifications/conversation_notifications_mailer/conversation_assignment.liquid
================
<p>Hi {{user.available_name}},</p>

<p>Time to save the world. A new conversation has been assigned to you</p>

{% for chat_message in conversation.recent_messages %}
  <div>
    <h4 style="margin: 0;">
      {% if chat_message.sender == user.available_name %}
        You
      {% else %}
        {{chat_message.sender}}
      {% endif %}
    </h4>
  </div>

  <div style="padding: 10px 20px; margin: 5px 0 20px 0; background: #F2F3F7; border-radius: 10px; display: inline-block; font-family: 'Helvetica Neue',Tahoma,Arial,sans-serif; text-align: start; unicode-bidi: plaintext;">
    {% if chat_message.content %}
      {{chat_message.content}}
    {% endif %}

    {% if chat_message.attachments %}
      {% for attachment in chat_message.attachments %}
        Attachment [<a href="{{ attachment }}" _target="blank">Click here to view</a>]
      {% endfor %}
    {% endif %}
  </div>
{% endfor %}

<p>
Click <a href="{{action_url}}">here</a> to get cracking.
</p>

================
File: views/mailers/agent_notifications/conversation_notifications_mailer/conversation_creation.liquid
================
<p>Hi {{user.available_name}}</p>

<p>
  A new conversation (<a href="{{ action_url }}">#{{conversation.display_id}}</a>) has been created in {{ inbox.name }}.
  <strong>{{ conversation.contact_name }}</strong> wrote:
</p>

{% for chat_message in conversation.recent_messages %}
  <div>
    <h4 style="margin: 0;">
      {% if chat_message.sender == user.available_name %}
        You
      {% else %}
        {{chat_message.sender}}
      {% endif %}
    </h4>
  </div>

  <div style="padding: 10px 20px; margin: 5px 0 20px 0; background: #F2F3F7; border-radius: 10px; display: inline-block; font-family: 'Helvetica Neue',Tahoma,Arial,sans-serif; text-align: start; unicode-bidi: plaintext;">
    {% if chat_message.content %}
      {{chat_message.content}}
    {% endif %}

    {% if chat_message.attachments %}
      {% for attachment in chat_message.attachments %}
        Attachment [<a href="{{ attachment }}" _target="blank">Click here to view</a>]
      {% endfor %}
    {% endif %}
  </div>
{% endfor %}

================
File: views/mailers/agent_notifications/conversation_notifications_mailer/conversation_mention.liquid
================
<p>Hi {{user.available_name}}, </p>

<p>You've been mentioned in a conversation. <b>{{message.sender_display_name}}</b> wrote:</p>
<blockquote style="box-sizing:border-box; padding:8px 16px; margin:0 0 20px; font-size:14px; border-left:5px solid #eeeeee">
  {{message.text_content}}
</blockquote>

<p><b>Previous messages:</b></p>
{% for chat_message in conversation.recent_messages %}
  <div>
    <h4 style="margin: 0;">
      {% if chat_message.sender == user.available_name %}
        You
      {% else %}
        {{chat_message.sender}}
      {% endif %}
    </h4>
  </div>

  <div style="padding: 10px 20px; margin: 5px 0 20px 0; background: #F2F3F7; border-radius: 10px; display: inline-block; font-family: 'Helvetica Neue',Tahoma,Arial,sans-serif; text-align: start; unicode-bidi: plaintext;">
    {% if chat_message.content %}
      {{chat_message.content}}
    {% endif %}

    {% if chat_message.attachments %}
      {% for attachment in chat_message.attachments %}
        Attachment [<a href="{{ attachment }}" _target="blank">Click here to view</a>]
      {% endfor %}
    {% endif %}
  </div>
{% endfor %}
<p>
  <a href="{{ action_url }}">View Message</a>
</p>

================
File: views/mailers/agent_notifications/conversation_notifications_mailer/participating_conversation_new_message.liquid
================
<p>Hi {{user.available_name}},</p>

<p>You have received a new message in a conversation you are participating.</p>

<p>Click <a href="{{action_url}}">here</a> to get cracking.</p>

================
File: views/mailers/agent_notifications/conversation_notifications_mailer/sla_missed_first_response.liquid
================
<p>Hi {{user.available_name}},</p>

<p>
  Conversation #{{conversation.display_id}} in {{ inbox.name }} 
  has missed the SLA for first response  under policy {{ sla_policy.name }}.
</p>

<p>
<a href="{{action_url}}">Please address immediately.</a>
</p>

================
File: views/mailers/agent_notifications/conversation_notifications_mailer/sla_missed_next_response.liquid
================
<p>Hi {{user.available_name}},</p>

<p>
  Conversation #{{conversation.display_id}} in {{ inbox.name }} 
  has missed the SLA for next response under policy {{ sla_policy.name }}..
</p>

<p>
<a href="{{action_url}}">Please address immediately.</a>
</p>

================
File: views/mailers/agent_notifications/conversation_notifications_mailer/sla_missed_resolution.liquid
================
<p>Hi {{user.available_name}},</p>

<p>
  Conversation #{{conversation.display_id}} in {{ inbox.name }} 
  has missed the SLA for resolution time under policy {{ sla_policy.name }}.
</p>

<p>
<a href="{{action_url}}">Please address immediately.</a>
</p>

================
File: views/mailers/conversation_reply_mailer/conversation_transcript.html.erb
================
<% @messages.each do |message| %>
  <tr>
    <td>
      <b><%= message.sender&.try(:available_name) || message.sender&.name || '' %></b>
      <% if message.conversation.inbox&.inbox_type == 'Email' %>
        <div style="font-size: 90%; color: #899096; line-height: 16px">
          <% if message.content_attributes.dig(:email, :from).present? %>
            <div>From: <%= message.content_attributes.dig(:email, :from).join(", ") %></div>
          <% else %>
            <div>From: <%= message.sender&.try(:email) %></div>
          <% end %>

          <% if message.content_attributes.dig(:email, :subject).present? %>
            <div>Subject: <%= message.content_attributes.dig(:email, :subject) %></div>
          <% end %>

          <% if message.content_attributes[:to_emails].present? %>
            <div>To: <%= message.content_attributes[:to_emails].join(", ") %></div>
          <% end %>
          <% if message.content_attributes[:cc_emails].present? %>
            <div>CC: <%= message.content_attributes[:cc_emails].join(", ") %></div>
          <% end %>
          <% if message.content_attributes[:bcc_emails].present? %>
            <div>BCC: <%= message.content_attributes[:bcc_emails].join(", ") %></div>
          <% end %>
        </div>
      <% end %>
    </td>
  </tr>
  <tr>
    <td style="padding-bottom: 32px;">
      <% if message.content %>
        <%= ChatwootMarkdownRenderer.new(message.content).render_message %>
      <% end %>
      <% if message.attachments %>
        <% message.attachments.each do |attachment| %>
          Attachment [<a href="<%= attachment.file_url %>" _target="blank">Click here to view</a>]
        <% end %>
      <% end %>
      <p style="font-size: 90%; font-size: 90%;color: #899096;margin-top: -8px; margin-bottom: 0px;">
      <% if @inbox.timezone.present? %>
        <%= message.created_at.in_time_zone(@inbox.timezone).strftime('%b %d, %I:%M %p %Z') %>
      <% else %>
        <%= message.created_at.strftime('%b %d, %I:%M %p %Z') %>
      <% end %>
      </p>
    </td>
  </tr>
<% end %>

================
File: views/mailers/conversation_reply_mailer/email_reply.html.erb
================
<% if @message.content %>
  <%= ChatwootMarkdownRenderer.new(@message.content).render_message %>
<% end %>
<% if @message.attachments %>
  <% @message.attachments.each do |attachment| %>
    attachment [<a href="<%= attachment.file_url %>" _target="blank">click here to view</a>]
  <% end %>
<% end %>

================
File: views/mailers/conversation_reply_mailer/reply_with_summary.html.erb
================
<p>Hi <%= @contact.name %>,</p>

<p>You have new messages on your conversation.</p>

<% @messages.each do |message| %>
  <tr>
    <td>
      <b><%= message.incoming? ? 'You' : message.sender&.available_name || message.sender&.name || 'Bot' %></b>
    </td>
  </tr>
  <tr>
    <td style="padding: 0px 16px; margin: 4px 0 8px 0; background: #F5FAFF; border-radius: 5px; display: inline-block; font-family: 'Helvetica Neue',Tahoma,Arial,sans-serif; text-align: start; unicode-bidi: plaintext;">
      <% if (message.content_type == 'input_csat' && message.message_type == 'template') %>
        <p>Click <a href="<%= message.conversation.csat_survey_link %>" _target="blank">here</a> to rate the conversation.</p>
      <% elsif message.content.present? %>
        <%= ChatwootMarkdownRenderer.new(message.content).render_message %>
      <% end %>
      <% if message.attachments.count.positive? %>
        <p>
          <% if message.content.present? %>
            <hr style="border: 0; border-bottom: 1px solid #AEC3D5;"/>
          <% end %>
          This message contains <%= message.attachments.count > 1 ? 'attachments' : 'an attachment' %>.
          <% message.attachments.each do |attachment| %>
            <br />- View the attachment <a href="<%= attachment.file_url %>" _target="blank">here</a>.
          <% end %>
        </p>
      <% end %>
    </td>
  </tr>
<% end %>

================
File: views/mailers/conversation_reply_mailer/reply_without_summary.html.erb
================
<% @messages.each do |message| %>
  <p style="font-family: Roboto,"Helvetica Neue",Tahoma,Arial,sans-serif; text-align: start; unicode-bidi: plaintext;">
    <% if message.content %>
      <%= ChatwootMarkdownRenderer.new(message.content).render_message %>
    <% end %>
    <% if message.attachments %>
      <% message.attachments.each do |attachment| %>
        attachment [<a href="<%= attachment.file_url %>" _target="blank">click here to view</a>]
      <% end %>
    <% end %>
  </p>
<% end %>

================
File: views/mailers/team_notifications/automation_notification_mailer/conversation_creation.liquid
================
<p>This is the mail from Automation System</p>

<p>{{ custom_message }}</p>

<p>
Click <a href="{{ action_url }}">here</a> to get cracking.
</p>

================
File: views/mailers/team_notifications/automation_notification_mailer/conversation_updated.liquid
================
<p>Hi {{user.available_name}}</p>


<p>{{ custom_message }}</p>

<p>
Click <a href="{{ action_url }}">here</a> to get cracking.
</p>

================
File: views/mailers/team_notifications/automation_notification_mailer/message_created.liquid
================
<p>Hi {{user.available_name}}</p>


<p>{{ custom_message }}</p>

<p>
Click <a href="{{ action_url }}">here</a> to get cracking.
</p>

================
File: views/microsoft/identity_association.json.jbuilder
================
json.associatedApplications do
  json.array! [@identity_json] do |identity_id|
    json.applicationId identity_id
  end
end

================
File: views/platform/api/v1/accounts/create.json.jbuilder
================
json.partial! 'platform/api/v1/models/account', formats: [:json], resource: @resource

================
File: views/platform/api/v1/accounts/show.json.jbuilder
================
json.partial! 'platform/api/v1/models/account', formats: [:json], resource: @resource

================
File: views/platform/api/v1/accounts/update.json.jbuilder
================
json.partial! 'platform/api/v1/models/account', formats: [:json], resource: @resource

================
File: views/platform/api/v1/agent_bots/avatar.json.jbuilder
================
json.partial! 'platform/api/v1/models/agent_bot', formats: [:json], resource: @resource

================
File: views/platform/api/v1/agent_bots/create.json.jbuilder
================
json.partial! 'platform/api/v1/models/agent_bot', formats: [:json], resource: @resource

================
File: views/platform/api/v1/agent_bots/index.json.jbuilder
================
json.array! @resources do |resource|
  json.partial! 'platform/api/v1/models/agent_bot', formats: [:json], resource: resource.permissible
end

================
File: views/platform/api/v1/agent_bots/show.json.jbuilder
================
json.partial! 'platform/api/v1/models/agent_bot', formats: [:json], resource: @resource

================
File: views/platform/api/v1/agent_bots/update.json.jbuilder
================
json.partial! 'platform/api/v1/models/agent_bot', formats: [:json], resource: @resource

================
File: views/platform/api/v1/models/_account.json.jbuilder
================
json.id resource.id
json.name resource.name
json.locale resource.locale
json.domain resource.domain
json.support_email resource.support_email
json.features resource.enabled_features
json.custom_attributes resource.custom_attributes
json.limits resource.limits
json.status resource.status

================
File: views/platform/api/v1/models/_agent_bot.json.jbuilder
================
json.id resource.id
json.name resource.name
json.description resource.description
json.outgoing_url resource.name
json.account_id resource.account_id
json.access_token resource.access_token.token

================
File: views/platform/api/v1/models/_user.json.jbuilder
================
json.access_token resource.access_token.token
json.account_id resource.active_account_user&.account_id
json.available_name resource.available_name
json.avatar_url resource.avatar_url
json.confirmed resource.confirmed?
json.display_name resource.display_name
json.message_signature resource.message_signature
json.email resource.email
json.id resource.id
json.name resource.name
json.provider resource.provider
json.pubsub_token resource.pubsub_token
json.custom_attributes resource.custom_attributes if resource.custom_attributes.present?
json.role resource.active_account_user&.role
json.ui_settings resource.ui_settings
json.uid resource.uid
json.accounts do
  json.array! resource.account_users do |account_user|
    json.id account_user.account_id
    json.name account_user.account.name
    json.active_at account_user.active_at
    json.role account_user.role
  end
end

================
File: views/platform/api/v1/users/create.json.jbuilder
================
json.partial! 'platform/api/v1/models/user', formats: [:json], resource: @resource

================
File: views/platform/api/v1/users/show.json.jbuilder
================
json.partial! 'platform/api/v1/models/user', formats: [:json], resource: @resource

================
File: views/platform/api/v1/users/update.json.jbuilder
================
json.partial! 'platform/api/v1/models/user', formats: [:json], resource: @resource

================
File: views/public/api/v1/csat_survey/show.json.jbuilder
================
json.partial! 'public/api/v1/models/csat_survey', formats: [:json], resource: @message

================
File: views/public/api/v1/csat_survey/update.json.jbuilder
================
json.partial! 'public/api/v1/models/csat_survey', formats: [:json], resource: @message

================
File: views/public/api/v1/inboxes/contacts/create.json.jbuilder
================
json.source_id @contact_inbox.source_id
json.pubsub_token @contact_inbox.pubsub_token
json.partial! 'public/api/v1/models/contact', resource: @contact_inbox.contact, formats: [:json]

================
File: views/public/api/v1/inboxes/contacts/show.json.jbuilder
================
json.source_id @contact_inbox.source_id
json.pubsub_token @contact_inbox.pubsub_token
json.partial! 'public/api/v1/models/contact', formats: [:json], resource: @contact_inbox.contact

================
File: views/public/api/v1/inboxes/contacts/update.json.jbuilder
================
json.source_id @contact_inbox.source_id
json.pubsub_token @contact_inbox.pubsub_token
json.partial! 'public/api/v1/models/contact', formats: [:json], resource: @contact_inbox.contact

================
File: views/public/api/v1/inboxes/conversations/create.json.jbuilder
================
json.partial! 'public/api/v1/models/conversation', formats: [:json], resource: @conversation

================
File: views/public/api/v1/inboxes/conversations/index.json.jbuilder
================
json.array! @conversations do |conversation|
  json.partial! 'public/api/v1/models/conversation', formats: [:json], resource: conversation
end

================
File: views/public/api/v1/inboxes/conversations/show.json.jbuilder
================
json.partial! 'public/api/v1/models/conversation', formats: [:json], resource: @conversation

================
File: views/public/api/v1/inboxes/conversations/toggle_status.json.jbuilder
================
json.partial! 'public/api/v1/models/conversation', formats: [:json], resource: @conversation

================
File: views/public/api/v1/inboxes/messages/create.json.jbuilder
================
json.partial! 'public/api/v1/models/message', formats: [:json], resource: @message

================
File: views/public/api/v1/inboxes/messages/index.json.jbuilder
================
json.array! @messages do |message|
  json.partial! 'public/api/v1/models/message', formats: [:json], resource: message
end

================
File: views/public/api/v1/inboxes/messages/update.json.jbuilder
================
json.partial! 'public/api/v1/models/message', formats: [:json], resource: @message

================
File: views/public/api/v1/inboxes/show.json.jbuilder
================
json.identifier @inbox_channel.identifier
json.identity_validation_enabled @inbox_channel.hmac_mandatory
json.partial! 'public/api/v1/models/inbox', formats: [:json], resource: @inbox_channel.inbox

================
File: views/public/api/v1/models/hc/_associated_article.json.jbuilder
================
json.id article.id
json.category_id article.category_id
json.title article.title
json.content article.content
json.description article.description
json.status article.status
json.account_id article.account_id
json.last_updated_at article.updated_at
json.views article.views

if article.author.present?
  json.author do
    json.partial! 'public/api/v1/models/hc/author', formats: [:json], resource: article.author
  end
end

================
File: views/public/api/v1/models/hc/_author.json.jbuilder
================
json.available_name resource.available_name
json.name resource.name
json.thumbnail resource.avatar_url

================
File: views/public/api/v1/models/hc/_portal.json.jbuilder
================
json.custom_domain portal.custom_domain
json.header_text portal.header_text
json.homepage_link portal.homepage_link
json.name portal.name
json.page_title portal.page_title
json.slug portal.slug

json.categories do
  if portal.categories.any?
    json.array! portal.categories.each do |category|
      json.partial! 'public/api/v1/models/category', formats: [:json], category: category
    end
  end
end

json.logo portal.file_base_data if portal.logo.present?

json.meta do
  json.articles_count portal.articles.published.size
  json.categories_count portal.categories.size
  json.default_locale portal.default_locale
end

================
File: views/public/api/v1/models/_article.json.jbuilder
================
json.id article.id
json.category_id article.category_id
json.title article.title
json.content article.content
json.description article.description
json.status article.status
json.position article.position
json.account_id article.account_id
json.last_updated_at article.updated_at
json.slug article.slug

if article.portal.present?
  json.portal do
    json.partial! 'public/api/v1/models/hc/portal', formats: [:json], portal: article.portal
  end
end

if article.category.present?
  json.category do
    json.id article.category.id
    json.slug article.category.slug
    json.locale article.category.locale
  end
end

json.views article.views

if article.author.present?
  json.author do
    json.partial! 'public/api/v1/models/hc/author', formats: [:json], resource: article.author
  end
end

json.associated_articles do
  if article.associated_articles.any?
    json.array! article.associated_articles.each do |associated_article|
      json.partial! 'public/api/v1/models/hc/associated_article', formats: [:json], article: associated_article
    end
  end
end

json.link "hc/#{article.portal.slug}/articles/#{article.slug}"

================
File: views/public/api/v1/models/_associated_category.json.jbuilder
================
json.name category.name
json.slug category.slug
json.locale category.locale
json.description category.description
json.position category.position

================
File: views/public/api/v1/models/_category.json.jbuilder
================
json.name category.name
json.slug category.slug
json.locale category.locale
json.description category.description
json.position category.position

json.related_categories do
  if category.related_categories.any?
    json.array! category.related_categories.each do |related_category|
      json.partial! partial: 'public/api/v1/models/associated_category', formats: [:json], category: related_category
    end
  end
end

if category.parent_category.present?
  json.parent_category do
    json.partial! partial: 'public/api/v1/models/associated_category', formats: [:json], category: category.parent_category
  end
end

if category.root_category.present?
  json.root_category do
    json.partial! partial: 'public/api/v1/models/associated_category', formats: [:json], category: category.root_category
  end
end

json.meta do
  json.articles_count category.articles.published.size
end

================
File: views/public/api/v1/models/_contact.json.jbuilder
================
json.id resource.id
json.name resource.name
json.email resource.email
json.phone_number resource.phone_number

================
File: views/public/api/v1/models/_conversation.json.jbuilder
================
json.id resource.display_id
json.uuid resource.uuid
json.inbox_id resource.inbox_id
json.contact_last_seen_at resource.contact_last_seen_at.to_i
json.status resource.status
json.agent_last_seen_at resource.agent_last_seen_at.to_i
json.messages do
  json.array! resource.messages.chat do |message|
    json.partial! 'public/api/v1/models/message', formats: [:json], resource: message
  end
end
json.contact resource.contact

================
File: views/public/api/v1/models/_csat_survey.json.jbuilder
================
json.id resource.id
json.csat_survey_response resource.csat_survey_response
json.inbox_avatar_url resource.inbox.avatar_url
json.inbox_name resource.inbox.name
json.locale resource.account.locale
json.conversation_id resource.conversation_id
json.created_at resource.created_at

================
File: views/public/api/v1/models/_inbox.json.jbuilder
================
json.name resource.name
json.timezone resource.timezone
json.working_hours resource.weekly_schedule
json.working_hours_enabled resource.working_hours_enabled
json.csat_survey_enabled resource.csat_survey_enabled
json.greeting_enabled resource.greeting_enabled

================
File: views/public/api/v1/models/_message.json.jbuilder
================
json.id resource.id
json.content resource.content
json.message_type resource.message_type_before_type_cast
json.content_type resource.content_type
json.content_attributes resource.content_attributes
json.created_at resource.created_at.to_i
json.conversation_id resource.conversation.display_id
json.attachments resource.attachments.map(&:push_event_data) if resource.attachments.present?
json.sender resource.sender.push_event_data if resource.sender

================
File: views/public/api/v1/portals/articles/_article_header.html.erb
================
<% category_link_params = {
      portal_slug: @portal.slug,
      category_locale: @article.category&.locale,
      category_slug: @article.category&.slug,
      theme: @theme_from_params,
      is_plain_layout_enabled: @is_plain_layout_enabled
    }
%>

<div class="flex flex-row items-center gap-px mb-6">
  <a
    class="text-slate-500 dark:text-slate-200 text-sm gap-1 hover:cursor-pointer <%= @is_plain_layout_enabled && 'hover:underline' %> leading-8 font-semibold"
    href="<%= generate_home_link(@portal.slug, @article.category&.locale, @theme_from_params, @is_plain_layout_enabled) %>" 
  >
    <%= I18n.t('public_portal.common.home') %>
  </a>
  <span class="w-4 h-4 [&>svg]:w-3 [&>svg]:h-3 flex items-center justify-center text-xs text-slate-500 dark:text-slate-300"><%= render partial: 'icons/chevron-right' %></span>
  <% if @article.category %>
    <a class="text-slate-500 dark:text-slate-200 text-sm gap-1 whitespace-nowrap hover:cursor-pointer <%= @is_plain_layout_enabled && 'hover:underline' %> leading-8 font-semibold" href="<%= generate_category_link(category_link_params) %>">
    <%= @article.category&.name %>
    </a>
    <span class="w-4 h-4 [&>svg]:w-3 [&>svg]:h-3 flex items-center justify-center text-xs text-slate-500 dark:text-slate-300"><%= render partial: 'icons/chevron-right' %></span>
    <span class="min-w-0 overflow-hidden text-sm font-semibold text-slate-800 dark:text-slate-100 text-ellipsis whitespace-nowrap"><%= @article.title %></span>
  <% else %>
    <span class="text-sm font-semibold leading-8 text-slate-700 dark:text-slate-100" ><%= I18n.t('public_portal.header.uncategorized') %></span>
  <% end %>
</div>
<h1 class="text-3xl font-semibold leading-normal md:tracking-normal md:text-4xl text-slate-900 dark:text-white">
  <%= article.title %>
</h1>
<div class="flex flex-col items-start justify-between w-full pt-6 md:flex-row md:items-center">
  <div class="flex items-start space-x-1">
    <span class="flex items-center text-base font-medium text-slate-600 dark:text-slate-400">
     <%= I18n.t('public_portal.common.last_updated_on', last_updated_on: article.updated_at.strftime("%b %d, %Y")) %>
    </span>
  </div>
</div>

================
File: views/public/api/v1/portals/articles/index.html.erb
================
<div class="bg-slate-50 dark:bg-slate-800">
	<div class="w-full max-w-4xl px-6 py-16 mx-auto space-y-12">
		<div class="space-y-4">
		<div>
			<a
			  class="leading-8 text-slate-800 hover:underline"
		      href="<%= generate_home_link(@portal.slug, @category.present? ? @category.slug : '', @theme_from_params, @is_plain_layout_enabled) %>"
			>
				<%= @portal.name %> <%= I18n.t('public_portal.common.home') %>
			</a>
		<span>/</span>
		<span>/</span>
		</div>
			<% @articles.each do |article| %>
				<h1 class="text-4xl font-semibold leading-snug md:tracking-normal md:text-5xl text-slate-900 dark:text-white">
				<%= article.title %></h1>
				<div class="flex flex-col items-start justify-between w-full pt-2 md:flex-row md:items-center">
					<div class="flex items-center space-x-2">
						<img src="<%= article.author.avatar_url %>" alt="" class="w-12 border rounded-full h-812">
						<div>
							<h5 class="mb-2 text-base font-medium text-slate-900 dark:text-white"><%= article.author.name %></h5>
							<p class="text-sm font-normal text-slate-700 dark:text-slate-100">
								<%= article.author.updated_at.strftime("%B %d %Y") %></p>
						</div>
					</div>
				</div>
			<% end %>
		</div>
	</div>
</div>
<div class="flex-grow w-full max-w-4xl px-8 py-16 mx-auto space-y-12">
	<article class="space-y-8">
		<div class="max-w-3xl font-sans text-lg leading-8 text-slate-800 dark:text-slate-50 blog-content">
		</div>
	</article>
</div>

================
File: views/public/api/v1/portals/articles/index.json.jbuilder
================
json.payload do
  json.array! @articles.includes([:category, :associated_articles, { author: { avatar_attachment: [:blob] } }]),
              partial: 'public/api/v1/models/article', formats: [:json], as: :article
end

json.meta do
  json.articles_count @articles.published.size
end

================
File: views/public/api/v1/portals/articles/show.html.erb
================
<% content_for :head do %>
  <title><%= @article.title %> | <%= @portal.name %></title>
  <% if @article.meta["title"].present? %>
    <meta name="title" content="<%= @article.meta["title"] %>">
  <% end %>
  <% if @article.meta["description"].present? %>
    <meta name="description" content="<%= @article.meta["description"] %>">
  <% end %>
  <% if @article.meta["tags"].present? %>
    <meta name="tags" content="<%= @article.meta["tags"].join(',') %>">
  <% end %>
<% end %>

<% if !@is_plain_layout_enabled %>
<div id="portal-bg" class="bg-white dark:bg-slate-900 shadow-inner">
  <div id="portal-bg-gradient" class="pt-8 pb-8 md:pt-14 md:pb-6">
    <div class="max-w-5xl px-4 md:px-8 mx-auto flex flex-col">
      <%= render "public/api/v1/portals/articles/article_header", article: @article %>
    </div>
  </div>
</div>
<% else %>
<div class="max-w-5xl mx-auto space-y-4 w-full px-4 md:px-8 <%= @is_plain_layout_enabled ? 'py-4' : 'py-8' %>">
  <%= render "public/api/v1/portals/articles/article_header", article: @article %>
</div>
<% end %>

<div class="flex max-w-5xl w-full px-4 md:px-8 mx-auto">
  <article id="cw-article-content" class="article-content flex-grow flex-2 mx-auto text-slate-800 dark:text-slate-50 text-lg max-w-3xl prose-h1:text-2xl prose-h2:text-xl prose-h2:mt-0 prose-h3:text-lg prose-code:[&>p]:p-1 prose-code:[&>p]:rounded-sm prose-code:[&>p]:bg-black-100 dark:prose-code:[&>p]:bg-black-600 prose-code:after:content-none prose-code:before:content-none prose dark:prose-invert break-words w-full <%= @is_plain_layout_enabled ? 'py-4' : 'pt-8 pb-12' %>">
    <%= @parsed_content %>
  </article>
  <div class="flex-1" id="cw-hc-toc"></div>
</div>
<style>
  .article-content li > p {
    margin: 0;
  }
</style>

================
File: views/public/api/v1/portals/articles/show.json.jbuilder
================
json.partial! 'public/api/v1/models/article', formats: [:json], article: @article

================
File: views/public/api/v1/portals/categories/_category-block.html.erb
================
<% category_link_params = {
      portal_slug: portal.slug,
      category_locale: category.locale,
      category_slug: category.slug,
      theme: @theme_from_params,
      is_plain_layout_enabled: @is_plain_layout_enabled
    }
%>

<section class="flex flex-col w-full h-full px-4 py-6 lg:container">
  <div class="flex items-center justify-between w-full">
    <h3 class="text-xl font-semibold leading-relaxed text-slate-900 dark:text-white hover:underline">
     <a href="<%= generate_category_link(category_link_params) %>">
      <%= category.name %>
    </a>
    </h3>
    <span class="text-slate-500">
      <%= render 'public/api/v1/portals/article_count', article_count: category.articles.published.order(position: :asc).size %>
    </span>
  </div>
  <div class="flex-grow w-full py-4 mt-2">
    <% if category.articles.published.size == 0 %>
      <div class="flex items-center justify-center h-full mb-4 bg-slate-50 dark:bg-slate-800 rounded-xl">
        <p class="text-sm text-slate-500"><%= I18n.t('public_portal.common.no_articles') %></p>
      </div>
    <% else %>
      <% category.articles.published.order(position: :asc).take(5).each do |article| %>
        <div class="flex content-center justify-between h-8 my-1">
          <a
            class="leading-8 text-slate-800 dark:text-slate-50 hover:underline"
            href="<%= generate_article_link(portal.slug, article.slug, @theme_from_params, @is_plain_layout_enabled) %>"
          >
            <%= article.title %>
          </a>
          <span class="flex items-center">
            <svg
              class="w-4 h-4 fill-current text-slate-700 dark:text-slate-200"
              width="24"
              height="24"
              fill="none"
              viewBox="0 0 24 24"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                d="M8.47 4.22a.75.75 0 0 0 0 1.06L15.19 12l-6.72 6.72a.75.75 0 1 0 1.06 1.06l7.25-7.25a.75.75 0 0 0 0-1.06L9.53 4.22a.75.75 0 0 0-1.06 0Z"
              />
            </svg>
          </span>
        </div>
      <% end %>
    <% end %>

  </div>
  <div>
    <a
      href="<%= generate_category_link(category_link_params) %>"
      class="flex flex-row items-center mt-4 text-base font-medium text-woot-600 dark:text-woot-500 hover:text-slate-900 dark:hover:text-white hover:underline"
    >
      <%= I18n.t('public_portal.common.view_all_articles') %>
      <span class="ml-2">
        <svg
          class="w-4 h-4 fill-current text-woot-500"
          width="24"
          height="24"
          fill="none"
          viewBox="0 0 24 24"
          xmlns="http://www.w3.org/2000/svg"
        >
          <path
            d="M13.267 4.209a.75.75 0 0 0-1.034 1.086l6.251 5.955H3.75a.75.75 0 0 0 0 1.5h14.734l-6.251 5.954a.75.75 0 0 0 1.034 1.087l7.42-7.067a.996.996 0 0 0 .3-.58.758.758 0 0 0-.001-.29.995.995 0 0 0-.3-.578l-7.419-7.067Z"
          />
        </svg>
      </span>
    </a>
  </div>
</section>

================
File: views/public/api/v1/portals/categories/_category-hero.html.erb
================
<div class="flex flex-col px-4 md:px-8 max-w-5xl w-full mx-auto gap-6 <%= @is_plain_layout_enabled && 'py-4' %>">
  <div class="flex items-center flex-row">
    <a
      class="text-slate-500 dark:text-slate-200 text-sm gap-1 <%= @is_plain_layout_enabled && 'hover:underline' %> hover:cursor-pointer leading-8 font-semibold"
      href="<%= generate_home_link(portal.slug, category.locale, @theme_from_params, @is_plain_layout_enabled) %>"
    >
      <%= I18n.t('public_portal.common.home') %>
    </a>
    <span class="w-4 h-4 [&>svg]:w-3 [&>svg]:h-3 flex items-center justify-center text-xs text-slate-500 dark:text-slate-300"><%= render partial: 'icons/chevron-right' %></span>
    <span class="text-sm text-slate-800 dark:text-slate-100 font-semibold"><%= category.name %></span>
  </div>
  <div class="flex justify-start flex-col items-start w-full gap-2">
    <div class="flex flex-col gap-2">
      <% if category.icon.present? %>
      <span class="text-4xl"><%= category.icon %></span>
      <% end %>
      <h1 class="text-3xl font-bold tracking-wide leading-[52.5px] text-slate-900 dark:text-white">
        <%= category.name %>
      </h1>
      <% if category.description.present? %>
      <span class="font-medium text-slate-700 dark:text-slate-200 text-base leading-5"><%= category.description %></span>
      <% end %>
    </div>
    <div class="flex flex-row items-center gap-1">
      <%= render "public/api/v1/portals/authors", category: category, show_expanded: true %>
      <span class="text-slate-600 dark:text-slate-400"></span>
      <span class="flex items-center text-base text-slate-600 dark:text-slate-400 font-medium"><%= render 'public/api/v1/portals/article_count', article_count: category.articles.published.size %></span>
    </div>
  </div>
</div>

================
File: views/public/api/v1/portals/categories/_hero.html.erb
================
<section class="bg-slate-50 dark:bg-slate-800 py-16 flex flex-col items-center justify-center">
  <div class="mx-auto max-w-2xl">
    <h1 class="text-4xl text-slate-900 dark:text-white font-semibold leading-relaxed text-center"><%= portal.header_text %></h1>
    <p class="text-slate-700 dark:text-slate-100 py-2 text-center"><%= I18n.t('public_portal.hero.sub_title') %></p>
  </div>
</section>

================
File: views/public/api/v1/portals/categories/index.html.erb
================
<%= render "hero", portal: @portal %>

<div class="max-w-5xl w-full flex-grow mx-auto py-16">
  <div class="grid grid-cols-2 gap-x-32 gap-y-12">
    <% @categories.each do |category| %>
      <%= render "category-block", category: category, portal: @portal %>
    <% end %>
  </div>
</div>

================
File: views/public/api/v1/portals/categories/index.json.jbuilder
================
json.payload do
  json.array! @categories, partial: 'public/api/v1/models/category', formats: [:json], as: :category
end

================
File: views/public/api/v1/portals/categories/show.html.erb
================
<% content_for :head do %>
  <title><%= @category.name %> | <%= @portal.name %></title>
  <% if @category.description.present? %>
    <meta name="description" content="<%= @category.description %>">
  <% end %>
<% end %>

<% if !@is_plain_layout_enabled %>
<div id="portal-bg" class="bg-white dark:bg-slate-900">
  <div id="portal-bg-gradient" class="pt-8 pb-8 md:pt-14 md:pb-6">
    <%= render 'public/api/v1/portals/categories/category-hero', category: @category, portal: @portal %>
  </div>
</div>
<% else %>
  <%= render 'public/api/v1/portals/categories/category-hero', category: @category, portal: @portal %>
<% end %>
<section class="max-w-5xl w-full mx-auto px-4 md:px-8 py-6 flex flex-col items-center justify-center flex-grow">
  <div class="w-full flex flex-col gap-6 flex-grow">
    <% if @category.articles.published.size == 0 %>
    <div class="h-full flex items-center justify-center bg-slate-50 dark:bg-slate-800 rounded-xl py-6">
      <p class="text-sm text-slate-500"><%= I18n.t('public_portal.common.no_articles') %></p>
    </div>
    <% else %>
    <% @category.articles.published.order(:position).each do |article| %>
    <div id="<%= !@is_plain_layout_enabled ? 'category-block' : '' %>" class="<%= !@is_plain_layout_enabled ? 'border border-solid border-slate-100 dark:border-slate-800 rounded-lg' : 'group' %>">
      <a
        class="<%= !@is_plain_layout_enabled ? 'p-4' : 'px-0 py-1' %> text-slate-800 dark:text-slate-50 flex justify-between content-center hover:cursor-pointer"
        href="<%= generate_article_link(@portal.slug, article.slug, @theme_from_params, @is_plain_layout_enabled) %>"
      >
        <div class="flex flex-col gap-5">
          <div class="flex flex-col gap-1">
            <h3 id="<%= !@is_plain_layout_enabled ? 'category-name' : '' %>" class="text-lg text-slate-900 tracking-[0.28px] dark:text-slate-50 font-semibold <%= @is_plain_layout_enabled ? 'group-hover:underline' : '' %>"><%= article.title %></h3>
            <p class="text-base font-normal text-slate-600 dark:text-slate-200 line-clamp-1 break-all"><%= render_category_content(article.content) %></p>
          </div>
          <span class="text-sm text-slate-600 dark:text-slate-400 font-medium flex items-center"><%= I18n.t('public_portal.common.last_updated_on', last_updated_on: article.updated_at.strftime("%b %d, %Y")) %></span>
        </div>
      </a>
    </div>  
    <% end %>
    <% end %>
  </div>
</section>

================
File: views/public/api/v1/portals/categories/show.json.jbuilder
================
json.partial! 'public/api/v1/models/category', formats: [:json], category: @category

================
File: views/public/api/v1/portals/error/404.html.erb
================
<div class="max-w-6xl h-full w-full flex-grow flex flex-col items-center justify-center mx-auto py-16 px-4 relative">
    <div class="text-center mb-12">
        <span class="text-8xl"></span>
    </div>
    <h1 class="text-6xl text-center font-semibold text-slate-800 dark:text-slate-100 leading-relaxed"><%= I18n.t('public_portal.404.title') %></h1>
    <p class="text-center text-slate-700 dark:text-slate-300 my-1"><%= I18n.t('public_portal.404.description') %></p>
    <div class="text-center my-8">
        <a href="<%= generate_home_link(@portal.slug, @portal.config['default_locale'] || params[:locale], @theme_from_params, @is_plain_layout_enabled) %>" class="text-woot-500 font-semibold underline">
            <%= I18n.t('public_portal.404.back_to_home') %>
        </a>
    </div>
</div>

================
File: views/public/api/v1/portals/_article_count.html.erb
================
<% if article_count == 0 %>
<% elsif article_count == 1 %>
  <%= article_count %> <%= I18n.t('public_portal.common.article') %>
<% else %>
  <%= article_count %> <%= I18n.t('public_portal.common.articles') %>
<% end %>

================
File: views/public/api/v1/portals/_authors.html.erb
================
<% author_count = category.articles.published.order(position: :asc).map(&:author).uniq.size %>
<% if author_count > 0 %>
  <div class="flex flex-row items-center gap-1">
    <div class="flex flex-row items-center -space-x-2">
        <% category.articles.published.order(position: :asc).map(&:author).uniq.take(3).each do |author| %>
          <%= render "public/api/v1/portals/thumbnail", author: author, size: 5 %>
        <% end %>
    </div>

    <% first_author = category.articles.published.order(position: :asc).map(&:author).uniq.first&.name || '' %>
    <% author_text = author_count > 1 ? "#{author_count} #{I18n.t('public_portal.common.authors')}" : "#{author_count} #{I18n.t('public_portal.common.author')}" %>
    <% other_authors_count = author_count - 1 %>
    <% other_authors_text = other_authors_count > 1 ? I18n.t('public_portal.common.others') : I18n.t('public_portal.common.other') %>

    <span class="<%= show_expanded ? 'text-base' : 'text-sm' %> font-medium text-slate-600 dark:text-slate-400">
    <% if show_expanded %>
        <%= "#{I18n.t('public_portal.common.by')} #{first_author}" %>
        <%= other_authors_count.positive? ? " and #{other_authors_count} #{other_authors_text}" : '' %>
    <% else %>
        <%= author_text %>
    <% end %>
    </span>
  </div>
<% end %>

================
File: views/public/api/v1/portals/_category-block.html.erb
================
<% category_link_params = {
      portal_slug: portal.slug,
      category_locale: category.locale,
      category_slug: category.slug,
      theme: @theme_from_params,
      is_plain_layout_enabled: @is_plain_layout_enabled
    }
%>

<section class="flex flex-col w-full h-full lg:container">
   <div id="<%= !@is_plain_layout_enabled ? 'category-block' : '' %>" class="flex flex-col gap-8 h-full <%= !@is_plain_layout_enabled ? 'border border-solid border-slate-100 dark:border-slate-800 py-5 px-3 rounded-lg' : '' %>">
      <div class="flex items-center justify-between w-full">
         <div class="flex flex-col items-start gap-1">
            <div class="flex flex-row items-center gap-2 <%= !@is_plain_layout_enabled && 'px-1' %>">
               <% if category.icon.present? %>
               <span class="text-lg rounded-md cursor-pointer <%= !@is_plain_layout_enabled && 'pl-1' %>"><%= category.icon %></span>
               <% end %>
               <h3 id="<%= !@is_plain_layout_enabled ? 'category-name' : '' %>" class="text-xl text-slate-800 dark:text-slate-50 font-semibold leading-relaxed hover:cursor-pointer <%= @is_plain_layout_enabled ? 'hover:underline' : '' %> <%= category.icon.blank? && !@is_plain_layout_enabled ? 'pl-1' : '' %>">
                  <a href="<%= generate_category_link(category_link_params) %>">
                  <%= category.name %>
                  </a>
               </h3>
            </div>
            <% if category.description.present? %>
            <span class="text-base text-slate-600 dark:text-slate-400 <%= !@is_plain_layout_enabled && 'px-2' %>"><%= category.description %></span>
            <% end %>
         </div>
      </div>
      <div class="flex flex-col gap-2 flex-grow <%= category.description.blank? && '-mt-4' %>">
         <% if category.articles.published.size==0 %>
         <div class="flex items-center justify-center h-full mb-4 bg-slate-50 dark:bg-slate-800 rounded-xl">
            <p class="text-sm text-slate-500"><%= I18n.t('public_portal.common.no_articles') %></p>
         </div>
         <% else %>
         <% category.articles.published.order(position: :asc).take(5).each do |article| %>
         <a class="leading-7 text-slate-700 dark:text-slate-100" href="<%= generate_article_link(portal.slug, article.slug, @theme_from_params, @is_plain_layout_enabled) %>">
            <div id="<%= !@is_plain_layout_enabled ? 'category-item' : '' %>" class="flex justify-between hover:cursor-pointer items-start py-1 rounded-lg gap-6 <%= !@is_plain_layout_enabled ? 'px-2' : 'hover:underline' %>">
               <%= article.title %>
               <span class="flex items-center font-normal mt-1.5">
                  <%= render partial: 'icons/chevron-right' %>
               </span>
            </div>
         </a>
         <% end %>
         <% end %>
      </div>
      <div class="flex justify-between flex-row items-center <%= !@is_plain_layout_enabled && 'px-2' %>">
         <div class="flex flex-row items-center gap-1">
           <%= render "public/api/v1/portals/authors", category: category, show_expanded: false %>
           <span class="text-slate-600 dark:text-slate-400"></span>
           <span class="text-sm font-medium text-slate-600 dark:text-slate-400"><%= render 'public/api/v1/portals/article_count', article_count: category.articles.published.order(position: :asc).size %></span>
         </div>
         <div>
            <a href="<%= generate_category_link(category_link_params) %>" class="flex flex-row items-center text-sm font-medium text-slate-600 dark:text-slate-400 hover:text-slate-700 dark:hover:text-slate-100">
            <%= I18n.t('public_portal.common.view_all_articles') %>
            </a>
         </div>
      </div>
   </div>
</section>

================
File: views/public/api/v1/portals/_featured_articles.html.erb
================
<% featured_articles = articles.where(category_id: categories).search_by_status(:published).order_by_views.limit(6) %>
<% if featured_articles.count >= 6 %>
<section class="flex flex-col w-full h-full lg:container">
   <div class="flex flex-col gap-5 px-3 py-5 border border-solid rounded-lg border-slate-100 dark:border-slate-800">
      <div class="flex items-center justify-between w-full"> 
         <div class="flex flex-col items-start gap-1">
            <div class="flex flex-row items-center gap-2 px-2">
               <h3 class="text-xl font-semibold leading-relaxed text-slate-800 dark:text-slate-50">
                  <%= I18n.t('public_portal.header.featured_articles') %>
               </h3>
            </div>
         </div>
      </div>
      <div class="grid grid-cols-1 gap-2 md:grid-cols-2 gap-x-2 gap-y-2">
         <% featured_articles.each do |article| %>
         <a class="leading-7 text-slate-700 dark:text-slate-100" href="<%= generate_article_link(portal.slug, article.slug, @theme_from_params, @is_plain_layout_enabled) %>">
            <div  id="category-item" class="flex items-start justify-between gap-6 px-2 py-1 rounded-lg">
               <%= article.title %>
               <span class="flex items-center font-normal mt-1.5">
                  <%= render partial: 'icons/chevron-right' %>
               </span>
            </div>
         </a>
         <% end %>
      </div>
   </div>
</section>
<% end %>

================
File: views/public/api/v1/portals/_footer.html.erb
================
<footer class="pt-16 pb-8 flex flex-col items-center justify-center">
  <div class="mx-auto max-w-2xl text-center py-2">
    <div class="flex items-center gap-2">

        <img
          class="w-4 h-4"
          alt="<%= @global_config['BRAND_NAME'] %>"
          src="<%= @global_config['LOGO_THUMBNAIL'] %>"
        />
      <p class="text-slate-700 dark:text-slate-300 text-sm font-medium text-center">
        <%= I18n.t('public_portal.footer.made_with') %>
       
          <a class="hover:underline" href="<%= @global_config['BRAND_URL'] %>" target="_blank" rel="noopener noreferrer nofoll/ow"><%= @global_config['BRAND_NAME'] %></a>
    
      </p>
    </div>
  </div>
</footer>

================
File: views/public/api/v1/portals/_header.html.erb
================
<header class="sticky top-0 z-50 w-full bg-white shadow-sm dark:bg-slate-900">
  <nav class="flex max-w-5xl px-4 mx-auto md:px-8" aria-label="Top">
    <div class="flex items-center w-full py-5 overflow-hidden">
      <a href="<%= generate_home_link(@portal.slug, @portal.config['default_locale'] || params[:locale], @theme_from_params, @is_plain_layout_enabled) %>" class="flex items-center h-10 text-lg font-semibold text-slate-900 dark:text-white">
        <% if @portal.logo.present? %>
          <img src="<%= url_for(@portal.logo) %>" class="w-auto h-10 mr-2" />
        <% end %>
        <%= @portal.name %>
      </a>
    </div>

    <%# Go to homepage link section %>
    <div class="flex items-center justify-between gap-2 sm:gap-5">
      <% if @portal.homepage_link %>
        <div class="hidden px-1 py-2 ml-8 cursor-pointer border-l-1 border-slate-50 dark:border-slate-800 md:block">
          <div class="flex-grow flex-shrink-0">
            <a id="header-action-button" target="_blank" rel="noopener noreferrer nofollow" href="<%= @portal.homepage_link %>" class="flex flex-row items-center gap-1 text-sm font-medium whitespace-nowrap text-slate-800 dark:text-slate-100 stroke-slate-700 dark:stroke-slate-200">
              <%= render partial: 'icons/redirect' %>
              <%= I18n.t('public_portal.header.go_to_homepage') %>
            </a>
          </div>
        </div>
      <% end %>

      <%# Appearance toggle section %>
      <div class="relative flex-grow flex-shrink-0 px-1 py-2 cursor-pointer">
        <button id="toggle-appearance" class="flex justify-between min-w-[76px] flex-row items-center stroke-slate-700 dark:stroke-slate-200 text-slate-800 dark:text-slate-100 gap-1" type="button">
          <div data-theme="system" class="flex-row items-center gap-1 theme-button <%= @theme_from_params == 'system' ? 'flex' : 'hidden' %>">
            <%= render partial: 'icons/monitor' %>
            <span class="text-sm font-medium"><%= I18n.t('public_portal.header.appearance.system') %></span>
          </div>
          <div data-theme="light" class="flex-row items-center gap-1 theme-button <%= @theme_from_params == 'light' ? 'flex' : 'hidden' %>">
            <%= render partial: 'icons/sun' %>
            <span class="text-sm font-medium"><%= I18n.t('public_portal.header.appearance.light') %></span>
          </div>
          <div data-theme="dark" class="flex-row items-center gap-1 theme-button <%= @theme_from_params == 'dark' ? 'flex' : 'hidden' %>">
            <%= render partial: 'icons/moon' %>
            <span class="text-sm font-medium"><%= I18n.t('public_portal.header.appearance.dark') %></span>
          </div>
          <div class="flex items-center px-1 pointer-events-none">
            <%= render partial: 'icons/chevron-down' %>
          </div>
        </button>
        <%# Appearance dropdown section %>
        <div id="appearance-dropdown" data-current-theme="<%= @theme_from_params %>" class="absolute flex-col w-32 h-auto bg-white border border-solid rounded dark:bg-slate-900 top-9 right-1 border-slate-100 dark:border-slate-800" aria-hidden="true" style="display: none;" data-dropdown="appearance-dropdown">
          <button id="toggle-theme-button" data-theme="system" class="flex flex-row items-center justify-between gap-1 px-2 py-2 border-b border-solid border-slate-100 dark:border-slate-800 stroke-slate-700 dark:stroke-slate-200 text-slate-800 dark:text-slate-100">
            <div class="flex flex-row items-center gap-1">
              <%= render partial: 'icons/monitor' %>
              <span class="text-xs font-medium"><%= I18n.t('public_portal.header.appearance.system') %></span>
            </div>
            <span class="check-mark-icon system-theme">
              <%= render partial: 'icons/check-mark' %>
            </span>
          </button>
          <button id="toggle-theme-button" data-theme="light" class="flex flex-row items-center justify-between gap-1 px-2 py-2 border-b border-solid border-slate-100 dark:border-slate-800 stroke-slate-700 dark:stroke-slate-200 text-slate-800 dark:text-slate-100">
            <div class="flex flex-row items-center gap-1">
              <%= render partial: 'icons/sun' %>
              <span class="text-xs font-medium"><%= I18n.t('public_portal.header.appearance.light') %></span>
            </div>
            <span class="check-mark-icon light-theme">
              <%= render partial: 'icons/check-mark' %>
            </span>
          </button>
          <button id="toggle-theme-button" data-theme="dark" class="flex flex-row items-center justify-between gap-1 px-2 py-2 stroke-slate-700 dark:stroke-slate-200 text-slate-800 dark:text-slate-100">
            <div class="flex flex-row items-center gap-1">
              <%= render partial: 'icons/moon' %>
              <span class="text-xs font-medium"><%= I18n.t('public_portal.header.appearance.dark') %></span>
            </div>
            <span class="check-mark-icon dark-theme">
              <%= render partial: 'icons/check-mark' %>
            </span>
          </button>
        </div>
      </div>

      <%# Locale switcher section %>
      <% if @portal.config["allowed_locales"].length > 1 %>
        <div id="header-action-button" class="flex items-center stroke-slate-700 dark:stroke-slate-200 text-slate-800 dark:text-slate-100">
          <div class="flex items-center gap-1 px-1 py-2 cursor-pointer">
            <%= render partial: 'icons/globe' %>
            <select
              data-portal-slug="<%= @portal.slug %>"
              class="w-24 overflow-hidden text-sm font-medium leading-tight bg-white appearance-none cursor-pointer dark:bg-slate-900 text-ellipsis whitespace-nowrap focus:outline-none focus:shadow-outline locale-switcher"
            >
              <% @portal.config["allowed_locales"].each do |locale| %>
                <option <%= locale == @locale ? 'selected': '' %> value="<%= locale %>"><%= "#{language_name(locale)} (#{locale})" %></option>
              <% end %>
            </select>
            <%= render partial: 'icons/chevron-down' %>
          </div>
        </div>
      <% end %>
    </div>
  </nav>
</header>

================
File: views/public/api/v1/portals/_hero.html.erb
================
<% if !@is_plain_layout_enabled %>
<section id="portal-bg" class="w-full bg-white dark:bg-slate-900 shadow-inner">
  <div id="portal-bg-gradient" class="pt-8 pb-8 md:pt-14 md:pb-6 min-h-[240px] md:min-h-[260px]">
    <div class="mx-auto max-w-5xl px-4 md:px-8 flex flex-col items-center sm:items-start">
      <h1 class="text-2xl md:text-4xl text-slate-900 dark:text-white font-semibold leading-normal">
        <%= portal.header_text %>
      </h1>
      <p class="text-slate-600 dark:text-slate-200 text-center text-lg leading-normal pt-4 pb-4"><%= I18n.t('public_portal.hero.sub_title') %></p>
      <div id="search-wrap" class="w-full"></div>
    </div>
  </div>
</section>
<% end %>

================
File: views/public/api/v1/portals/_thumbnail.html.erb
================
<% if author&.avatar_url&.present? %>
  <img src="<%= url_for(author.avatar_url) %>" alt="<%= author.name %>" class="w-<%= size %> h-<%= size %> rounded-full border border-solid border-white dark:border-slate-900">
<% else %>
  <div class="w-<%= size %> h-<%= size %> rounded-full [&>svg]:opacity-70 border border-solid fill-white dark:fill-slate-900 border-white dark:border-slate-900 flex justify-center items-center" style="background-color: <%= thumbnail_bg_color(author&.available_name) %>;">
    <%= render partial: 'icons/user' %>
  </div>
<% end %>

================
File: views/public/api/v1/portals/_uncategorized-block.html.erb
================
<section class="flex flex-col w-full h-full lg:container">
  <div id="<%= !@is_plain_layout_enabled ? 'category-block' : '' %>" class="flex flex-col gap-8 h-full <%= !@is_plain_layout_enabled ? 'border border-solid border-slate-100 dark:border-slate-800 py-5 px-3 rounded-lg' : '' %>">
    <div class="flex justify-between items-center w-full <%= !@is_plain_layout_enabled ?  'px-1' : '' %>">
      <h3 id="<%= !@is_plain_layout_enabled ? 'category-name' : '' %>" class="text-xl text-slate-800 dark:text-slate-50 font-semibold leading-relaxed hover:cursor-pointer <%= @is_plain_layout_enabled ? 'hover:underline' : 'pl-1' %>">
        <%= I18n.t('public_portal.header.uncategorized') %>
      </h3>
    </div>
    <div class="-mt-4">
      <% portal.articles.published.where(category_id: nil).order(position: :asc).take(5).each do |article| %>
      <a
        class="leading-7 text-slate-700 dark:text-slate-100"
        href="<%= generate_article_link(portal.slug, article.slug, @theme_from_params, @is_plain_layout_enabled) %>"
      >
        <div id="<%= !@is_plain_layout_enabled ? 'category-item' : '' %>" class="flex justify-between hover:cursor-pointer items-center py-1 rounded-lg gap-3  <%= !@is_plain_layout_enabled ? 'px-2' : 'hover:underline' %>">
          <%= article.title %>
          <span class="flex items-center font-normal">
            <%= render partial: 'icons/chevron-right' %>
          </span>
        </div>
      </a>
      <% end %>
    </div>
    <div class="flex justify-between flex-row items-center <%= !@is_plain_layout_enabled && 'px-2' %>">
      <span class="text-sm font-medium text-slate-600 dark:text-slate-400"><%= render 'public/api/v1/portals/article_count', article_count: portal.articles.published.where(category_id: nil).size %></span>
    </div>
  </div>
</section>

================
File: views/public/api/v1/portals/index.json.jbuilder
================
json.array! @portals, partial: 'public/api/v1/models/hc/portal', formats: [:json], as: :portal

================
File: views/public/api/v1/portals/show.html.erb
================
<%= render "public/api/v1/portals/hero", portal: @portal %>
<div class="max-w-5xl w-full flex flex-col flex-grow mx-auto py-8 px-4 md:px-8 gap-6">
  <%# Featured Articles %>
  <% if !@is_plain_layout_enabled %>
    <div><%= render "public/api/v1/portals/featured_articles", articles: @portal.articles, categories: @portal.categories.where(locale: @locale), portal: @portal %></div>
  <% end %>
  <%# Categories with articles %>
  <div class="grid grid-cols-1 md:grid-cols-2 gap-x-6 gap-y-6">
    <% @portal.categories.where(locale: @locale).joins(:articles).where(articles:{ status: :published }).order(position: :asc).group('categories.id').each do |category| %>
      <%= render "public/api/v1/portals/category-block", category: category, portal: @portal %>
    <% end %>
  </div>
  <%# Uncategorized articles %>
  <div class="grid grid-cols-1 lg:grid-cols-2 gap-x-6 gap-y-6">
    <% if @portal.articles.where(status: :published, category_id: nil, locale: @locale).count > 0 %>
      <%= render "public/api/v1/portals/uncategorized-block", category: "Uncategorized", portal: @portal %>
    <% end %>
  </div>
</div>

================
File: views/public/api/v1/portals/show.json.jbuilder
================
json.partial! 'public/api/v1/models/hc/portal', formats: [:json], portal: @portal

================
File: views/public/api/v1/portals/sitemap.xml.erb
================
<?xml version="1.0" encoding="UTF-8"?>
<sitemapindex>
  <% @portal.articles.where(status: :published).each do |article| %>
    <sitemap>
      <loc><%= @help_center_url %><%= generate_article_link(@portal.slug, article.slug, false, false) %></loc>
      <lastmod><%= article.updated_at.strftime("%Y-%m-%d") %></lastmod>
    </sitemap>
  <% end %>
</sitemapindex>

================
File: views/super_admin/accounts/_reset_cache.html.erb
================
<section class="main-content__body">
 <hr/>
  <%= form_for([:reset_cache, namespace, page.resource], method: :post, html: { class: "form" }) do |f| %>
    <div class="form-actions">
      <p class="pb-3">This will clear the IndexedDB cache keys from redis. <br>The next load will fetch the data from backend.</p>
      <%= f.submit 'Reset Frontend Cache' %>
    </div>
  <% end %>
</section>

================
File: views/super_admin/accounts/_seed_data.html.erb
================
<% if ENV.fetch('ENABLE_ACCOUNT_SEEDING', !Rails.env.production?)  %>
<section class="main-content__body">
 <hr/>
  <%= form_for([:seed, namespace, page.resource], method: :post, html: { class: "form" }) do |f| %>

  <div class="form-actions">
    <div class="pb-3">
      <p>Click the button to generate seed data into this account for demos.</p>
      <p class="text-color-red">Note: This will clear all the existing data in this account.</p>
    </div>
  <%= f.submit 'Generate Seed Data' %>
  </div>
  <% end %>
</section>
<% end %>

================
File: views/super_admin/accounts/show.html.erb
================
<%#
# Show

This view is the template for the show page.
It renders the attributes of a resource,
as well as a link to its edit page.

## Local variables:

- `page`:
  An instance of [Administrate::Page::Show][1].
  Contains methods for accessing the resource to be displayed on the page,
  as well as helpers for describing how each attribute of the resource
  should be displayed.

[1]: http://www.rubydoc.info/gems/administrate/Administrate/Page/Show %>

  <% content_for(:title) do
    t("administrate.actions.show_resource", name: page.page_title)
  end %>

  <header class="main-content__header" role="banner">
    <h1 class="main-content__page-title">
      <%= content_for(:title) %>
    </h1>

    <div>
      <%= if accessible_action?(page.resource, :edit)
        link_to("Edit", [:edit, namespace, page.resource], class: "button")
      end %>
    </div>
  </header>

  <section class="main-content__body">
    <div class="pr-16">
      <% page.attributes.each do |title, attributes| %>
        <% if title.present? && title == 'all_features' %>
          <% regular_features, premium_features =
            attributes.partition do |attr|
              !SuperAdmin::AccountFeaturesHelper.account_premium_features.include?(
                attr.data.keys.first,
              )
            end %>

          <div class="space-y-4">
            <% regular_features.each do |attribute| %>
              <div class="attribute-label" id="<%= attribute.name %>">
                <%= t(
                  "helpers.label.#{resource_name}.#{attribute.name}",
                  default: page.resource.class.human_attribute_name(attribute.name),
                ) %>
              </div>

              <div class="attribute-data attribute-data--<%=attribute.html_class%>"><%= render_field attribute, page: page %></div>
            <% end %>
          </div>

          <hr class="my-8 border-n-weak">

          <div class="space-y-4">
            <% premium_features.each do |attribute| %>
              <div class="attribute-label" id="<%= attribute.name %>">
                <%= t(
                  "helpers.label.#{resource_name}.#{attribute.name}",
                  default: page.resource.class.human_attribute_name(attribute.name),
                ) %>
              </div>

              <div class="attribute-data attribute-data--<%=attribute.html_class%>"><%= render_field attribute, page: page %></div>
            <% end %>
          </div>
        <% else %>
          <fieldset class="<%= "field-unit--nested" if title.present? %>">
            <% if title.present? %>
              <legend><%= t "helpers.label.#{page.resource_name}.#{title}", default: title %></legend>
            <% end %>

            <% attributes.each do |attribute| %>
              <div class="attribute-label" id="<%= attribute.name %>">
                <%= t(
                  "helpers.label.#{resource_name}.#{attribute.name}",
                  default: page.resource.class.human_attribute_name(attribute.name),
                ) %>
              </div>

              <div class="attribute-data attribute-data--<%=attribute.html_class%>"><%= render_field attribute, page: page %></div>
            <% end %>
          </fieldset>
        <% end %>
      <% end %>
    </div>
  </section>

  <section class="main-content__body">
    <% account_user_page =
      Administrate::Page::Form.new(AccountUserDashboard.new, AccountUser.new) %>
    <%= form_for([namespace, account_user_page.resource], html: { class: "form" }) do |f| %>
      <% if account_user_page.resource.errors.any? %>
        <div id="error_explanation">
          <h2>
            <%= t(
              "administrate.form.errors",
              pluralized_errors:
                pluralize(
                  account_user_page.resource.errors.count,
                  t("administrate.form.error"),
                ),
              resource_name: display_resource_name(account_user_page.resource_name),
            ) %>
          </h2>

          <ul>
            <% account_user_page.resource.errors.full_messages.each do |message| %>
              <li class="flash-error"><%= message %></li>
            <% end %>
          </ul>
        </div>
      <% end %>

      <% account_user_page.attributes.each do |title, attributes| -%>
        <% attributes.each do |attribute| %>
          <% if attribute.name == "account" %>
            <%= f.hidden_field("account_id", value: page.resource.id) %>
          <% else %>
            <div
              class="
                field-unit field-unit--<%= attribute.html_class %>
                field-unit--<%= requireness(attribute) %>
              "
            >
              <%= render_field attribute, f: f %>
            </div>
          <% end %>
        <% end %>
      <% end -%>

      <div class="form-actions">
        <%= f.submit %>
      </div>
    <% end %>

  </section>

  <%= render partial: "seed_data", locals: { page: page } %>

  <%= render partial: "reset_cache", locals: { page: page } %>

================
File: views/super_admin/app_configs/show.html.erb
================
<% content_for(:title) do %>
  Configure Settings - <%= @config.titleize %>
<% end %>

<header class="main-content__header" role="banner">
  <h1 class="main-content__page-title" id="page-title">
    <%= content_for(:title) %>
  </h1>
</header>

<style>
.eye-icon.eye-hide path {
  d: path('M3 3l18 18M10.5 10.677a2 2 0 002.823 2.823M7.362 7.561C5.68 8.74 4.279 10.42 3 12c1.889 2.991 5.282 6 9 6 1.55 0 3.043-.523 4.395-1.35M12 6c4.008 0 6.701 3.009 9 6a15.66 15.66 0 01-1.078 1.5');
}
</style>

<section class="main-content__body">
  <%= form_with url: super_admin_app_config_url(config: @config) , method: :post do |form| %>
    <% @allowed_configs.each do |key| %>
      <div class="flex mb-8">
        <div class="field-unit__label">
          <%= form.label "app_config[#{key}]", @installation_configs[key]&.dig('display_title') || key %>
        </div>
        <div class="-mt-2 field-unit__field ">
          <% if @installation_configs[key]&.dig('type') == 'boolean' %>
            <%= form.select "app_config[#{key}]",
              [["True", true], ["False", false]],
              { selected: ActiveModel::Type::Boolean.new.cast(@app_config[key]) },
              class: "mt-2 border border-slate-100 p-1 rounded-md"
            %>
          <% elsif @installation_configs[key]&.dig('type') == 'code' %>
            <%= form.text_area "app_config[#{key}]",
                value: @app_config[key],
                rows: 12,
                wrap: 'off',
                class: "mt-2 border font-mono text-xs border-slate-100 p-1 rounded-md overflow-scroll"
            %>
          <% elsif @installation_configs[key]&.dig('type') == 'secret' %>
            <div class="relative">
              <%= form.password_field "app_config[#{key}]",
                  id: "app_config_#{key}",
                  value: @app_config[key],
                  class: "mt-2 border border-slate-100 p-1.5 pr-8 rounded-md w-full"
              %>
              <button
                type="button"
                class="absolute reset-base !bg-white top-1/2 !outline-0 !text-n-slate-11 -translate-y-1/2 right-2 p-1 hover:!bg-n-slate-5 rounded-sm toggle-password"
                data-target="app_config_<%= key %>"
              >
                <svg class="eye-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M12 5C5.63636 5 2 12 2 12C2 12 5.63636 19 12 19C18.3636 19 22 12 22 12C22 12 18.3636 5 12 5Z"/>
                  <path d="M12 15C13.6569 15 15 13.6569 15 12C15 10.3431 13.6569 9 12 9C10.3431 9 9 10.3431 9 12C9 13.6569 10.3431 15 12 15Z"/>
                </svg>
              </button>
            </div>
          <% else %>
            <%= form.text_field "app_config[#{key}]", value: @app_config[key] %>
          <% end %>
          <%if @installation_configs[key]&.dig('description').present? %>
            <p class="pt-2 text-xs italic text-slate-400">
              <%= @installation_configs[key]&.dig('description') %>
            </p>
          <% end %>
        </div>
      </div>
    <% end %>
    <div class="form-actions">
      <%= form.submit "Submit" %>
    </div>
  <% end %>
</section>

<% content_for :javascript do %>
  <script>
  document.addEventListener('DOMContentLoaded', () => {
    document.querySelectorAll('.toggle-password').forEach(button => {
      button.addEventListener('click', () => {
        const targetId = button.dataset.target;
        const input = document.getElementById(targetId);
        const type = input.type === 'password' ? 'text' : 'password';
        input.type = type;

        // Toggle icon
        const svg = button.querySelector('.eye-icon');
        if (type === 'password') {
          svg.classList.remove('eye-hide')
        } else {
          svg.classList.add('eye-hide')
        }
      });
    });
  });
  </script>
<% end %>

================
File: views/super_admin/application/_collection.html.erb
================
<%#
# Collection

This partial is used on the `index` and `show` pages
to display a collection of resources in an HTML table.

## Local variables:

- `collection_presenter`:
  An instance of [Administrate::Page::Collection][1].
  The table presenter uses `ResourceDashboard::COLLECTION_ATTRIBUTES` to determine
  the columns displayed in the table
- `resources`:
  An ActiveModel::Relation collection of resources to be displayed in the table.
  By default, the number of resources is limited by pagination
  or by a hard limit to prevent excessive page load times

[1]: http://www.rubydoc.info/gems/administrate/Administrate/Page/Collection
%>

<table aria-labelledby="<%= table_title %>">
  <thead>
    <tr>
      <% collection_presenter.attribute_types.each do |attr_name, attr_type| %>
        <th class="cell-label
        cell-label--<%= attr_type.html_class %>
        cell-label--<%= collection_presenter.ordered_html_class(attr_name) %>"
        scope="col"
        role="columnheader"
        aria-sort="<%= sort_order(collection_presenter.ordered_html_class(attr_name)) %>">
        <%= link_to(sanitized_order_params(page, collection_field_name).merge(
          collection_presenter.order_params_for(attr_name, key: collection_field_name)
        )) do %>
        <%= t(
          "helpers.label.#{collection_presenter.resource_name}.#{attr_name}",
          default: attr_name.to_s,
        ).titleize %>
            <% if collection_presenter.ordered_by?(attr_name) %>
              <span class="cell-label__sort-indicator cell-label__sort-indicator--<%= collection_presenter.ordered_html_class(attr_name) %>">
                <svg aria-hidden="true">
                  <use xlink:href="#icon-up-caret" />
                </svg>
              </span>
            <% end %>
          <% end %>
        </th>
      <% end %>
      <% [existing_action?(collection_presenter.resource_name, :edit),
          existing_action?(collection_presenter.resource_name, :destroy)].count(true).times do %>
        <th scope="col"></th>
      <% end %>
    </tr>
  </thead>

  <tbody>
    <% resources.each do |resource| %>
      <tr class="js-table-row"
          tabindex="0"
          <% if existing_action? collection_presenter.resource_name, :show %>
            <%= %(role=link data-url=#{polymorphic_path([namespace, resource])}) %>
          <% end %>
          >
        <% collection_presenter.attributes_for(resource).each do |attribute| %>
          <td class="cell-data cell-data--<%= attribute.html_class %>">
            <% if authorized_action? resource, :show -%>
              <a href="<%= polymorphic_path([namespace, resource]) -%>"
                 class="action-show"
                 >
                <%= render_field attribute %>
              </a>
            <% end -%>
          </td>
        <% end %>

        <% if existing_action? collection_presenter.resource_name, :edit %>
          <td><%= link_to(
            t("administrate.actions.edit"),
            [:edit, namespace, resource],
            class: "action-edit",
          ) if authorized_action? resource, :edit%></td>
        <% end %>

        <% if existing_action? collection_presenter.resource_name, :destroy %>
          <td><%= link_to(
            t("administrate.actions.destroy"),
            [namespace, resource],
            class: "text-color-red",
            method: :delete,
            data: { confirm: t("administrate.actions.confirm") }
          ) if authorized_action? resource, :destroy %></td>
        <% end %>
      </tr>
    <% end %>
  </tbody>
</table>

================
File: views/super_admin/application/_filters.html.erb
================
<%#
# Filters

This partial is used on the `index` page to display available filters
for a collection of resources.

## Local variables:

- `page`:
  An instance of [Administrate::Page::Collection][1].
  Contains helper methods to help display a table,
  and knows which attributes should be displayed in the resource's table.

[1]: http://www.rubydoc.info/gems/administrate/Administrate/Page/Collection
%>

<% 
  # Get the dashboard class name from the resource name
  resource_name = page.resource_name.classify
  dashboard_class_name = "#{resource_name}Dashboard"
  dashboard_class = dashboard_class_name.constantize
  
  # Get the current filter if any
  current_filter = nil
  if params[:search] && params[:search].include?(':')
    current_filter = params[:search].split(':').first
  end
%>

<% if dashboard_class.const_defined?(:COLLECTION_FILTERS) && !dashboard_class::COLLECTION_FILTERS.empty? %>
  <div class="flex items-center bg-gray-100 border-0 rounded-md shadow-none relative w-[260px]">
    <div class="flex items-center h-10 px-2 w-full">
      <div class="flex items-center justify-center flex-shrink-0 mr-2 text-gray-500" title="Filter by">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"></polygon>
        </svg>
      </div>
      <div class="flex-1 h-full min-w-0 relative">
        <select id="filter-select" class="appearance-none bg-gray-100 border-0 text-gray-700 cursor-pointer text-sm h-full overflow-hidden truncate whitespace-nowrap w-full pr-7 pl-0 py-2 focus:outline-none bg-[url('data:image/svg+xml,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 width=%2712%27 height=%2712%27 viewBox=%270 0 12 12%27%3E%3Cpath fill=%27%23293f54%27 d=%27M6 9L1 4h10z%27/%3E%3C/svg%3E')] bg-[right_0.25rem_center] bg-no-repeat bg-[length:0.75rem]" onchange="applyFilter(this.value)">
          <option value="">All records</option>
          <% dashboard_class::COLLECTION_FILTERS.each do |filter_name, _| %>
            <option value="<%= filter_name %>" <%= 'selected' if filter_name.to_s == current_filter %>>
              <%= filter_name.to_s.titleize %>
            </option>
          <% end %>
        </select>
        <% if current_filter %>
          <a href="?" class="flex items-center justify-center rounded-full text-gray-500 text-xl font-bold h-[18px] w-[18px] leading-none absolute right-5 top-1/2 -translate-y-1/2 no-underline z-2 hover:text-gray-900" title="Clear filter"></a>
        <% end %>
      </div>
    </div>
  </div>

  <script>
    function applyFilter(filterName) {
      if (filterName) {
        window.location.href = "?search=" + encodeURIComponent(filterName) + "%3A";
      } else {
        window.location.href = "?";
      }
    }
  </script>
<% end %>

================
File: views/super_admin/application/_flashes.html.erb
================
<%#
# Flash Partial

This partial renders flash messages on every page.

## Relevant Helpers:

- `flash`:
  Returns a hash,
  where the keys are the type of flash (alert, error, notice, etc)
  and the values are the message to be displayed.
%>

<% if flash.any? %>
  <div class="flashes">
    <% flash.each do |key, value| -%>
      <div class="flash flash-<%= key %>"><%= value.to_s.html_safe %></div>
    <% end -%>
  </div>
<% end %>

================
File: views/super_admin/application/_icons.html.erb
================
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="icon-microsoft" viewBox="0 0 24 24">
    <path fill="currentColor" d="M2 3h9v9H2zm9 19H2v-9h9zM21 3v9h-9V3zm0 19h-9v-9h9z"/>
  </symbol>
  <symbol id="icon-cancel" viewBox="0 0 48 48">
    <path fill-rule="evenodd" d="M24 19.757l-8.485-8.485c-.784-.783-2.047-.782-2.827 0l-1.417 1.416c-.777.777-.78 2.046.002 2.827L19.757 24l-8.485 8.485c-.783.784-.782 2.047 0 2.827l1.416 1.417c.777.777 2.046.78 2.827-.002L24 28.243l8.485 8.485c.784.783 2.047.782 2.827 0l1.417-1.416c.777-.777.78-2.046-.002-2.827L28.243 24l8.485-8.485c.783-.784.782-2.047 0-2.827l-1.416-1.417c-.777-.777-2.046-.78-2.827.002L24 19.757zM24 47c12.703 0 23-10.297 23-23S36.703 1 24 1 1 11.297 1 24s10.297 23 23 23z" />
  </symbol>

  <symbol id="icon-grid-line" viewBox="0 0 20 20">
    <path d="M16.75 3.25C16.9489 3.25 17.1397 3.32902 17.2803 3.46967C17.421 3.61032 17.5 3.80109 17.5 4V16C17.5 16.1989 17.421 16.3897 17.2803 16.5303C17.1397 16.671 16.9489 16.75 16.75 16.75H3.25C3.05109 16.75 2.86032 16.671 2.71967 16.5303C2.57902 16.3897 2.5 16.1989 2.5 16V4C2.5 3.80109 2.57902 3.61032 2.71967 3.46967C2.86032 3.32902 3.05109 3.25 3.25 3.25H16.75ZM9.25 10.75H4V15.25H9.25V10.75ZM16 10.75H10.75V15.25H16V10.75ZM9.25 4.75H4V9.25H9.25V4.75ZM16 4.75H10.75V9.25H16V4.75Z" fill="currentColor"/>
  </symbol>

  <symbol id="icon-user-follow-line" viewBox="0 0 20 20">
    <path d="M11.5 11.689V13.2565C10.8212 13.0165 10.0947 12.9429 9.38155 13.0418C8.6684 13.1408 7.9894 13.4094 7.40157 13.8252C6.81375 14.2409 6.33426 14.7916 6.00337 15.4311C5.67249 16.0705 5.49986 16.78 5.5 17.5L4 17.4993C3.99977 16.5834 4.20919 15.6797 4.61222 14.8573C5.01526 14.0349 5.6012 13.3157 6.32516 12.7548C7.04912 12.1939 7.89188 11.8061 8.78887 11.6212C9.68585 11.4364 10.6132 11.4593 11.5 11.6883V11.689ZM10 10.75C7.51375 10.75 5.5 8.73625 5.5 6.25C5.5 3.76375 7.51375 1.75 10 1.75C12.4863 1.75 14.5 3.76375 14.5 6.25C14.5 8.73625 12.4863 10.75 10 10.75ZM10 9.25C11.6575 9.25 13 7.9075 13 6.25C13 4.5925 11.6575 3.25 10 3.25C8.3425 3.25 7 4.5925 7 6.25C7 7.9075 8.3425 9.25 10 9.25ZM14.3448 15.9355L16.996 13.2843L18.0573 14.3448L14.3448 18.0573L11.6928 15.4053L12.754 14.3448L14.344 15.9355H14.3448Z" fill="currentColor"/>
  </symbol>

  <symbol id="icon-mist-fill" viewBox="0 0 20 20">
    <path d="M4 4H7V5.5H4V4ZM13 15.25H16V16.75H13V15.25ZM2.5 7.75H10V9.25H2.5V7.75ZM11.5 7.75H16V9.25H11.5V7.75ZM4 11.5H8.5V13H4V11.5ZM10 11.5H17.5V13H10V11.5ZM8.5 4H17.5V5.5H8.5V4ZM2.5 15.25H11.5V16.75H2.5V15.25Z" fill="currentColor"/>
  </symbol>

  <symbol id="icon-settings-2-line" viewBox="0 0 20 20">
    <path d="M7.51453 4L9.46979 2.04475C9.61043 1.90415 9.80116 1.82516 10 1.82516C10.1989 1.82516 10.3896 1.90415 10.5303 2.04475L12.4855 4H15.25C15.4489 4 15.6397 4.07902 15.7804 4.21967C15.921 4.36033 16 4.55109 16 4.75V7.5145L17.9553 9.46975C18.0959 9.6104 18.1749 9.80113 18.1749 10C18.1749 10.1989 18.0959 10.3896 17.9553 10.5303L16 12.4855V15.25C16 15.4489 15.921 15.6397 15.7804 15.7803C15.6397 15.921 15.4489 16 15.25 16H12.4855L10.5303 17.9553C10.3896 18.0959 10.1989 18.1748 10 18.1748C9.80116 18.1748 9.61043 18.0959 9.46979 17.9553L7.51453 16H4.75003C4.55112 16 4.36036 15.921 4.21971 15.7803C4.07905 15.6397 4.00003 15.4489 4.00003 15.25V12.4855L2.04479 10.5303C1.90418 10.3896 1.8252 10.1989 1.8252 10C1.8252 9.80113 1.90418 9.6104 2.04479 9.46975L4.00003 7.5145V4.75C4.00003 4.55109 4.07905 4.36033 4.21971 4.21967C4.36036 4.07902 4.55112 4 4.75003 4H7.51453ZM5.50003 5.5V8.13625L3.63629 10L5.50003 11.8638V14.5H8.13629L10 16.3638L11.8638 14.5H14.5V11.8638L16.3638 10L14.5 8.13625V5.5H11.8638L10 3.63625L8.13629 5.5H5.50003ZM10 13C9.20438 13 8.44132 12.6839 7.87871 12.1213C7.31611 11.5587 7.00003 10.7957 7.00003 10C7.00003 9.20435 7.31611 8.44129 7.87871 7.87868C8.44132 7.31607 9.20438 7 10 7C10.7957 7 11.5587 7.31607 12.1214 7.87868C12.684 8.44129 13 9.20435 13 10C13 10.7957 12.684 11.5587 12.1214 12.1213C11.5587 12.6839 10.7957 13 10 13ZM10 11.5C10.3979 11.5 10.7794 11.342 11.0607 11.0607C11.342 10.7794 11.5 10.3978 11.5 10C11.5 9.60218 11.342 9.22065 11.0607 8.93934C10.7794 8.65804 10.3979 8.5 10 8.5C9.60221 8.5 9.22068 8.65804 8.93937 8.93934C8.65807 9.22065 8.50003 9.60218 8.50003 10C8.50003 10.3978 8.65807 10.7794 8.93937 11.0607C9.22068 11.342 9.60221 11.5 10 11.5Z" fill="currentColor"/>
  </symbol>

  <symbol id="icon-health-book-line" viewBox="0 0 20 20">
    <path d="M16 2.5C16.414 2.5 16.75 2.836 16.75 3.25V16.75C16.75 17.164 16.414 17.5 16 17.5H5.5C5.086 17.5 4.75 17.164 4.75 16.75V15.25H3.25V13.75H4.75V12.25H3.25V10.75H4.75V9.25H3.25V7.75H4.75V6.25H3.25V4.75H4.75V3.25C4.75 2.836 5.086 2.5 5.5 2.5H16ZM15.25 4H6.25V16H15.25V4ZM11.5 7V9.25H13.75V10.75H11.4992L11.5 13H10L9.99925 10.75H7.75V9.25H10V7H11.5Z" fill="currentColor"/>
  </symbol>

  <symbol id="icon-building-4-line" viewBox="0 0 20 20">
    <path d="M16.75 16H18.25V17.5H1.75V16H3.25V3.25C3.25 3.05109 3.32902 2.86032 3.46967 2.71967C3.61032 2.57902 3.80109 2.5 4 2.5H16C16.1989 2.5 16.3897 2.57902 16.5303 2.71967C16.671 2.86032 16.75 3.05109 16.75 3.25V16ZM15.25 16V4H4.75V16H15.25ZM7 9.25H9.25V10.75H7V9.25ZM7 6.25H9.25V7.75H7V6.25ZM7 12.25H9.25V13.75H7V12.25ZM10.75 12.25H13V13.75H10.75V12.25ZM10.75 9.25H13V10.75H10.75V9.25ZM10.75 6.25H13V7.75H10.75V6.25Z" fill="currentColor"/>
  </symbol>

  <symbol id="icon-robot-line" viewBox="0 0 20 20">
    <path d="M10.75 4.04125C14.125 4.414 16.75 7.27525 16.75 10.75V17.5H3.25V10.75C3.25 7.27525 5.875 4.414 9.25 4.04125V1.75H10.75V4.04125ZM15.25 16V10.75C15.25 9.35761 14.6969 8.02226 13.7123 7.03769C12.7277 6.05312 11.3924 5.5 10 5.5C8.60761 5.5 7.27226 6.05312 6.28769 7.03769C5.30312 8.02226 4.75 9.35761 4.75 10.75V16H15.25ZM10 14.5C9.00544 14.5 8.05161 14.1049 7.34835 13.4017C6.64509 12.6984 6.25 11.7446 6.25 10.75C6.25 9.75544 6.64509 8.80161 7.34835 8.09835C8.05161 7.39509 9.00544 7 10 7C10.9946 7 11.9484 7.39509 12.6517 8.09835C13.3549 8.80161 13.75 9.75544 13.75 10.75C13.75 11.7446 13.3549 12.6984 12.6517 13.4017C11.9484 14.1049 10.9946 14.5 10 14.5V14.5ZM10 13C10.5967 13 11.169 12.7629 11.591 12.341C12.0129 11.919 12.25 11.3467 12.25 10.75C12.25 10.1533 12.0129 9.58097 11.591 9.15901C11.169 8.73705 10.5967 8.5 10 8.5C9.40326 8.5 8.83097 8.73705 8.40901 9.15901C7.98705 9.58097 7.75 10.1533 7.75 10.75C7.75 11.3467 7.98705 11.919 8.40901 12.341C8.83097 12.7629 9.40326 13 10 13V13ZM10 11.5C9.80109 11.5 9.61032 11.421 9.46967 11.2803C9.32902 11.1397 9.25 10.9489 9.25 10.75C9.25 10.5511 9.32902 10.3603 9.46967 10.2197C9.61032 10.079 9.80109 10 10 10C10.1989 10 10.3897 10.079 10.5303 10.2197C10.671 10.3603 10.75 10.5511 10.75 10.75C10.75 10.9489 10.671 11.1397 10.5303 11.2803C10.3897 11.421 10.1989 11.5 10 11.5Z" fill="currentColor"/>
  </symbol>

  <symbol id="icon-apps-2-line" viewBox="0 0 20 20">
    <path d="M5.875 9.625C5.43179 9.625 4.99292 9.5377 4.58344 9.36809C4.17397 9.19848 3.80191 8.94988 3.48851 8.63649C3.17512 8.32309 2.92652 7.95103 2.75691 7.54156C2.5873 7.13208 2.5 6.69321 2.5 6.25C2.5 5.80679 2.5873 5.36792 2.75691 4.95844C2.92652 4.54897 3.17512 4.17691 3.48851 3.86351C3.80191 3.55012 4.17397 3.30152 4.58344 3.13191C4.99292 2.9623 5.43179 2.875 5.875 2.875C6.77011 2.875 7.62855 3.23058 8.26149 3.86351C8.89442 4.49645 9.25 5.35489 9.25 6.25C9.25 7.14511 8.89442 8.00355 8.26149 8.63649C7.62855 9.26942 6.77011 9.625 5.875 9.625V9.625ZM6.25 17.125C5.35489 17.125 4.49645 16.7694 3.86351 16.1365C3.23058 15.5035 2.875 14.6451 2.875 13.75C2.875 12.8549 3.23058 11.9965 3.86351 11.3635C4.49645 10.7306 5.35489 10.375 6.25 10.375C7.14511 10.375 8.00355 10.7306 8.63649 11.3635C9.26942 11.9965 9.625 12.8549 9.625 13.75C9.625 14.6451 9.26942 15.5035 8.63649 16.1365C8.00355 16.7694 7.14511 17.125 6.25 17.125V17.125ZM13.75 9.625C13.3068 9.625 12.8679 9.5377 12.4584 9.36809C12.049 9.19848 11.6769 8.94988 11.3635 8.63649C11.0501 8.32309 10.8015 7.95103 10.6319 7.54156C10.4623 7.13208 10.375 6.69321 10.375 6.25C10.375 5.80679 10.4623 5.36792 10.6319 4.95844C10.8015 4.54897 11.0501 4.17691 11.3635 3.86351C11.6769 3.55012 12.049 3.30152 12.4584 3.13191C12.8679 2.9623 13.3068 2.875 13.75 2.875C14.6451 2.875 15.5035 3.23058 16.1365 3.86351C16.7694 4.49645 17.125 5.35489 17.125 6.25C17.125 7.14511 16.7694 8.00355 16.1365 8.63649C15.5035 9.26942 14.6451 9.625 13.75 9.625V9.625ZM13.75 17.125C12.8549 17.125 11.9965 16.7694 11.3635 16.1365C10.7306 15.5035 10.375 14.6451 10.375 13.75C10.375 12.8549 10.7306 11.9965 11.3635 11.3635C11.9965 10.7306 12.8549 10.375 13.75 10.375C14.6451 10.375 15.5035 10.7306 16.1365 11.3635C16.7694 11.9965 17.125 12.8549 17.125 13.75C17.125 14.6451 16.7694 15.5035 16.1365 16.1365C15.5035 16.7694 14.6451 17.125 13.75 17.125ZM5.875 8.125C6.37228 8.125 6.84919 7.92746 7.20083 7.57583C7.55246 7.22419 7.75 6.74728 7.75 6.25C7.75 5.75272 7.55246 5.27581 7.20083 4.92417C6.84919 4.57254 6.37228 4.375 5.875 4.375C5.37772 4.375 4.90081 4.57254 4.54917 4.92417C4.19754 5.27581 4 5.75272 4 6.25C4 6.74728 4.19754 7.22419 4.54917 7.57583C4.90081 7.92746 5.37772 8.125 5.875 8.125V8.125ZM6.25 15.625C6.74728 15.625 7.22419 15.4275 7.57583 15.0758C7.92746 14.7242 8.125 14.2473 8.125 13.75C8.125 13.2527 7.92746 12.7758 7.57583 12.4242C7.22419 12.0725 6.74728 11.875 6.25 11.875C5.75272 11.875 5.27581 12.0725 4.92417 12.4242C4.57254 12.7758 4.375 13.2527 4.375 13.75C4.375 14.2473 4.57254 14.7242 4.92417 15.0758C5.27581 15.4275 5.75272 15.625 6.25 15.625ZM13.75 8.125C14.2473 8.125 14.7242 7.92746 15.0758 7.57583C15.4275 7.22419 15.625 6.74728 15.625 6.25C15.625 5.75272 15.4275 5.27581 15.0758 4.92417C14.7242 4.57254 14.2473 4.375 13.75 4.375C13.2527 4.375 12.7758 4.57254 12.4242 4.92417C12.0725 5.27581 11.875 5.75272 11.875 6.25C11.875 6.74728 12.0725 7.22419 12.4242 7.57583C12.7758 7.92746 13.2527 8.125 13.75 8.125ZM13.75 15.625C14.2473 15.625 14.7242 15.4275 15.0758 15.0758C15.4275 14.7242 15.625 14.2473 15.625 13.75C15.625 13.2527 15.4275 12.7758 15.0758 12.4242C14.7242 12.0725 14.2473 11.875 13.75 11.875C13.2527 11.875 12.7758 12.0725 12.4242 12.4242C12.0725 12.7758 11.875 13.2527 11.875 13.75C11.875 14.2473 12.0725 14.7242 12.4242 15.0758C12.7758 15.4275 13.2527 15.625 13.75 15.625Z" fill="currentColor"/>
  </symbol>

  <symbol id="icon-folder-3-line" viewBox="0 0 20 20">
    <path d="M10.3105 4.75H16.75C16.9489 4.75 17.1397 4.82902 17.2803 4.96967C17.421 5.11032 17.5 5.30109 17.5 5.5V16C17.5 16.1989 17.421 16.3897 17.2803 16.5303C17.1397 16.671 16.9489 16.75 16.75 16.75H3.25C3.05109 16.75 2.86032 16.671 2.71967 16.5303C2.57902 16.3897 2.5 16.1989 2.5 16V4C2.5 3.80109 2.57902 3.61032 2.71967 3.46967C2.86032 3.32902 3.05109 3.25 3.25 3.25H8.8105L10.3105 4.75ZM4 6.25V15.25H16V6.25H4Z" fill="currentColor"/>
  </symbol>

  <symbol id="icon-draft-line" viewBox="0 0 20 20">
    <path d="M16 2.5C16.414 2.5 16.75 2.836 16.75 3.25V6.06775L15.25 7.56775V4H4.75V16H15.25V13.9315L16.75 12.4315V16.75C16.75 17.164 16.414 17.5 16 17.5H4C3.586 17.5 3.25 17.164 3.25 16.75V3.25C3.25 2.836 3.586 2.5 4 2.5H16ZM17.3335 7.606L18.394 8.6665L12.5605 14.5L11.4985 14.4985L11.5 13.4395L17.3335 7.606V7.606ZM10.75 10V11.5H7V10H10.75ZM13 7V8.5H7V7H13Z" fill="currentColor"/>
  </symbol>

  <symbol id="icon-reply-line" viewBox="0 0 20 20">
    <path d="M9.25 16L1.75 10L9.25 4V7.75C13.3922 7.75 16.75 11.1078 16.75 15.25C16.75 15.4548 16.7425 15.6572 16.726 15.8575C15.6288 13.777 13.4785 12.3393 10.9847 12.2538L10.75 12.25H9.25V16ZM7.75 10.75H10.7755L11.0357 10.7552C11.9995 10.7875 12.9287 10.9877 13.7927 11.3297C12.6925 10.0562 11.065 9.25 9.25 9.25H7.75V7.12075L4.1515 10L7.75 12.8792V10.75Z" fill="currentColor"/>
  </symbol>

  <symbol id="icon-logout-circle-r-line" viewBox="0 0 20 20">
    <path d="M10 17.5C5.85775 17.5 2.5 14.1423 2.5 10C2.5 5.85775 5.85775 2.5 10 2.5C11.1645 2.49913 12.3131 2.76983 13.3547 3.29061C14.3963 3.81139 15.302 4.56788 16 5.5H13.9675C13.1014 4.73632 12.0334 4.23877 10.8915 4.06705C9.74969 3.89533 8.58255 4.05674 7.53017 4.53191C6.47778 5.00708 5.58486 5.77582 4.95855 6.74589C4.33224 7.71596 3.99915 8.84615 3.99925 10.0008C3.99934 11.1555 4.33262 12.2856 4.95909 13.2556C5.58557 14.2256 6.47861 14.9942 7.53108 15.4692C8.58354 15.9442 9.75071 16.1054 10.8925 15.9335C12.0343 15.7616 13.1023 15.2638 13.9683 14.5H16.0007C15.3027 15.4322 14.3968 16.1888 13.3551 16.7096C12.3134 17.2303 11.1646 17.501 10 17.5V17.5ZM15.25 13V10.75H9.25V9.25H15.25V7L19 10L15.25 13Z" fill="currentColor"/>
  </symbol>
  <symbol id="icon-dashboard-line" viewBox="0 0 20 20">
    <path d="M10.75 16.75V9.25H16.75V16.75H10.75ZM3.25 10.75V3.25H9.25V10.75H3.25ZM7.75 9.25V4.75H4.75V9.25H7.75ZM3.25 16.75V12.25H9.25V16.75H3.25ZM4.75 15.25H7.75V13.75H4.75V15.25ZM12.25 15.25H15.25V10.75H12.25V15.25ZM10.75 3.25H16.75V7.75H10.75V3.25ZM12.25 4.75V6.25H15.25V4.75H12.25Z" fill="currentColor"/>
  </symbol>

  <symbol id="icon-refresh-line" viewBox="0 0 16 16">
    <path d="M4.0778 3.4598C5.16654 2.51639 6.55939 1.99799 8 2C11.3138 2 14 4.6862 14 8C14 9.2816 13.598 10.4696 12.914 11.444L11 8H12.8C12.8001 7.05897 12.5235 6.13868 12.0048 5.35355C11.486 4.56842 10.748 3.95309 9.88231 3.58407C9.01666 3.21505 8.06163 3.10862 7.13597 3.27801C6.21032 3.4474 5.35487 3.88514 4.676 4.5368L4.0778 3.4598ZM11.9222 12.5402C10.8335 13.4836 9.44061 14.002 8 14C4.6862 14 2 11.3138 2 8C2 6.7184 2.402 5.5304 3.086 4.556L5 8H3.2C3.19992 8.94102 3.47645 9.86132 3.9952 10.6464C4.51395 11.4316 5.25204 12.0469 6.11769 12.4159C6.98334 12.7849 7.93837 12.8914 8.86403 12.722C9.78968 12.5526 10.6451 12.1149 11.324 11.4632L11.9222 12.5402Z" fill="#1F93FF"/>
  </symbol>

  <symbol id="icon-sailbot-fill" viewBox="0 0 24 24">
    <path d="M3.89995 17.4H20.1C20.1835 17.4 20.2654 17.4233 20.3365 17.4672C20.4076 17.5111 20.4651 17.574 20.5024 17.6487C20.5398 17.7235 20.5556 17.8072 20.5481 17.8904C20.5406 17.9736 20.5101 18.0531 20.46 18.12L18.57 20.64C18.4861 20.7518 18.3774 20.8425 18.2524 20.905C18.1275 20.9675 17.9897 21 17.85 21H6.14995C6.01023 21 5.87243 20.9675 5.74746 20.905C5.62249 20.8425 5.51378 20.7518 5.42995 20.64L3.53995 18.12C3.48981 18.0531 3.45927 17.9736 3.45177 17.8904C3.44426 17.8072 3.46009 17.7235 3.49746 17.6487C3.53483 17.574 3.59228 17.5111 3.66337 17.4672C3.73446 17.4233 3.81638 17.4 3.89995 17.4ZM14.7 3.38249V14.7C14.7 14.9387 14.6051 15.1676 14.4363 15.3364C14.2676 15.5052 14.0386 15.6 13.8 15.6H4.83595C4.75127 15.5999 4.66835 15.5759 4.59671 15.5307C4.52507 15.4856 4.46761 15.4211 4.43095 15.3448C4.39429 15.2685 4.37991 15.1834 4.38946 15.0992C4.39902 15.0151 4.43211 14.9354 4.48495 14.8692L13.899 3.10169C13.9572 3.02905 14.0366 2.97628 14.1261 2.95066C14.2157 2.92503 14.3109 2.92782 14.3988 2.95863C14.4867 2.98943 14.5629 3.04675 14.6168 3.12267C14.6707 3.19858 14.6998 3.28936 14.7 3.38249Z" fill="currentColor"/>
  </symbol>

  <symbol id="icon-menu-search-line" viewBox="0 0 24 24">
    <path d="M14.625 6.75C13.1753 6.75 12 7.92525 12 9.375C12 10.8247 13.1753 12 14.625 12C16.0747 12 17.25 10.8247 17.25 9.375C17.25 7.92525 16.0747 6.75 14.625 6.75ZM10.5 9.375C10.5 7.09682 12.3468 5.25 14.625 5.25C16.9032 5.25 18.75 7.09682 18.75 9.375C18.75 10.2431 18.4818 11.0486 18.0238 11.7131L20.0303 13.7197L18.9697 14.7803L16.9631 12.7738C16.2986 13.2318 15.4931 13.5 14.625 13.5C12.3468 13.5 10.5 11.6532 10.5 9.375ZM5.25 6H9V7.5H5.25V6ZM5.25 11.25H9V12.75H5.25V11.25ZM18.75 16.5V18H5.25V16.5H18.75Z" fill="currentColor"/>
  </symbol>

  <symbol id="icon-hourglass-line" viewBox="0 0 24 24">
    <rect width="24" height="24" fill="white"/>
    <path d="M7.5 6H6V4.5H18V6H16.5V7.5C16.5 8.71157 15.8878 9.68601 15.1171 10.4825C14.5899 11.0273 13.9485 11.529 13.2982 12C13.9485 12.471 14.5899 12.9728 15.1171 13.5175C15.8878 14.314 16.5 15.2885 16.5 16.5V18H18V19.5H6V18H7.5V16.5C7.5 15.2885 8.11212 14.314 8.88293 13.5175C9.41012 12.9728 10.0515 12.471 10.7018 12C10.0515 11.529 9.41012 11.0273 8.88293 10.4825C8.11212 9.68601 7.5 8.71157 7.5 7.5V6ZM9 6V7.5C9 8.01386 9.19519 8.50124 9.57848 9H14.4215C14.8048 8.50124 15 8.01386 15 7.5V6H9ZM12 12.9164C11.2161 13.4702 10.506 13.9972 9.96083 14.5606C9.81756 14.7087 9.69005 14.8548 9.57848 15H14.4215C14.3099 14.8548 14.1824 14.7087 14.0392 14.5606C13.494 13.9972 12.7839 13.4702 12 12.9164Z" fill="currentColor"/>
  </symbol>

  <symbol id="icon-paint-brush-line" viewBox="0 0 24 24">
    <path d="M5.6999 5.69999V8.39999H18.2999V5.69999H5.6999ZM4.7999 3.89999H19.1999C19.4386 3.89999 19.6675 3.99482 19.8363 4.1636C20.0051 4.33238 20.0999 4.5613 20.0999 4.79999V9.29999C20.0999 9.53869 20.0051 9.76761 19.8363 9.93639C19.6675 10.1052 19.4386 10.2 19.1999 10.2H4.7999C4.56121 10.2 4.33229 10.1052 4.16351 9.93639C3.99472 9.76761 3.8999 9.53869 3.8999 9.29999V4.79999C3.8999 4.5613 3.99472 4.33238 4.16351 4.1636C4.33229 3.99482 4.56121 3.89999 4.7999 3.89999V3.89999ZM6.5999 12H11.9999C12.2386 12 12.4675 12.0948 12.6363 12.2636C12.8051 12.4324 12.8999 12.6613 12.8999 12.9V15.6H13.7999V21H10.1999V15.6H11.0999V13.8H5.6999C5.46121 13.8 5.23229 13.7052 5.06351 13.5364C4.89472 13.3676 4.7999 13.1387 4.7999 12.9V11.1H6.5999V12ZM17.1587 13.5588L18.7499 11.9676L20.3411 13.5588C20.6557 13.8735 20.8699 14.2744 20.9567 14.7108C21.0435 15.1473 20.9989 15.5996 20.8286 16.0107C20.6583 16.4218 20.3699 16.7732 19.9999 17.0204C19.6299 17.2676 19.1949 17.3996 18.7499 17.3996C18.3049 17.3996 17.8699 17.2676 17.4999 17.0204C17.1299 16.7732 16.8415 16.4218 16.6712 16.0107C16.5009 15.5996 16.4563 15.1473 16.5431 14.7108C16.6299 14.2744 16.8441 13.8735 17.1587 13.5588V13.5588Z" fill="currentColor"/>
  </symbol>

  <symbol id="icon-whatsapp-line" viewBox="0 0 24 24">
    <path d="M7.72771 17.8446L8.37931 18.2253C9.47816 18.8662 10.7279 19.2026 12 19.2C13.424 19.2 14.8161 18.7777 16.0001 17.9866C17.1842 17.1954 18.107 16.0709 18.6519 14.7553C19.1969 13.4397 19.3395 11.992 19.0617 10.5953C18.7839 9.19869 18.0981 7.91577 17.0912 6.90883C16.0842 5.90189 14.8013 5.21616 13.4047 4.93835C12.008 4.66053 10.5603 4.80312 9.24469 5.34807C7.92906 5.89302 6.80458 6.81586 6.01343 7.99989C5.22228 9.18393 4.80001 10.576 4.80001 12C4.80001 13.2924 5.13931 14.5317 5.77561 15.6216L6.15541 16.2732L5.56771 18.4341L7.72771 17.8446ZM3.00361 21L4.22041 16.5288C3.41864 15.1544 2.9974 13.5912 3.00001 12C3.00001 7.0293 7.02931 3 12 3C16.9707 3 21 7.0293 21 12C21 16.9707 16.9707 21 12 21C10.4095 21.0026 8.847 20.5817 7.47301 19.7805L3.00361 21ZM8.75191 7.7772C8.87251 7.7682 8.99401 7.7682 9.11461 7.7736C9.16321 7.7772 9.21181 7.7826 9.26041 7.788C9.40351 7.8042 9.56101 7.8915 9.61411 8.0121C9.88231 8.6205 10.1433 9.2334 10.3953 9.8481C10.4511 9.9849 10.4178 10.1604 10.3116 10.3314C10.2386 10.447 10.1596 10.5588 10.0749 10.6662C9.97321 10.7967 9.75451 11.0361 9.75451 11.0361C9.75451 11.0361 9.66541 11.1423 9.69961 11.2746C9.71221 11.325 9.75361 11.3979 9.79141 11.4591L9.84451 11.5446C10.0749 11.9289 10.3845 12.3186 10.7625 12.6858C10.8705 12.7902 10.9758 12.8973 11.0892 12.9972C11.5104 13.3689 11.9874 13.6722 12.5022 13.8972L12.5067 13.899C12.5832 13.9323 12.6219 13.9503 12.7335 13.998C12.7893 14.0214 12.8469 14.0421 12.9054 14.0574C12.9659 14.0728 13.0295 14.0699 13.0883 14.0491C13.1471 14.0282 13.1984 13.9904 13.2357 13.9404C13.8873 13.1511 13.9467 13.0998 13.9521 13.0998V13.1016C13.9974 13.0594 14.0512 13.0273 14.1098 13.0076C14.1685 12.9879 14.2307 12.981 14.2923 12.9873C14.3463 12.9909 14.4012 13.0008 14.4516 13.0233C14.9295 13.242 15.7116 13.5831 15.7116 13.5831L16.2354 13.818C16.3236 13.8603 16.4037 13.9602 16.4064 14.0565C16.41 14.1168 16.4154 14.214 16.3947 14.3922C16.3659 14.6253 16.2957 14.9052 16.2255 15.0519C16.1774 15.152 16.1136 15.2438 16.0365 15.3237C15.9457 15.4191 15.8463 15.5058 15.7395 15.5829C15.7026 15.6107 15.6651 15.6377 15.627 15.6639C15.5151 15.7349 15.4001 15.801 15.2823 15.8619C15.0506 15.985 14.7947 16.0556 14.5326 16.0689C14.3661 16.0779 14.1996 16.0905 14.0322 16.0815C14.025 16.0815 13.521 16.0032 13.521 16.0032C12.2414 15.6666 11.0581 15.0361 10.065 14.1618C9.86161 13.9827 9.67351 13.7901 9.48091 13.5984C8.67991 12.8019 8.07511 11.9424 7.70791 11.1306C7.51996 10.7322 7.41844 10.2985 7.41001 9.858C7.4063 9.31157 7.58492 8.7795 7.91761 8.346C7.98331 8.2614 8.04541 8.1732 8.15251 8.0715C8.26681 7.9635 8.33881 7.9059 8.41711 7.8663C8.52122 7.81413 8.63479 7.78352 8.75101 7.7763L8.75191 7.7772Z" fill="currentColor"/>
  </symbol>

  <symbol id="icon-book-2-line" viewBox="0 0 24 24">
    <path d="M20.0999 17.4H6.5999C6.36121 17.4 6.13229 17.4948 5.96351 17.6636C5.79472 17.8324 5.6999 18.0613 5.6999 18.3C5.6999 18.5387 5.79472 18.7676 5.96351 18.9364C6.13229 19.1052 6.36121 19.2 6.5999 19.2H20.0999V21H6.5999C5.88382 21 5.19706 20.7155 4.69071 20.2092C4.18437 19.7028 3.8999 19.0161 3.8999 18.3V4.8C3.8999 4.32261 4.08954 3.86477 4.42711 3.52721C4.76468 3.18964 5.22251 3 5.6999 3H20.0999V17.4ZM5.6999 15.645C5.8457 15.6153 5.996 15.6 6.1499 15.6H18.2999V4.8H5.6999V15.645ZM15.5999 9.3H8.3999V7.5H15.5999V9.3Z" fill="currentColor"/>
  </symbol>

  <symbol id="icon-message-line" viewBox="0 0 24 24">
  <path d="M7.0095 18.3L3 21.45V4.80002C3 4.56133 3.09482 4.33241 3.2636 4.16363C3.43239 3.99485 3.66131 3.90002 3.9 3.90002H20.1C20.3387 3.90002 20.5676 3.99485 20.7364 4.16363C20.9052 4.33241 21 4.56133 21 4.80002V17.4C21 17.6387 20.9052 17.8676 20.7364 18.0364C20.5676 18.2052 20.3387 18.3 20.1 18.3H7.0095ZM6.3867 16.5H19.2V5.70002H4.8V17.7465L6.3867 16.5ZM8.4 10.2H15.6V12H8.4V10.2Z" fill="#0A0D14"/>
  </symbol>

  <symbol id="icon-messenger-line" viewBox="0 0 24 24">
  <path d="M8.1876 18.5025C8.7186 18.2685 9.3126 18.2244 9.8688 18.3774C10.5618 18.5664 11.2773 18.6618 12 18.66C16.1265 18.66 19.2 15.7017 19.2 11.73C19.2 7.7583 16.1265 4.8 12 4.8C7.8735 4.8 4.8 7.7583 4.8 11.73C4.8 13.773 5.6064 15.5748 7.0194 16.8384C7.27613 17.0658 7.48374 17.3432 7.62952 17.6537C7.7753 17.9641 7.85618 18.301 7.8672 18.6438L8.1876 18.5025ZM12 3C17.0706 3 21 6.7143 21 11.73C21 16.7457 17.0706 20.46 12 20.46C11.1199 20.4623 10.2436 20.346 9.3945 20.1144C9.23502 20.0706 9.06531 20.0829 8.9139 20.1495L7.1283 20.9379C7.02042 20.9856 6.90247 21.006 6.78484 20.9974C6.6672 20.9888 6.55347 20.9515 6.45366 20.8887C6.35384 20.8258 6.27099 20.7394 6.2124 20.637C6.1538 20.5347 6.12125 20.4195 6.1176 20.3016L6.0681 18.6996C6.06486 18.6022 6.0418 18.5065 6.00033 18.4183C5.95886 18.3301 5.89985 18.2512 5.8269 18.1866C4.0755 16.6215 3 14.3553 3 11.73C3 6.7143 6.9303 3 12 3ZM6.5955 14.2833L9.2388 10.0893C9.33825 9.9314 9.46936 9.79583 9.62385 9.69116C9.77834 9.58648 9.95286 9.51497 10.1364 9.48114C10.3199 9.44731 10.5084 9.4519 10.6901 9.49461C10.8718 9.53733 11.0426 9.61724 11.1918 9.7293L13.2942 11.3043C13.3879 11.375 13.5021 11.4133 13.6195 11.4133C13.737 11.4133 13.8512 11.375 13.9449 11.3043L16.7844 9.1479C17.1633 8.8608 17.6583 9.3144 17.4045 9.7176L14.7612 13.9116C14.6617 14.0695 14.5306 14.2051 14.3761 14.3097C14.2217 14.4144 14.0471 14.4859 13.8636 14.5198C13.6801 14.5536 13.4916 14.549 13.3099 14.5063C13.1282 14.4636 12.9574 14.3837 12.8082 14.2716L10.7058 12.6966C10.6121 12.6259 10.4979 12.5876 10.3804 12.5876C10.263 12.5876 10.1488 12.6259 10.0551 12.6966L7.2156 14.8521C6.8367 15.1392 6.3417 14.6856 6.5955 14.2824V14.2833Z" fill="#0A0D14"/>
  </symbol>

  <symbol id="icon-mail-send-fill" viewBox="0 0 24 24">
    <path d="M2.99995 6.14999V4.79369C3.0016 4.55733 3.09616 4.33111 3.26321 4.16389C3.43026 3.99667 3.65639 3.90188 3.89275 3.89999H20.1072C20.6003 3.89999 21 4.30049 21 4.79369V19.2063C20.9983 19.4427 20.9037 19.6689 20.7367 19.8361C20.5696 20.0033 20.3435 20.0981 20.1072 20.1H3.89275C3.65588 20.0998 3.4288 20.0055 3.26139 19.8379C3.09398 19.6703 2.99995 19.4432 2.99995 19.2063V18.3H19.2V7.76999L12 14.25L2.99995 6.14999ZM1.19995 10.2H5.69995V12H1.19995V10.2ZM1.19995 14.7H8.39995V16.5H1.19995V14.7Z" fill="#0A0D14"/>
  </symbol>

  <symbol id="icon-chat-smile-3-line" viewBox="0 0 24 24">
    <path d="M3.00001 12C3.00001 7.0293 7.02931 3 12 3C16.9707 3 21 7.0293 21 12C21 16.9707 16.9707 21 12 21H3.00001L5.63611 18.3639C4.79914 17.5291 4.13539 16.5371 3.683 15.445C3.23061 14.3529 2.9985 13.1821 3.00001 12ZM7.34521 19.2H12C13.424 19.2 14.8161 18.7777 16.0001 17.9866C17.1841 17.1954 18.107 16.0709 18.6519 14.7553C19.1969 13.4397 19.3395 11.992 19.0617 10.5953C18.7838 9.19869 18.0981 7.91577 17.0912 6.90883C16.0842 5.90189 14.8013 5.21616 13.4047 4.93835C12.008 4.66053 10.5603 4.80312 9.24469 5.34807C7.92906 5.89302 6.80457 6.81586 6.01343 7.99989C5.22228 9.18393 4.80001 10.576 4.80001 12C4.80001 13.9368 5.56591 15.7485 6.90871 17.0913L8.18131 18.3639L7.34521 19.2ZM8.40001 12.9H15.6C15.6 13.8548 15.2207 14.7705 14.5456 15.4456C13.8705 16.1207 12.9548 16.5 12 16.5C11.0452 16.5 10.1296 16.1207 9.45442 15.4456C8.77929 14.7705 8.40001 13.8548 8.40001 12.9Z" fill="#0A0D14"/>
  </symbol>

  <symbol id="icon-telegram-line" viewBox="0 0 24 24">
    <path d="M12 19.2C13.9096 19.2 15.7409 18.4414 17.0912 17.0912C18.4414 15.7409 19.2 13.9096 19.2 12C19.2 10.0904 18.4414 8.25909 17.0912 6.90883C15.7409 5.55857 13.9096 4.8 12 4.8C10.0904 4.8 8.25909 5.55857 6.90883 6.90883C5.55857 8.25909 4.8 10.0904 4.8 12C4.8 13.9096 5.55857 15.7409 6.90883 17.0912C8.25909 18.4414 10.0904 19.2 12 19.2ZM12 21C7.0293 21 3 16.9707 3 12C3 7.0293 7.0293 3 12 3C16.9707 3 21 7.0293 21 12C21 16.9707 16.9707 21 12 21ZM9.201 13.053L6.9528 12.3519C6.4668 12.2034 6.4641 11.8686 7.0617 11.6283L15.8214 8.2443C16.3299 8.0373 16.6179 8.2992 16.4532 8.9553L14.9619 15.9933C14.8575 16.4946 14.556 16.6143 14.1375 16.383L11.8416 14.6838L10.7715 15.717C10.6617 15.8232 10.5726 15.9141 10.4034 15.9366C10.2351 15.96 10.0965 15.9096 9.9948 15.6306L9.2118 13.0467L9.201 13.0539V13.053Z" fill="#0A0D14"/>
  </symbol>

  <symbol id="icon-line-line" viewBox="0 0 24 24">
    <path d="M21 10.821C21 12.4293 20.3817 13.881 19.0893 15.2976C17.1993 17.4702 12.9801 20.1243 12.0117 20.5284C11.0451 20.9343 11.1918 20.2701 11.2251 20.0451L11.3484 19.2801C11.379 19.0443 11.4096 18.6951 11.3196 18.4701C11.2188 18.2208 10.8192 18.0885 10.5267 18.0273C6.2022 17.4531 3 14.43 3 10.821C3 6.79347 7.0383 3.51477 12 3.51477C16.9608 3.51477 21 6.79347 21 10.821ZM17.76 14.0835C18.7617 12.9855 19.2 11.9586 19.2 10.821C19.2 7.87977 16.041 5.31477 12 5.31477C7.959 5.31477 4.8 7.87977 4.8 10.821C4.8 13.4355 7.2552 15.7773 10.7634 16.2426L10.8957 16.266C11.8659 16.4694 12.5913 16.8186 12.9918 17.8032L13.0242 17.8896C14.6496 16.8312 16.7808 15.2076 17.7591 14.0835H17.76ZM17.5242 10.4835C17.6445 10.4909 17.7574 10.5439 17.8399 10.6317C17.9225 10.7195 17.9684 10.8355 17.9684 10.956C17.9684 11.0765 17.9225 11.1924 17.8399 11.2802C17.7574 11.368 17.6445 11.421 17.5242 11.4285H16.2075V12.2727H17.5233C17.587 12.2699 17.6507 12.28 17.7104 12.3025C17.77 12.325 17.8246 12.3593 17.8707 12.4034C17.9167 12.4475 17.9534 12.5005 17.9785 12.5591C18.0035 12.6178 18.0164 12.6809 18.0164 12.7447C18.0164 12.8085 18.0035 12.8716 17.9785 12.9303C17.9534 12.989 17.9167 13.0419 17.8707 13.086C17.8246 13.1301 17.77 13.1645 17.7104 13.1869C17.6507 13.2094 17.587 13.2196 17.5233 13.2168H15.735C15.6104 13.2158 15.4912 13.1658 15.4032 13.0775C15.3153 12.9892 15.2657 12.8698 15.2652 12.7452V9.16677C15.2652 8.90847 15.4767 8.69427 15.7377 8.69427H17.5269C17.6522 8.69463 17.7723 8.74475 17.8606 8.83362C17.949 8.92248 17.9984 9.04281 17.998 9.16812C17.9977 9.29344 17.9476 9.41348 17.8587 9.50183C17.7698 9.59019 17.6495 9.63963 17.5242 9.63927H16.2084V10.4835H17.5242ZM14.6325 12.7452C14.6323 12.8071 14.6198 12.8684 14.5959 12.9255C14.572 12.9826 14.5371 13.0345 14.4931 13.0781C14.4491 13.1217 14.397 13.1563 14.3397 13.1798C14.2824 13.2032 14.221 13.2152 14.1591 13.215C14.085 13.2166 14.0116 13.2005 13.9451 13.1679C13.8785 13.1353 13.8208 13.0873 13.7766 13.0278L11.9442 10.5402V12.7452C11.9352 12.864 11.8817 12.975 11.7943 13.056C11.7069 13.137 11.5922 13.182 11.4731 13.182C11.3539 13.182 11.2392 13.137 11.1518 13.056C11.0644 12.975 11.0109 12.864 11.0019 12.7452V9.16677C11.0017 9.04233 11.0508 8.92287 11.1385 8.83462C11.2263 8.74638 11.3455 8.69655 11.4699 8.69607C11.6157 8.69607 11.7507 8.77347 11.8407 8.88597L13.6875 11.3835V9.16677C13.6875 8.90847 13.899 8.69427 14.16 8.69427C14.4183 8.69427 14.6325 8.90847 14.6325 9.16677V12.7452ZM10.3269 12.7452C10.3262 12.8703 10.276 12.9902 10.1873 13.0785C10.0987 13.1668 9.97867 13.2165 9.8535 13.2168C9.72873 13.2161 9.60928 13.1661 9.52113 13.0778C9.43299 12.9895 9.38327 12.8699 9.3828 12.7452V9.16677C9.3828 8.90847 9.5952 8.69427 9.8553 8.69427C10.1154 8.69427 10.3269 8.90847 10.3269 9.16677V12.7452ZM8.4774 13.2168H6.6873C6.56236 13.2161 6.44272 13.1662 6.35429 13.0779C6.26586 12.9897 6.21574 12.8701 6.2148 12.7452V9.16677C6.22513 9.04857 6.27938 8.93854 6.36685 8.85838C6.45432 8.77822 6.56865 8.73375 6.6873 8.73375C6.80595 8.73375 6.92028 8.77822 7.00775 8.85838C7.09522 8.93854 7.14947 9.04857 7.1598 9.16677V12.2718H8.4774C8.60272 12.2718 8.7229 12.3216 8.81151 12.4102C8.90012 12.4988 8.9499 12.619 8.9499 12.7443C8.9499 12.8696 8.90012 12.9898 8.81151 13.0784C8.7229 13.167 8.60272 13.2168 8.4774 13.2168Z" fill="#0A0D14"/>
  </symbol>

  <symbol id="icon-eyeglass" viewBox="0 0 48 48">
    <path d="M27.885 32.515c-2.864 1.966-6.333 3.116-10.07 3.116C7.976 35.63 0 27.656 0 17.817 0 7.976 7.976 0 17.816 0S35.63 7.976 35.63 17.816c0 3.736-1.15 7.205-3.115 10.07l14.53 14.53c1.278 1.277 1.275 3.352 0 4.628-1.28 1.278-3.353 1.278-4.63 0l-14.53-14.53zm-10.07-3.736c6.056 0 10.964-4.91 10.964-10.964 0-6.055-4.91-10.964-10.964-10.964-6.055 0-10.964 4.91-10.964 10.964 0 6.055 4.91 10.963 10.964 10.963z" fill="currentColor"/>
  </symbol>

  <symbol id="icon-tick-line" viewBox="0 0 24 24">
    <path d="M4.53 12.97a.75.75 0 0 0-1.06 1.06l4.5 4.5a.75.75 0 0 0 1.06 0l11-11a.75.75 0 0 0-1.06-1.06L8.5 16.94l-3.97-3.97Z" fill="currentColor"/>
  </symbol>

  <symbol id="icon-lock-line" viewBox="0 0 24 24">
    <path d="M18.3 10.2H19.2C19.4387 10.2 19.6676 10.2948 19.8364 10.4636C20.0052 10.6324 20.1 10.8613 20.1 11.1V20.1C20.1 20.3387 20.0052 20.5676 19.8364 20.7364C19.6676 20.9052 19.4387 21 19.2 21H4.80002C4.56133 21 4.33241 20.9052 4.16363 20.7364C3.99485 20.5676 3.90002 20.3387 3.90002 20.1V11.1C3.90002 10.8613 3.99485 10.6324 4.16363 10.4636C4.33241 10.2948 4.56133 10.2 4.80002 10.2H5.70002V9.3C5.70002 8.47267 5.86298 7.65345 6.17958 6.88909C6.49619 6.12474 6.96024 5.43024 7.54525 4.84523C8.13026 4.26022 8.82477 3.79616 9.58912 3.47956C10.3535 3.16295 11.1727 3 12 3C12.8274 3 13.6466 3.16295 14.4109 3.47956C15.1753 3.79616 15.8698 4.26022 16.4548 4.84523C17.0398 5.43024 17.5039 6.12474 17.8205 6.88909C18.1371 7.65345 18.3 8.47267 18.3 9.3V10.2ZM5.70002 12V19.2H18.3V12H5.70002ZM11.1 13.8H12.9V17.4H11.1V13.8ZM16.5 10.2V9.3C16.5 8.10653 16.0259 6.96193 15.182 6.11802C14.3381 5.27411 13.1935 4.8 12 4.8C10.8066 4.8 9.66196 5.27411 8.81804 6.11802C7.97413 6.96193 7.50002 8.10653 7.50002 9.3V10.2H16.5Z" fill="currentColor"/>
  </symbol>

  <symbol id="icon-captain" viewBox="0 0 24 24">
    <path d="M7.02051 9.50216C7.02051 9.01881 7.41237 8.62695 7.89571 8.62695C8.37909 8.62695 8.77091 9.01881 8.77091 9.50216V11.5248C8.77091 12.0082 8.37909 12.4 7.89571 12.4C7.41237 12.4 7.02051 12.0082 7.02051 11.5248V9.50216Z" fill="currentColor"/>
    <path d="M9.82117 9.50216C9.82117 9.01881 10.213 8.62695 10.6964 8.62695C11.1798 8.62695 11.5716 9.01881 11.5716 9.50216V11.5248C11.5716 12.0082 11.1798 12.4 10.6964 12.4C10.213 12.4 9.82117 12.0082 9.82117 11.5248V9.50216Z" fill="currentColor"/>
    <path fill-rule="evenodd" clip-rule="evenodd" d="M16.6162 6.22553C13.357 5.76568 10.7003 5.74756 7.36793 6.22351C6.5256 6.34382 5.96827 6.42512 5.54331 6.54928C5.14927 6.66446 4.92518 6.80177 4.73984 7.00894C4.35603 7.43786 4.30542 7.923 4.25311 9.61502C4.20172 11.2779 4.30356 12.7682 4.49645 14.445C4.59922 15.3386 4.66994 15.9416 4.78286 16.4001C4.88998 16.835 5.01955 17.0688 5.19961 17.2478C5.38111 17.4282 5.61372 17.5555 6.04062 17.6588C6.49219 17.768 7.08468 17.834 7.96525 17.9301C10.8131 18.2408 12.9449 18.2392 15.8034 17.9317C16.6946 17.8359 17.2968 17.7698 17.7551 17.6613C18.1905 17.5582 18.4247 17.4319 18.6036 17.2566C18.7789 17.085 18.9128 16.8483 19.0289 16.3917C19.15 15.9154 19.2325 15.2851 19.3518 14.3592C19.5646 12.7072 19.7179 11.2564 19.7238 9.66706C19.7302 7.96781 19.6955 7.48431 19.3073 7.03586C19.1198 6.81923 18.8919 6.67683 18.4889 6.55823C18.0537 6.43014 17.4813 6.3476 16.6162 6.22553ZM7.16446 4.79872C10.6358 4.30293 13.4288 4.32234 16.8172 4.80043L16.8668 4.8074C17.6691 4.92055 18.3469 5.01616 18.8952 5.17755C19.487 5.35169 19.9819 5.61608 20.3955 6.09398C21.1758 6.9954 21.1707 8.06494 21.1639 9.48592C21.1636 9.54745 21.1633 9.60961 21.1631 9.67247C21.1568 11.3529 20.9942 12.8746 20.7792 14.5431L20.7735 14.5873C20.6614 15.458 20.5689 16.1755 20.4237 16.7465C20.2709 17.3469 20.0427 17.8617 19.6106 18.2849C19.1823 18.7043 18.6761 18.9223 18.0866 19.0618C17.5299 19.1936 16.8372 19.2681 16.0022 19.3579L15.9573 19.3627C12.9972 19.6811 10.7615 19.6829 7.80915 19.3608L7.7636 19.3559C6.94029 19.2661 6.25475 19.1913 5.70225 19.0576C5.11489 18.9155 4.61209 18.6932 4.18492 18.2685C3.75628 17.8424 3.53115 17.336 3.38542 16.7443C3.24797 16.1863 3.16807 15.4915 3.07185 14.6548L3.06664 14.6095C2.86882 12.8898 2.76033 11.3256 2.81459 9.57052C2.81656 9.50684 2.81844 9.44387 2.8203 9.38159C2.86249 7.97127 2.89413 6.91333 3.66729 6.04925C4.07752 5.5908 4.56238 5.33656 5.13959 5.16786C5.6749 5.01141 6.33496 4.91716 7.11626 4.80561C7.13225 4.80331 7.14832 4.80102 7.16446 4.79872Z" fill="currentColor"/>
  </symbol>

  <symbol id="icon-up-caret" viewBox="0 0 48 48">
    <path d="M2.988 33.02c-1.66 0-1.943-.81-.618-1.824l20-15.28c.878-.672 2.31-.67 3.188 0l20.075 15.288c1.316 1.003 1.048 1.816-.62 1.816H2.987z" />
  </symbol>

  <symbol id="icon-copy" viewBox="0 0 24 24">
    <path d="M5.503 4.627 5.5 6.75v10.504a3.25 3.25 0 0 0 3.25 3.25h8.616a2.251 2.251 0 0 1-2.122 1.5H8.75A4.75 4.75 0 0 1 4 17.254V6.75c0-.98.627-1.815 1.503-2.123ZM17.75 2A2.25 2.25 0 0 1 20 4.25v13a2.25 2.25 0 0 1-2.25 2.25h-9a2.25 2.25 0 0 1-2.25-2.25v-13A2.25 2.25 0 0 1 8.75 2h9Zm0 1.5h-9a.75.75 0 0 0-.75.75v13c0 .414.336.75.75.75h9a.75.75 0 0 0 .75-.75v-13a.75.75 0 0 0-.75-.75Z" />
  </symbol>

  <symbol id="eye-show" viewBox="0 0 24 24">
    <path d="M12 9.005a4 4 0 1 1 0 8 4 4 0 0 1 0-8Zm0 1.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5ZM12 5.5c4.613 0 8.596 3.15 9.701 7.564a.75.75 0 1 1-1.455.365 8.503 8.503 0 0 0-16.493.004.75.75 0 0 1-1.455-.363A10.003 10.003 0 0 1 12 5.5Z" />
  </symbol>

  <symbol id="eye-hide" viewBox="0 0 24 24">
    <path d="M2.22 2.22a.75.75 0 0 0-.073.976l.073.084 4.034 4.035a9.986 9.986 0 0 0-3.955 5.75.75.75 0 0 0 1.455.364 8.49 8.49 0 0 1 3.58-5.034l1.81 1.81A4 4 0 0 0 14.8 15.86l5.919 5.92a.75.75 0 0 0 1.133-.977l-.073-.084-6.113-6.114.001-.002-1.2-1.198-2.87-2.87h.002L8.719 7.658l.001-.002-1.133-1.13L3.28 2.22a.75.75 0 0 0-1.06 0Zm7.984 9.045 3.535 3.536a2.5 2.5 0 0 1-3.535-3.535ZM12 5.5c-1 0-1.97.148-2.889.425l1.237 1.236a8.503 8.503 0 0 1 9.899 6.272.75.75 0 0 0 1.455-.363A10.003 10.003 0 0 0 12 5.5Zm.195 3.51 3.801 3.8a4.003 4.003 0 0 0-3.801-3.8Z" />
  </symbol>

  <symbol id="icon-gear" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M3.50498 13.75C3.18794 13.2017 2.94148 12.6156 2.77148 12.0055C3.14146 11.8173 3.45218 11.5305 3.66926 11.1767C3.88633 10.8229 4.00131 10.4159 4.00146 10.0008C4.00162 9.58574 3.88695 9.1787 3.67014 8.82474C3.45332 8.47078 3.14282 8.18369 2.77298 7.99524C3.11201 6.76935 3.75753 5.64995 4.64873 4.74249C4.9968 4.96878 5.4007 5.09436 5.81572 5.10532C6.23074 5.11629 6.6407 5.01221 7.00023 4.80461C7.35976 4.59701 7.65485 4.29399 7.85283 3.92907C8.05081 3.56415 8.14396 3.15157 8.12198 2.73699C9.35357 2.41871 10.6459 2.41922 11.8772 2.73849C11.8554 3.15306 11.9488 3.56558 12.1469 3.9304C12.3451 4.29521 12.6403 4.59809 12.9999 4.80553C13.3595 5.01297 13.7694 5.11688 14.1844 5.10575C14.5994 5.09463 15.0033 4.9689 15.3512 4.74249C15.7855 5.18499 16.171 5.68824 16.495 6.24999C16.8197 6.81174 17.0627 7.39749 17.2285 7.99449C16.8585 8.18267 16.5478 8.46952 16.3307 8.82332C16.1136 9.17712 15.9987 9.58407 15.9985 9.99915C15.9984 10.4142 16.113 10.8213 16.3298 11.1752C16.5466 11.5292 16.8571 11.8163 17.227 12.0047C16.888 13.2306 16.2424 14.35 15.3512 15.2575C15.0032 15.0312 14.5993 14.9056 14.1843 14.8947C13.7692 14.8837 13.3593 14.9878 12.9997 15.1954C12.6402 15.403 12.3451 15.706 12.1471 16.0709C11.9492 16.4358 11.856 16.8484 11.878 17.263C10.6464 17.5813 9.35406 17.5808 8.12273 17.2615C8.14452 16.8469 8.05118 16.4344 7.85305 16.0696C7.65492 15.7048 7.35972 15.4019 7.00011 15.1944C6.64051 14.987 6.23053 14.8831 5.81553 14.8942C5.40053 14.9054 4.99671 15.0311 4.64873 15.2575C4.20548 14.8052 3.82118 14.2987 3.50498 13.75V13.75ZM7.74998 13.897C8.5492 14.358 9.15012 15.0978 9.43748 15.9745C9.81173 16.0097 10.1875 16.0105 10.5617 15.9752C10.8493 15.0984 11.4505 14.3586 12.25 13.8977C13.0489 13.4355 13.9904 13.2846 14.8937 13.474C15.1112 13.168 15.2987 12.8417 15.4547 12.5005C14.8393 11.8131 14.4993 10.9226 14.5 9.99999C14.5 9.05499 14.8525 8.17224 15.4547 7.49949C15.2976 7.15835 15.1093 6.83246 14.8922 6.52599C13.9894 6.71522 13.0486 6.5646 12.25 6.10299C11.4508 5.64202 10.8499 4.90223 10.5625 4.02549C10.1882 3.99024 9.81248 3.98949 9.43823 4.02474C9.15068 4.9016 8.54949 5.64141 7.74998 6.10224C6.95107 6.56448 6.00959 6.71538 5.10623 6.52599C4.88916 6.8322 4.70133 7.15814 4.54523 7.49949C5.16066 8.18691 5.50065 9.07733 5.49998 9.99999C5.49998 10.945 5.14748 11.8277 4.54523 12.5005C4.70234 12.8416 4.89064 13.1675 5.10773 13.474C6.01052 13.2848 6.95139 13.4354 7.74998 13.897ZM9.99998 12.25C9.40325 12.25 8.83095 12.0129 8.40899 11.591C7.98704 11.169 7.74998 10.5967 7.74998 9.99999C7.74998 9.40325 7.98704 8.83096 8.40899 8.409C8.83095 7.98704 9.40325 7.74999 9.99998 7.74999C10.5967 7.74999 11.169 7.98704 11.591 8.409C12.0129 8.83096 12.25 9.40325 12.25 9.99999C12.25 10.5967 12.0129 11.169 11.591 11.591C11.169 12.0129 10.5967 12.25 9.99998 12.25ZM9.99998 10.75C10.1989 10.75 10.3897 10.671 10.5303 10.5303C10.671 10.3897 10.75 10.1989 10.75 9.99999C10.75 9.80108 10.671 9.61031 10.5303 9.46966C10.3897 9.32901 10.1989 9.24999 9.99998 9.24999C9.80107 9.24999 9.61031 9.32901 9.46965 9.46966C9.329 9.61031 9.24998 9.80108 9.24998 9.99999C9.24998 10.1989 9.329 10.3897 9.46965 10.5303C9.61031 10.671 9.80107 10.75 9.99998 10.75V10.75Z" fill="#868C98"/>
  </symbol>

  <symbol id="icon-linear" viewBox="0 0 24 24">
  <path d="M0.294 14.765c-0.053-0.228 0.218-0.371 0.383-0.206l8.762 8.762c0.165 0.165 0.022 0.436-0.206 0.383C4.812 22.668 1.332 19.188 0.294 14.765zM0 11.253c-0.004 0.068 0.021 0.134 0.07 0.183l12.494 12.494c0.048 0.048 0.115 0.074 0.183 0.07c0.568-0.035 1.127-0.11 1.671-0.222c0.183-0.038 0.247-0.263 0.115-0.396l-13.847-13.847c-0.132-0.132-0.358-0.068-0.396 0.115c-0.112 0.544-0.187 1.102-0.222 1.671zM1.011 7.129c-0.04 0.09-0.02 0.195 0.05 0.264l15.546 15.546c0.069 0.069 0.174 0.09 0.264 0.05c0.429-0.191 0.844-0.406 1.244-0.644c0.133-0.079 0.153-0.261 0.044-0.37l-16.134-16.134c-0.109-0.109-0.291-0.089-0.37 0.044c-0.238 0.4-0.453 0.816-0.644 1.244zM3.038 4.338c-0.089-0.089-0.094-0.231-0.011-0.325c2.2-2.46 5.4-4.013 8.973-4.013 6.627 0 12 5.373 12 12c0 3.562-1.55 6.76-4.013 8.961c-0.094 0.084-0.236 0.078-0.325-0.011l-16.624-16.612z"/>
</symbol>
</svg>

================
File: views/super_admin/application/_javascript.html.erb
================
<%#
# Javascript Partial

This partial imports the necessary javascript on each page.
By default, it includes the application JS,
but each page can define additional JS sources
by providing a `content_for(:javascript)` block.
%>

<% Administrate::Engine.javascripts.each do |js_path| %>
  <%= javascript_include_tag js_path %>
<% end %>

<%= yield :javascript %>

<% if Rails.env.test? %>
  <%= javascript_tag do %>
    $.fx.off = true;
    $.ajaxSetup({ async: false });
  <% end %>
<% end %>

<script>
window.chatwootSettings = {
  hideMessageBubble: true,
};

(function(d,t) {
  var BASE_URL = '';
  var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
  g.src= BASE_URL + "/packs/js/sdk.js";
  g.defer = true;
  g.async = true;
  s.parentNode.insertBefore(g,s);
  g.onload=function(){
    window.chatwootSDK.run({
      websiteToken: '<%= ChatwootHub.support_config[:support_website_token] %>',
      baseUrl: '<%= ChatwootHub.support_config[:support_script_url] %>'
    })
  }
})(document,"script");

window.addEventListener('chatwoot:ready', function() {
  window.$chatwoot.setUser('<%= ChatwootHub.installation_identifier %>', {
    identifier_hash: '<%= ChatwootHub.support_config[:support_identifier_hash] %>',
    email: '<%= SuperAdmin.first.email %>',
    name: '<%= SuperAdmin.first.name %>'
  });
})

</script>

================
File: views/super_admin/application/_nav_item.html.erb
================
<li
  class="px-4 border-l-4 mb-1 <%= current_page?(url) ? 'border-woot-500' : 'border-transparent' %>"
>
  <% text_class_name = current_page?(url) ? 'text-woot-500 bg-slate-25' : 'text-slate-800' %>
  <%= link_to(url, class: text_class_name + " -ml-1 focus:outline-none cursor-pointer flex items-center px-2 py-1.5 text-slate-800 cursor-pointer hover:text-woot-500 hover:bg-slate-25 rounded-lg") do %>
    <svg width="16" height="16"><use xlink:href="#<%= icon %>" /></svg>
    <span class="ml-2 text-sm"><%= label %></span>
  <% end %>
</li>

================
File: views/super_admin/application/_navigation.html.erb
================
<%#
# Navigation

This partial is used to display the navigation in Administrate.
By default, the navigation contains navigation links
for all resources in the admin dashboard,
as defined by the routes in the `admin/` namespace
%>

<%= vite_client_tag %>
<%= vite_javascript_tag 'superadmin_pages' %>

<%
  sidebar_icons = {
    accounts: 'icon-building-4-line',
    users: 'icon-user-follow-line',
    platform_apps: 'icon-apps-2-line',
    agent_bots: 'icon-robot-line',
  }
%>

<div class="border-slate-100 border-r w-56 flex-shrink-0 justify-between h-full flex flex-col" role="navigation">
  <div>
    <div class="flex mx-4 mb-4 border-slate-100 border-b py-6">
      <%= link_to image_tag('/brand-assets/logo_thumbnail.svg', alt: 'Chatwoot Admin Dashboard', class: 'h-10'), super_admin_root_url %>
      <div class="flex flex-col ml-3">
        <div class="text-sm">Chatwoot <%= Chatwoot.config[:version] %></div>
        <div class="text-xs text-slate-700 mt-0.5">Super Admin Console</div>
      </div>
    </div>

    <ul class="my-4">
      <%= render partial: "nav_item", locals: { icon: 'icon-grid-line', url: super_admin_root_url, label: 'Dashboard' } %>
      <% Administrate::Namespace.new(namespace).resources.each do |resource| %>
        <% next if ["account_users", "access_tokens", "installation_configs", "dashboard", "devise/sessions", "app_configs", "instance_statuses", "settings"].include?  resource.resource %>
        <%= render partial: "nav_item", locals: {
            icon: sidebar_icons[resource.resource.to_sym],
            url: resource_index_route(resource),
            label: display_resource_name(resource),
          }
        %>
      <% end %>
    </ul>
  </div>
  <div>
    <ul class="my-4">
      <% if ChatwootApp.enterprise? %>
      <%= render partial: "nav_item", locals: { icon: 'icon-settings-2-line', url: super_admin_settings_url, label: 'Settings' } %>
      <% end %>
      <%= render partial: "nav_item", locals: { icon: 'icon-mist-fill', url: sidekiq_web_url, label: 'Sidekiq Dashboard' } %>
      <%= render partial: "nav_item", locals: { icon: 'icon-health-book-line', url: super_admin_instance_status_url, label: 'Instance Health' } %>
      <%= render partial: "nav_item", locals: { icon: 'icon-dashboard-line', url: '/', label: 'Agent Dashboard' } %>
      <%= render partial: "nav_item", locals: { icon: 'icon-logout-circle-r-line', url: super_admin_logout_url, label: 'Logout' } %>
    </ul>
  </div>
</div>

================
File: views/super_admin/application/_search.html.erb
================
<form class="search" role="search">
  <label class="search__label" for="search">
    <svg class="search__eyeglass-icon" role="img">
      <title>
        <%= t("administrate.search.label", resource: resource_name) %>
      </title>
      <use xlink:href="#icon-eyeglass" />
    </svg>
  </label>

  <input class="search__input"
         id="search"
         type="search"
         name="search"
         placeholder="<%= t("administrate.search.label", resource: resource_name) %>"
         value="<%= search_term %>">

  <%= link_to clear_search_params, class: "search__clear-link" do %>
    <svg class="search__clear-icon" role="img">
      <title><%= t("administrate.search.clear") %></title>
      <use xlink:href="#icon-cancel" />
    </svg>
  <% end %>
</form>

================
File: views/super_admin/application/_stylesheet.html.erb
================
<%#
# Stylesheet Partial

This partial imports the necessary stylesheets on each page.
By default, it includes the application CSS,
but each page can define additional CSS sources
by providing a `content_for(:stylesheet)` block.
%>

<% Administrate::Engine.stylesheets.each do |css_path| %>
  <%= stylesheet_link_tag css_path %>
<% end %>

<%= yield :stylesheet %>

================
File: views/super_admin/application/index.html.erb
================
<%#
# Index

This view is the template for the index page.
It is responsible for rendering the search bar, header and pagination.
It renders the `_table` partial to display details about the resources.

## Local variables:

- `page`:
  An instance of [Administrate::Page::Collection][1].
  Contains helper methods to help display a table,
  and knows which attributes should be displayed in the resource's table.
- `resources`:
  An instance of `ActiveRecord::Relation` containing the resources
  that match the user's search criteria.
  By default, these resources are passed to the table partial to be displayed.
- `search_term`:
  A string containing the term the user has searched for, if any.
- `show_search_bar`:
  A boolean that determines if the search bar should be shown.

[1]: http://www.rubydoc.info/gems/administrate/Administrate/Page/Collection
%>

<% content_for(:title) do %>
  <%= display_resource_name(page.resource_name) %>
<% end %>

<header class="main-content__header" role="banner">
  <div class="flex items-center justify-between w-full">
    <h1 class="main-content__page-title m-0 mr-6" id="page-title">
      <%= content_for(:title) %>
    </h1>

    <div class="flex items-center">
      <% if show_search_bar %>
        <div class="flex items-center">
          <%= render("filters", page: page) %>
          <div class="ml-3">
            <%= render(
              "search",
              search_term: search_term,
              resource_name: display_resource_name(page.resource_name)
            ) %>
          </div>
        </div>
      <% end %>

      <div class="whitespace-nowrap ml-4">
        <%= link_to(
          t(
            "administrate.actions.new_resource",
            name: page.resource_name.titleize.downcase
          ),
          [:new, namespace, page.resource_path.to_sym],
          class: "button",
        ) if accessible_action?(new_resource, :new) %>
      </div>
    </div>
  </div>
</header>

<section class="main-content__body main-content__body--flush">
  <%= render(
    "collection",
    collection_presenter: page,
    collection_field_name: resource_name,
    page: page,
    resources: resources,
    table_title: "page-title"
  ) %>

  <%= paginate resources, param_name: '_page'%>
</section>

================
File: views/super_admin/application/show.html.erb
================
<%#
# Show

This view is the template for the show page.
It renders the attributes of a resource,
as well as a link to its edit page.

## Local variables:

- `page`:
  An instance of [Administrate::Page::Show][1].
  Contains methods for accessing the resource to be displayed on the page,
  as well as helpers for describing how each attribute of the resource
  should be displayed.

[1]: http://www.rubydoc.info/gems/administrate/Administrate/Page/Show
%>

<% content_for(:title) { t("administrate.actions.show_resource", name: page.page_title) } %>

<header class="main-content__header">
  <h1 class="main-content__page-title">
    <%= content_for(:title) %>
  </h1>

  <div>
    <%= link_to(
      "Edit",
      [:edit, namespace, page.resource],
      class: "button",
    ) if accessible_action?(page.resource, :edit) %>

    <%= link_to(
      t("administrate.actions.destroy"),
      [namespace, page.resource],
      class: "button button--danger",
      method: :delete,
      data: { confirm: t("administrate.actions.confirm") }
    ) if accessible_action?(page.resource, :destroy) %>
  </div>
</header>

<section class="main-content__body">
  <dl>
    <% page.attributes.each do |title, attributes| %>
      <fieldset class="<%= "field-unit--nested" if title.present? %>">
        <% if title.present? %>
          <legend><%= t "helpers.label.#{page.resource_name}.#{title}", default: title %></legend>
        <% end %>

        <% attributes.each do |attribute| %>
          <dt class="attribute-label" id="<%= attribute.name %>">
          <%= t(
            "helpers.label.#{resource_name}.#{attribute.name}",
            default: page.resource.class.human_attribute_name(attribute.name),
          ) %>
          </dt>

          <dd class="attribute-data attribute-data--<%=attribute.html_class%>"
              ><%= render_field attribute, page: page %></dd>
        <% end %>
      </fieldset>
    <% end %>
  </dl>
</section>

================
File: views/super_admin/dashboard/index.html.erb
================
<% content_for(:title) do %>
  Admin Dashboard
<% end %>

<%= render_vue_component('DashboardIndex', {
  accountsCount: @accounts_count,
  usersCount: @users_count,
  inboxesCount: @inboxes_count,
  conversationsCount: @conversations_count,
  chartData: @data
}) %>

================
File: views/super_admin/devise/sessions/new.html.erb
================
<!DOCTYPE html>
<html>
  <head>
    <title>SuperAdmin | Chatwoot</title>
    <%= vite_client_tag %>
    <%= vite_javascript_tag 'superadmin' %>
  </head>
  <body>
    <div class="h-full w-full antialiased">
      <main class="flex flex-col bg-woot-25 min-h-screen w-full py-20 sm:px-6 lg:px-8 dark:bg-slate-900">
        <section class="max-w-5xl mx-auto">
          <img src="/brand-assets/logo.svg" alt="Chatwoot" class="mx-auto h-8 w-auto block dark:hidden">
          <img src="/brand-assets/logo_dark.svg" alt="Chatwoot" class="mx-auto h-8 w-auto hidden dark:block">
          <h2 class="mt-6 text-center text-3xl font-medium text-slate-900 dark:text-woot-50">
            Howdy, admin 
          </h2>
        </section>
        <section class="bg-white shadow sm:mx-auto mt-11 sm:w-full sm:max-w-lg dark:bg-slate-800 p-11 sm:shadow-lg sm:rounded-lg mb-8 mt-15">
          <div>
            <%= form_for(resource, as: resource_name, url: '/super_admin/sign_in') do |f| %>
              <% if flash[:error].present? %>
                <div data-alert class="rounded-md bg-red-500 p-4 text-white text-sm mb-5"><%= flash[:error] %></div>
              <% end %>
              <div class="mb-5">
                <label for="email_address" class="flex justify-between text-sm font-medium leading-6 text-slate-900 dark:text-white">
                Email Address
                </label>
                <div class="mt-1">
                  <%= f.email_field :email, autofocus: true, autocomplete: "email", placeholder: "Email eg: someone@example.com", class: "block w-full rounded-md border-0 px-3 py-3 appearance-none shadow-sm ring-1 ring-inset text-slate-900 dark:text-slate-100 placeholder:text-slate-400 focus:ring-2 focus:ring-inset focus:ring-woot-500 sm:text-sm sm:leading-6 outline-none dark:bg-slate-700 dark:ring-slate-600 dark:focus:ring-woot-500 ring-slate-200" %>
                </div>
              </div>
              <div class="mb-5">
                <label for="password" class="flex justify-between text-sm font-medium leading-6 text-slate-900 dark:text-white">
                  Password
                </label>
                <div class="mt-1">
                  <%= f.password_field :password, autocomplete: "current-password",  placeholder: "Password", class: "block w-full rounded-md border-0 px-3 py-3 appearance-none shadow-sm ring-1 ring-inset text-slate-900 dark:text-slate-100 placeholder:text-slate-400 focus:ring-2 focus:ring-inset focus:ring-woot-500 sm:text-sm sm:leading-6 outline-none dark:bg-slate-700 dark:ring-slate-600 dark:focus:ring-woot-500 ring-slate-200" %>
                </div>
              </div>
              <button type="submit" class="flex items-center w-full justify-center rounded-md bg-woot-500 py-3 px-3 text-base font-medium text-white shadow-sm hover:bg-woot-600 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-woot-500 cursor-pointer">
                <span>Login</span>
              </button>
            <% end %>
          </div>
        </section>
      </main>
    </div>
  </body>
</html>

================
File: views/super_admin/instance_statuses/show.html.erb
================
<% content_for(:title) do %>
  Instance Status
<% end %>
<header class="main-content__header" role="banner">
  <h1 class="main-content__page-title" id="page-title">
    <%= content_for(:title) %>
  </h1>
</header>
<section class="main-content__body">
  <table>
  <tr>
    <th>Metric</th>
    <th>Value</th>
  </tr>
  <% @metrics.each do |key,value| %>
   <tr>
   <td> <%= key %> </td>
   <td> <%= value %></td>
  </tr>
  <% end %>
</table>

</section>

================
File: views/super_admin/settings/show.html.erb
================
<% content_for(:title) do %>
  Settings
<% end %>
<header class="flex px-8 py-4 items-center border-b border-n-weak" role="banner">
  <div class="border border-n-weak mr-4 p-2 rounded-full">
    <svg width="24" height="24"><use xlink:href="#icon-settings-2-line" /></svg>
  </div>
  <div class="flex flex-col h-14 justify-center">
    <h1 class="text-base font-medium leading-6 text-n-slate-12" id="page-title">
      <%= content_for(:title) %>
    </h1>
    <p class="text-sm font-normal leading-5 text-slate-500 m-0">Update your instance settings, access billing portal</p>
  </div>
</header>
<section class="main-content__body px-8">
  <% if Redis::Alfred.get(Redis::Alfred::CHATWOOT_INSTALLATION_CONFIG_RESET_WARNING) %>
    <div class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative mb-5" role="alert">
    <strong class="font-bold">Alert!</strong>
    <span class="block sm:inline">Unauthorized premium changes detected in Chatwoot. To keep using them, please upgrade your plan.
      Contact for help :</span><span class="inline rounded-full bg-red-200 px-2  text-white  ml-2">sales@chatwoot.com</span>
    </div>
  <% end %>

  <div class="bg-white py-2 px-4 xl:px-0">
    <div class="mb-4">
      <div class="flex items-center gap-2">
        <h2 class="h-5 leading-5 text-n-slate-12 font-medium">Current plan</h2>
        <a href="<%= refresh_super_admin_settings_url %>" class="inline-flex gap-1 text-xs font-medium items-center text-woot-500 hover:text-woot-700">
          <svg width="16" height="16"><use xlink:href="#icon-refresh-line" /></svg>
          <span>Refresh</span>
        </a>
      </div>
      <p class="text-n-slate-11 mt-1"><%= SuperAdmin::FeaturesHelper.plan_details.html_safe %></p>
      <div class="flex items-center mt-6">
        <h4 class="text-sm font-medium leading-5 h-5 text-n-slate-12 mr-4">Installation Identifier</h4>
        <span class="text-sm leading-5 h-5 text-n-slate-11"><%= ChatwootHub.installation_identifier %></span>
      </div>
    </div>
    <div class="flex p-4 outline outline-1 outline-n-container rounded-lg mt-8 items-start md:items-center shadow-sm flex-col md:flex-row">
      <div class="flex flex-col flex-grow gap-1">
        <h2 class="h-5 leading-5 text-n-slate-12 text-sm font-medium">Current plan</h2>
        <p class="text-n-slate-11 m-0 text-sm"><%= SuperAdmin::FeaturesHelper.plan_details.html_safe %></p>
      </div>
      <a href="<%= ChatwootHub.billing_url %>" target="_blank" rel="noopener noreferrer">
        <button class="mt-4 md:mt-0 flex gap-1 items-center bg-transparent shadow-sm h-9 hover:text-n-slate-12 hover:bg-slate-50 outline outline-1 outline-n-container rounded text-n-slate-11 font-medium p-2">
          <svg width="16" height="16"><use xlink:href="#icon-settings-2-line" /></svg>
          <span class="px-1">Manage</span>
        </button>
      </a>
    </div>

    <% if ChatwootHub.pricing_plan != 'community' &&  User.count > ChatwootHub.pricing_plan_quantity %>
    <div role="alert">
      <div class="border border-t-0 border-red-400 rounded-b bg-red-100 px-4 py-3 text-red-700">
        <p>You have <%= User.count %> agents. Please add more licenses to add more users.</p>
      </div>
    </div>
    <% end %>


    <div class="flex p-4 outline outline-1 outline-n-container rounded-lg mt-4 items-start md:items-center shadow-sm flex-col md:flex-row">
      <div class="flex flex-col flex-grow gap-1">
        <h2 class="h-5 leading-5 text-n-slate-12 text-sm font-medium">Need help?</h2>
        <p class="text-n-slate-11 m-0 text-sm">Do you face any issues? We are here to help.</p>
      </div>
      <a href="https://discord.gg/cJXdrwS" target="_blank">
        <button class="flex mt-4 md:mt-0 gap-1 items-center bg-transparent shadow-sm h-9 bg-violet-500 hover:bg-violet-600 text-white border border-solid border-violet-600 rounded font-medium p-2">
          <svg class="h-4 w-4" width="24" height="24" fill="none" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 2c5.523 0 10 4.477 10 10s-4.477 10-10 10a9.96 9.96 0 0 1-4.587-1.112l-3.826 1.067a1.25 1.25 0 0 1-1.54-1.54l1.068-3.823A9.96 9.96 0 0 1 2 12C2 6.477 6.477 2 12 2Zm0 1.5A8.5 8.5 0 0 0 3.5 12c0 1.47.373 2.883 1.073 4.137l.15.27-1.112 3.984 3.987-1.112.27.15A8.5 8.5 0 1 0 12 3.5ZM8.75 13h4.498a.75.75 0 0 1 .102 1.493l-.102.007H8.75a.75.75 0 0 1-.102-1.493L8.75 13h4.498H8.75Zm0-3.5h6.505a.75.75 0 0 1 .101 1.493l-.101.007H8.75a.75.75 0 0 1-.102-1.493L8.75 9.5h6.505H8.75Z" fill="currentColor"/></svg>
          <span class="px-1">Community Support</span>
        </button>
      </a>
      <% if ChatwootHub.pricing_plan !='community' %>
        <button class="ml-4 flex gap-1 items-center bg-transparent h-9 hover:text-n-slate-12 hover:bg-slate-50 border border-solid border-slate-100 rounded text-n-slate-11 font-medium p-2" onclick="window.$chatwoot.toggle('open')">
          <svg class="h-4 w-4" width="24" height="24" fill="none" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 2c5.523 0 10 4.477 10 10s-4.477 10-10 10a9.96 9.96 0 0 1-4.587-1.112l-3.826 1.067a1.25 1.25 0 0 1-1.54-1.54l1.068-3.823A9.96 9.96 0 0 1 2 12C2 6.477 6.477 2 12 2Zm0 1.5A8.5 8.5 0 0 0 3.5 12c0 1.47.373 2.883 1.073 4.137l.15.27-1.112 3.984 3.987-1.112.27.15A8.5 8.5 0 1 0 12 3.5ZM8.75 13h4.498a.75.75 0 0 1 .102 1.493l-.102.007H8.75a.75.75 0 0 1-.102-1.493L8.75 13h4.498H8.75Zm0-3.5h6.505a.75.75 0 0 1 .101 1.493l-.101.007H8.75a.75.75 0 0 1-.102-1.493L8.75 9.5h6.505H8.75Z" fill="currentColor"/></svg>
          <span class="px-1">Chat Support</span>
        </button>
      <% end %>
    </div>
    <div class="mt-10 py-4">
      <h3 class="h-5 leading-5 text-n-slate-12 font-medium text-base">Features</h3>
    </div>
    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-x-2 gap-y-3">
      <% SuperAdmin::FeaturesHelper.available_features.each do |feature, attrs| %>
        <div class="group outline outline-1 outline-n-container p-4 rounded-lg relative shadow-sm">
          <span class="<%= attrs[:enabled] ? 'bg-green-400 text-white': 'bg-slate-300 text-slate-800' %> absolute rounded-full p-1 inline-flex right-4 top-5">
            <svg width="14" height="14"><use xlink:href="<%= attrs[:enabled] ? '#icon-tick-line': '#icon-lock-line' %>" /></svg>
          </span>
          <div class="visible <% if !attrs[:enabled] %> group-hover:invisible <% end %> flex items-center justify-center w-10 h-10 mb-2 border border-slate-100 border-solid text-slate-800 rounded-full">
            <svg width="20" height="20"><use xlink:href="#<%= attrs[:icon] %>" /></svg>
          </div>
          <% if !attrs[:enabled] %>
          <div class="flex h-9 absolute top-5 items-center invisible group-hover:visible">
            <a href="<%= ChatwootHub.billing_url %>" target="_blank" rel="noopener noreferrer" class="flex gap-1 items-center bg-slate-100 h-9 hover:bg-slate-300 hover:text-n-slate-12 border border-solid border-slate-100 rounded text-n-slate-11 font-medium p-2">
              <svg class="h-4 w-4" width="24" height="24" fill="none" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M13.209 3.103c-.495-1.004-1.926-1.004-2.421 0L8.43 7.88l-5.273.766c-1.107.161-1.55 1.522-.748 2.303l3.815 3.72-.9 5.25c-.19 1.103.968 1.944 1.959 1.424l4.715-2.48 4.716 2.48c.99.52 2.148-.32 1.96-1.424l-.902-5.25 3.816-3.72c.8-.78.359-2.142-.748-2.303l-5.273-.766-2.358-4.777ZM9.74 8.615l2.258-4.576 2.259 4.576a1.35 1.35 0 0 0 1.016.738l5.05.734-3.654 3.562a1.35 1.35 0 0 0-.388 1.195l.862 5.03-4.516-2.375a1.35 1.35 0 0 0-1.257 0l-4.516 2.374.862-5.029a1.35 1.35 0 0 0-.388-1.195l-3.654-3.562 5.05-.734c.44-.063.82-.34 1.016-.738ZM1.164 3.782a.75.75 0 0 0 .118 1.054l2.5 2a.75.75 0 1 0 .937-1.172l-2.5-2a.75.75 0 0 0-1.055.118Z" fill="currentColor"/><path d="M22.836 18.218a.75.75 0 0 0-.117-1.054l-2.5-2a.75.75 0 0 0-.938 1.172l2.5 2a.75.75 0 0 0 1.055-.117ZM1.282 17.164a.75.75 0 1 0 .937 1.172l2.5-2a.75.75 0 0 0-.937-1.172l-2.5 2ZM22.836 3.782a.75.75 0 0 1-.117 1.054l-2.5 2a.75.75 0 0 1-.938-1.172l2.5-2a.75.75 0 0 1 1.055.118Z"  fill="currentColor"/></svg>
              <span class="px-1">Upgrade now</span>
            </a>
          </div>
          <% end %>
          <div class="flex items-center justify-between mb-1.5 mt-4">
            <div class="flex items-center gap-2">
              <h3 class="text-n-slate-12 font-medium"><%= attrs[:name] %></h3>
              <% if attrs[:enterprise] %>
                <span class="px-2 h-4 leading-4 rounded-xl text-green-800 font-medium bg-green-100/70 text-xxs">EE</span>
              <% end %>
              <% if attrs[:config_key].present? && attrs[:enabled] %>
                <a class="inline-flex items-center justify-center h-5 w-5 hover:bg-slate-50 rounded-sm" href="/super_admin/app_config?config=<%= attrs[:config_key] %>">
                  <svg width="18" height="18"><use xlink:href="#icon-gear" /></svg>
                </a>
              <% end %>
            </div>
          </div>
          <p class="text-n-slate-11 mb-0"><%= attrs[:description] %></p>
        </div>
      <% end %>
    </div>
  </div>
</section>

================
File: views/super_admin/users/_collection.html.erb
================
<%#
# Collection

This partial is used on the `index` and `show` pages
to display a collection of resources in an HTML table.

## Local variables:

- `collection_presenter`:
  An instance of [Administrate::Page::Collection][1].
  The table presenter uses `ResourceDashboard::COLLECTION_ATTRIBUTES` to determine
  the columns displayed in the table
- `resources`:
  An ActiveModel::Relation collection of resources to be displayed in the table.
  By default, the number of resources is limited by pagination
  or by a hard limit to prevent excessive page load times

[1]: http://www.rubydoc.info/gems/administrate/Administrate/Page/Collection
%>

<table aria-labelledby="<%= table_title %>">
  <thead>
    <tr>
      <% collection_presenter.attribute_types.each do |attr_name, attr_type| %>
        <th class="cell-label
        cell-label--<%= attr_type.html_class %>
        cell-label--<%= collection_presenter.ordered_html_class(attr_name) %>"
        scope="col"
        role="columnheader"
        aria-sort="<%= sort_order(collection_presenter.ordered_html_class(attr_name)) %>">
        <%= link_to(sanitized_order_params(page, collection_field_name).merge(
          collection_presenter.order_params_for(attr_name, key: collection_field_name)
        )) do %>
        <%= t(
          "helpers.label.#{collection_presenter.resource_name}.#{attr_name}",
          default: attr_name.to_s,
        ).titleize %>
            <% if collection_presenter.ordered_by?(attr_name) %>
              <span class="cell-label__sort-indicator cell-label__sort-indicator--<%= collection_presenter.ordered_html_class(attr_name) %>">
                <svg aria-hidden="true">
                  <use xlink:href="#icon-up-caret" />
                </svg>
              </span>
            <% end %>
          <% end %>
        </th>
      <% end %>
      <% [existing_action?(collection_presenter.resource_name, :edit),
          existing_action?(collection_presenter.resource_name, :destroy)].count(true).times do %>
        <th scope="col"></th>
      <% end %>
    </tr>
  </thead>

  <tbody>
    <% resources.each do |resource| %>
      <tr class="js-table-row"
          tabindex="0"
          <% if existing_action? collection_presenter.resource_name, :show %>
            <%= %(role=link data-url=#{polymorphic_path([namespace, resource.becomes(User)])}) %>
          <% end %>
          >
        <% collection_presenter.attributes_for(resource).each do |attribute| %>
          <td class="cell-data cell-data--<%= attribute.html_class %>">
            <% if authorized_action? resource,  :show -%>
              <a href="<%= polymorphic_path([namespace, resource.becomes(User)]) -%>"
                 class="action-show"
                 >
                <%= render_field attribute %>
              </a>
            <% end -%>
          </td>
        <% end %>

        <% if existing_action? collection_presenter.resource_name, :edit %>
          <td><%= link_to(
            t("administrate.actions.edit"),
            [:edit, namespace, resource.becomes(User)],
            class: "action-edit",
          ) if authorized_action? resource, :edit%></td>
        <% end %>

        <% if existing_action? collection_presenter.resource_name, :destroy %>
          <td><%= link_to(
            t("administrate.actions.destroy"),
            [namespace, collection_presenter.resource_name == 'account_user' ? resource : resource.becomes(User)],
            class: "text-color-red",
            method: :delete,
            data: { confirm: t("administrate.actions.confirm") }
          ) if authorized_action? resource, :destroy %></td>
        <% end %>
      </tr>
    <% end %>
  </tbody>
</table>

================
File: views/super_admin/users/_impersonate.erb
================
<section class="main-content__body">
 <hr/>
  <div class="form-actions">
  <p class="text-color-red">Caution: Any actions executed after impersonate will appear as if performed by the impersonated user - [<%= page.resource.name %> ]</p>
    <a class='button' target='_blank' href='<%= page.resource.generate_sso_link %>'>Impersonate user </a>
  </div>
</section>

================
File: views/super_admin/users/show.html.erb
================
<%#
# Show

This view is the template for the show page.
It renders the attributes of a resource,
as well as a link to its edit page.

## Local variables:

- `page`:
  An instance of [Administrate::Page::Show][1].
  Contains methods for accessing the resource to be displayed on the page,
  as well as helpers for describing how each attribute of the resource
  should be displayed.

[1]: http://www.rubydoc.info/gems/administrate/Administrate/Page/Show
%>

<% content_for(:title) { t("administrate.actions.show_resource", name: page.page_title) } %>

<header class="main-content__header" role="banner">
  <h1 class="main-content__page-title">
    <%= content_for(:title) %>
  </h1>

  <div>
    <%= link_to(
            t("administrate.actions.edit"),
            [:edit, namespace,  page.resource.becomes(User)],
            class: "button",
          ) if authorized_action? page.resource, :edit %>
  </div>
</header>

<section class="main-content__body">
  <dl>
    <% page.attributes.each do |title, attributes| %>
      <fieldset class="<%= "field-unit--nested" if title.present? %>">
        <% if title.present? %>
          <legend><%= t "helpers.label.#{page.resource_name}.#{title}", default: title %></legend>
        <% end %>

        <% attributes.each do |attribute| %>
          <dt class="attribute-label" id="<%= attribute.name %>">
          <%= t(
            "helpers.label.#{resource_name}.#{attribute.name}",
            default: page.resource.class.human_attribute_name(attribute.name),
          ) %>
          </dt>

          <dd class="attribute-data attribute-data--<%=attribute.html_class%>"
              ><%= render_field attribute, page: page %></dd>
        <% end %>
      </fieldset>
    <% end %>
  </dl>
</section>

<section class="main-content__body">
  <% account_user_page = Administrate::Page::Form.new(AccountUserDashboard.new, AccountUser.new) %>
  <%= form_for([namespace, account_user_page.resource], html: { class: "form" }) do |f| %>
  <% if account_user_page.resource.errors.any? %>
    <div id="error_explanation">
      <h2>
        <%= t(
          "administrate.form.errors",
          pluralized_errors: pluralize(account_user_page.resource.errors.count, t("administrate.form.error")),
          resource_name: display_resource_name(account_user_page.resource_name)
        ) %>
      </h2>

      <ul>
        <% account_user_page.resource.errors.full_messages.each do |message| %>
          <li class="flash-error"><%= message %></li>
        <% end %>
      </ul>
    </div>
  <% end %>

  <% account_user_page.attributes.each do |title, attributes| -%>
    <% attributes.each do |attribute| %>
      <% if attribute.name == "user" %>
        <%= f.hidden_field('user_id', value: page.resource.id) %>
      <% else %>
      <div class="field-unit field-unit--<%= attribute.html_class %> field-unit--<%= requireness(attribute) %>">
        <%= render_field attribute, f: f %>
      </div>
      <% end %>
    <% end %>  
  <% end -%>

  <div class="form-actions">
    <%= f.submit %>
  </div>
<% end %>

</section>

<%= render partial: "impersonate", locals: {page: page} %>

================
File: views/survey/responses/show.html.erb
================
<!DOCTYPE html>
<html>
  <head>
    <title><%= @global_config['INSTALLATION_NAME'] %></title>
    <%= csrf_meta_tags %>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0" />
    <script>
      window.globalConfig = <%= raw @global_config.to_json %>
    </script>
    <%= vite_client_tag %>
    <%= vite_javascript_tag 'survey' %>
  </head>
  <body>
    <div id="app"></div>
    <%= yield %>
  </body>
</html>

================
File: views/widget_tests/index.html.erb
================
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0" />


<%
  user_id = 1
  user_hash = OpenSSL::HMAC.hexdigest(
    'sha256',
    @web_widget.hmac_token,
    user_id.to_s
  )

%>
<script>

window.chatwootSettings = {
  hideMessageBubble: false,
  // showUnreadMessagesDialog: false,
  // baseDomain: '.loca.lt',
  position: '<%= @widget_position %>',
  locale: 'en',
  useBrowserLanguage: true,
  type: '<%= @widget_type %>',
  // showPopoutButton: true,
  widgetStyle: '<%= @widget_style %>',
  darkMode: '<%= @dark_mode %>',
};

(function(d,t) {
  var BASE_URL = '';
  var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
  g.src= BASE_URL + "/packs/js/sdk.js";
  g.defer = true;
  g.async = true;
  s.parentNode.insertBefore(g,s);
  g.onload=function(){
    window.chatwootSDK.run({
      websiteToken: '<%= @web_widget.website_token %>',
      baseUrl: BASE_URL
    })
  }
})(document,"script");

window.addEventListener('chatwoot:ready', function() {
  console.log('chatwoot:ready', window.$chatwoot);
  if (window.location.search.includes('setUser')) {
    window.$chatwoot.setUser('<%= user_id %>', {
      identifier_hash: '<%= user_hash %>',
      email: 'jane@example.com',
      name: 'Jane Doe',
      phone_number: ''
    });
  }
})

window.addEventListener('chatwoot:error', function(e) {
  console.log('chatwoot:error', e.detail)
})


window.addEventListener('chatwoot:on-message', function(e) {
  console.log('chatwoot:on-message', e.detail)
})


window.addEventListener('chatwoot:on-start-conversation', function(e) {
  console.log('chatwoot:on-start-conversation', e.detail)
})
</script>

================
File: views/widgets/show.html.erb
================
<!DOCTYPE html>
<html>
  <head>
    <title><%= @global_config['INSTALLATION_NAME'] %></title>
    <%= csrf_meta_tags %>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0" />
    <script>
      window.chatwootWebChannel = {
        avatarUrl: '<%= @web_widget.inbox.avatar_url %>',
        hasAConnectedAgentBot: '<%= @web_widget.inbox.agent_bot&.name %>',
        locale: '<%= @web_widget.account.locale %>',
        websiteName: '<%= @web_widget.inbox.name %>',
        websiteToken: '<%= @web_widget.website_token %>',
        welcomeTagline: '<%= @web_widget.welcome_tagline %>',
        welcomeTitle: '<%= @web_widget.welcome_title %>',
        widgetColor: '<%= @web_widget.widget_color %>',
        portal: <%= @web_widget.inbox.portal.to_json.html_safe %>,
        enabledFeatures: <%= @web_widget.selected_feature_flags.to_json.html_safe %>,
        enabledLanguages: <%= available_locales_with_name.to_json.html_safe %>,
        replyTime: '<%= @web_widget.reply_time %>',
        preChatFormEnabled: <%= @web_widget.pre_chat_form_enabled %>,
        preChatFormOptions: <%= @web_widget.pre_chat_form_options.to_json.html_safe %>,
        workingHoursEnabled: <%= @web_widget.inbox.working_hours_enabled %>,
        csatSurveyEnabled: <%= @web_widget.inbox.csat_survey_enabled %>,
        workingHours: <%= @web_widget.inbox.working_hours.to_json.html_safe %>,
        outOfOfficeMessage: <%= @web_widget.inbox.out_of_office_message.to_json.html_safe %>,
        utcOffset: '<%= ActiveSupport::TimeZone[@web_widget.inbox.timezone].now.formatted_offset %>',
        timezone: '<%= @web_widget.inbox.timezone %>',
        allowMessagesAfterResolved: <%= @web_widget.inbox.allow_messages_after_resolved %>,
        disableBranding: <%= @web_widget.inbox.account.feature_enabled?('disable_branding') %>,
      }
      window.chatwootPubsubToken = '<%= @contact_inbox.pubsub_token %>'
      window.authToken = '<%= @token %>'
      window.globalConfig = <%= raw @global_config.to_json %>
    </script>
    <%= vite_client_tag %>
    <%= vite_javascript_tag 'widget' %>
  </head>
  <body>
    <div id="app" class="h-full"></div>
    <%= yield %>
  </body>
</html>

================
File: workers/conversation_reply_email_worker.rb
================
# TODO: lets move this to active job, since thats what we use over all
class ConversationReplyEmailWorker
  include Sidekiq::Worker
  sidekiq_options queue: :mailers

  def perform(conversation_id, last_queued_id)
    @conversation = Conversation.find(conversation_id)

    # send the email
    if @conversation.messages.incoming&.last&.content_type == 'incoming_email'
      ConversationReplyMailer.with(account: @conversation.account).reply_without_summary(@conversation, last_queued_id).deliver_later
    else
      ConversationReplyMailer.with(account: @conversation.account).reply_with_summary(@conversation, last_queued_id).deliver_later
    end

    # delete the redis set from the first new message on the conversation
    Redis::Alfred.delete(conversation_mail_key)
  end

  private

  def email_inbox?
    @conversation.inbox&.inbox_type == 'Email'
  end

  def conversation_mail_key
    format(::Redis::Alfred::CONVERSATION_MAILER_KEY, conversation_id: @conversation.id)
  end
end

================
File: workers/email_reply_worker.rb
================
class EmailReplyWorker
  include Sidekiq::Worker
  sidekiq_options queue: :mailers, retry: 3

  def perform(message_id)
    message = Message.find(message_id)

    return unless message.email_notifiable_message?

    # send the email
    ConversationReplyMailer.with(account: message.account).email_reply(message).deliver_now
  rescue StandardError => e
    ChatwootExceptionTracker.new(e, account: message.account).capture_exception
    message.update!(status: :failed, external_error: e.message)
  end
end



================================================================
End of Codebase
================================================================
