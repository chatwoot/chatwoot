{"ast":null,"code":"import { __assign, __values } from \"tslib\";\nexport var DEFAULT_RETRY_AFTER = 60 * 1000; // 60 seconds\n\n/**\n * Extracts Retry-After value from the request header or returns default value\n * @param header string representation of 'Retry-After' header\n * @param now current unix timestamp\n *\n */\n\nexport function parseRetryAfterHeader(header, now) {\n  if (now === void 0) {\n    now = Date.now();\n  }\n\n  var headerDelay = parseInt(\"\" + header, 10);\n\n  if (!isNaN(headerDelay)) {\n    return headerDelay * 1000;\n  }\n\n  var headerDate = Date.parse(\"\" + header);\n\n  if (!isNaN(headerDate)) {\n    return headerDate - now;\n  }\n\n  return DEFAULT_RETRY_AFTER;\n}\n/**\n * Gets the time that given category is disabled until for rate limiting\n */\n\nexport function disabledUntil(limits, category) {\n  return limits[category] || limits.all || 0;\n}\n/**\n * Checks if a category is rate limited\n */\n\nexport function isRateLimited(limits, category, now) {\n  if (now === void 0) {\n    now = Date.now();\n  }\n\n  return disabledUntil(limits, category) > now;\n}\n/**\n * Update ratelimits from incoming headers.\n * Returns true if headers contains a non-empty rate limiting header.\n */\n\nexport function updateRateLimits(limits, headers, now) {\n  var e_1, _a, e_2, _b;\n\n  if (now === void 0) {\n    now = Date.now();\n  }\n\n  var updatedRateLimits = __assign({}, limits); // \"The name is case-insensitive.\"\n  // https://developer.mozilla.org/en-US/docs/Web/API/Headers/get\n\n\n  var rateLimitHeader = headers['x-sentry-rate-limits'];\n  var retryAfterHeader = headers['retry-after'];\n\n  if (rateLimitHeader) {\n    try {\n      /**\n       * rate limit headers are of the form\n       *     <header>,<header>,..\n       * where each <header> is of the form\n       *     <retry_after>: <categories>: <scope>: <reason_code>\n       * where\n       *     <retry_after> is a delay in seconds\n       *     <categories> is the event type(s) (error, transaction, etc) being rate limited and is of the form\n       *         <category>;<category>;...\n       *     <scope> is what's being limited (org, project, or key) - ignored by SDK\n       *     <reason_code> is an arbitrary string like \"org_quota\" - ignored by SDK\n       */\n      for (var _c = __values(rateLimitHeader.trim().split(',')), _d = _c.next(); !_d.done; _d = _c.next()) {\n        var limit = _d.value;\n        var parameters = limit.split(':', 2);\n        var headerDelay = parseInt(parameters[0], 10);\n        var delay = (!isNaN(headerDelay) ? headerDelay : 60) * 1000; // 60sec default\n\n        if (!parameters[1]) {\n          updatedRateLimits.all = now + delay;\n        } else {\n          try {\n            for (var _e = (e_2 = void 0, __values(parameters[1].split(';'))), _f = _e.next(); !_f.done; _f = _e.next()) {\n              var category = _f.value;\n              updatedRateLimits[category] = now + delay;\n            }\n          } catch (e_2_1) {\n            e_2 = {\n              error: e_2_1\n            };\n          } finally {\n            try {\n              if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n            } finally {\n              if (e_2) throw e_2.error;\n            }\n          }\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  } else if (retryAfterHeader) {\n    updatedRateLimits.all = now + parseRetryAfterHeader(retryAfterHeader, now);\n  }\n\n  return updatedRateLimits;\n}","map":null,"metadata":{},"sourceType":"module"}