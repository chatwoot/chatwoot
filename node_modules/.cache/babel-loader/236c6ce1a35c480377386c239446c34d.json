{"ast":null,"code":"import { __assign, __read } from \"tslib\";\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n\nimport { getCurrentHub } from '@sentry/core';\nimport { Severity } from '@sentry/types';\nimport { addExceptionMechanism, addInstrumentationHandler, getLocationHref, isErrorEvent, isPrimitive, isString, logger } from '@sentry/utils';\nimport { eventFromUnknownInput } from '../eventbuilder';\nimport { IS_DEBUG_BUILD } from '../flags';\nimport { shouldIgnoreOnError } from '../helpers';\n/** Global handlers */\n\nvar GlobalHandlers =\n/** @class */\nfunction () {\n  /** JSDoc */\n  function GlobalHandlers(options) {\n    /**\n     * @inheritDoc\n     */\n    this.name = GlobalHandlers.id;\n    /**\n     * Stores references functions to installing handlers. Will set to undefined\n     * after they have been run so that they are not used twice.\n     */\n\n    this._installFunc = {\n      onerror: _installGlobalOnErrorHandler,\n      onunhandledrejection: _installGlobalOnUnhandledRejectionHandler\n    };\n    this._options = __assign({\n      onerror: true,\n      onunhandledrejection: true\n    }, options);\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  GlobalHandlers.prototype.setupOnce = function () {\n    Error.stackTraceLimit = 50;\n    var options = this._options; // We can disable guard-for-in as we construct the options object above + do checks against\n    // `this._installFunc` for the property.\n    // eslint-disable-next-line guard-for-in\n\n    for (var key in options) {\n      var installFunc = this._installFunc[key];\n\n      if (installFunc && options[key]) {\n        globalHandlerLog(key);\n        installFunc();\n        this._installFunc[key] = undefined;\n      }\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  GlobalHandlers.id = 'GlobalHandlers';\n  return GlobalHandlers;\n}();\n\nexport { GlobalHandlers };\n/** JSDoc */\n\nfunction _installGlobalOnErrorHandler() {\n  addInstrumentationHandler('error', // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  function (data) {\n    var _a = __read(getHubAndAttachStacktrace(), 2),\n        hub = _a[0],\n        attachStacktrace = _a[1];\n\n    if (!hub.getIntegration(GlobalHandlers)) {\n      return;\n    }\n\n    var msg = data.msg,\n        url = data.url,\n        line = data.line,\n        column = data.column,\n        error = data.error;\n\n    if (shouldIgnoreOnError() || error && error.__sentry_own_request__) {\n      return;\n    }\n\n    var event = error === undefined && isString(msg) ? _eventFromIncompleteOnError(msg, url, line, column) : _enhanceEventWithInitialFrame(eventFromUnknownInput(error || msg, undefined, attachStacktrace, false), url, line, column);\n    event.level = Severity.Error;\n    addMechanismAndCapture(hub, error, event, 'onerror');\n  });\n}\n/** JSDoc */\n\n\nfunction _installGlobalOnUnhandledRejectionHandler() {\n  addInstrumentationHandler('unhandledrejection', // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  function (e) {\n    var _a = __read(getHubAndAttachStacktrace(), 2),\n        hub = _a[0],\n        attachStacktrace = _a[1];\n\n    if (!hub.getIntegration(GlobalHandlers)) {\n      return;\n    }\n\n    var error = e; // dig the object of the rejection out of known event types\n\n    try {\n      // PromiseRejectionEvents store the object of the rejection under 'reason'\n      // see https://developer.mozilla.org/en-US/docs/Web/API/PromiseRejectionEvent\n      if ('reason' in e) {\n        error = e.reason;\n      } // something, somewhere, (likely a browser extension) effectively casts PromiseRejectionEvents\n      // to CustomEvents, moving the `promise` and `reason` attributes of the PRE into\n      // the CustomEvent's `detail` attribute, since they're not part of CustomEvent's spec\n      // see https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent and\n      // https://github.com/getsentry/sentry-javascript/issues/2380\n      else if ('detail' in e && 'reason' in e.detail) {\n          error = e.detail.reason;\n        }\n    } catch (_oO) {// no-empty\n    }\n\n    if (shouldIgnoreOnError() || error && error.__sentry_own_request__) {\n      return true;\n    }\n\n    var event = isPrimitive(error) ? _eventFromRejectionWithPrimitive(error) : eventFromUnknownInput(error, undefined, attachStacktrace, true);\n    event.level = Severity.Error;\n    addMechanismAndCapture(hub, error, event, 'onunhandledrejection');\n    return;\n  });\n}\n/**\n * Create an event from a promise rejection where the `reason` is a primitive.\n *\n * @param reason: The `reason` property of the promise rejection\n * @returns An Event object with an appropriate `exception` value\n */\n\n\nfunction _eventFromRejectionWithPrimitive(reason) {\n  return {\n    exception: {\n      values: [{\n        type: 'UnhandledRejection',\n        // String() is needed because the Primitive type includes symbols (which can't be automatically stringified)\n        value: \"Non-Error promise rejection captured with value: \" + String(reason)\n      }]\n    }\n  };\n}\n/**\n * This function creates a stack from an old, error-less onerror handler.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\nfunction _eventFromIncompleteOnError(msg, url, line, column) {\n  var ERROR_TYPES_RE = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/i; // If 'message' is ErrorEvent, get real message from inside\n\n  var message = isErrorEvent(msg) ? msg.message : msg;\n  var name = 'Error';\n  var groups = message.match(ERROR_TYPES_RE);\n\n  if (groups) {\n    name = groups[1];\n    message = groups[2];\n  }\n\n  var event = {\n    exception: {\n      values: [{\n        type: name,\n        value: message\n      }]\n    }\n  };\n  return _enhanceEventWithInitialFrame(event, url, line, column);\n}\n/** JSDoc */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\nfunction _enhanceEventWithInitialFrame(event, url, line, column) {\n  // event.exception\n  var e = event.exception = event.exception || {}; // event.exception.values\n\n  var ev = e.values = e.values || []; // event.exception.values[0]\n\n  var ev0 = ev[0] = ev[0] || {}; // event.exception.values[0].stacktrace\n\n  var ev0s = ev0.stacktrace = ev0.stacktrace || {}; // event.exception.values[0].stacktrace.frames\n\n  var ev0sf = ev0s.frames = ev0s.frames || [];\n  var colno = isNaN(parseInt(column, 10)) ? undefined : column;\n  var lineno = isNaN(parseInt(line, 10)) ? undefined : line;\n  var filename = isString(url) && url.length > 0 ? url : getLocationHref(); // event.exception.values[0].stacktrace.frames\n\n  if (ev0sf.length === 0) {\n    ev0sf.push({\n      colno: colno,\n      filename: filename,\n      function: '?',\n      in_app: true,\n      lineno: lineno\n    });\n  }\n\n  return event;\n}\n\nfunction globalHandlerLog(type) {\n  IS_DEBUG_BUILD && logger.log(\"Global Handler attached: \" + type);\n}\n\nfunction addMechanismAndCapture(hub, error, event, type) {\n  addExceptionMechanism(event, {\n    handled: false,\n    type: type\n  });\n  hub.captureEvent(event, {\n    originalException: error\n  });\n}\n\nfunction getHubAndAttachStacktrace() {\n  var hub = getCurrentHub();\n  var client = hub.getClient();\n  var attachStacktrace = client && client.getOptions().attachStacktrace;\n  return [hub, attachStacktrace];\n}","map":null,"metadata":{},"sourceType":"module"}