{"ast":null,"code":"import { liftTarget, canJoin, joinPoint, canSplit, ReplaceAroundStep, findWrapping } from 'prosemirror-transform';\nimport { Fragment, Slice } from 'prosemirror-model';\nimport { NodeSelection, Selection, TextSelection, AllSelection } from 'prosemirror-state'; // :: (EditorState, ?(tr: Transaction)) → bool\n// Delete the selection, if there is one.\n\nfunction deleteSelection(state, dispatch) {\n  if (state.selection.empty) {\n    return false;\n  }\n\n  if (dispatch) {\n    dispatch(state.tr.deleteSelection().scrollIntoView());\n  }\n\n  return true;\n} // :: (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// If the selection is empty and at the start of a textblock, try to\n// reduce the distance between that block and the one before it—if\n// there's a block directly before it that can be joined, join them.\n// If not, try to move the selected block closer to the next one in\n// the document structure by lifting it out of its parent or moving it\n// into a parent of the previous block. Will use the view for accurate\n// (bidi-aware) start-of-textblock detection if given.\n\n\nfunction joinBackward(state, dispatch, view) {\n  var ref = state.selection;\n  var $cursor = ref.$cursor;\n\n  if (!$cursor || (view ? !view.endOfTextblock(\"backward\", state) : $cursor.parentOffset > 0)) {\n    return false;\n  }\n\n  var $cut = findCutBefore($cursor); // If there is no node before this, try to lift\n\n  if (!$cut) {\n    var range = $cursor.blockRange(),\n        target = range && liftTarget(range);\n\n    if (target == null) {\n      return false;\n    }\n\n    if (dispatch) {\n      dispatch(state.tr.lift(range, target).scrollIntoView());\n    }\n\n    return true;\n  }\n\n  var before = $cut.nodeBefore; // Apply the joining algorithm\n\n  if (!before.type.spec.isolating && deleteBarrier(state, $cut, dispatch)) {\n    return true;\n  } // If the node below has no content and the node above is\n  // selectable, delete the node below and select the one above.\n\n\n  if ($cursor.parent.content.size == 0 && (textblockAt(before, \"end\") || NodeSelection.isSelectable(before))) {\n    if (dispatch) {\n      var tr = state.tr.deleteRange($cursor.before(), $cursor.after());\n      tr.setSelection(textblockAt(before, \"end\") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1) : NodeSelection.create(tr.doc, $cut.pos - before.nodeSize));\n      dispatch(tr.scrollIntoView());\n    }\n\n    return true;\n  } // If the node before is an atom, delete it\n\n\n  if (before.isAtom && $cut.depth == $cursor.depth - 1) {\n    if (dispatch) {\n      dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nfunction textblockAt(node, side) {\n  for (; node; node = side == \"start\" ? node.firstChild : node.lastChild) {\n    if (node.isTextblock) {\n      return true;\n    }\n  }\n\n  return false;\n} // :: (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// When the selection is empty and at the start of a textblock, select\n// the node before that textblock, if possible. This is intended to be\n// bound to keys like backspace, after\n// [`joinBackward`](#commands.joinBackward) or other deleting\n// commands, as a fall-back behavior when the schema doesn't allow\n// deletion at the selected point.\n\n\nfunction selectNodeBackward(state, dispatch, view) {\n  var ref = state.selection;\n  var $head = ref.$head;\n  var empty = ref.empty;\n  var $cut = $head;\n\n  if (!empty) {\n    return false;\n  }\n\n  if ($head.parent.isTextblock) {\n    if (view ? !view.endOfTextblock(\"backward\", state) : $head.parentOffset > 0) {\n      return false;\n    }\n\n    $cut = findCutBefore($head);\n  }\n\n  var node = $cut && $cut.nodeBefore;\n\n  if (!node || !NodeSelection.isSelectable(node)) {\n    return false;\n  }\n\n  if (dispatch) {\n    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView());\n  }\n\n  return true;\n}\n\nfunction findCutBefore($pos) {\n  if (!$pos.parent.type.spec.isolating) {\n    for (var i = $pos.depth - 1; i >= 0; i--) {\n      if ($pos.index(i) > 0) {\n        return $pos.doc.resolve($pos.before(i + 1));\n      }\n\n      if ($pos.node(i).type.spec.isolating) {\n        break;\n      }\n    }\n  }\n\n  return null;\n} // :: (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// If the selection is empty and the cursor is at the end of a\n// textblock, try to reduce or remove the boundary between that block\n// and the one after it, either by joining them or by moving the other\n// block closer to this one in the tree structure. Will use the view\n// for accurate start-of-textblock detection if given.\n\n\nfunction joinForward(state, dispatch, view) {\n  var ref = state.selection;\n  var $cursor = ref.$cursor;\n\n  if (!$cursor || (view ? !view.endOfTextblock(\"forward\", state) : $cursor.parentOffset < $cursor.parent.content.size)) {\n    return false;\n  }\n\n  var $cut = findCutAfter($cursor); // If there is no node after this, there's nothing to do\n\n  if (!$cut) {\n    return false;\n  }\n\n  var after = $cut.nodeAfter; // Try the joining algorithm\n\n  if (deleteBarrier(state, $cut, dispatch)) {\n    return true;\n  } // If the node above has no content and the node below is\n  // selectable, delete the node above and select the one below.\n\n\n  if ($cursor.parent.content.size == 0 && (textblockAt(after, \"start\") || NodeSelection.isSelectable(after))) {\n    if (dispatch) {\n      var tr = state.tr.deleteRange($cursor.before(), $cursor.after());\n      tr.setSelection(textblockAt(after, \"start\") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1) : NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)));\n      dispatch(tr.scrollIntoView());\n    }\n\n    return true;\n  } // If the next node is an atom, delete it\n\n\n  if (after.isAtom && $cut.depth == $cursor.depth - 1) {\n    if (dispatch) {\n      dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());\n    }\n\n    return true;\n  }\n\n  return false;\n} // :: (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// When the selection is empty and at the end of a textblock, select\n// the node coming after that textblock, if possible. This is intended\n// to be bound to keys like delete, after\n// [`joinForward`](#commands.joinForward) and similar deleting\n// commands, to provide a fall-back behavior when the schema doesn't\n// allow deletion at the selected point.\n\n\nfunction selectNodeForward(state, dispatch, view) {\n  var ref = state.selection;\n  var $head = ref.$head;\n  var empty = ref.empty;\n  var $cut = $head;\n\n  if (!empty) {\n    return false;\n  }\n\n  if ($head.parent.isTextblock) {\n    if (view ? !view.endOfTextblock(\"forward\", state) : $head.parentOffset < $head.parent.content.size) {\n      return false;\n    }\n\n    $cut = findCutAfter($head);\n  }\n\n  var node = $cut && $cut.nodeAfter;\n\n  if (!node || !NodeSelection.isSelectable(node)) {\n    return false;\n  }\n\n  if (dispatch) {\n    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());\n  }\n\n  return true;\n}\n\nfunction findCutAfter($pos) {\n  if (!$pos.parent.type.spec.isolating) {\n    for (var i = $pos.depth - 1; i >= 0; i--) {\n      var parent = $pos.node(i);\n\n      if ($pos.index(i) + 1 < parent.childCount) {\n        return $pos.doc.resolve($pos.after(i + 1));\n      }\n\n      if (parent.type.spec.isolating) {\n        break;\n      }\n    }\n  }\n\n  return null;\n} // :: (EditorState, ?(tr: Transaction)) → bool\n// Join the selected block or, if there is a text selection, the\n// closest ancestor block of the selection that can be joined, with\n// the sibling above it.\n\n\nfunction joinUp(state, dispatch) {\n  var sel = state.selection,\n      nodeSel = sel instanceof NodeSelection,\n      point;\n\n  if (nodeSel) {\n    if (sel.node.isTextblock || !canJoin(state.doc, sel.from)) {\n      return false;\n    }\n\n    point = sel.from;\n  } else {\n    point = joinPoint(state.doc, sel.from, -1);\n\n    if (point == null) {\n      return false;\n    }\n  }\n\n  if (dispatch) {\n    var tr = state.tr.join(point);\n\n    if (nodeSel) {\n      tr.setSelection(NodeSelection.create(tr.doc, point - state.doc.resolve(point).nodeBefore.nodeSize));\n    }\n\n    dispatch(tr.scrollIntoView());\n  }\n\n  return true;\n} // :: (EditorState, ?(tr: Transaction)) → bool\n// Join the selected block, or the closest ancestor of the selection\n// that can be joined, with the sibling after it.\n\n\nfunction joinDown(state, dispatch) {\n  var sel = state.selection,\n      point;\n\n  if (sel instanceof NodeSelection) {\n    if (sel.node.isTextblock || !canJoin(state.doc, sel.to)) {\n      return false;\n    }\n\n    point = sel.to;\n  } else {\n    point = joinPoint(state.doc, sel.to, 1);\n\n    if (point == null) {\n      return false;\n    }\n  }\n\n  if (dispatch) {\n    dispatch(state.tr.join(point).scrollIntoView());\n  }\n\n  return true;\n} // :: (EditorState, ?(tr: Transaction)) → bool\n// Lift the selected block, or the closest ancestor block of the\n// selection that can be lifted, out of its parent node.\n\n\nfunction lift(state, dispatch) {\n  var ref = state.selection;\n  var $from = ref.$from;\n  var $to = ref.$to;\n  var range = $from.blockRange($to),\n      target = range && liftTarget(range);\n\n  if (target == null) {\n    return false;\n  }\n\n  if (dispatch) {\n    dispatch(state.tr.lift(range, target).scrollIntoView());\n  }\n\n  return true;\n} // :: (EditorState, ?(tr: Transaction)) → bool\n// If the selection is in a node whose type has a truthy\n// [`code`](#model.NodeSpec.code) property in its spec, replace the\n// selection with a newline character.\n\n\nfunction newlineInCode(state, dispatch) {\n  var ref = state.selection;\n  var $head = ref.$head;\n  var $anchor = ref.$anchor;\n\n  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) {\n    return false;\n  }\n\n  if (dispatch) {\n    dispatch(state.tr.insertText(\"\\n\").scrollIntoView());\n  }\n\n  return true;\n}\n\nfunction defaultBlockAt(match) {\n  for (var i = 0; i < match.edgeCount; i++) {\n    var ref = match.edge(i);\n    var type = ref.type;\n\n    if (type.isTextblock && !type.hasRequiredAttrs()) {\n      return type;\n    }\n  }\n\n  return null;\n} // :: (EditorState, ?(tr: Transaction)) → bool\n// When the selection is in a node with a truthy\n// [`code`](#model.NodeSpec.code) property in its spec, create a\n// default block after the code block, and move the cursor there.\n\n\nfunction exitCode(state, dispatch) {\n  var ref = state.selection;\n  var $head = ref.$head;\n  var $anchor = ref.$anchor;\n\n  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) {\n    return false;\n  }\n\n  var above = $head.node(-1),\n      after = $head.indexAfter(-1),\n      type = defaultBlockAt(above.contentMatchAt(after));\n\n  if (!above.canReplaceWith(after, after, type)) {\n    return false;\n  }\n\n  if (dispatch) {\n    var pos = $head.after(),\n        tr = state.tr.replaceWith(pos, pos, type.createAndFill());\n    tr.setSelection(Selection.near(tr.doc.resolve(pos), 1));\n    dispatch(tr.scrollIntoView());\n  }\n\n  return true;\n} // :: (EditorState, ?(tr: Transaction)) → bool\n// If a block node is selected, create an empty paragraph before (if\n// it is its parent's first child) or after it.\n\n\nfunction createParagraphNear(state, dispatch) {\n  var ref = state.selection;\n  var $from = ref.$from;\n  var $to = ref.$to;\n\n  if ($from.parent.inlineContent || $to.parent.inlineContent) {\n    return false;\n  }\n\n  var type = defaultBlockAt($from.parent.contentMatchAt($to.indexAfter()));\n\n  if (!type || !type.isTextblock) {\n    return false;\n  }\n\n  if (dispatch) {\n    var side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;\n    var tr = state.tr.insert(side, type.createAndFill());\n    tr.setSelection(TextSelection.create(tr.doc, side + 1));\n    dispatch(tr.scrollIntoView());\n  }\n\n  return true;\n} // :: (EditorState, ?(tr: Transaction)) → bool\n// If the cursor is in an empty textblock that can be lifted, lift the\n// block.\n\n\nfunction liftEmptyBlock(state, dispatch) {\n  var ref = state.selection;\n  var $cursor = ref.$cursor;\n\n  if (!$cursor || $cursor.parent.content.size) {\n    return false;\n  }\n\n  if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {\n    var before = $cursor.before();\n\n    if (canSplit(state.doc, before)) {\n      if (dispatch) {\n        dispatch(state.tr.split(before).scrollIntoView());\n      }\n\n      return true;\n    }\n  }\n\n  var range = $cursor.blockRange(),\n      target = range && liftTarget(range);\n\n  if (target == null) {\n    return false;\n  }\n\n  if (dispatch) {\n    dispatch(state.tr.lift(range, target).scrollIntoView());\n  }\n\n  return true;\n} // :: (EditorState, ?(tr: Transaction)) → bool\n// Split the parent block of the selection. If the selection is a text\n// selection, also delete its content.\n\n\nfunction splitBlock(state, dispatch) {\n  var ref = state.selection;\n  var $from = ref.$from;\n  var $to = ref.$to;\n\n  if (state.selection instanceof NodeSelection && state.selection.node.isBlock) {\n    if (!$from.parentOffset || !canSplit(state.doc, $from.pos)) {\n      return false;\n    }\n\n    if (dispatch) {\n      dispatch(state.tr.split($from.pos).scrollIntoView());\n    }\n\n    return true;\n  }\n\n  if (!$from.parent.isBlock) {\n    return false;\n  }\n\n  if (dispatch) {\n    var atEnd = $to.parentOffset == $to.parent.content.size;\n    var tr = state.tr;\n\n    if (state.selection instanceof TextSelection) {\n      tr.deleteSelection();\n    }\n\n    var deflt = $from.depth == 0 ? null : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));\n    var types = atEnd && deflt ? [{\n      type: deflt\n    }] : null;\n    var can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types);\n\n    if (!types && !can && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt && [{\n      type: deflt\n    }])) {\n      types = [{\n        type: deflt\n      }];\n      can = true;\n    }\n\n    if (can) {\n      tr.split(tr.mapping.map($from.pos), 1, types);\n\n      if (!atEnd && !$from.parentOffset && $from.parent.type != deflt && $from.node(-1).canReplace($from.index(-1), $from.indexAfter(-1), Fragment.from([deflt.create(), $from.parent]))) {\n        tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);\n      }\n    }\n\n    dispatch(tr.scrollIntoView());\n  }\n\n  return true;\n} // :: (EditorState, ?(tr: Transaction)) → bool\n// Acts like [`splitBlock`](#commands.splitBlock), but without\n// resetting the set of active marks at the cursor.\n\n\nfunction splitBlockKeepMarks(state, dispatch) {\n  return splitBlock(state, dispatch && function (tr) {\n    var marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();\n\n    if (marks) {\n      tr.ensureMarks(marks);\n    }\n\n    dispatch(tr);\n  });\n} // :: (EditorState, ?(tr: Transaction)) → bool\n// Move the selection to the node wrapping the current selection, if\n// any. (Will not select the document node.)\n\n\nfunction selectParentNode(state, dispatch) {\n  var ref = state.selection;\n  var $from = ref.$from;\n  var to = ref.to;\n  var pos;\n  var same = $from.sharedDepth(to);\n\n  if (same == 0) {\n    return false;\n  }\n\n  pos = $from.before(same);\n\n  if (dispatch) {\n    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, pos)));\n  }\n\n  return true;\n} // :: (EditorState, ?(tr: Transaction)) → bool\n// Select the whole document.\n\n\nfunction selectAll(state, dispatch) {\n  if (dispatch) {\n    dispatch(state.tr.setSelection(new AllSelection(state.doc)));\n  }\n\n  return true;\n}\n\nfunction joinMaybeClear(state, $pos, dispatch) {\n  var before = $pos.nodeBefore,\n      after = $pos.nodeAfter,\n      index = $pos.index();\n\n  if (!before || !after || !before.type.compatibleContent(after.type)) {\n    return false;\n  }\n\n  if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {\n    if (dispatch) {\n      dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());\n    }\n\n    return true;\n  }\n\n  if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || canJoin(state.doc, $pos.pos))) {\n    return false;\n  }\n\n  if (dispatch) {\n    dispatch(state.tr.clearIncompatible($pos.pos, before.type, before.contentMatchAt(before.childCount)).join($pos.pos).scrollIntoView());\n  }\n\n  return true;\n}\n\nfunction deleteBarrier(state, $cut, dispatch) {\n  var before = $cut.nodeBefore,\n      after = $cut.nodeAfter,\n      conn,\n      match;\n\n  if (before.type.spec.isolating || after.type.spec.isolating) {\n    return false;\n  }\n\n  if (joinMaybeClear(state, $cut, dispatch)) {\n    return true;\n  }\n\n  var canDelAfter = $cut.parent.canReplace($cut.index(), $cut.index() + 1);\n\n  if (canDelAfter && (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) && match.matchType(conn[0] || after.type).validEnd) {\n    if (dispatch) {\n      var end = $cut.pos + after.nodeSize,\n          wrap = Fragment.empty;\n\n      for (var i = conn.length - 1; i >= 0; i--) {\n        wrap = Fragment.from(conn[i].create(null, wrap));\n      }\n\n      wrap = Fragment.from(before.copy(wrap));\n      var tr = state.tr.step(new ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new Slice(wrap, 1, 0), conn.length, true));\n      var joinAt = end + 2 * conn.length;\n\n      if (canJoin(tr.doc, joinAt)) {\n        tr.join(joinAt);\n      }\n\n      dispatch(tr.scrollIntoView());\n    }\n\n    return true;\n  }\n\n  var selAfter = Selection.findFrom($cut, 1);\n  var range = selAfter && selAfter.$from.blockRange(selAfter.$to),\n      target = range && liftTarget(range);\n\n  if (target != null && target >= $cut.depth) {\n    if (dispatch) {\n      dispatch(state.tr.lift(range, target).scrollIntoView());\n    }\n\n    return true;\n  }\n\n  if (canDelAfter && after.isTextblock && textblockAt(before, \"end\")) {\n    var at = before,\n        wrap$1 = [];\n\n    for (;;) {\n      wrap$1.push(at);\n\n      if (at.isTextblock) {\n        break;\n      }\n\n      at = at.lastChild;\n    }\n\n    if (at.canReplace(at.childCount, at.childCount, after.content)) {\n      if (dispatch) {\n        var end$1 = Fragment.empty;\n\n        for (var i$1 = wrap$1.length - 1; i$1 >= 0; i$1--) {\n          end$1 = Fragment.from(wrap$1[i$1].copy(end$1));\n        }\n\n        var tr$1 = state.tr.step(new ReplaceAroundStep($cut.pos - wrap$1.length, $cut.pos + after.nodeSize, $cut.pos + 1, $cut.pos + after.nodeSize - 1, new Slice(end$1, wrap$1.length, 0), 0, true));\n        dispatch(tr$1.scrollIntoView());\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n} // Parameterized commands\n// :: (NodeType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Wrap the selection in a node of the given type with the given\n// attributes.\n\n\nfunction wrapIn(nodeType, attrs) {\n  return function (state, dispatch) {\n    var ref = state.selection;\n    var $from = ref.$from;\n    var $to = ref.$to;\n    var range = $from.blockRange($to),\n        wrapping = range && findWrapping(range, nodeType, attrs);\n\n    if (!wrapping) {\n      return false;\n    }\n\n    if (dispatch) {\n      dispatch(state.tr.wrap(range, wrapping).scrollIntoView());\n    }\n\n    return true;\n  };\n} // :: (NodeType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Returns a command that tries to set the selected textblocks to the\n// given node type with the given attributes.\n\n\nfunction setBlockType(nodeType, attrs) {\n  return function (state, dispatch) {\n    var ref = state.selection;\n    var from = ref.from;\n    var to = ref.to;\n    var applicable = false;\n    state.doc.nodesBetween(from, to, function (node, pos) {\n      if (applicable) {\n        return false;\n      }\n\n      if (!node.isTextblock || node.hasMarkup(nodeType, attrs)) {\n        return;\n      }\n\n      if (node.type == nodeType) {\n        applicable = true;\n      } else {\n        var $pos = state.doc.resolve(pos),\n            index = $pos.index();\n        applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType);\n      }\n    });\n\n    if (!applicable) {\n      return false;\n    }\n\n    if (dispatch) {\n      dispatch(state.tr.setBlockType(from, to, nodeType, attrs).scrollIntoView());\n    }\n\n    return true;\n  };\n}\n\nfunction markApplies(doc, ranges, type) {\n  var loop = function loop(i) {\n    var ref = ranges[i];\n    var $from = ref.$from;\n    var $to = ref.$to;\n    var can = $from.depth == 0 ? doc.type.allowsMarkType(type) : false;\n    doc.nodesBetween($from.pos, $to.pos, function (node) {\n      if (can) {\n        return false;\n      }\n\n      can = node.inlineContent && node.type.allowsMarkType(type);\n    });\n\n    if (can) {\n      return {\n        v: true\n      };\n    }\n  };\n\n  for (var i = 0; i < ranges.length; i++) {\n    var returned = loop(i);\n    if (returned) return returned.v;\n  }\n\n  return false;\n} // :: (MarkType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool\n// Create a command function that toggles the given mark with the\n// given attributes. Will return `false` when the current selection\n// doesn't support that mark. This will remove the mark if any marks\n// of that type exist in the selection, or add it otherwise. If the\n// selection is empty, this applies to the [stored\n// marks](#state.EditorState.storedMarks) instead of a range of the\n// document.\n\n\nfunction toggleMark(markType, attrs) {\n  return function (state, dispatch) {\n    var ref = state.selection;\n    var empty = ref.empty;\n    var $cursor = ref.$cursor;\n    var ranges = ref.ranges;\n\n    if (empty && !$cursor || !markApplies(state.doc, ranges, markType)) {\n      return false;\n    }\n\n    if (dispatch) {\n      if ($cursor) {\n        if (markType.isInSet(state.storedMarks || $cursor.marks())) {\n          dispatch(state.tr.removeStoredMark(markType));\n        } else {\n          dispatch(state.tr.addStoredMark(markType.create(attrs)));\n        }\n      } else {\n        var has = false,\n            tr = state.tr;\n\n        for (var i = 0; !has && i < ranges.length; i++) {\n          var ref$1 = ranges[i];\n          var $from = ref$1.$from;\n          var $to = ref$1.$to;\n          has = state.doc.rangeHasMark($from.pos, $to.pos, markType);\n        }\n\n        for (var i$1 = 0; i$1 < ranges.length; i$1++) {\n          var ref$2 = ranges[i$1];\n          var $from$1 = ref$2.$from;\n          var $to$1 = ref$2.$to;\n\n          if (has) {\n            tr.removeMark($from$1.pos, $to$1.pos, markType);\n          } else {\n            var from = $from$1.pos,\n                to = $to$1.pos,\n                start = $from$1.nodeAfter,\n                end = $to$1.nodeBefore;\n            var spaceStart = start && start.isText ? /^\\s*/.exec(start.text)[0].length : 0;\n            var spaceEnd = end && end.isText ? /\\s*$/.exec(end.text)[0].length : 0;\n\n            if (from + spaceStart < to) {\n              from += spaceStart;\n              to -= spaceEnd;\n            }\n\n            tr.addMark(from, to, markType.create(attrs));\n          }\n        }\n\n        dispatch(tr.scrollIntoView());\n      }\n    }\n\n    return true;\n  };\n}\n\nfunction wrapDispatchForJoin(dispatch, isJoinable) {\n  return function (tr) {\n    if (!tr.isGeneric) {\n      return dispatch(tr);\n    }\n\n    var ranges = [];\n\n    for (var i = 0; i < tr.mapping.maps.length; i++) {\n      var map = tr.mapping.maps[i];\n\n      for (var j = 0; j < ranges.length; j++) {\n        ranges[j] = map.map(ranges[j]);\n      }\n\n      map.forEach(function (_s, _e, from, to) {\n        return ranges.push(from, to);\n      });\n    } // Figure out which joinable points exist inside those ranges,\n    // by checking all node boundaries in their parent nodes.\n\n\n    var joinable = [];\n\n    for (var i$1 = 0; i$1 < ranges.length; i$1 += 2) {\n      var from = ranges[i$1],\n          to = ranges[i$1 + 1];\n      var $from = tr.doc.resolve(from),\n          depth = $from.sharedDepth(to),\n          parent = $from.node(depth);\n\n      for (var index = $from.indexAfter(depth), pos = $from.after(depth + 1); pos <= to; ++index) {\n        var after = parent.maybeChild(index);\n\n        if (!after) {\n          break;\n        }\n\n        if (index && joinable.indexOf(pos) == -1) {\n          var before = parent.child(index - 1);\n\n          if (before.type == after.type && isJoinable(before, after)) {\n            joinable.push(pos);\n          }\n        }\n\n        pos += after.nodeSize;\n      }\n    } // Join the joinable points\n\n\n    joinable.sort(function (a, b) {\n      return a - b;\n    });\n\n    for (var i$2 = joinable.length - 1; i$2 >= 0; i$2--) {\n      if (canJoin(tr.doc, joinable[i$2])) {\n        tr.join(joinable[i$2]);\n      }\n    }\n\n    dispatch(tr);\n  };\n} // :: ((state: EditorState, ?(tr: Transaction)) → bool, union<(before: Node, after: Node) → bool, [string]>) → (state: EditorState, ?(tr: Transaction)) → bool\n// Wrap a command so that, when it produces a transform that causes\n// two joinable nodes to end up next to each other, those are joined.\n// Nodes are considered joinable when they are of the same type and\n// when the `isJoinable` predicate returns true for them or, if an\n// array of strings was passed, if their node type name is in that\n// array.\n\n\nfunction autoJoin(command, isJoinable) {\n  if (Array.isArray(isJoinable)) {\n    var types = isJoinable;\n\n    isJoinable = function isJoinable(node) {\n      return types.indexOf(node.type.name) > -1;\n    };\n  }\n\n  return function (state, dispatch) {\n    return command(state, dispatch && wrapDispatchForJoin(dispatch, isJoinable));\n  };\n} // :: (...[(EditorState, ?(tr: Transaction), ?EditorView) → bool]) → (EditorState, ?(tr: Transaction), ?EditorView) → bool\n// Combine a number of command functions into a single function (which\n// calls them one by one until one returns true).\n\n\nfunction chainCommands() {\n  var commands = [],\n      len = arguments.length;\n\n  while (len--) {\n    commands[len] = arguments[len];\n  }\n\n  return function (state, dispatch, view) {\n    for (var i = 0; i < commands.length; i++) {\n      if (commands[i](state, dispatch, view)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n}\n\nvar backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);\nvar del = chainCommands(deleteSelection, joinForward, selectNodeForward); // :: Object\n// A basic keymap containing bindings not specific to any schema.\n// Binds the following keys (when multiple commands are listed, they\n// are chained with [`chainCommands`](#commands.chainCommands)):\n//\n// * **Enter** to `newlineInCode`, `createParagraphNear`, `liftEmptyBlock`, `splitBlock`\n// * **Mod-Enter** to `exitCode`\n// * **Backspace** and **Mod-Backspace** to `deleteSelection`, `joinBackward`, `selectNodeBackward`\n// * **Delete** and **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`\n// * **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`\n// * **Mod-a** to `selectAll`\n\nvar pcBaseKeymap = {\n  \"Enter\": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),\n  \"Mod-Enter\": exitCode,\n  \"Backspace\": backspace,\n  \"Mod-Backspace\": backspace,\n  \"Delete\": del,\n  \"Mod-Delete\": del,\n  \"Mod-a\": selectAll\n}; // :: Object\n// A copy of `pcBaseKeymap` that also binds **Ctrl-h** like Backspace,\n// **Ctrl-d** like Delete, **Alt-Backspace** like Ctrl-Backspace, and\n// **Ctrl-Alt-Backspace**, **Alt-Delete**, and **Alt-d** like\n// Ctrl-Delete.\n\nvar macBaseKeymap = {\n  \"Ctrl-h\": pcBaseKeymap[\"Backspace\"],\n  \"Alt-Backspace\": pcBaseKeymap[\"Mod-Backspace\"],\n  \"Ctrl-d\": pcBaseKeymap[\"Delete\"],\n  \"Ctrl-Alt-Backspace\": pcBaseKeymap[\"Mod-Delete\"],\n  \"Alt-Delete\": pcBaseKeymap[\"Mod-Delete\"],\n  \"Alt-d\": pcBaseKeymap[\"Mod-Delete\"]\n};\n\nfor (var key in pcBaseKeymap) {\n  macBaseKeymap[key] = pcBaseKeymap[key];\n} // declare global: os, navigator\n\n\nvar mac = typeof navigator != \"undefined\" ? /Mac/.test(navigator.platform) : typeof os != \"undefined\" ? os.platform() == \"darwin\" : false; // :: Object\n// Depending on the detected platform, this will hold\n// [`pcBasekeymap`](#commands.pcBaseKeymap) or\n// [`macBaseKeymap`](#commands.macBaseKeymap).\n\nvar baseKeymap = mac ? macBaseKeymap : pcBaseKeymap;\nexport { autoJoin, baseKeymap, chainCommands, createParagraphNear, deleteSelection, exitCode, joinBackward, joinDown, joinForward, joinUp, lift, liftEmptyBlock, macBaseKeymap, newlineInCode, pcBaseKeymap, selectAll, selectNodeBackward, selectNodeForward, selectParentNode, setBlockType, splitBlock, splitBlockKeepMarks, toggleMark, wrapIn };","map":null,"metadata":{},"sourceType":"module"}