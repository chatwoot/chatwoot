{"ast":null,"code":"// Lists\n'use strict';\n\nvar isSpace = require('../common/utils').isSpace; // Search `[-+*][\\n ]`, returns next pos after marker on success\n// or -1 on fail.\n\n\nfunction skipBulletListMarker(state, startLine) {\n  var marker, pos, max, ch;\n  pos = state.bMarks[startLine] + state.tShift[startLine];\n  max = state.eMarks[startLine];\n  marker = state.src.charCodeAt(pos++); // Check bullet\n\n  if (marker !== 0x2A\n  /* * */\n  && marker !== 0x2D\n  /* - */\n  && marker !== 0x2B\n  /* + */\n  ) {\n      return -1;\n    }\n\n  if (pos < max) {\n    ch = state.src.charCodeAt(pos);\n\n    if (!isSpace(ch)) {\n      // \" -test \" - is not a list item\n      return -1;\n    }\n  }\n\n  return pos;\n} // Search `\\d+[.)][\\n ]`, returns next pos after marker on success\n// or -1 on fail.\n\n\nfunction skipOrderedListMarker(state, startLine) {\n  var ch,\n      start = state.bMarks[startLine] + state.tShift[startLine],\n      pos = start,\n      max = state.eMarks[startLine]; // List marker should have at least 2 chars (digit + dot)\n\n  if (pos + 1 >= max) {\n    return -1;\n  }\n\n  ch = state.src.charCodeAt(pos++);\n\n  if (ch < 0x30\n  /* 0 */\n  || ch > 0x39\n  /* 9 */\n  ) {\n      return -1;\n    }\n\n  for (;;) {\n    // EOL -> fail\n    if (pos >= max) {\n      return -1;\n    }\n\n    ch = state.src.charCodeAt(pos++);\n\n    if (ch >= 0x30\n    /* 0 */\n    && ch <= 0x39\n    /* 9 */\n    ) {\n        // List marker should have no more than 9 digits\n        // (prevents integer overflow in browsers)\n        if (pos - start >= 10) {\n          return -1;\n        }\n\n        continue;\n      } // found valid marker\n\n\n    if (ch === 0x29\n    /* ) */\n    || ch === 0x2e\n    /* . */\n    ) {\n        break;\n      }\n\n    return -1;\n  }\n\n  if (pos < max) {\n    ch = state.src.charCodeAt(pos);\n\n    if (!isSpace(ch)) {\n      // \" 1.test \" - is not a list item\n      return -1;\n    }\n  }\n\n  return pos;\n}\n\nfunction markTightParagraphs(state, idx) {\n  var i,\n      l,\n      level = state.level + 2;\n\n  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {\n    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {\n      state.tokens[i + 2].hidden = true;\n      state.tokens[i].hidden = true;\n      i += 2;\n    }\n  }\n}\n\nmodule.exports = function list(state, startLine, endLine, silent) {\n  var ch,\n      contentStart,\n      i,\n      indent,\n      indentAfterMarker,\n      initial,\n      isOrdered,\n      itemLines,\n      l,\n      listLines,\n      listTokIdx,\n      markerCharCode,\n      markerValue,\n      max,\n      nextLine,\n      offset,\n      oldListIndent,\n      oldParentType,\n      oldSCount,\n      oldTShift,\n      oldTight,\n      pos,\n      posAfterMarker,\n      prevEmptyEnd,\n      start,\n      terminate,\n      terminatorRules,\n      token,\n      isTerminatingParagraph = false,\n      tight = true; // if it's indented more than 3 spaces, it should be a code block\n\n  if (state.sCount[startLine] - state.blkIndent >= 4) {\n    return false;\n  } // Special case:\n  //  - item 1\n  //   - item 2\n  //    - item 3\n  //     - item 4\n  //      - this one is a paragraph continuation\n\n\n  if (state.listIndent >= 0 && state.sCount[startLine] - state.listIndent >= 4 && state.sCount[startLine] < state.blkIndent) {\n    return false;\n  } // limit conditions when list can interrupt\n  // a paragraph (validation mode only)\n\n\n  if (silent && state.parentType === 'paragraph') {\n    // Next list item should still terminate previous list item;\n    //\n    // This code can fail if plugins use blkIndent as well as lists,\n    // but I hope the spec gets fixed long before that happens.\n    //\n    if (state.tShift[startLine] >= state.blkIndent) {\n      isTerminatingParagraph = true;\n    }\n  } // Detect list type and position after marker\n\n\n  if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {\n    isOrdered = true;\n    start = state.bMarks[startLine] + state.tShift[startLine];\n    markerValue = Number(state.src.substr(start, posAfterMarker - start - 1)); // If we're starting a new ordered list right after\n    // a paragraph, it should start with 1.\n\n    if (isTerminatingParagraph && markerValue !== 1) return false;\n  } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {\n    isOrdered = false;\n  } else {\n    return false;\n  } // If we're starting a new unordered list right after\n  // a paragraph, first line should not be empty.\n\n\n  if (isTerminatingParagraph) {\n    if (state.skipSpaces(posAfterMarker) >= state.eMarks[startLine]) return false;\n  } // We should terminate list on style change. Remember first one to compare.\n\n\n  markerCharCode = state.src.charCodeAt(posAfterMarker - 1); // For validation mode we can terminate immediately\n\n  if (silent) {\n    return true;\n  } // Start list\n\n\n  listTokIdx = state.tokens.length;\n\n  if (isOrdered) {\n    token = state.push('ordered_list_open', 'ol', 1);\n\n    if (markerValue !== 1) {\n      token.attrs = [['start', markerValue]];\n    }\n  } else {\n    token = state.push('bullet_list_open', 'ul', 1);\n  }\n\n  token.map = listLines = [startLine, 0];\n  token.markup = String.fromCharCode(markerCharCode); //\n  // Iterate list items\n  //\n\n  nextLine = startLine;\n  prevEmptyEnd = false;\n  terminatorRules = state.md.block.ruler.getRules('list');\n  oldParentType = state.parentType;\n  state.parentType = 'list';\n\n  while (nextLine < endLine) {\n    pos = posAfterMarker;\n    max = state.eMarks[nextLine];\n    initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);\n\n    while (pos < max) {\n      ch = state.src.charCodeAt(pos);\n\n      if (ch === 0x09) {\n        offset += 4 - (offset + state.bsCount[nextLine]) % 4;\n      } else if (ch === 0x20) {\n        offset++;\n      } else {\n        break;\n      }\n\n      pos++;\n    }\n\n    contentStart = pos;\n\n    if (contentStart >= max) {\n      // trimming space in \"-    \\n  3\" case, indent is 1 here\n      indentAfterMarker = 1;\n    } else {\n      indentAfterMarker = offset - initial;\n    } // If we have more than 4 spaces, the indent is 1\n    // (the rest is just indented code block)\n\n\n    if (indentAfterMarker > 4) {\n      indentAfterMarker = 1;\n    } // \"  -  test\"\n    //  ^^^^^ - calculating total length of this thing\n\n\n    indent = initial + indentAfterMarker; // Run subparser & write tokens\n\n    token = state.push('list_item_open', 'li', 1);\n    token.markup = String.fromCharCode(markerCharCode);\n    token.map = itemLines = [startLine, 0]; // change current state, then restore it after parser subcall\n\n    oldTight = state.tight;\n    oldTShift = state.tShift[startLine];\n    oldSCount = state.sCount[startLine]; //  - example list\n    // ^ listIndent position will be here\n    //   ^ blkIndent position will be here\n    //\n\n    oldListIndent = state.listIndent;\n    state.listIndent = state.blkIndent;\n    state.blkIndent = indent;\n    state.tight = true;\n    state.tShift[startLine] = contentStart - state.bMarks[startLine];\n    state.sCount[startLine] = offset;\n\n    if (contentStart >= max && state.isEmpty(startLine + 1)) {\n      // workaround for this case\n      // (list item is empty, list terminates before \"foo\"):\n      // ~~~~~~~~\n      //   -\n      //\n      //     foo\n      // ~~~~~~~~\n      state.line = Math.min(state.line + 2, endLine);\n    } else {\n      state.md.block.tokenize(state, startLine, endLine, true);\n    } // If any of list item is tight, mark list as tight\n\n\n    if (!state.tight || prevEmptyEnd) {\n      tight = false;\n    } // Item become loose if finish with empty line,\n    // but we should filter last element, because it means list finish\n\n\n    prevEmptyEnd = state.line - startLine > 1 && state.isEmpty(state.line - 1);\n    state.blkIndent = state.listIndent;\n    state.listIndent = oldListIndent;\n    state.tShift[startLine] = oldTShift;\n    state.sCount[startLine] = oldSCount;\n    state.tight = oldTight;\n    token = state.push('list_item_close', 'li', -1);\n    token.markup = String.fromCharCode(markerCharCode);\n    nextLine = startLine = state.line;\n    itemLines[1] = nextLine;\n    contentStart = state.bMarks[startLine];\n\n    if (nextLine >= endLine) {\n      break;\n    } //\n    // Try to check if list is terminated or continued.\n    //\n\n\n    if (state.sCount[nextLine] < state.blkIndent) {\n      break;\n    } // if it's indented more than 3 spaces, it should be a code block\n\n\n    if (state.sCount[startLine] - state.blkIndent >= 4) {\n      break;\n    } // fail if terminating block found\n\n\n    terminate = false;\n\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n\n    if (terminate) {\n      break;\n    } // fail if list has another type\n\n\n    if (isOrdered) {\n      posAfterMarker = skipOrderedListMarker(state, nextLine);\n\n      if (posAfterMarker < 0) {\n        break;\n      }\n    } else {\n      posAfterMarker = skipBulletListMarker(state, nextLine);\n\n      if (posAfterMarker < 0) {\n        break;\n      }\n    }\n\n    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {\n      break;\n    }\n  } // Finalize list\n\n\n  if (isOrdered) {\n    token = state.push('ordered_list_close', 'ol', -1);\n  } else {\n    token = state.push('bullet_list_close', 'ul', -1);\n  }\n\n  token.markup = String.fromCharCode(markerCharCode);\n  listLines[1] = nextLine;\n  state.line = nextLine;\n  state.parentType = oldParentType; // mark paragraphs tight if needed\n\n  if (tight) {\n    markTightParagraphs(state, listTokIdx);\n  }\n\n  return true;\n};","map":null,"metadata":{},"sourceType":"module"}