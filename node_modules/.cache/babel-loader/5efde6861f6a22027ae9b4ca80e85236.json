{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { SentryError, SyncPromise } from '@sentry/utils';\nimport { BaseTransport } from './base';\n/** `XHR` based transport */\n\nvar XHRTransport =\n/** @class */\nfunction (_super) {\n  __extends(XHRTransport, _super);\n\n  function XHRTransport() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * @param sentryRequest Prepared SentryRequest to be delivered\n   * @param originalPayload Original payload used to create SentryRequest\n   */\n\n\n  XHRTransport.prototype._sendRequest = function (sentryRequest, originalPayload) {\n    var _this = this; // eslint-disable-next-line deprecation/deprecation\n\n\n    if (this._isRateLimited(sentryRequest.type)) {\n      this.recordLostEvent('ratelimit_backoff', sentryRequest.type);\n      return Promise.reject({\n        event: originalPayload,\n        type: sentryRequest.type,\n        // eslint-disable-next-line deprecation/deprecation\n        reason: \"Transport for \" + sentryRequest.type + \" requests locked till \" + this._disabledUntil(sentryRequest.type) + \" due to too many requests.\",\n        status: 429\n      });\n    }\n\n    return this._buffer.add(function () {\n      return new SyncPromise(function (resolve, reject) {\n        var request = new XMLHttpRequest();\n\n        request.onreadystatechange = function () {\n          if (request.readyState === 4) {\n            var headers = {\n              'x-sentry-rate-limits': request.getResponseHeader('X-Sentry-Rate-Limits'),\n              'retry-after': request.getResponseHeader('Retry-After')\n            };\n\n            _this._handleResponse({\n              requestType: sentryRequest.type,\n              response: request,\n              headers: headers,\n              resolve: resolve,\n              reject: reject\n            });\n          }\n        };\n\n        request.open('POST', sentryRequest.url);\n\n        for (var header in _this.options.headers) {\n          if (Object.prototype.hasOwnProperty.call(_this.options.headers, header)) {\n            request.setRequestHeader(header, _this.options.headers[header]);\n          }\n        }\n\n        request.send(sentryRequest.body);\n      });\n    }).then(undefined, function (reason) {\n      // It's either buffer rejection or any other xhr/fetch error, which are treated as NetworkError.\n      if (reason instanceof SentryError) {\n        _this.recordLostEvent('queue_overflow', sentryRequest.type);\n      } else {\n        _this.recordLostEvent('network_error', sentryRequest.type);\n      }\n\n      throw reason;\n    });\n  };\n\n  return XHRTransport;\n}(BaseTransport);\n\nexport { XHRTransport };","map":null,"metadata":{},"sourceType":"module"}