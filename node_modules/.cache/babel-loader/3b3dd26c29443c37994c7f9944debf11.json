{"ast":null,"code":"import { Plugin } from 'prosemirror-state';\nimport { findWrapping, canJoin } from 'prosemirror-transform'; // ::- Input rules are regular expressions describing a piece of text\n// that, when typed, causes something to happen. This might be\n// changing two dashes into an emdash, wrapping a paragraph starting\n// with `\"> \"` into a blockquote, or something entirely different.\n\nvar InputRule = function InputRule(match, handler) {\n  this.match = match;\n  this.handler = typeof handler == \"string\" ? stringHandler(handler) : handler;\n};\n\nfunction stringHandler(string) {\n  return function (state, match, start, end) {\n    var insert = string;\n\n    if (match[1]) {\n      var offset = match[0].lastIndexOf(match[1]);\n      insert += match[0].slice(offset + match[1].length);\n      start += offset;\n      var cutOff = start - end;\n\n      if (cutOff > 0) {\n        insert = match[0].slice(offset - cutOff, offset) + insert;\n        start = end;\n      }\n    }\n\n    return state.tr.insertText(insert, start, end);\n  };\n}\n\nvar MAX_MATCH = 500; // :: (config: {rules: [InputRule]}) → Plugin\n// Create an input rules plugin. When enabled, it will cause text\n// input that matches any of the given rules to trigger the rule's\n// action.\n\nfunction inputRules(ref) {\n  var rules = ref.rules;\n  var plugin = new Plugin({\n    state: {\n      init: function init() {\n        return null;\n      },\n      apply: function apply(tr, prev) {\n        var stored = tr.getMeta(this);\n\n        if (stored) {\n          return stored;\n        }\n\n        return tr.selectionSet || tr.docChanged ? null : prev;\n      }\n    },\n    props: {\n      handleTextInput: function handleTextInput(view, from, to, text) {\n        return run(view, from, to, text, rules, plugin);\n      },\n      handleDOMEvents: {\n        compositionend: function compositionend(view) {\n          setTimeout(function () {\n            var ref = view.state.selection;\n            var $cursor = ref.$cursor;\n\n            if ($cursor) {\n              run(view, $cursor.pos, $cursor.pos, \"\", rules, plugin);\n            }\n          });\n        }\n      }\n    },\n    isInputRules: true\n  });\n  return plugin;\n}\n\nfunction run(view, from, to, text, rules, plugin) {\n  if (view.composing) {\n    return false;\n  }\n\n  var state = view.state,\n      $from = state.doc.resolve(from);\n\n  if ($from.parent.type.spec.code) {\n    return false;\n  }\n\n  var textBefore = $from.parent.textBetween(Math.max(0, $from.parentOffset - MAX_MATCH), $from.parentOffset, null, \"\\uFFFC\") + text;\n\n  for (var i = 0; i < rules.length; i++) {\n    var match = rules[i].match.exec(textBefore);\n    var tr = match && rules[i].handler(state, match, from - (match[0].length - text.length), to);\n\n    if (!tr) {\n      continue;\n    }\n\n    view.dispatch(tr.setMeta(plugin, {\n      transform: tr,\n      from: from,\n      to: to,\n      text: text\n    }));\n    return true;\n  }\n\n  return false;\n} // :: (EditorState, ?(Transaction)) → bool\n// This is a command that will undo an input rule, if applying such a\n// rule was the last thing that the user did.\n\n\nfunction undoInputRule(state, dispatch) {\n  var plugins = state.plugins;\n\n  for (var i = 0; i < plugins.length; i++) {\n    var plugin = plugins[i],\n        undoable = void 0;\n\n    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {\n      if (dispatch) {\n        var tr = state.tr,\n            toUndo = undoable.transform;\n\n        for (var j = toUndo.steps.length - 1; j >= 0; j--) {\n          tr.step(toUndo.steps[j].invert(toUndo.docs[j]));\n        }\n\n        if (undoable.text) {\n          var marks = tr.doc.resolve(undoable.from).marks();\n          tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));\n        } else {\n          tr.delete(undoable.from, undoable.to);\n        }\n\n        dispatch(tr);\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n} // :: InputRule Converts double dashes to an emdash.\n\n\nvar emDash = new InputRule(/--$/, \"—\"); // :: InputRule Converts three dots to an ellipsis character.\n\nvar ellipsis = new InputRule(/\\.\\.\\.$/, \"…\"); // :: InputRule “Smart” opening double quotes.\n\nvar openDoubleQuote = new InputRule(/(?:^|[\\s\\{\\[\\(\\<'\"\\u2018\\u201C])(\")$/, \"“\"); // :: InputRule “Smart” closing double quotes.\n\nvar closeDoubleQuote = new InputRule(/\"$/, \"”\"); // :: InputRule “Smart” opening single quotes.\n\nvar openSingleQuote = new InputRule(/(?:^|[\\s\\{\\[\\(\\<'\"\\u2018\\u201C])(')$/, \"‘\"); // :: InputRule “Smart” closing single quotes.\n\nvar closeSingleQuote = new InputRule(/'$/, \"’\"); // :: [InputRule] Smart-quote related input rules.\n\nvar smartQuotes = [openDoubleQuote, closeDoubleQuote, openSingleQuote, closeSingleQuote]; // :: (RegExp, NodeType, ?union<Object, ([string]) → ?Object>, ?([string], Node) → bool) → InputRule\n// Build an input rule for automatically wrapping a textblock when a\n// given string is typed. The `regexp` argument is\n// directly passed through to the `InputRule` constructor. You'll\n// probably want the regexp to start with `^`, so that the pattern can\n// only occur at the start of a textblock.\n//\n// `nodeType` is the type of node to wrap in. If it needs attributes,\n// you can either pass them directly, or pass a function that will\n// compute them from the regular expression match.\n//\n// By default, if there's a node with the same type above the newly\n// wrapped node, the rule will try to [join](#transform.Transform.join) those\n// two nodes. You can pass a join predicate, which takes a regular\n// expression match and the node before the wrapped node, and can\n// return a boolean to indicate whether a join should happen.\n\nfunction wrappingInputRule(regexp, nodeType, getAttrs, joinPredicate) {\n  return new InputRule(regexp, function (state, match, start, end) {\n    var attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;\n    var tr = state.tr.delete(start, end);\n    var $start = tr.doc.resolve(start),\n        range = $start.blockRange(),\n        wrapping = range && findWrapping(range, nodeType, attrs);\n\n    if (!wrapping) {\n      return null;\n    }\n\n    tr.wrap(range, wrapping);\n    var before = tr.doc.resolve(start - 1).nodeBefore;\n\n    if (before && before.type == nodeType && canJoin(tr.doc, start - 1) && (!joinPredicate || joinPredicate(match, before))) {\n      tr.join(start - 1);\n    }\n\n    return tr;\n  });\n} // :: (RegExp, NodeType, ?union<Object, ([string]) → ?Object>) → InputRule\n// Build an input rule that changes the type of a textblock when the\n// matched text is typed into it. You'll usually want to start your\n// regexp with `^` to that it is only matched at the start of a\n// textblock. The optional `getAttrs` parameter can be used to compute\n// the new node's attributes, and works the same as in the\n// `wrappingInputRule` function.\n\n\nfunction textblockTypeInputRule(regexp, nodeType, getAttrs) {\n  return new InputRule(regexp, function (state, match, start, end) {\n    var $start = state.doc.resolve(start);\n    var attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;\n\n    if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), nodeType)) {\n      return null;\n    }\n\n    return state.tr.delete(start, end).setBlockType(start, start, nodeType, attrs);\n  });\n}\n\nexport { InputRule, closeDoubleQuote, closeSingleQuote, ellipsis, emDash, inputRules, openDoubleQuote, openSingleQuote, smartQuotes, textblockTypeInputRule, undoInputRule, wrappingInputRule };","map":null,"metadata":{},"sourceType":"module"}