{"ast":null,"code":"/* eslint-disable @typescript-eslint/explicit-function-return-type */\n\n/* eslint-disable @typescript-eslint/typedef */\n\n/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { isThenable } from './is';\n/**\n * Creates a resolved sync promise.\n *\n * @param value the value to resolve the promise with\n * @returns the resolved sync promise\n */\n\nexport function resolvedSyncPromise(value) {\n  return new SyncPromise(function (resolve) {\n    resolve(value);\n  });\n}\n/**\n * Creates a rejected sync promise.\n *\n * @param value the value to reject the promise with\n * @returns the rejected sync promise\n */\n\nexport function rejectedSyncPromise(reason) {\n  return new SyncPromise(function (_, reject) {\n    reject(reason);\n  });\n}\n/**\n * Thenable class that behaves like a Promise and follows it's interface\n * but is not async internally\n */\n\nvar SyncPromise =\n/** @class */\nfunction () {\n  function SyncPromise(executor) {\n    var _this = this;\n\n    this._state = 0\n    /* PENDING */\n    ;\n    this._handlers = [];\n    /** JSDoc */\n\n    this._resolve = function (value) {\n      _this._setResult(1\n      /* RESOLVED */\n      , value);\n    };\n    /** JSDoc */\n\n\n    this._reject = function (reason) {\n      _this._setResult(2\n      /* REJECTED */\n      , reason);\n    };\n    /** JSDoc */\n\n\n    this._setResult = function (state, value) {\n      if (_this._state !== 0\n      /* PENDING */\n      ) {\n          return;\n        }\n\n      if (isThenable(value)) {\n        void value.then(_this._resolve, _this._reject);\n        return;\n      }\n\n      _this._state = state;\n      _this._value = value;\n\n      _this._executeHandlers();\n    };\n    /** JSDoc */\n\n\n    this._executeHandlers = function () {\n      if (_this._state === 0\n      /* PENDING */\n      ) {\n          return;\n        }\n\n      var cachedHandlers = _this._handlers.slice();\n\n      _this._handlers = [];\n      cachedHandlers.forEach(function (handler) {\n        if (handler[0]) {\n          return;\n        }\n\n        if (_this._state === 1\n        /* RESOLVED */\n        ) {\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            handler[1](_this._value);\n          }\n\n        if (_this._state === 2\n        /* REJECTED */\n        ) {\n            handler[2](_this._value);\n          }\n\n        handler[0] = true;\n      });\n    };\n\n    try {\n      executor(this._resolve, this._reject);\n    } catch (e) {\n      this._reject(e);\n    }\n  }\n  /** JSDoc */\n\n\n  SyncPromise.prototype.then = function (onfulfilled, onrejected) {\n    var _this = this;\n\n    return new SyncPromise(function (resolve, reject) {\n      _this._handlers.push([false, function (result) {\n        if (!onfulfilled) {\n          // TODO: ¯\\_(ツ)_/¯\n          // TODO: FIXME\n          resolve(result);\n        } else {\n          try {\n            resolve(onfulfilled(result));\n          } catch (e) {\n            reject(e);\n          }\n        }\n      }, function (reason) {\n        if (!onrejected) {\n          reject(reason);\n        } else {\n          try {\n            resolve(onrejected(reason));\n          } catch (e) {\n            reject(e);\n          }\n        }\n      }]);\n\n      _this._executeHandlers();\n    });\n  };\n  /** JSDoc */\n\n\n  SyncPromise.prototype.catch = function (onrejected) {\n    return this.then(function (val) {\n      return val;\n    }, onrejected);\n  };\n  /** JSDoc */\n\n\n  SyncPromise.prototype.finally = function (onfinally) {\n    var _this = this;\n\n    return new SyncPromise(function (resolve, reject) {\n      var val;\n      var isRejected;\n      return _this.then(function (value) {\n        isRejected = false;\n        val = value;\n\n        if (onfinally) {\n          onfinally();\n        }\n      }, function (reason) {\n        isRejected = true;\n        val = reason;\n\n        if (onfinally) {\n          onfinally();\n        }\n      }).then(function () {\n        if (isRejected) {\n          reject(val);\n          return;\n        }\n\n        resolve(val);\n      });\n    });\n  };\n\n  return SyncPromise;\n}();\n\nexport { SyncPromise };","map":null,"metadata":{},"sourceType":"module"}