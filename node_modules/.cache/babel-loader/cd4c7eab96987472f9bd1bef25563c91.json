{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar ANY = Symbol('SemVer ANY'); // hoisted class for cyclic dependency\n\nvar Comparator = /*#__PURE__*/function () {\n  function Comparator(comp, options) {\n    _classCallCheck(this, Comparator);\n\n    options = parseOptions(options);\n\n    if (comp instanceof Comparator) {\n      if (comp.loose === !!options.loose) {\n        return comp;\n      } else {\n        comp = comp.value;\n      }\n    }\n\n    debug('comparator', comp, options);\n    this.options = options;\n    this.loose = !!options.loose;\n    this.parse(comp);\n\n    if (this.semver === ANY) {\n      this.value = '';\n    } else {\n      this.value = this.operator + this.semver.version;\n    }\n\n    debug('comp', this);\n  }\n\n  _createClass(Comparator, [{\n    key: \"parse\",\n    value: function parse(comp) {\n      var r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];\n      var m = comp.match(r);\n\n      if (!m) {\n        throw new TypeError(\"Invalid comparator: \".concat(comp));\n      }\n\n      this.operator = m[1] !== undefined ? m[1] : '';\n\n      if (this.operator === '=') {\n        this.operator = '';\n      } // if it literally is just '>' or '' then allow anything.\n\n\n      if (!m[2]) {\n        this.semver = ANY;\n      } else {\n        this.semver = new SemVer(m[2], this.options.loose);\n      }\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.value;\n    }\n  }, {\n    key: \"test\",\n    value: function test(version) {\n      debug('Comparator.test', version, this.options.loose);\n\n      if (this.semver === ANY || version === ANY) {\n        return true;\n      }\n\n      if (typeof version === 'string') {\n        try {\n          version = new SemVer(version, this.options);\n        } catch (er) {\n          return false;\n        }\n      }\n\n      return cmp(version, this.operator, this.semver, this.options);\n    }\n  }, {\n    key: \"intersects\",\n    value: function intersects(comp, options) {\n      if (!(comp instanceof Comparator)) {\n        throw new TypeError('a Comparator is required');\n      }\n\n      if (!options || _typeof(options) !== 'object') {\n        options = {\n          loose: !!options,\n          includePrerelease: false\n        };\n      }\n\n      if (this.operator === '') {\n        if (this.value === '') {\n          return true;\n        }\n\n        return new Range(comp.value, options).test(this.value);\n      } else if (comp.operator === '') {\n        if (comp.value === '') {\n          return true;\n        }\n\n        return new Range(this.value, options).test(comp.semver);\n      }\n\n      var sameDirectionIncreasing = (this.operator === '>=' || this.operator === '>') && (comp.operator === '>=' || comp.operator === '>');\n      var sameDirectionDecreasing = (this.operator === '<=' || this.operator === '<') && (comp.operator === '<=' || comp.operator === '<');\n      var sameSemVer = this.semver.version === comp.semver.version;\n      var differentDirectionsInclusive = (this.operator === '>=' || this.operator === '<=') && (comp.operator === '>=' || comp.operator === '<=');\n      var oppositeDirectionsLessThan = cmp(this.semver, '<', comp.semver, options) && (this.operator === '>=' || this.operator === '>') && (comp.operator === '<=' || comp.operator === '<');\n      var oppositeDirectionsGreaterThan = cmp(this.semver, '>', comp.semver, options) && (this.operator === '<=' || this.operator === '<') && (comp.operator === '>=' || comp.operator === '>');\n      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;\n    }\n  }], [{\n    key: \"ANY\",\n    get: function get() {\n      return ANY;\n    }\n  }]);\n\n  return Comparator;\n}();\n\nmodule.exports = Comparator;\n\nvar parseOptions = require('../internal/parse-options');\n\nvar _require = require('../internal/re'),\n    re = _require.re,\n    t = _require.t;\n\nvar cmp = require('../functions/cmp');\n\nvar debug = require('../internal/debug');\n\nvar SemVer = require('./semver');\n\nvar Range = require('./range');","map":null,"metadata":{},"sourceType":"module"}