{"version":3,"file":"index.js","sources":["../src/map.js","../src/transform.js","../src/step.js","../src/replace_step.js","../src/structure.js","../src/mark_step.js","../src/mark.js","../src/replace.js"],"sourcesContent":["// Mappable:: interface\n// There are several things that positions can be mapped through.\n// Such objects conform to this interface.\n//\n//   map:: (pos: number, assoc: ?number) → number\n//   Map a position through this object. When given, `assoc` (should\n//   be -1 or 1, defaults to 1) determines with which side the\n//   position is associated, which determines in which direction to\n//   move when a chunk of content is inserted at the mapped position.\n//\n//   mapResult:: (pos: number, assoc: ?number) → MapResult\n//   Map a position, and return an object containing additional\n//   information about the mapping. The result's `deleted` field tells\n//   you whether the position was deleted (completely enclosed in a\n//   replaced range) during the mapping. When content on only one side\n//   is deleted, the position itself is only considered deleted when\n//   `assoc` points in the direction of the deleted content.\n\n// Recovery values encode a range index and an offset. They are\n// represented as numbers, because tons of them will be created when\n// mapping, for example, a large number of decorations. The number's\n// lower 16 bits provide the index, the remaining bits the offset.\n//\n// Note: We intentionally don't use bit shift operators to en- and\n// decode these, since those clip to 32 bits, which we might in rare\n// cases want to overflow. A 64-bit float can represent 48-bit\n// integers precisely.\n\nconst lower16 = 0xffff\nconst factor16 = Math.pow(2, 16)\n\nfunction makeRecover(index, offset) { return index + offset * factor16 }\nfunction recoverIndex(value) { return value & lower16 }\nfunction recoverOffset(value) { return (value - (value & lower16)) / factor16 }\n\n// ::- An object representing a mapped position with extra\n// information.\nexport class MapResult {\n  constructor(pos, deleted = false, recover = null) {\n    // :: number The mapped version of the position.\n    this.pos = pos\n    // :: bool Tells you whether the position was deleted, that is,\n    // whether the step removed its surroundings from the document.\n    this.deleted = deleted\n    this.recover = recover\n  }\n}\n\n// :: class extends Mappable\n// A map describing the deletions and insertions made by a step, which\n// can be used to find the correspondence between positions in the\n// pre-step version of a document and the same position in the\n// post-step version.\nexport class StepMap {\n  // :: ([number])\n  // Create a position map. The modifications to the document are\n  // represented as an array of numbers, in which each group of three\n  // represents a modified chunk as `[start, oldSize, newSize]`.\n  constructor(ranges, inverted = false) {\n    this.ranges = ranges\n    this.inverted = inverted\n  }\n\n  recover(value) {\n    let diff = 0, index = recoverIndex(value)\n    if (!this.inverted) for (let i = 0; i < index; i++)\n      diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1]\n    return this.ranges[index * 3] + diff + recoverOffset(value)\n  }\n\n  // : (number, ?number) → MapResult\n  mapResult(pos, assoc = 1) { return this._map(pos, assoc, false) }\n\n  // : (number, ?number) → number\n  map(pos, assoc = 1) { return this._map(pos, assoc, true) }\n\n  _map(pos, assoc, simple) {\n    let diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2\n    for (let i = 0; i < this.ranges.length; i += 3) {\n      let start = this.ranges[i] - (this.inverted ? diff : 0)\n      if (start > pos) break\n      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end = start + oldSize\n      if (pos <= end) {\n        let side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc\n        let result = start + diff + (side < 0 ? 0 : newSize)\n        if (simple) return result\n        let recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i / 3, pos - start)\n        return new MapResult(result, assoc < 0 ? pos != start : pos != end, recover)\n      }\n      diff += newSize - oldSize\n    }\n    return simple ? pos + diff : new MapResult(pos + diff)\n  }\n\n  touches(pos, recover) {\n    let diff = 0, index = recoverIndex(recover)\n    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2\n    for (let i = 0; i < this.ranges.length; i += 3) {\n      let start = this.ranges[i] - (this.inverted ? diff : 0)\n      if (start > pos) break\n      let oldSize = this.ranges[i + oldIndex], end = start + oldSize\n      if (pos <= end && i == index * 3) return true\n      diff += this.ranges[i + newIndex] - oldSize\n    }\n    return false\n  }\n\n  // :: ((oldStart: number, oldEnd: number, newStart: number, newEnd: number))\n  // Calls the given function on each of the changed ranges included in\n  // this map.\n  forEach(f) {\n    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2\n    for (let i = 0, diff = 0; i < this.ranges.length; i += 3) {\n      let start = this.ranges[i], oldStart = start - (this.inverted ? diff : 0), newStart = start + (this.inverted ? 0 : diff)\n      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex]\n      f(oldStart, oldStart + oldSize, newStart, newStart + newSize)\n      diff += newSize - oldSize\n    }\n  }\n\n  // :: () → StepMap\n  // Create an inverted version of this map. The result can be used to\n  // map positions in the post-step document to the pre-step document.\n  invert() {\n    return new StepMap(this.ranges, !this.inverted)\n  }\n\n  toString() {\n    return (this.inverted ? \"-\" : \"\") + JSON.stringify(this.ranges)\n  }\n\n  // :: (n: number) → StepMap\n  // Create a map that moves all positions by offset `n` (which may be\n  // negative). This can be useful when applying steps meant for a\n  // sub-document to a larger document, or vice-versa.\n  static offset(n) {\n    return n == 0 ? StepMap.empty : new StepMap(n < 0 ? [0, -n, 0] : [0, 0, n])\n  }\n}\n\nStepMap.empty = new StepMap([])\n\n// :: class extends Mappable\n// A mapping represents a pipeline of zero or more [step\n// maps](#transform.StepMap). It has special provisions for losslessly\n// handling mapping positions through a series of steps in which some\n// steps are inverted versions of earlier steps. (This comes up when\n// ‘[rebasing](/docs/guide/#transform.rebasing)’ steps for\n// collaboration or history management.)\nexport class Mapping {\n  // :: (?[StepMap])\n  // Create a new mapping with the given position maps.\n  constructor(maps, mirror, from, to) {\n    // :: [StepMap]\n    // The step maps in this mapping.\n    this.maps = maps || []\n    // :: number\n    // The starting position in the `maps` array, used when `map` or\n    // `mapResult` is called.\n    this.from = from || 0\n    // :: number\n    // The end position in the `maps` array.\n    this.to = to == null ? this.maps.length : to\n    this.mirror = mirror\n  }\n\n  // :: (?number, ?number) → Mapping\n  // Create a mapping that maps only through a part of this one.\n  slice(from = 0, to = this.maps.length) {\n    return new Mapping(this.maps, this.mirror, from, to)\n  }\n\n  copy() {\n    return new Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to)\n  }\n\n  // :: (StepMap, ?number)\n  // Add a step map to the end of this mapping. If `mirrors` is\n  // given, it should be the index of the step map that is the mirror\n  // image of this one.\n  appendMap(map, mirrors) {\n    this.to = this.maps.push(map)\n    if (mirrors != null) this.setMirror(this.maps.length - 1, mirrors)\n  }\n\n  // :: (Mapping)\n  // Add all the step maps in a given mapping to this one (preserving\n  // mirroring information).\n  appendMapping(mapping) {\n    for (let i = 0, startSize = this.maps.length; i < mapping.maps.length; i++) {\n      let mirr = mapping.getMirror(i)\n      this.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : null)\n    }\n  }\n\n  // :: (number) → ?number\n  // Finds the offset of the step map that mirrors the map at the\n  // given offset, in this mapping (as per the second argument to\n  // `appendMap`).\n  getMirror(n) {\n    if (this.mirror) for (let i = 0; i < this.mirror.length; i++)\n      if (this.mirror[i] == n) return this.mirror[i + (i % 2 ? -1 : 1)]\n  }\n\n  setMirror(n, m) {\n    if (!this.mirror) this.mirror = []\n    this.mirror.push(n, m)\n  }\n\n  // :: (Mapping)\n  // Append the inverse of the given mapping to this one.\n  appendMappingInverted(mapping) {\n    for (let i = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i >= 0; i--) {\n      let mirr = mapping.getMirror(i)\n      this.appendMap(mapping.maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : null)\n    }\n  }\n\n  // :: () → Mapping\n  // Create an inverted version of this mapping.\n  invert() {\n    let inverse = new Mapping\n    inverse.appendMappingInverted(this)\n    return inverse\n  }\n\n  // : (number, ?number) → number\n  // Map a position through this mapping.\n  map(pos, assoc = 1) {\n    if (this.mirror) return this._map(pos, assoc, true)\n    for (let i = this.from; i < this.to; i++)\n      pos = this.maps[i].map(pos, assoc)\n    return pos\n  }\n\n  // : (number, ?number) → MapResult\n  // Map a position through this mapping, returning a mapping\n  // result.\n  mapResult(pos, assoc = 1) { return this._map(pos, assoc, false) }\n\n  _map(pos, assoc, simple) {\n    let deleted = false\n\n    for (let i = this.from; i < this.to; i++) {\n      let map = this.maps[i], result = map.mapResult(pos, assoc)\n      if (result.recover != null) {\n        let corr = this.getMirror(i)\n        if (corr != null && corr > i && corr < this.to) {\n          i = corr\n          pos = this.maps[corr].recover(result.recover)\n          continue\n        }\n      }\n\n      if (result.deleted) deleted = true\n      pos = result.pos\n    }\n\n    return simple ? pos : new MapResult(pos, deleted)\n  }\n}\n","import {Mapping} from \"./map\"\n\nexport function TransformError(message) {\n  let err = Error.call(this, message)\n  err.__proto__ = TransformError.prototype\n  return err\n}\n\nTransformError.prototype = Object.create(Error.prototype)\nTransformError.prototype.constructor = TransformError\nTransformError.prototype.name = \"TransformError\"\n\n// ::- Abstraction to build up and track an array of\n// [steps](#transform.Step) representing a document transformation.\n//\n// Most transforming methods return the `Transform` object itself, so\n// that they can be chained.\nexport class Transform {\n  // :: (Node)\n  // Create a transform that starts with the given document.\n  constructor(doc) {\n    // :: Node\n    // The current document (the result of applying the steps in the\n    // transform).\n    this.doc = doc\n    // :: [Step]\n    // The steps in this transform.\n    this.steps = []\n    // :: [Node]\n    // The documents before each of the steps.\n    this.docs = []\n    // :: Mapping\n    // A mapping with the maps for each of the steps in this transform.\n    this.mapping = new Mapping\n  }\n\n  // :: Node The starting document.\n  get before() { return this.docs.length ? this.docs[0] : this.doc }\n\n  // :: (step: Step) → this\n  // Apply a new step in this transform, saving the result. Throws an\n  // error when the step fails.\n  step(object) {\n    let result = this.maybeStep(object)\n    if (result.failed) throw new TransformError(result.failed)\n    return this\n  }\n\n  // :: (Step) → StepResult\n  // Try to apply a step in this transformation, ignoring it if it\n  // fails. Returns the step result.\n  maybeStep(step) {\n    let result = step.apply(this.doc)\n    if (!result.failed) this.addStep(step, result.doc)\n    return result\n  }\n\n  // :: bool\n  // True when the document has been changed (when there are any\n  // steps).\n  get docChanged() {\n    return this.steps.length > 0\n  }\n\n  addStep(step, doc) {\n    this.docs.push(this.doc)\n    this.steps.push(step)\n    this.mapping.appendMap(step.getMap())\n    this.doc = doc\n  }\n}\n","import {ReplaceError} from \"prosemirror-model\"\n\nimport {StepMap} from \"./map\"\n\nfunction mustOverride() { throw new Error(\"Override me\") }\n\nconst stepsByID = Object.create(null)\n\n// ::- A step object represents an atomic change. It generally applies\n// only to the document it was created for, since the positions\n// stored in it will only make sense for that document.\n//\n// New steps are defined by creating classes that extend `Step`,\n// overriding the `apply`, `invert`, `map`, `getMap` and `fromJSON`\n// methods, and registering your class with a unique\n// JSON-serialization identifier using\n// [`Step.jsonID`](#transform.Step^jsonID).\nexport class Step {\n  // :: (doc: Node) → StepResult\n  // Applies this step to the given document, returning a result\n  // object that either indicates failure, if the step can not be\n  // applied to this document, or indicates success by containing a\n  // transformed document.\n  apply(_doc) { return mustOverride() }\n\n  // :: () → StepMap\n  // Get the step map that represents the changes made by this step,\n  // and which can be used to transform between positions in the old\n  // and the new document.\n  getMap() { return StepMap.empty }\n\n  // :: (doc: Node) → Step\n  // Create an inverted version of this step. Needs the document as it\n  // was before the step as argument.\n  invert(_doc) { return mustOverride() }\n\n  // :: (mapping: Mappable) → ?Step\n  // Map this step through a mappable thing, returning either a\n  // version of that step with its positions adjusted, or `null` if\n  // the step was entirely deleted by the mapping.\n  map(_mapping) { return mustOverride() }\n\n  // :: (other: Step) → ?Step\n  // Try to merge this step with another one, to be applied directly\n  // after it. Returns the merged step when possible, null if the\n  // steps can't be merged.\n  merge(_other) { return null }\n\n  // :: () → Object\n  // Create a JSON-serializeable representation of this step. When\n  // defining this for a custom subclass, make sure the result object\n  // includes the step type's [JSON id](#transform.Step^jsonID) under\n  // the `stepType` property.\n  toJSON() { return mustOverride() }\n\n  // :: (Schema, Object) → Step\n  // Deserialize a step from its JSON representation. Will call\n  // through to the step class' own implementation of this method.\n  static fromJSON(schema, json) {\n    if (!json || !json.stepType) throw new RangeError(\"Invalid input for Step.fromJSON\")\n    let type = stepsByID[json.stepType]\n    if (!type) throw new RangeError(`No step type ${json.stepType} defined`)\n    return type.fromJSON(schema, json)\n  }\n\n  // :: (string, constructor<Step>)\n  // To be able to serialize steps to JSON, each step needs a string\n  // ID to attach to its JSON representation. Use this method to\n  // register an ID for your step classes. Try to pick something\n  // that's unlikely to clash with steps from other modules.\n  static jsonID(id, stepClass) {\n    if (id in stepsByID) throw new RangeError(\"Duplicate use of step JSON ID \" + id)\n    stepsByID[id] = stepClass\n    stepClass.prototype.jsonID = id\n    return stepClass\n  }\n}\n\n// ::- The result of [applying](#transform.Step.apply) a step. Contains either a\n// new document or a failure value.\nexport class StepResult {\n  // : (?Node, ?string)\n  constructor(doc, failed) {\n    // :: ?Node The transformed document.\n    this.doc = doc\n    // :: ?string Text providing information about a failed step.\n    this.failed = failed\n  }\n\n  // :: (Node) → StepResult\n  // Create a successful step result.\n  static ok(doc) { return new StepResult(doc, null) }\n\n  // :: (string) → StepResult\n  // Create a failed step result.\n  static fail(message) { return new StepResult(null, message) }\n\n  // :: (Node, number, number, Slice) → StepResult\n  // Call [`Node.replace`](#model.Node.replace) with the given\n  // arguments. Create a successful result if it succeeds, and a\n  // failed one if it throws a `ReplaceError`.\n  static fromReplace(doc, from, to, slice) {\n    try {\n      return StepResult.ok(doc.replace(from, to, slice))\n    } catch (e) {\n      if (e instanceof ReplaceError) return StepResult.fail(e.message)\n      throw e\n    }\n  }\n}\n","import {Slice} from \"prosemirror-model\"\n\nimport {Step, StepResult} from \"./step\"\nimport {StepMap} from \"./map\"\n\n// ::- Replace a part of the document with a slice of new content.\nexport class ReplaceStep extends Step {\n  // :: (number, number, Slice, ?bool)\n  // The given `slice` should fit the 'gap' between `from` and\n  // `to`—the depths must line up, and the surrounding nodes must be\n  // able to be joined with the open sides of the slice. When\n  // `structure` is true, the step will fail if the content between\n  // from and to is not just a sequence of closing and then opening\n  // tokens (this is to guard against rebased replace steps\n  // overwriting something they weren't supposed to).\n  constructor(from, to, slice, structure) {\n    super()\n    // :: number\n    // The start position of the replaced range.\n    this.from = from\n    // :: number\n    // The end position of the replaced range.\n    this.to = to\n    // :: Slice\n    // The slice to insert.\n    this.slice = slice\n    this.structure = !!structure\n  }\n\n  apply(doc) {\n    if (this.structure && contentBetween(doc, this.from, this.to))\n      return StepResult.fail(\"Structure replace would overwrite content\")\n    return StepResult.fromReplace(doc, this.from, this.to, this.slice)\n  }\n\n  getMap() {\n    return new StepMap([this.from, this.to - this.from, this.slice.size])\n  }\n\n  invert(doc) {\n    return new ReplaceStep(this.from, this.from + this.slice.size, doc.slice(this.from, this.to))\n  }\n\n  map(mapping) {\n    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1)\n    if (from.deleted && to.deleted) return null\n    return new ReplaceStep(from.pos, Math.max(from.pos, to.pos), this.slice)\n  }\n\n  merge(other) {\n    if (!(other instanceof ReplaceStep) || other.structure || this.structure) return null\n\n    if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {\n      let slice = this.slice.size + other.slice.size == 0 ? Slice.empty\n          : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd)\n      return new ReplaceStep(this.from, this.to + (other.to - other.from), slice, this.structure)\n    } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {\n      let slice = this.slice.size + other.slice.size == 0 ? Slice.empty\n          : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd)\n      return new ReplaceStep(other.from, this.to, slice, this.structure)\n    } else {\n      return null\n    }\n  }\n\n  toJSON() {\n    let json = {stepType: \"replace\", from: this.from, to: this.to}\n    if (this.slice.size) json.slice = this.slice.toJSON()\n    if (this.structure) json.structure = true\n    return json\n  }\n\n  static fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\")\n      throw new RangeError(\"Invalid input for ReplaceStep.fromJSON\")\n    return new ReplaceStep(json.from, json.to, Slice.fromJSON(schema, json.slice), !!json.structure)\n  }\n}\n\nStep.jsonID(\"replace\", ReplaceStep)\n\n// ::- Replace a part of the document with a slice of content, but\n// preserve a range of the replaced content by moving it into the\n// slice.\nexport class ReplaceAroundStep extends Step {\n  // :: (number, number, number, number, Slice, number, ?bool)\n  // Create a replace-around step with the given range and gap.\n  // `insert` should be the point in the slice into which the content\n  // of the gap should be moved. `structure` has the same meaning as\n  // it has in the [`ReplaceStep`](#transform.ReplaceStep) class.\n  constructor(from, to, gapFrom, gapTo, slice, insert, structure) {\n    super()\n    // :: number\n    // The start position of the replaced range.\n    this.from = from\n    // :: number\n    // The end position of the replaced range.\n    this.to = to\n    // :: number\n    // The start of preserved range.\n    this.gapFrom = gapFrom\n    // :: number\n    // The end of preserved range.\n    this.gapTo = gapTo\n    // :: Slice\n    // The slice to insert.\n    this.slice = slice\n    // :: number\n    // The position in the slice where the preserved range should be\n    // inserted.\n    this.insert = insert\n    this.structure = !!structure\n  }\n\n  apply(doc) {\n    if (this.structure && (contentBetween(doc, this.from, this.gapFrom) ||\n                           contentBetween(doc, this.gapTo, this.to)))\n      return StepResult.fail(\"Structure gap-replace would overwrite content\")\n\n    let gap = doc.slice(this.gapFrom, this.gapTo)\n    if (gap.openStart || gap.openEnd)\n      return StepResult.fail(\"Gap is not a flat range\")\n    let inserted = this.slice.insertAt(this.insert, gap.content)\n    if (!inserted) return StepResult.fail(\"Content does not fit in gap\")\n    return StepResult.fromReplace(doc, this.from, this.to, inserted)\n  }\n\n  getMap() {\n    return new StepMap([this.from, this.gapFrom - this.from, this.insert,\n                        this.gapTo, this.to - this.gapTo, this.slice.size - this.insert])\n  }\n\n  invert(doc) {\n    let gap = this.gapTo - this.gapFrom\n    return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap,\n                                 this.from + this.insert, this.from + this.insert + gap,\n                                 doc.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from),\n                                 this.gapFrom - this.from, this.structure)\n  }\n\n  map(mapping) {\n    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1)\n    let gapFrom = mapping.map(this.gapFrom, -1), gapTo = mapping.map(this.gapTo, 1)\n    if ((from.deleted && to.deleted) || gapFrom < from.pos || gapTo > to.pos) return null\n    return new ReplaceAroundStep(from.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure)\n  }\n\n  toJSON() {\n    let json = {stepType: \"replaceAround\", from: this.from, to: this.to,\n                gapFrom: this.gapFrom, gapTo: this.gapTo, insert: this.insert}\n    if (this.slice.size) json.slice = this.slice.toJSON()\n    if (this.structure) json.structure = true\n    return json\n  }\n\n  static fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\" ||\n        typeof json.gapFrom != \"number\" || typeof json.gapTo != \"number\" || typeof json.insert != \"number\")\n      throw new RangeError(\"Invalid input for ReplaceAroundStep.fromJSON\")\n    return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo,\n                                 Slice.fromJSON(schema, json.slice), json.insert, !!json.structure)\n  }\n}\n\nStep.jsonID(\"replaceAround\", ReplaceAroundStep)\n\nfunction contentBetween(doc, from, to) {\n  let $from = doc.resolve(from), dist = to - from, depth = $from.depth\n  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {\n    depth--\n    dist--\n  }\n  if (dist > 0) {\n    let next = $from.node(depth).maybeChild($from.indexAfter(depth))\n    while (dist > 0) {\n      if (!next || next.isLeaf) return true\n      next = next.firstChild\n      dist--\n    }\n  }\n  return false\n}\n","import {Slice, Fragment} from \"prosemirror-model\"\n\nimport {Transform} from \"./transform\"\nimport {ReplaceStep, ReplaceAroundStep} from \"./replace_step\"\n\nfunction canCut(node, start, end) {\n  return (start == 0 || node.canReplace(start, node.childCount)) &&\n    (end == node.childCount || node.canReplace(0, end))\n}\n\n// :: (NodeRange) → ?number\n// Try to find a target depth to which the content in the given range\n// can be lifted. Will not go across\n// [isolating](#model.NodeSpec.isolating) parent nodes.\nexport function liftTarget(range) {\n  let parent = range.parent\n  let content = parent.content.cutByIndex(range.startIndex, range.endIndex)\n  for (let depth = range.depth;; --depth) {\n    let node = range.$from.node(depth)\n    let index = range.$from.index(depth), endIndex = range.$to.indexAfter(depth)\n    if (depth < range.depth && node.canReplace(index, endIndex, content))\n      return depth\n    if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex)) break\n  }\n}\n\n// :: (NodeRange, number) → this\n// Split the content in the given range off from its parent, if there\n// is sibling content before or after it, and move it up the tree to\n// the depth specified by `target`. You'll probably want to use\n// [`liftTarget`](#transform.liftTarget) to compute `target`, to make\n// sure the lift is valid.\nTransform.prototype.lift = function(range, target) {\n  let {$from, $to, depth} = range\n\n  let gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1)\n  let start = gapStart, end = gapEnd\n\n  let before = Fragment.empty, openStart = 0\n  for (let d = depth, splitting = false; d > target; d--)\n    if (splitting || $from.index(d) > 0) {\n      splitting = true\n      before = Fragment.from($from.node(d).copy(before))\n      openStart++\n    } else {\n      start--\n    }\n  let after = Fragment.empty, openEnd = 0\n  for (let d = depth, splitting = false; d > target; d--)\n    if (splitting || $to.after(d + 1) < $to.end(d)) {\n      splitting = true\n      after = Fragment.from($to.node(d).copy(after))\n      openEnd++\n    } else {\n      end++\n    }\n\n  return this.step(new ReplaceAroundStep(start, end, gapStart, gapEnd,\n                                         new Slice(before.append(after), openStart, openEnd),\n                                         before.size - openStart, true))\n}\n\n// :: (NodeRange, NodeType, ?Object, ?NodeRange) → ?[{type: NodeType, attrs: ?Object}]\n// Try to find a valid way to wrap the content in the given range in a\n// node of the given type. May introduce extra nodes around and inside\n// the wrapper node, if necessary. Returns null if no valid wrapping\n// could be found. When `innerRange` is given, that range's content is\n// used as the content to fit into the wrapping, instead of the\n// content of `range`.\nexport function findWrapping(range, nodeType, attrs, innerRange = range) {\n  let around = findWrappingOutside(range, nodeType)\n  let inner = around && findWrappingInside(innerRange, nodeType)\n  if (!inner) return null\n  return around.map(withAttrs).concat({type: nodeType, attrs}).concat(inner.map(withAttrs))\n}\n\nfunction withAttrs(type) { return {type, attrs: null} }\n\nfunction findWrappingOutside(range, type) {\n  let {parent, startIndex, endIndex} = range\n  let around = parent.contentMatchAt(startIndex).findWrapping(type)\n  if (!around) return null\n  let outer = around.length ? around[0] : type\n  return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null\n}\n\nfunction findWrappingInside(range, type) {\n  let {parent, startIndex, endIndex} = range\n  let inner = parent.child(startIndex)\n  let inside = type.contentMatch.findWrapping(inner.type)\n  if (!inside) return null\n  let lastType = inside.length ? inside[inside.length - 1] : type\n  let innerMatch = lastType.contentMatch\n  for (let i = startIndex; innerMatch && i < endIndex; i++)\n    innerMatch = innerMatch.matchType(parent.child(i).type)\n  if (!innerMatch || !innerMatch.validEnd) return null\n  return inside\n}\n\n// :: (NodeRange, [{type: NodeType, attrs: ?Object}]) → this\n// Wrap the given [range](#model.NodeRange) in the given set of wrappers.\n// The wrappers are assumed to be valid in this position, and should\n// probably be computed with [`findWrapping`](#transform.findWrapping).\nTransform.prototype.wrap = function(range, wrappers) {\n  let content = Fragment.empty\n  for (let i = wrappers.length - 1; i >= 0; i--)\n    content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content))\n\n  let start = range.start, end = range.end\n  return this.step(new ReplaceAroundStep(start, end, start, end, new Slice(content, 0, 0), wrappers.length, true))\n}\n\n// :: (number, ?number, NodeType, ?Object) → this\n// Set the type of all textblocks (partly) between `from` and `to` to\n// the given node type with the given attributes.\nTransform.prototype.setBlockType = function(from, to = from, type, attrs) {\n  if (!type.isTextblock) throw new RangeError(\"Type given to setBlockType should be a textblock\")\n  let mapFrom = this.steps.length\n  this.doc.nodesBetween(from, to, (node, pos) => {\n    if (node.isTextblock && !node.hasMarkup(type, attrs) && canChangeType(this.doc, this.mapping.slice(mapFrom).map(pos), type)) {\n      // Ensure all markup that isn't allowed in the new node type is cleared\n      this.clearIncompatible(this.mapping.slice(mapFrom).map(pos, 1), type)\n      let mapping = this.mapping.slice(mapFrom)\n      let startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1)\n      this.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1,\n                                      new Slice(Fragment.from(type.create(attrs, null, node.marks)), 0, 0), 1, true))\n      return false\n    }\n  })\n  return this\n}\n\nfunction canChangeType(doc, pos, type) {\n  let $pos = doc.resolve(pos), index = $pos.index()\n  return $pos.parent.canReplaceWith(index, index + 1, type)\n}\n\n// :: (number, ?NodeType, ?Object, ?[Mark]) → this\n// Change the type, attributes, and/or marks of the node at `pos`.\n// When `type` isn't given, the existing node type is preserved,\nTransform.prototype.setNodeMarkup = function(pos, type, attrs, marks) {\n  let node = this.doc.nodeAt(pos)\n  if (!node) throw new RangeError(\"No node at given position\")\n  if (!type) type = node.type\n  let newNode = type.create(attrs, null, marks || node.marks)\n  if (node.isLeaf)\n    return this.replaceWith(pos, pos + node.nodeSize, newNode)\n\n  if (!type.validContent(node.content))\n    throw new RangeError(\"Invalid content for node type \" + type.name)\n\n  return this.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1,\n                                         new Slice(Fragment.from(newNode), 0, 0), 1, true))\n}\n\n// :: (Node, number, number, ?[?{type: NodeType, attrs: ?Object}]) → bool\n// Check whether splitting at the given position is allowed.\nexport function canSplit(doc, pos, depth = 1, typesAfter) {\n  let $pos = doc.resolve(pos), base = $pos.depth - depth\n  let innerType = (typesAfter && typesAfter[typesAfter.length - 1]) || $pos.parent\n  if (base < 0 || $pos.parent.type.spec.isolating ||\n      !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) ||\n      !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))\n    return false\n  for (let d = $pos.depth - 1, i = depth - 2; d > base; d--, i--) {\n    let node = $pos.node(d), index = $pos.index(d)\n    if (node.type.spec.isolating) return false\n    let rest = node.content.cutByIndex(index, node.childCount)\n    let after = (typesAfter && typesAfter[i]) || node\n    if (after != node) rest = rest.replaceChild(0, after.type.create(after.attrs))\n    if (!node.canReplace(index + 1, node.childCount) || !after.type.validContent(rest))\n      return false\n  }\n  let index = $pos.indexAfter(base)\n  let baseType = typesAfter && typesAfter[0]\n  return $pos.node(base).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base + 1).type)\n}\n\n// :: (number, ?number, ?[?{type: NodeType, attrs: ?Object}]) → this\n// Split the node at the given position, and optionally, if `depth` is\n// greater than one, any number of nodes above that. By default, the\n// parts split off will inherit the node type of the original node.\n// This can be changed by passing an array of types and attributes to\n// use after the split.\nTransform.prototype.split = function(pos, depth = 1, typesAfter) {\n  let $pos = this.doc.resolve(pos), before = Fragment.empty, after = Fragment.empty\n  for (let d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {\n    before = Fragment.from($pos.node(d).copy(before))\n    let typeAfter = typesAfter && typesAfter[i]\n    after = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after))\n  }\n  return this.step(new ReplaceStep(pos, pos, new Slice(before.append(after), depth, depth), true))\n}\n\n// :: (Node, number) → bool\n// Test whether the blocks before and after a given position can be\n// joined.\nexport function canJoin(doc, pos) {\n  let $pos = doc.resolve(pos), index = $pos.index()\n  return joinable($pos.nodeBefore, $pos.nodeAfter) &&\n    $pos.parent.canReplace(index, index + 1)\n}\n\nfunction joinable(a, b) {\n  return a && b && !a.isLeaf && a.canAppend(b)\n}\n\n// :: (Node, number, ?number) → ?number\n// Find an ancestor of the given position that can be joined to the\n// block before (or after if `dir` is positive). Returns the joinable\n// point, if any.\nexport function joinPoint(doc, pos, dir = -1) {\n  let $pos = doc.resolve(pos)\n  for (let d = $pos.depth;; d--) {\n    let before, after, index = $pos.index(d)\n    if (d == $pos.depth) {\n      before = $pos.nodeBefore\n      after = $pos.nodeAfter\n    } else if (dir > 0) {\n      before = $pos.node(d + 1)\n      index++\n      after = $pos.node(d).maybeChild(index)\n    } else {\n      before = $pos.node(d).maybeChild(index - 1)\n      after = $pos.node(d + 1)\n    }\n    if (before && !before.isTextblock && joinable(before, after) &&\n        $pos.node(d).canReplace(index, index + 1)) return pos\n    if (d == 0) break\n    pos = dir < 0 ? $pos.before(d) : $pos.after(d)\n  }\n}\n\n// :: (number, ?number) → this\n// Join the blocks around the given position. If depth is 2, their\n// last and first siblings are also joined, and so on.\nTransform.prototype.join = function(pos, depth = 1) {\n  let step = new ReplaceStep(pos - depth, pos + depth, Slice.empty, true)\n  return this.step(step)\n}\n\n// :: (Node, number, NodeType) → ?number\n// Try to find a point where a node of the given type can be inserted\n// near `pos`, by searching up the node hierarchy when `pos` itself\n// isn't a valid place but is at the start or end of a node. Return\n// null if no position was found.\nexport function insertPoint(doc, pos, nodeType) {\n  let $pos = doc.resolve(pos)\n  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType)) return pos\n\n  if ($pos.parentOffset == 0)\n    for (let d = $pos.depth - 1; d >= 0; d--) {\n      let index = $pos.index(d)\n      if ($pos.node(d).canReplaceWith(index, index, nodeType)) return $pos.before(d + 1)\n      if (index > 0) return null\n    }\n  if ($pos.parentOffset == $pos.parent.content.size)\n    for (let d = $pos.depth - 1; d >= 0; d--) {\n      let index = $pos.indexAfter(d)\n      if ($pos.node(d).canReplaceWith(index, index, nodeType)) return $pos.after(d + 1)\n      if (index < $pos.node(d).childCount) return null\n    }\n}\n\n// :: (Node, number, Slice) → ?number\n// Finds a position at or around the given position where the given\n// slice can be inserted. Will look at parent nodes' nearest boundary\n// and try there, even if the original position wasn't directly at the\n// start or end of that node. Returns null when no position was found.\nexport function dropPoint(doc, pos, slice) {\n  let $pos = doc.resolve(pos)\n  if (!slice.content.size) return pos\n  let content = slice.content\n  for (let i = 0; i < slice.openStart; i++) content = content.firstChild.content\n  for (let pass = 1; pass <= (slice.openStart == 0 && slice.size ? 2 : 1); pass++) {\n    for (let d = $pos.depth; d >= 0; d--) {\n      let bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1\n      let insertPos = $pos.index(d) + (bias > 0 ? 1 : 0)\n      let parent = $pos.node(d), fits = false\n      if (pass == 1) {\n        fits = parent.canReplace(insertPos, insertPos, content)\n      } else {\n        let wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type)\n        fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0])\n      }\n      if (fits)\n        return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1)\n    }\n  }\n  return null\n}\n","import {Fragment, Slice} from \"prosemirror-model\"\nimport {Step, StepResult} from \"./step\"\n\nfunction mapFragment(fragment, f, parent) {\n  let mapped = []\n  for (let i = 0; i < fragment.childCount; i++) {\n    let child = fragment.child(i)\n    if (child.content.size) child = child.copy(mapFragment(child.content, f, child))\n    if (child.isInline) child = f(child, parent, i)\n    mapped.push(child)\n  }\n  return Fragment.fromArray(mapped)\n}\n\n// ::- Add a mark to all inline content between two positions.\nexport class AddMarkStep extends Step {\n  // :: (number, number, Mark)\n  constructor(from, to, mark) {\n    super()\n    // :: number\n    // The start of the marked range.\n    this.from = from\n    // :: number\n    // The end of the marked range.\n    this.to = to\n    // :: Mark\n    // The mark to add.\n    this.mark = mark\n  }\n\n  apply(doc) {\n    let oldSlice = doc.slice(this.from, this.to), $from = doc.resolve(this.from)\n    let parent = $from.node($from.sharedDepth(this.to))\n    let slice = new Slice(mapFragment(oldSlice.content, (node, parent) => {\n      if (!node.isAtom || !parent.type.allowsMarkType(this.mark.type)) return node\n      return node.mark(this.mark.addToSet(node.marks))\n    }, parent), oldSlice.openStart, oldSlice.openEnd)\n    return StepResult.fromReplace(doc, this.from, this.to, slice)\n  }\n\n  invert() {\n    return new RemoveMarkStep(this.from, this.to, this.mark)\n  }\n\n  map(mapping) {\n    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1)\n    if (from.deleted && to.deleted || from.pos >= to.pos) return null\n    return new AddMarkStep(from.pos, to.pos, this.mark)\n  }\n\n  merge(other) {\n    if (other instanceof AddMarkStep &&\n        other.mark.eq(this.mark) &&\n        this.from <= other.to && this.to >= other.from)\n      return new AddMarkStep(Math.min(this.from, other.from),\n                             Math.max(this.to, other.to), this.mark)\n  }\n\n  toJSON() {\n    return {stepType: \"addMark\", mark: this.mark.toJSON(),\n            from: this.from, to: this.to}\n  }\n\n  static fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\")\n      throw new RangeError(\"Invalid input for AddMarkStep.fromJSON\")\n    return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark))\n  }\n}\n\nStep.jsonID(\"addMark\", AddMarkStep)\n\n// ::- Remove a mark from all inline content between two positions.\nexport class RemoveMarkStep extends Step {\n  // :: (number, number, Mark)\n  constructor(from, to, mark) {\n    super()\n    // :: number\n    // The start of the unmarked range.\n    this.from = from\n    // :: number\n    // The end of the unmarked range.\n    this.to = to\n    // :: Mark\n    // The mark to remove.\n    this.mark = mark\n  }\n\n  apply(doc) {\n    let oldSlice = doc.slice(this.from, this.to)\n    let slice = new Slice(mapFragment(oldSlice.content, node => {\n      return node.mark(this.mark.removeFromSet(node.marks))\n    }), oldSlice.openStart, oldSlice.openEnd)\n    return StepResult.fromReplace(doc, this.from, this.to, slice)\n  }\n\n  invert() {\n    return new AddMarkStep(this.from, this.to, this.mark)\n  }\n\n  map(mapping) {\n    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1)\n    if (from.deleted && to.deleted || from.pos >= to.pos) return null\n    return new RemoveMarkStep(from.pos, to.pos, this.mark)\n  }\n\n  merge(other) {\n    if (other instanceof RemoveMarkStep &&\n        other.mark.eq(this.mark) &&\n        this.from <= other.to && this.to >= other.from)\n      return new RemoveMarkStep(Math.min(this.from, other.from),\n                                Math.max(this.to, other.to), this.mark)\n  }\n\n  toJSON() {\n    return {stepType: \"removeMark\", mark: this.mark.toJSON(),\n            from: this.from, to: this.to}\n  }\n\n  static fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\")\n      throw new RangeError(\"Invalid input for RemoveMarkStep.fromJSON\")\n    return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark))\n  }\n}\n\nStep.jsonID(\"removeMark\", RemoveMarkStep)\n","import {MarkType, Slice, Fragment} from \"prosemirror-model\"\n\nimport {Transform} from \"./transform\"\nimport {AddMarkStep, RemoveMarkStep} from \"./mark_step\"\nimport {ReplaceStep} from \"./replace_step\"\n\n// :: (number, number, Mark) → this\n// Add the given mark to the inline content between `from` and `to`.\nTransform.prototype.addMark = function(from, to, mark) {\n  let removed = [], added = [], removing = null, adding = null\n  this.doc.nodesBetween(from, to, (node, pos, parent) => {\n    if (!node.isInline) return\n    let marks = node.marks\n    if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {\n      let start = Math.max(pos, from), end = Math.min(pos + node.nodeSize, to)\n      let newSet = mark.addToSet(marks)\n\n      for (let i = 0; i < marks.length; i++) {\n        if (!marks[i].isInSet(newSet)) {\n          if (removing && removing.to == start && removing.mark.eq(marks[i]))\n            removing.to = end\n          else\n            removed.push(removing = new RemoveMarkStep(start, end, marks[i]))\n        }\n      }\n\n      if (adding && adding.to == start)\n        adding.to = end\n      else\n        added.push(adding = new AddMarkStep(start, end, mark))\n    }\n  })\n\n  removed.forEach(s => this.step(s))\n  added.forEach(s => this.step(s))\n  return this\n}\n\n// :: (number, number, ?union<Mark, MarkType>) → this\n// Remove marks from inline nodes between `from` and `to`. When `mark`\n// is a single mark, remove precisely that mark. When it is a mark type,\n// remove all marks of that type. When it is null, remove all marks of\n// any type.\nTransform.prototype.removeMark = function(from, to, mark = null) {\n  let matched = [], step = 0\n  this.doc.nodesBetween(from, to, (node, pos) => {\n    if (!node.isInline) return\n    step++\n    let toRemove = null\n    if (mark instanceof MarkType) {\n      let set = node.marks, found\n      while (found = mark.isInSet(set)) {\n        ;(toRemove || (toRemove = [])).push(found)\n        set = found.removeFromSet(set)\n      }\n    } else if (mark) {\n      if (mark.isInSet(node.marks)) toRemove = [mark]\n    } else {\n      toRemove = node.marks\n    }\n    if (toRemove && toRemove.length) {\n      let end = Math.min(pos + node.nodeSize, to)\n      for (let i = 0; i < toRemove.length; i++) {\n        let style = toRemove[i], found\n        for (let j = 0; j < matched.length; j++) {\n          let m = matched[j]\n          if (m.step == step - 1 && style.eq(matched[j].style)) found = m\n        }\n        if (found) {\n          found.to = end\n          found.step = step\n        } else {\n          matched.push({style, from: Math.max(pos, from), to: end, step})\n        }\n      }\n    }\n  })\n  matched.forEach(m => this.step(new RemoveMarkStep(m.from, m.to, m.style)))\n  return this\n}\n\n// :: (number, NodeType, ?ContentMatch) → this\n// Removes all marks and nodes from the content of the node at `pos`\n// that don't match the given new parent node type. Accepts an\n// optional starting [content match](#model.ContentMatch) as third\n// argument.\nTransform.prototype.clearIncompatible = function(pos, parentType, match = parentType.contentMatch) {\n  let node = this.doc.nodeAt(pos)\n  let delSteps = [], cur = pos + 1\n  for (let i = 0; i < node.childCount; i++) {\n    let child = node.child(i), end = cur + child.nodeSize\n    let allowed = match.matchType(child.type, child.attrs)\n    if (!allowed) {\n      delSteps.push(new ReplaceStep(cur, end, Slice.empty))\n    } else {\n      match = allowed\n      for (let j = 0; j < child.marks.length; j++) if (!parentType.allowsMarkType(child.marks[j].type))\n        this.step(new RemoveMarkStep(cur, end, child.marks[j]))\n    }\n    cur = end\n  }\n  if (!match.validEnd) {\n    let fill = match.fillBefore(Fragment.empty, true)\n    this.replace(cur, cur, new Slice(fill, 0, 0))\n  }\n  for (let i = delSteps.length - 1; i >= 0; i--) this.step(delSteps[i])\n  return this\n}\n","import {Fragment, Slice} from \"prosemirror-model\"\n\nimport {ReplaceStep, ReplaceAroundStep} from \"./replace_step\"\nimport {Transform} from \"./transform\"\nimport {insertPoint} from \"./structure\"\n\n// :: (Node, number, ?number, ?Slice) → ?Step\n// ‘Fit’ a slice into a given position in the document, producing a\n// [step](#transform.Step) that inserts it. Will return null if\n// there's no meaningful way to insert the slice here, or inserting it\n// would be a no-op (an empty slice over an empty range).\nexport function replaceStep(doc, from, to = from, slice = Slice.empty) {\n  if (from == to && !slice.size) return null\n\n  let $from = doc.resolve(from), $to = doc.resolve(to)\n  // Optimization -- avoid work if it's obvious that it's not needed.\n  if (fitsTrivially($from, $to, slice)) return new ReplaceStep(from, to, slice)\n  return new Fitter($from, $to, slice).fit()\n}\n\n// :: (number, ?number, ?Slice) → this\n// Replace the part of the document between `from` and `to` with the\n// given `slice`.\nTransform.prototype.replace = function(from, to = from, slice = Slice.empty) {\n  let step = replaceStep(this.doc, from, to, slice)\n  if (step) this.step(step)\n  return this\n}\n\n// :: (number, number, union<Fragment, Node, [Node]>) → this\n// Replace the given range with the given content, which may be a\n// fragment, node, or array of nodes.\nTransform.prototype.replaceWith = function(from, to, content) {\n  return this.replace(from, to, new Slice(Fragment.from(content), 0, 0))\n}\n\n// :: (number, number) → this\n// Delete the content between the given positions.\nTransform.prototype.delete = function(from, to) {\n  return this.replace(from, to, Slice.empty)\n}\n\n// :: (number, union<Fragment, Node, [Node]>) → this\n// Insert the given content at the given position.\nTransform.prototype.insert = function(pos, content) {\n  return this.replaceWith(pos, pos, content)\n}\n\nfunction fitsTrivially($from, $to, slice) {\n  return !slice.openStart && !slice.openEnd && $from.start() == $to.start() &&\n    $from.parent.canReplace($from.index(), $to.index(), slice.content)\n}\n\n// Algorithm for 'placing' the elements of a slice into a gap:\n//\n// We consider the content of each node that is open to the left to be\n// independently placeable. I.e. in <p(\"foo\"), p(\"bar\")>, when the\n// paragraph on the left is open, \"foo\" can be placed (somewhere on\n// the left side of the replacement gap) independently from p(\"bar\").\n//\n// This class tracks the state of the placement progress in the\n// following properties:\n//\n//  - `frontier` holds a stack of `{type, match}` objects that\n//    represent the open side of the replacement. It starts at\n//    `$from`, then moves forward as content is placed, and is finally\n//    reconciled with `$to`.\n//\n//  - `unplaced` is a slice that represents the content that hasn't\n//    been placed yet.\n//\n//  - `placed` is a fragment of placed content. Its open-start value\n//    is implicit in `$from`, and its open-end value in `frontier`.\nclass Fitter {\n  constructor($from, $to, slice) {\n    this.$to = $to\n    this.$from = $from\n    this.unplaced = slice\n\n    this.frontier = []\n    for (let i = 0; i <= $from.depth; i++) {\n      let node = $from.node(i)\n      this.frontier.push({\n        type: node.type,\n        match: node.contentMatchAt($from.indexAfter(i))\n      })\n    }\n\n    this.placed = Fragment.empty\n    for (let i = $from.depth; i > 0; i--)\n      this.placed = Fragment.from($from.node(i).copy(this.placed))\n  }\n\n  get depth() { return this.frontier.length - 1 }\n\n  fit() {\n    // As long as there's unplaced content, try to place some of it.\n    // If that fails, either increase the open score of the unplaced\n    // slice, or drop nodes from it, and then try again.\n    while (this.unplaced.size) {\n      let fit = this.findFittable()\n      if (fit) this.placeNodes(fit)\n      else this.openMore() || this.dropNode()\n    }\n    // When there's inline content directly after the frontier _and_\n    // directly after `this.$to`, we must generate a `ReplaceAround`\n    // step that pulls that content into the node after the frontier.\n    // That means the fitting must be done to the end of the textblock\n    // node after `this.$to`, not `this.$to` itself.\n    let moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth\n    let $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline))\n    if (!$to) return null\n\n    // If closing to `$to` succeeded, create a step\n    let content = this.placed, openStart = $from.depth, openEnd = $to.depth\n    while (openStart && openEnd && content.childCount == 1) { // Normalize by dropping open parent nodes\n      content = content.firstChild.content\n      openStart--; openEnd--\n    }\n    let slice = new Slice(content, openStart, openEnd)\n    if (moveInline > -1)\n      return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice, placedSize)\n    if (slice.size || $from.pos != this.$to.pos) // Don't generate no-op steps\n      return new ReplaceStep($from.pos, $to.pos, slice)\n  }\n\n  // Find a position on the start spine of `this.unplaced` that has\n  // content that can be moved somewhere on the frontier. Returns two\n  // depths, one for the slice and one for the frontier.\n  findFittable() {\n    // Only try wrapping nodes (pass 2) after finding a place without\n    // wrapping failed.\n    for (let pass = 1; pass <= 2; pass++) {\n      for (let sliceDepth = this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {\n        let fragment, parent\n        if (sliceDepth) {\n          parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild\n          fragment = parent.content\n        } else {\n          fragment = this.unplaced.content\n        }\n        let first = fragment.firstChild\n        for (let frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {\n          let {type, match} = this.frontier[frontierDepth], wrap, inject\n          // In pass 1, if the next node matches, or there is no next\n          // node but the parents look compatible, we've found a\n          // place.\n          if (pass == 1 && (first ? match.matchType(first.type) || (inject = match.fillBefore(Fragment.from(first), false))\n                            : type.compatibleContent(parent.type)))\n            return {sliceDepth, frontierDepth, parent, inject}\n          // In pass 2, look for a set of wrapping nodes that make\n          // `first` fit here.\n          else if (pass == 2 && first && (wrap = match.findWrapping(first.type)))\n            return {sliceDepth, frontierDepth, parent, wrap}\n          // Don't continue looking further up if the parent node\n          // would fit here.\n          if (parent && match.matchType(parent.type)) break\n        }\n      }\n    }\n  }\n\n  openMore() {\n    let {content, openStart, openEnd} = this.unplaced\n    let inner = contentAt(content, openStart)\n    if (!inner.childCount || inner.firstChild.isLeaf) return false\n    this.unplaced = new Slice(content, openStart + 1,\n                              Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0))\n    return true\n  }\n\n  dropNode() {\n    let {content, openStart, openEnd} = this.unplaced\n    let inner = contentAt(content, openStart)\n    if (inner.childCount <= 1 && openStart > 0) {\n      let openAtEnd = content.size - openStart <= openStart + inner.size\n      this.unplaced = new Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1,\n                                openAtEnd ? openStart - 1 : openEnd)\n    } else {\n      this.unplaced = new Slice(dropFromFragment(content, openStart, 1), openStart, openEnd)\n    }\n  }\n\n  // : ({sliceDepth: number, frontierDepth: number, parent: ?Node, wrap: ?[NodeType], inject: ?Fragment})\n  // Move content from the unplaced slice at `sliceDepth` to the\n  // frontier node at `frontierDepth`. Close that frontier node when\n  // applicable.\n  placeNodes({sliceDepth, frontierDepth, parent, inject, wrap}) {\n    while (this.depth > frontierDepth) this.closeFrontierNode()\n    if (wrap) for (let i = 0; i < wrap.length; i++) this.openFrontierNode(wrap[i])\n\n    let slice = this.unplaced, fragment = parent ? parent.content : slice.content\n    let openStart = slice.openStart - sliceDepth\n    let taken = 0, add = []\n    let {match, type} = this.frontier[frontierDepth]\n    if (inject) {\n      for (let i = 0; i < inject.childCount; i++) add.push(inject.child(i))\n      match = match.matchFragment(inject)\n    }\n    // Computes the amount of (end) open nodes at the end of the\n    // fragment. When 0, the parent is open, but no more. When\n    // negative, nothing is open.\n    let openEndCount = (fragment.size + sliceDepth) - (slice.content.size - slice.openEnd)\n    // Scan over the fragment, fitting as many child nodes as\n    // possible.\n    while (taken < fragment.childCount) {\n      let next = fragment.child(taken), matches = match.matchType(next.type)\n      if (!matches) break\n      taken++\n      if (taken > 1 || openStart == 0 || next.content.size) { // Drop empty open nodes\n        match = matches\n        add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0,\n                                taken == fragment.childCount ? openEndCount : -1))\n      }\n    }\n    let toEnd = taken == fragment.childCount\n    if (!toEnd) openEndCount = -1\n\n    this.placed = addToFragment(this.placed, frontierDepth, Fragment.from(add))\n    this.frontier[frontierDepth].match = match\n\n    // If the parent types match, and the entire node was moved, and\n    // it's not open, close this frontier node right away.\n    if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)\n      this.closeFrontierNode()\n\n    // Add new frontier nodes for any open nodes at the end.\n    for (let i = 0, cur = fragment; i < openEndCount; i++) {\n      let node = cur.lastChild\n      this.frontier.push({type: node.type, match: node.contentMatchAt(node.childCount)})\n      cur = node.content\n    }\n\n    // Update `this.unplaced`. Drop the entire node from which we\n    // placed it we got to its end, otherwise just drop the placed\n    // nodes.\n    this.unplaced = !toEnd ? new Slice(dropFromFragment(slice.content, sliceDepth, taken), slice.openStart, slice.openEnd)\n      : sliceDepth == 0 ? Slice.empty\n      : new Slice(dropFromFragment(slice.content, sliceDepth - 1, 1),\n                  sliceDepth - 1, openEndCount < 0 ? slice.openEnd : sliceDepth - 1)\n  }\n\n  mustMoveInline() {\n    if (!this.$to.parent.isTextblock || this.$to.end() == this.$to.pos) return -1\n    let top = this.frontier[this.depth], level\n    if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) ||\n        (this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth)) return -1\n\n    let {depth} = this.$to, after = this.$to.after(depth)\n    while (depth > 1 && after == this.$to.end(--depth)) ++after\n    return after\n  }\n\n  findCloseLevel($to) {\n    scan: for (let i = Math.min(this.depth, $to.depth); i >= 0; i--) {\n      let {match, type} = this.frontier[i]\n      let dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1))\n      let fit = contentAfterFits($to, i, type, match, dropInner)\n      if (!fit) continue\n      for (let d = i - 1; d >= 0; d--) {\n        let {match, type} = this.frontier[d]\n        let matches = contentAfterFits($to, d, type, match, true)\n        if (!matches || matches.childCount) continue scan\n      }\n      return {depth: i, fit, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to}\n    }\n  }\n\n  close($to) {\n    let close = this.findCloseLevel($to)\n    if (!close) return null\n\n    while (this.depth > close.depth) this.closeFrontierNode()\n    if (close.fit.childCount) this.placed = addToFragment(this.placed, close.depth, close.fit)\n    $to = close.move\n    for (let d = close.depth + 1; d <= $to.depth; d++) {\n      let node = $to.node(d), add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d))\n      this.openFrontierNode(node.type, node.attrs, add)\n    }\n    return $to\n  }\n\n  openFrontierNode(type, attrs, content) {\n    let top = this.frontier[this.depth]\n    top.match = top.match.matchType(type)\n    this.placed = addToFragment(this.placed, this.depth, Fragment.from(type.create(attrs, content)))\n    this.frontier.push({type, match: type.contentMatch})\n  }\n\n  closeFrontierNode() {\n    let open = this.frontier.pop()\n    let add = open.match.fillBefore(Fragment.empty, true)\n    if (add.childCount) this.placed = addToFragment(this.placed, this.frontier.length, add)\n  }\n}\n\nfunction dropFromFragment(fragment, depth, count) {\n  if (depth == 0) return fragment.cutByIndex(count)\n  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)))\n}\n\nfunction addToFragment(fragment, depth, content) {\n  if (depth == 0) return fragment.append(content)\n  return fragment.replaceChild(fragment.childCount - 1,\n                               fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)))\n}\n\nfunction contentAt(fragment, depth) {\n  for (let i = 0; i < depth; i++) fragment = fragment.firstChild.content\n  return fragment\n}\n\nfunction closeNodeStart(node, openStart, openEnd) {\n  if (openStart <= 0) return node\n  let frag = node.content\n  if (openStart > 1)\n    frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0))\n  if (openStart > 0) {\n    frag = node.type.contentMatch.fillBefore(frag).append(frag)\n    if (openEnd <= 0) frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(Fragment.empty, true))\n  }\n  return node.copy(frag)\n}\n\nfunction contentAfterFits($to, depth, type, match, open) {\n  let node = $to.node(depth), index = open ? $to.indexAfter(depth) : $to.index(depth)\n  if (index == node.childCount && !type.compatibleContent(node.type)) return null\n  let fit = match.fillBefore(node.content, true, index)\n  return fit && !invalidMarks(type, node.content, index) ? fit : null\n}\n\nfunction invalidMarks(type, fragment, start) {\n  for (let i = start; i < fragment.childCount; i++)\n    if (!type.allowsMarks(fragment.child(i).marks)) return true\n  return false\n}\n\n// :: (number, number, Slice) → this\n// Replace a range of the document with a given slice, using `from`,\n// `to`, and the slice's [`openStart`](#model.Slice.openStart) property\n// as hints, rather than fixed start and end points. This method may\n// grow the replaced area or close open nodes in the slice in order to\n// get a fit that is more in line with WYSIWYG expectations, by\n// dropping fully covered parent nodes of the replaced region when\n// they are marked [non-defining](#model.NodeSpec.defining), or\n// including an open parent node from the slice that _is_ marked as\n// [defining](#model.NodeSpec.defining).\n//\n// This is the method, for example, to handle paste. The similar\n// [`replace`](#transform.Transform.replace) method is a more\n// primitive tool which will _not_ move the start and end of its given\n// range, and is useful in situations where you need more precise\n// control over what happens.\nTransform.prototype.replaceRange = function(from, to, slice) {\n  if (!slice.size) return this.deleteRange(from, to)\n\n  let $from = this.doc.resolve(from), $to = this.doc.resolve(to)\n  if (fitsTrivially($from, $to, slice))\n    return this.step(new ReplaceStep(from, to, slice))\n\n  let targetDepths = coveredDepths($from, this.doc.resolve(to))\n  // Can't replace the whole document, so remove 0 if it's present\n  if (targetDepths[targetDepths.length - 1] == 0) targetDepths.pop()\n  // Negative numbers represent not expansion over the whole node at\n  // that depth, but replacing from $from.before(-D) to $to.pos.\n  let preferredTarget = -($from.depth + 1)\n  targetDepths.unshift(preferredTarget)\n  // This loop picks a preferred target depth, if one of the covering\n  // depths is not outside of a defining node, and adds negative\n  // depths for any depth that has $from at its start and does not\n  // cross a defining node.\n  for (let d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {\n    let spec = $from.node(d).type.spec\n    if (spec.defining || spec.isolating) break\n    if (targetDepths.indexOf(d) > -1) preferredTarget = d\n    else if ($from.before(d) == pos) targetDepths.splice(1, 0, -d)\n  }\n  // Try to fit each possible depth of the slice into each possible\n  // target depth, starting with the preferred depths.\n  let preferredTargetIndex = targetDepths.indexOf(preferredTarget)\n\n  let leftNodes = [], preferredDepth = slice.openStart\n  for (let content = slice.content, i = 0;; i++) {\n    let node = content.firstChild\n    leftNodes.push(node)\n    if (i == slice.openStart) break\n    content = node.content\n  }\n  // Back up if the node directly above openStart, or the node above\n  // that separated only by a non-defining textblock node, is defining.\n  if (preferredDepth > 0 && leftNodes[preferredDepth - 1].type.spec.defining &&\n      $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 1].type)\n    preferredDepth -= 1\n  else if (preferredDepth >= 2 && leftNodes[preferredDepth - 1].isTextblock && leftNodes[preferredDepth - 2].type.spec.defining &&\n           $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 2].type)\n    preferredDepth -= 2\n\n  for (let j = slice.openStart; j >= 0; j--) {\n    let openDepth = (j + preferredDepth + 1) % (slice.openStart + 1)\n    let insert = leftNodes[openDepth]\n    if (!insert) continue\n    for (let i = 0; i < targetDepths.length; i++) {\n      // Loop over possible expansion levels, starting with the\n      // preferred one\n      let targetDepth = targetDepths[(i + preferredTargetIndex) % targetDepths.length], expand = true\n      if (targetDepth < 0) { expand = false; targetDepth = -targetDepth }\n      let parent = $from.node(targetDepth - 1), index = $from.index(targetDepth - 1)\n      if (parent.canReplaceWith(index, index, insert.type, insert.marks))\n        return this.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to,\n                            new Slice(closeFragment(slice.content, 0, slice.openStart, openDepth),\n                                      openDepth, slice.openEnd))\n    }\n  }\n\n  let startSteps = this.steps.length\n  for (let i = targetDepths.length - 1; i >= 0; i--) {\n    this.replace(from, to, slice)\n    if (this.steps.length > startSteps) break\n    let depth = targetDepths[i]\n    if (depth < 0) continue\n    from = $from.before(depth); to = $to.after(depth)\n  }\n  return this\n}\n\nfunction closeFragment(fragment, depth, oldOpen, newOpen, parent) {\n  if (depth < oldOpen) {\n    let first = fragment.firstChild\n    fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)))\n  }\n  if (depth > newOpen) {\n    let match = parent.contentMatchAt(0)\n    let start = match.fillBefore(fragment).append(fragment)\n    fragment = start.append(match.matchFragment(start).fillBefore(Fragment.empty, true))\n  }\n  return fragment\n}\n\n// :: (number, number, Node) → this\n// Replace the given range with a node, but use `from` and `to` as\n// hints, rather than precise positions. When from and to are the same\n// and are at the start or end of a parent node in which the given\n// node doesn't fit, this method may _move_ them out towards a parent\n// that does allow the given node to be placed. When the given range\n// completely covers a parent node, this method may completely replace\n// that parent node.\nTransform.prototype.replaceRangeWith = function(from, to, node) {\n  if (!node.isInline && from == to && this.doc.resolve(from).parent.content.size) {\n    let point = insertPoint(this.doc, from, node.type)\n    if (point != null) from = to = point\n  }\n  return this.replaceRange(from, to, new Slice(Fragment.from(node), 0, 0))\n}\n\n// :: (number, number) → this\n// Delete the given range, expanding it to cover fully covered\n// parent nodes until a valid replace is found.\nTransform.prototype.deleteRange = function(from, to) {\n  let $from = this.doc.resolve(from), $to = this.doc.resolve(to)\n  let covered = coveredDepths($from, $to)\n  for (let i = 0; i < covered.length; i++) {\n    let depth = covered[i], last = i == covered.length - 1\n    if ((last && depth == 0) || $from.node(depth).type.contentMatch.validEnd)\n      return this.delete($from.start(depth), $to.end(depth))\n    if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))\n      return this.delete($from.before(depth), $to.after(depth))\n  }\n  for (let d = 1; d <= $from.depth && d <= $to.depth; d++) {\n    if (from - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d)\n      return this.delete($from.before(d), to)\n  }\n  return this.delete(from, to)\n}\n\n// : (ResolvedPos, ResolvedPos) → [number]\n// Returns an array of all depths for which $from - $to spans the\n// whole content of the nodes at that depth.\nfunction coveredDepths($from, $to) {\n  let result = [], minDepth = Math.min($from.depth, $to.depth)\n  for (let d = minDepth; d >= 0; d--) {\n    let start = $from.start(d)\n    if (start < $from.pos - ($from.depth - d) ||\n        $to.end(d) > $to.pos + ($to.depth - d) ||\n        $from.node(d).type.spec.isolating ||\n        $to.node(d).type.spec.isolating) break\n    if (start == $to.start(d)) result.push(d)\n  }\n  return result\n}\n"],"names":["const","let","ReplaceError","super","Slice","slice","Fragment","d","splitting","this","index","MarkType","found","i","prototypeAccessors","type","match"],"mappings":"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"}