(self["webpackChunk_june_so_analytics_next"] = self["webpackChunk_june_so_analytics_next"] || []).push([["vendors-node_modules_segment_tsub_dist_index_js"],{

/***/ 5130:
/*!**************************************************!*\
  !*** ./node_modules/@segment/tsub/dist/index.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Store = exports.matches = exports.transform = void 0;
var transformers_1 = __webpack_require__(/*! ./transformers */ 2764);
Object.defineProperty(exports, "transform", ({ enumerable: true, get: function () { return transformers_1.default; } }));
var matchers_1 = __webpack_require__(/*! ./matchers */ 714);
Object.defineProperty(exports, "matches", ({ enumerable: true, get: function () { return matchers_1.default; } }));
var store_1 = __webpack_require__(/*! ./store */ 4372);
Object.defineProperty(exports, "Store", ({ enumerable: true, get: function () { return store_1.default; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 714:
/*!*****************************************************!*\
  !*** ./node_modules/@segment/tsub/dist/matchers.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var get = __webpack_require__(/*! dlv */ 6905);
function matches(event, matcher) {
    if (!matcher) {
        throw new Error('No matcher supplied!');
    }
    switch (matcher.type) {
        case 'all':
            return all();
        case 'fql':
            return fql(matcher.ir, event);
        default:
            throw new Error("Matcher of type " + matcher.type + " unsupported.");
    }
}
exports["default"] = matches;
function all() {
    return true;
}
function fql(ir, event) {
    if (!ir) {
        return false;
    }
    try {
        ir = JSON.parse(ir);
    }
    catch (e) {
        throw new Error("Failed to JSON.parse FQL intermediate representation \"" + ir + "\": " + e);
    }
    var result = fqlEvaluate(ir, event);
    if (typeof result !== 'boolean') {
        // An error was returned, or a lowercase, typeof, or similar function was run alone. Nothing to evaluate.
        return false;
    }
    return result;
}
// FQL is 100% type strict in Go. Show no mercy to types which do not comply.
function fqlEvaluate(ir, event) {
    // If the given ir chunk is not an array, then we should check the single given path or value for literally `true`.
    if (!Array.isArray(ir)) {
        return getValue(ir, event) === true;
    }
    // Otherwise, it is a sequence of ordered steps to follow to reach our solution!
    var item = ir[0];
    switch (item) {
        /*** Unary cases ***/
        // '!' => Invert the result
        case '!':
            return !fqlEvaluate(ir[1], event);
        /*** Binary cases ***/
        // 'or' => Any condition being true returns true
        case 'or':
            for (var i = 1; i < ir.length; i++) {
                if (fqlEvaluate(ir[i], event)) {
                    return true;
                }
            }
            return false;
        // 'and' => Any condition being false returns false
        case 'and':
            for (var i = 1; i < ir.length; i++) {
                if (!fqlEvaluate(ir[i], event)) {
                    return false;
                }
            }
            return true;
        // Equivalence comparisons
        case '=':
        case '!=':
            return compareItems(getValue(ir[1], event), getValue(ir[2], event), item, event);
        // Numerical comparisons
        case '<=':
        case '<':
        case '>':
        case '>=':
            // Compare the two values with the given operator.
            return compareNumbers(getValue(ir[1], event), getValue(ir[2], event), item, event);
        /*** Functions ***/
        // 'contains(str1, str2)' => The first string has a substring of the second string
        case 'contains':
            return contains(getValue(ir[1], event), getValue(ir[2], event));
        // 'match(str, match)' => The given string matches the provided glob matcher
        case 'match':
            return match(getValue(ir[1], event), getValue(ir[2], event));
        // 'lowercase(str)' => Returns a lowercased string, null if the item is not a string
        case 'lowercase':
            var target = getValue(ir[1], event);
            if (typeof target !== 'string') {
                return null;
            }
            return target.toLowerCase();
        // 'typeof(val)' => Returns the FQL type of the value
        case 'typeof':
            // TODO: Do we need mapping to allow for universal comparisons? e.g. Object -> JSON, Array -> List, Floats?
            return typeof getValue(ir[1], event);
        // 'length(val)' => Returns the length of an array or string, NaN if neither
        case 'length':
            return length(getValue(ir[1], event));
        // If nothing hit, we or the IR messed up somewhere.
        default:
            throw new Error("FQL IR could not evaluate for token: " + item);
    }
}
function getValue(item, event) {
    // If item is an array, leave it as-is.
    if (Array.isArray(item)) {
        return item;
    }
    // If item is an object, it has the form of `{"value": VAL}`
    if (typeof item === 'object') {
        return item.value;
    }
    // Otherwise, it's an event path, e.g. "properties.email"
    return get(event, item);
}
function compareNumbers(first, second, operator, event) {
    // Check if it's more IR (such as a length() function)
    if (isIR(first)) {
        first = fqlEvaluate(first, event);
    }
    if (isIR(second)) {
        second = fqlEvaluate(second, event);
    }
    if (typeof first !== 'number' || typeof second !== 'number') {
        return false;
    }
    // Reminder: NaN is not comparable to any other number (including NaN) and will always return false as desired.
    switch (operator) {
        // '<=' => The first number is less than or equal to the second.
        case '<=':
            return first <= second;
        // '>=' => The first number is greater than or equal to the second
        case '>=':
            return first >= second;
        // '<' The first number is less than the second.
        case '<':
            return first < second;
        // '>' The first number is greater than the second.
        case '>':
            return first > second;
        default:
            throw new Error("Invalid operator in compareNumbers: " + operator);
    }
}
function compareItems(first, second, operator, event) {
    // Check if it's more IR (such as a lowercase() function)
    if (isIR(first)) {
        first = fqlEvaluate(first, event);
    }
    if (isIR(second)) {
        second = fqlEvaluate(second, event);
    }
    if (typeof first === 'object' && typeof second === 'object') {
        first = JSON.stringify(first);
        second = JSON.stringify(second);
    }
    // Objects with the exact same contents AND order ARE considered identical. (Don't compare by reference)
    // Even in Go, this MUST be the same byte order.
    // e.g. {a: 1, b:2} === {a: 1, b:2} BUT {a:1, b:2} !== {b:2, a:1}
    // Maybe later we'll use a stable stringifier, but we're matching server-side behavior for now.
    switch (operator) {
        // '=' => The two following items are exactly identical
        case '=':
            return first === second;
        // '!=' => The two following items are NOT exactly identical.
        case '!=':
            return first !== second;
        default:
            throw new Error("Invalid operator in compareItems: " + operator);
    }
}
function contains(first, second) {
    if (typeof first !== 'string' || typeof second !== 'string') {
        return false;
    }
    return first.indexOf(second) !== -1;
}
function match(str, glob) {
    if (typeof str !== 'string' || typeof glob !== 'string') {
        return false;
    }
    return globMatches(glob, str);
}
function length(item) {
    // Match server-side behavior.
    if (item === null) {
        return 0;
    }
    // Type-check to avoid returning .length of an object
    if (!Array.isArray(item) && typeof item !== 'string') {
        return NaN;
    }
    return item.length;
}
// This is a heuristic technically speaking, but should be close enough. The odds of someone trying to test
// a func with identical IR notation is pretty low.
function isIR(value) {
    // TODO: This can be better checked by checking if this is a {"value": THIS}
    if (!Array.isArray(value)) {
        return false;
    }
    // Function checks
    if ((value[0] === 'lowercase' || value[0] === 'length' || value[0] === 'typeof') &&
        value.length === 2) {
        return true;
    }
    if ((value[0] === 'contains' || value[0] === 'match') && value.length === 3) {
        return true;
    }
    return false;
}
// Any reputable glob matcher is designed to work on filesystems and doesn't allow the override of the separator
// character "/". This is problematic since our server-side representation e.g. evaluates "match('ab/c', 'a*)"
// as TRUE, whereas any glob matcher for JS available does false. So we're rewriting it here.
// See: https://github.com/segmentio/glob/blob/master/glob.go
function globMatches(pattern, str) {
    var _a, _b;
    Pattern: while (pattern.length > 0) {
        var star = void 0;
        var chunk = void 0;
        (_a = scanChunk(pattern), star = _a.star, chunk = _a.chunk, pattern = _a.pattern);
        if (star && chunk === '') {
            // Trailing * matches rest of string
            return true;
        }
        // Look for match at current position
        var _c = matchChunk(chunk, str), t = _c.t, ok = _c.ok, err = _c.err;
        if (err) {
            return false;
        }
        // If we're the last chunk, make sure we've exhausted the str
        // otherwise we'll give a false result even if we could still match
        // using the star
        if (ok && (t.length === 0 || pattern.length > 0)) {
            str = t;
            continue;
        }
        if (star) {
            // Look for match, skipping i+1 bytes.
            for (var i = 0; i < str.length; i++) {
                ;
                (_b = matchChunk(chunk, str.slice(i + 1)), t = _b.t, ok = _b.ok, err = _b.err);
                if (ok) {
                    // If we're the last chunk, make sure we exhausted the str.
                    if (pattern.length === 0 && t.length > 0) {
                        continue;
                    }
                    str = t;
                    continue Pattern;
                }
                if (err) {
                    return false;
                }
            }
        }
        return false;
    }
    return str.length === 0;
}
function scanChunk(pattern) {
    var result = {
        star: false,
        chunk: '',
        pattern: '',
    };
    while (pattern.length > 0 && pattern[0] === '*') {
        pattern = pattern.slice(1);
        result.star = true;
    }
    var inRange = false;
    var i;
    Scan: for (i = 0; i < pattern.length; i++) {
        switch (pattern[i]) {
            case '\\':
                // Error check handled in matchChunk: bad pattern.
                if (i + 1 < pattern.length) {
                    i++;
                }
                break;
            case '[':
                inRange = true;
                break;
            case ']':
                inRange = false;
                break;
            case '*':
                if (!inRange) {
                    break Scan;
                }
        }
    }
    result.chunk = pattern.slice(0, i);
    result.pattern = pattern.slice(i);
    return result;
}
// matchChunk checks whether chunk matches the beginning of s.
// If so, it returns the remainder of s (after the match).
// Chunk is all single-character operators: literals, char classes, and ?.
function matchChunk(chunk, str) {
    var _a, _b;
    var result = {
        t: '',
        ok: false,
        err: false,
    };
    while (chunk.length > 0) {
        if (str.length === 0) {
            return result;
        }
        switch (chunk[0]) {
            case '[':
                var char = str[0];
                str = str.slice(1);
                chunk = chunk.slice(1);
                var notNegated = true;
                if (chunk.length > 0 && chunk[0] === '^') {
                    notNegated = false;
                    chunk = chunk.slice(1);
                }
                // Parse all ranges
                var foundMatch = false;
                var nRange = 0;
                while (true) {
                    if (chunk.length > 0 && chunk[0] === ']' && nRange > 0) {
                        chunk = chunk.slice(1);
                        break;
                    }
                    var lo = '';
                    var hi = '';
                    var err = void 0;
                    (_a = getEsc(chunk), lo = _a.char, chunk = _a.newChunk, err = _a.err);
                    if (err) {
                        return result;
                    }
                    hi = lo;
                    if (chunk[0] === '-') {
                        ;
                        (_b = getEsc(chunk.slice(1)), hi = _b.char, chunk = _b.newChunk, err = _b.err);
                        if (err) {
                            return result;
                        }
                    }
                    if (lo <= char && char <= hi) {
                        foundMatch = true;
                    }
                    nRange++;
                }
                if (foundMatch !== notNegated) {
                    return result;
                }
                break;
            case '?':
                str = str.slice(1);
                chunk = chunk.slice(1);
                break;
            case '\\':
                chunk = chunk.slice(1);
                if (chunk.length === 0) {
                    result.err = true;
                    return result;
                }
            // Fallthrough, missing break intentional.
            default:
                if (chunk[0] !== str[0]) {
                    return result;
                }
                str = str.slice(1);
                chunk = chunk.slice(1);
        }
    }
    result.t = str;
    result.ok = true;
    result.err = false;
    return result;
}
// getEsc gets a possibly-escaped character from chunk, for a character class.
function getEsc(chunk) {
    var result = {
        char: '',
        newChunk: '',
        err: false,
    };
    if (chunk.length === 0 || chunk[0] === '-' || chunk[0] === ']') {
        result.err = true;
        return result;
    }
    if (chunk[0] === '\\') {
        chunk = chunk.slice(1);
        if (chunk.length === 0) {
            result.err = true;
            return result;
        }
    }
    // Unlike Go, JS strings operate on characters instead of bytes.
    // This is why we aren't copying over the GetRuneFromString stuff.
    result.char = chunk[0];
    result.newChunk = chunk.slice(1);
    if (result.newChunk.length === 0) {
        result.err = true;
    }
    return result;
}
//# sourceMappingURL=matchers.js.map

/***/ }),

/***/ 4372:
/*!**************************************************!*\
  !*** ./node_modules/@segment/tsub/dist/store.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var Store = /** @class */ (function () {
    function Store(rules) {
        this.rules = [];
        this.rules = rules || [];
    }
    Store.prototype.getRulesByDestinationName = function (destinationName) {
        var rules = [];
        for (var _i = 0, _a = this.rules; _i < _a.length; _i++) {
            var rule = _a[_i];
            // Rules with no destinationName are global (workspace || workspace::source)
            if (rule.destinationName === destinationName || rule.destinationName === undefined) {
                rules.push(rule);
            }
        }
        return rules;
    };
    return Store;
}());
exports["default"] = Store;
//# sourceMappingURL=store.js.map

/***/ }),

/***/ 2764:
/*!*********************************************************!*\
  !*** ./node_modules/@segment/tsub/dist/transformers.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var MD5 = __webpack_require__(/*! tiny-hashes/md5 */ 2766);
var get = __webpack_require__(/*! dlv */ 6905);
var ldexp = __webpack_require__(/*! math-float64-ldexp */ 362);
var set = __webpack_require__(/*! dset/dist/dset.js */ 5092);
var unset_1 = __webpack_require__(/*! ./unset */ 4195);
function transform(payload, transformers) {
    var transformedPayload = payload;
    for (var _i = 0, transformers_1 = transformers; _i < transformers_1.length; _i++) {
        var transformer = transformers_1[_i];
        switch (transformer.type) {
            case 'drop':
                return null;
            case 'drop_properties':
                dropProperties(transformedPayload, transformer.config);
                break;
            case 'allow_properties':
                allowProperties(transformedPayload, transformer.config);
                break;
            case 'sample_event':
                if (sampleEvent(transformedPayload, transformer.config)) {
                    break;
                }
                return null;
            case 'map_properties':
                mapProperties(transformedPayload, transformer.config);
                break;
            case 'hash_properties':
                // Not yet supported, but don't throw an error. Just ignore.
                break;
            default:
                throw new Error("Transformer of type \"" + transformer.type + "\" is unsupported.");
        }
    }
    return transformedPayload;
}
exports["default"] = transform;
// dropProperties removes all specified props from the object.
function dropProperties(payload, config) {
    for (var key in config.drop) {
        if (!config.drop.hasOwnProperty(key)) {
            continue;
        }
        // If key is empty, it refers to the top-level object.
        var field = key === '' ? payload : get(payload, key);
        // Can only drop props off of arrays and objects.
        if (typeof field !== 'object' || field === null) {
            continue;
        }
        for (var _i = 0, _a = config.drop[key]; _i < _a.length; _i++) {
            var target = _a[_i];
            delete field[target];
        }
    }
}
// allowProperties ONLY allows the specific targets within the keys. (e.g. "a.foo": ["bar", "baz"]
// on {a: {foo: {bar: 1, baz: 2}, other: 3}} will not have any drops, as it only looks inside a.foo
function allowProperties(payload, config) {
    for (var key in config.allow) {
        if (!config.allow.hasOwnProperty(key)) {
            continue;
        }
        // If key is empty, it refers to the top-level object.
        var field = key === '' ? payload : get(payload, key);
        // Can only drop props off of arrays and objects.
        if (typeof field !== 'object' || field === null) {
            continue;
        }
        // Execution order fortunately doesn't really matter (e.g. if someone filtered off of foo.bar, then foo.bar.baz)
        // except for micro-optimization.
        for (var k in field) {
            if (!field.hasOwnProperty(k)) {
                continue;
            }
            if (config.allow[key].indexOf(k) === -1) {
                delete field[k];
            }
        }
    }
}
function mapProperties(payload, config) {
    // Some configs might try to modify or read from a field multiple times. We will only ever read
    // values as they were before any modifications began. Thus, if you try to override e.g.
    // {a: {b: 1}} with set(a, 'b', 2) (which results in {a: {b: 2}}) and then try to copy a.b into
    // a.c, you will get {a: {b: 2, c:1}} and NOT {a: {b:2, c:2}}. This prevents map evaluation
    // order from mattering, and === what server-side does.
    // See: https://github.com/segmentio/tsub/blob/661695a63b60b90471796e667458f076af788c19/transformers/map_properties.go#L179-L200
    var initialPayload = JSON.parse(JSON.stringify(payload));
    for (var key in config.map) {
        if (!config.map.hasOwnProperty(key)) {
            continue;
        }
        var actionMap = config.map[key];
        // Can't manipulate non-objects. Check that the parent is one. Strip the last .field
        // from the string.
        var splitKey = key.split('.');
        var parent_1 = void 0;
        if (splitKey.length > 1) {
            splitKey.pop();
            parent_1 = get(initialPayload, splitKey.join('.'));
        }
        else {
            parent_1 = payload;
        }
        if (typeof parent_1 !== 'object') {
            continue;
        }
        // These actions are exclusive to each other.
        if (actionMap.copy) {
            var valueToCopy = get(initialPayload, actionMap.copy);
            if (valueToCopy !== undefined) {
                set(payload, key, valueToCopy);
            }
        }
        else if (actionMap.move) {
            var valueToMove = get(initialPayload, actionMap.move);
            if (valueToMove !== undefined) {
                set(payload, key, valueToMove);
            }
            unset_1.unset(payload, actionMap.move);
        }
        // Have to check only if property exists, as null, undefined, and other vals could be explicitly set.
        else if (actionMap.hasOwnProperty('set')) {
            set(payload, key, actionMap.set);
        }
        // to_string is not exclusive and can be paired with other actions. Final action.
        if (actionMap.to_string) {
            var valueToString = get(payload, key);
            // Do not string arrays and objects. Do not double-encode strings.
            if (typeof valueToString === 'string' ||
                (typeof valueToString === 'object' && valueToString !== null)) {
                continue;
            }
            // TODO: Check stringifier in Golang for parity.
            if (valueToString !== undefined) {
                set(payload, key, JSON.stringify(valueToString));
            }
            else {
                // TODO: Check this behavior.
                set(payload, key, 'undefined');
            }
        }
    }
}
function sampleEvent(payload, config) {
    if (config.sample.percent <= 0) {
        return false;
    }
    else if (config.sample.percent >= 1) {
        return true;
    }
    // If we're not filtering deterministically, just use raw percentage.
    if (!config.sample.path) {
        return samplePercent(config.sample.percent);
    }
    // Otherwise, use a deterministic hash.
    return sampleConsistentPercent(payload, config);
}
function samplePercent(percent) {
    // Math.random returns [0, 1) => 0.0<>0.9999...
    return Math.random() <= percent;
}
// sampleConsistentPercent converts an input string of bytes into a consistent uniform
// continuous distribution of [0.0, 1.0]. This is based on
// http://mumble.net/~campbell/tmp/random_real.c, but using the digest
// result of the input value as the random information.
// IMPORTANT - This function needs to === the Golang implementation to ensure that the two return the same vals!
// See: https://github.com/segmentio/sampler/blob/65cb04132305a04fcd4bcaef67d57fbe40c30241/sampler.go#L13-L38
// Since AJS supports IE9+ (typed arrays were introduced in IE10) we're doing some manual array math.
// This could be done directly with strings, but arrays are easier to reason about/have better function support.
function sampleConsistentPercent(payload, config) {
    var field = get(payload, config.sample.path);
    // Operate off of JSON bytes. TODO: Validate all type behavior, esp. strings.
    var digest = MD5(JSON.stringify(field));
    var exponent = -64;
    // Manually maintain 64-bit int as an array.
    var significand = [];
    // Left-shift and OR for first 8 bytes of digest. (8 bytes * 8 = 64 bits)
    consumeDigest(digest.slice(0, 8), significand);
    var leadingZeros = 0;
    for (var i = 0; i < 64; i++) {
        if (significand[i] === 1) {
            break;
        }
        leadingZeros++;
    }
    if (leadingZeros !== 0) {
        // Use the last 8 bytes of the digest, same as before.
        var val = [];
        consumeDigest(digest.slice(9, 16), val);
        exponent -= leadingZeros;
        // Left-shift away leading zeros in significand.
        significand.splice(0, leadingZeros);
        // Right-shift val by 64 minus leading zeros and push into significand.
        val.splice(64 - leadingZeros);
        significand = significand.concat(val);
    }
    // Flip 64th bit
    significand[63] = significand[63] === 0 ? 1 : 0;
    // Convert our manual binary into a JS num (binary arr => binary string => psuedo-int) and run the ldexp!
    return ldexp(parseInt(significand.join(''), 2), exponent) < config.sample.percent;
}
// Array byte filler helper
function consumeDigest(digest, arr) {
    for (var i = 0; i < 8; i++) {
        var remainder = digest[i];
        for (var binary = 128; binary >= 1; binary /= 2) {
            if (remainder - binary >= 0) {
                remainder -= binary;
                arr.push(1);
            }
            else {
                arr.push(0);
            }
        }
    }
}
//# sourceMappingURL=transformers.js.map

/***/ }),

/***/ 4195:
/*!**************************************************!*\
  !*** ./node_modules/@segment/tsub/dist/unset.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.unset = void 0;
var get = __webpack_require__(/*! dlv */ 6905);
function unset(obj, prop) {
    if (get(obj, prop)) {
        var segs = prop.split('.');
        var last = segs.pop();
        while (segs.length && segs[segs.length - 1].slice(-1) === '\\') {
            last = segs.pop().slice(0, -1) + '.' + last;
        }
        while (segs.length)
            obj = obj[(prop = segs.shift())];
        return delete obj[last];
    }
    return true;
}
exports.unset = unset;
//# sourceMappingURL=unset.js.map

/***/ }),

/***/ 5092:
/*!*******************************************************************!*\
  !*** ./node_modules/@segment/tsub/node_modules/dset/dist/dset.js ***!
  \*******************************************************************/
/***/ (function(module) {

module.exports = function (obj, keys, val) {
	keys.split && (keys=keys.split('.'));
	var i=0, l=keys.length, t=obj, x, k;
	for (; i < l;) {
		k = keys[i++];
		if (k === '__proto__' || k === 'constructor' || k === 'prototype') continue;
		t = t[k] = (i === l ? val : ((x=t[k]) != null ? x : (keys[i]*0 !== 0 || !!~keys[i].indexOf('.')) ? {} : []));
	}
}


/***/ }),

/***/ 7906:
/*!******************************************************!*\
  !*** ./node_modules/const-ninf-float64/lib/index.js ***!
  \******************************************************/
/***/ (function(module) {

"use strict";


// EXPORTS //

module.exports = Number.NEGATIVE_INFINITY;


/***/ }),

/***/ 3855:
/*!******************************************************!*\
  !*** ./node_modules/const-pinf-float64/lib/index.js ***!
  \******************************************************/
/***/ (function(module) {

"use strict";


// EXPORTS //

module.exports = Number.POSITIVE_INFINITY;


/***/ }),

/***/ 9640:
/*!**********************************************************!*\
  !*** ./node_modules/const-smallest-float64/lib/index.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


// MODULE //

var setReadOnly = __webpack_require__( /*! utils-define-read-only-property */ 5863 );


// CONSTANTS //

var constants = {};

// 1 / Math.pow( 2, 1023-1 )
setReadOnly( constants, 'VALUE', 2.2250738585072014e-308 );

// 1 / Math.pow( 2, 1023-1+52 )
setReadOnly( constants, 'DENORMALIZED', 4.940656458412465e-324 );


// EXPORTS //

module.exports = constants;


/***/ }),

/***/ 6905:
/*!******************************************!*\
  !*** ./node_modules/dlv/dist/dlv.umd.js ***!
  \******************************************/
/***/ (function(module) {

!function(t,n){ true?module.exports=function(t,n,e,i,o){for(n=n.split?n.split("."):n,i=0;i<n.length;i++)t=t?t[n[i]]:o;return t===o?e:t}:0}(this);
//# sourceMappingURL=dlv.umd.js.map


/***/ }),

/***/ 5286:
/*!********************************************!*\
  !*** ./node_modules/math-abs/lib/index.js ***!
  \********************************************/
/***/ (function(module) {

"use strict";


/**
* FUNCTION: abs( x )
*	Computes the absolute value of `x`.
*
* @param {Number} x - input value
* @returns {Number} absolute value
*/
function abs( x ) {
	if ( x < 0 ) {
		return -x;
	}
	if ( x === 0 ) {
		return 0; // handle negative zero
	}
	return x;
} // end FUNCTION abs()


// EXPORTS //

module.exports = abs;


/***/ }),

/***/ 6234:
/*!*********************************************************!*\
  !*** ./node_modules/math-float64-copysign/lib/index.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


// MODULES //

var toWords = __webpack_require__( /*! math-float64-to-words */ 6818 );
var getHighWord = __webpack_require__( /*! math-float64-get-high-word */ 8002 );
var fromWords = __webpack_require__( /*! math-float64-from-words */ 1340 ); 


// VARIABLES //

// 10000000000000000000000000000000 => 2147483648 => 0x80000000
var SIGN_MASK = 0x80000000;

// 01111111111111111111111111111111 => 2147483647 => 0x7fffffff
var MAGNITUDE_MASK = 0x7fffffff;


// COPYSIGN //

/**
* FUNCTION: copysign( x, y )
*	Returns a double-precision floating-point number with the magnitude of `x` and the sign of `y`.
*
* @param {Number} x - number from which to derive a magnitude
* @param {Number} y - number from which to derive a sign
* @returns {Number} a double-precision floating-point number
*/
function copysign( x, y ) {
	var hx;
	var hy;

	// Split `x` into higher and lower order words:
	x = toWords( x );
	hx = x[ 0 ];

	// Turn off the sign bit of `x`:
	hx &= MAGNITUDE_MASK;

	// Extract the higher order word from `y`:
	hy = getHighWord( y );

	// Leave only the sign bit of `y` turned on:
	hy &= SIGN_MASK;

	// Copy the sign bit of `y` to `x`:
	hx |= hy;

	// Return a new value having the same magnitude as `x`, but with the sign of `y`:
	return fromWords( hx, x[ 1 ] );
} // end FUNCTION copysign()


// EXPORTS //

module.exports = copysign;


/***/ }),

/***/ 4840:
/*!*********************************************************!*\
  !*** ./node_modules/math-float64-exponent/lib/index.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


// MODULES //

var getHighWord = __webpack_require__( /*! math-float64-get-high-word */ 8002 );


// VARIABLES //

// Exponent mask: 01111111111100000000000000000000
var EXP_MASK = 0x7ff00000;
var BIAS = 1023;


// EXPONENT //

/**
* FUNCTION: exponent( x )
*	Returns an integer corresponding to the unbiased exponent of a double-precision floating-point number.
*
* @param {Number} x - input value
* @returns {Number} unbiased exponent
*/
function exponent( x ) {
	// Extract from the input value a higher order word (unsigned 32-bit integer) which contains the exponent:
	var high = getHighWord( x );

	// Apply a mask to isolate only the exponent bits and then shift off all bits which are part of the fraction:
	high = ( high & EXP_MASK ) >>> 20;

	// Remove the bias and return:
	return high - BIAS;
} // end FUNCTION exponent()


// EXPORTS //

module.exports = exponent;


/***/ }),

/***/ 1340:
/*!***********************************************************!*\
  !*** ./node_modules/math-float64-from-words/lib/index.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


// MODULES //

var indices = __webpack_require__( /*! ./indices.js */ 7623 );


// NOTES //

/**
* float64 (64 bits)
* f := fraction (significand/mantissa) (52 bits)
* e := exponent (11 bits)
* s := sign bit (1 bit)
*
* |-------- -------- -------- -------- -------- -------- -------- --------|
* |                                Float64                                |
* |-------- -------- -------- -------- -------- -------- -------- --------|
* |              Uint32               |               Uint32              |
* |-------- -------- -------- -------- -------- -------- -------- --------|
*
* If little endian (more significant bits last):
*                         <-- lower      higher -->
* |   f7       f6       f5       f4       f3       f2    e2 | f1 |s|  e1  |
*
* If big endian (more significant bits first):
*                         <-- higher      lower -->
* |s| e1    e2 | f1     f2       f3       f4       f5        f6      f7   |
*
*
* Note: in which Uint32 should we place the higher order bits? If LE, the second; if BE, the first.
* Refs: http://pubs.opengroup.org/onlinepubs/9629399/chap14.htm
*/


// VARIABLES //

var FLOAT64_VIEW = new Float64Array( 1 );
var UINT32_VIEW = new Uint32Array( FLOAT64_VIEW.buffer );

var HIGH = indices.HIGH;
var LOW = indices.LOW;


// TO FLOAT64 //

/**
* FUNCTION: toFloat64( high, low )
*	Creates a double-precision floating-point number from a higher order word (32-bit integer) and a lower order word (32-bit integer).
*
* @param {Number} high - higher order word (unsigned 32-bit integer)
* @param {Number} low - lower order word (unsigned 32-bit integer)
* @returns {Number} floating-point number
*/
function toFloat64( high, low ) {
	UINT32_VIEW[ HIGH ] = high;
	UINT32_VIEW[ LOW ] = low;
	return FLOAT64_VIEW[ 0 ];
} // end FUNCTION toFloat64()


// EXPORTS //

module.exports = toFloat64;


/***/ }),

/***/ 7623:
/*!*************************************************************!*\
  !*** ./node_modules/math-float64-from-words/lib/indices.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


// MODULES //

var isLittleEndian = __webpack_require__( /*! utils-is-little-endian */ 3730 );


// INDICES //

var HIGH;
var LOW;

if ( isLittleEndian === true ) {
	HIGH = 1; // second index
	LOW = 0; // first index
} else {
	HIGH = 0; // first index
	LOW = 1; // second index
}


// EXPORTS //

module.exports = {
	'HIGH': HIGH,
	'LOW': LOW
};


/***/ }),

/***/ 2630:
/*!*************************************************************!*\
  !*** ./node_modules/math-float64-get-high-word/lib/high.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


// MODULES //

var isLittleEndian = __webpack_require__( /*! utils-is-little-endian */ 3730 );


// INDEX //

var HIGH;
if ( isLittleEndian === true ) {
	HIGH = 1; // second index
} else {
	HIGH = 0; // first index
}


// EXPORTS //

module.exports = HIGH;


/***/ }),

/***/ 8002:
/*!**************************************************************!*\
  !*** ./node_modules/math-float64-get-high-word/lib/index.js ***!
  \**************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


// MODULES //

var HIGH = __webpack_require__( /*! ./high.js */ 2630 );


// NOTES //

/**
* float64 (64 bits)
* f := fraction (significand/mantissa) (52 bits)
* e := exponent (11 bits)
* s := sign bit (1 bit)
*
* |-------- -------- -------- -------- -------- -------- -------- --------|
* |                                Float64                                |
* |-------- -------- -------- -------- -------- -------- -------- --------|
* |              Uint32               |               Uint32              |
* |-------- -------- -------- -------- -------- -------- -------- --------|
*
* If little endian (more significant bits last):
*                         <-- lower      higher -->
* |   f7       f6       f5       f4       f3       f2    e2 | f1 |s|  e1  |
*
* If big endian (more significant bits first):
*                         <-- higher      lower -->
* |s| e1    e2 | f1     f2       f3       f4       f5        f6      f7   |
*
*
* Note: in which Uint32 can we find the higher order bits? If LE, the second; if BE, the first.
* Refs: http://pubs.opengroup.org/onlinepubs/9629399/chap14.htm
*/


// VARIABLES //

var FLOAT64_VIEW = new Float64Array( 1 );
var UINT32_VIEW = new Uint32Array( FLOAT64_VIEW.buffer );


// HIGH WORD //

/**
* FUNCTION: highWord( x )
*	Returns an unsigned 32-bit integer corresponding to the more significant 32 bits of a double-precision floating-point number.
*
* @param {Number} x - input value
* @returns {Number} higher order word
*/
function highWord( x ) {
	FLOAT64_VIEW[ 0 ] = x;
	return UINT32_VIEW[ HIGH ];
} // end FUNCTION highWord()


// EXPORTS //

module.exports = highWord;


/***/ }),

/***/ 362:
/*!******************************************************!*\
  !*** ./node_modules/math-float64-ldexp/lib/index.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


// NOTES //

/**
* Notes:
*	=> ldexp: load exponent (see [The Open Group]{@link http://pubs.opengroup.org/onlinepubs/9699919799/functions/ldexp.html}).
*/


// MODULES //

var PINF = __webpack_require__( /*! const-pinf-float64 */ 3855 );
var NINF = __webpack_require__( /*! const-ninf-float64 */ 7906 );
var normalize = __webpack_require__( /*! math-float64-normalize */ 7847 );
var floatExp = __webpack_require__( /*! math-float64-exponent */ 4840 );
var copysign = __webpack_require__( /*! math-float64-copysign */ 6234 );
var toWords = __webpack_require__( /*! math-float64-to-words */ 6818 );
var fromWords = __webpack_require__( /*! math-float64-from-words */ 1340 );


// VARIABLES //

var BIAS = 1023;

// -(BIAS+(52-1)) = -(1023+51) = -1074
var MIN_SUBNORMAL_EXPONENT = -1074;

// -BIAS = -1023
var MAX_SUBNORMAL_EXPONENT = -BIAS;

// 11111111110 => 2046 - BIAS = 1023
var MAX_EXPONENT = BIAS;

// 1/(1<<52) = 1/(2**52) = 1/4503599627370496
var TWO52_INV = 2.220446049250313e-16;

// Exponent all 0s: 10000000000011111111111111111111
var CLEAR_EXP_MASK = 0x800fffff; // 2148532223


// LDEXP //

/**
* FUNCTION: ldexp( frac, exp )
*	Multiplies a double-precision floating-point number by an integer power of two.
*
* @param {Number} frac - fraction
* @param {Number} exp - exponent
* @returns {Number} double-precision floating-point number
*/
function ldexp( frac, exp ) {
	var high;
	var tmp;
	var w;
	var m;
	if (
		frac === 0 || // handles +-0
		frac !== frac || // handles NaN
		frac === PINF ||
		frac === NINF
	) {
		return frac;
	}
	// Normalize the input fraction:
	tmp = normalize( frac );
	frac = tmp[ 0 ];
	exp += tmp[ 1 ];

	// Extract the exponent from `frac` and add it to `exp`:
	exp += floatExp( frac );

	// Check for underflow/overflow...
	if ( exp < MIN_SUBNORMAL_EXPONENT ) {
		return copysign( 0, frac );
	}
	if ( exp > MAX_EXPONENT ) {
		if ( frac < 0 ) {
			return NINF;
		}
		return PINF;
	}
	// Check for a subnormal and scale accordingly to retain precision...
	if ( exp <= MAX_SUBNORMAL_EXPONENT ) {
		exp += 52;
		m = TWO52_INV;
	} else {
		m = 1.0;
	}
	// Split the fraction into higher and lower order words:
	w = toWords( frac );
	high = w[ 0 ];

	// Clear the exponent bits within the higher order word:
	high &= CLEAR_EXP_MASK;

	// Set the exponent bits to the new exponent:
	high |= ((exp+BIAS) << 20);

	// Create a new floating-point number:
	return m * fromWords( high, w[ 1 ] );
} // end FUNCTION ldexp()


// EXPORTS //

module.exports = ldexp;


/***/ }),

/***/ 7847:
/*!**********************************************************!*\
  !*** ./node_modules/math-float64-normalize/lib/index.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


// MODULES //

var SMALLEST_FLOAT64 = (__webpack_require__(/*! const-smallest-float64 */ 9640).VALUE);
var isinfinite = __webpack_require__( /*! validate.io-infinite */ 1945 );
var abs = __webpack_require__( /*! math-abs */ 5286 );


// CONSTANTS //

// (1<<52)
var SCALAR = 4503599627370496;


// NORMALIZE //

/**
* FUNCTION: normalize( x )
*	Returns a normal number `y` and exponent `exp` satisfying `x = y * 2^exp`.
*
* @param {Number} x - input value
* @returns {Number[]|Null} a two-element array containing `y` and `exp`
*/
function normalize( x ) {
	if ( x !== x || isinfinite( x ) ) {
		return [ x, 0 ];
	}
	if ( x !== 0 && abs( x ) < SMALLEST_FLOAT64 ) {
		return [ x*SCALAR, -52 ];
	}
	return [ x, 0 ];
} // end FUNCTION normalize()


// EXPORTS //

module.exports = normalize;


/***/ }),

/***/ 6818:
/*!*********************************************************!*\
  !*** ./node_modules/math-float64-to-words/lib/index.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


// MODULES //

var indices = __webpack_require__( /*! ./indices.js */ 5011 );


// NOTES //

/**
* float64 (64 bits)
* f := fraction (significand/mantissa) (52 bits)
* e := exponent (11 bits)
* s := sign bit (1 bit)
*
* |-------- -------- -------- -------- -------- -------- -------- --------|
* |                                Float64                                |
* |-------- -------- -------- -------- -------- -------- -------- --------|
* |              Uint32               |               Uint32              |
* |-------- -------- -------- -------- -------- -------- -------- --------|
*
* If little endian (more significant bits last):
*                         <-- lower      higher -->
* |   f7       f6       f5       f4       f3       f2    e2 | f1 |s|  e1  |
*
* If big endian (more significant bits first):
*                         <-- higher      lower -->
* |s| e1    e2 | f1     f2       f3       f4       f5        f6      f7   |
*
*
* Note: in which Uint32 can we find the higher order bits? If LE, the second; if BE, the first.
* Refs: http://pubs.opengroup.org/onlinepubs/9629399/chap14.htm
*/


// VARIABLES //

var FLOAT64_VIEW = new Float64Array( 1 );
var UINT32_VIEW = new Uint32Array( FLOAT64_VIEW.buffer );

var HIGH = indices.HIGH;
var LOW = indices.LOW;


// WORDS //

/**
* FUNCTION: words( x )
*	Splits a floating-point number into a higher order word (32-bit integer) and a lower order word (32-bit integer).
*
* @param {Number} x - input value
* @returns {Number[]} two-element array containing a higher order word and a lower order word
*/
function words( x ) {
	FLOAT64_VIEW[ 0 ] = x;
	return [ UINT32_VIEW[ HIGH ], UINT32_VIEW[ LOW ] ];
} // end FUNCTION words()


// EXPORTS //

module.exports = words;


/***/ }),

/***/ 5011:
/*!***********************************************************!*\
  !*** ./node_modules/math-float64-to-words/lib/indices.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


// MODULES //

var isLittleEndian = __webpack_require__( /*! utils-is-little-endian */ 3730 );


// INDICES //

var HIGH;
var LOW;

if ( isLittleEndian ) {
	HIGH = 1; // second index
	LOW = 0; // first index
} else {
	HIGH = 0; // first index
	LOW = 1; // second index
}


// EXPORTS //

module.exports = {
	'HIGH': HIGH,
	'LOW': LOW
};


/***/ }),

/***/ 5863:
/*!*******************************************************************!*\
  !*** ./node_modules/utils-define-read-only-property/lib/index.js ***!
  \*******************************************************************/
/***/ (function(module) {

"use strict";


/**
* FUNCTION: setReadOnly( obj, prop, value )
*	Defines a read-only property.
*
* @param {Object} obj - object on which to define the property
* @param {String} prop - property name
* @param {*} value - value to set
* @returns {Void}
*/
function setReadOnly( obj, prop, value ) {
	Object.defineProperty( obj, prop, {
		'value': value,
		'configurable': false,
		'writable': false,
		'enumerable': true
	});
} // end FUNCTION setReadOnly()


// EXPORTS //

module.exports = setReadOnly;


/***/ }),

/***/ 9479:
/*!**********************************************************!*\
  !*** ./node_modules/utils-is-little-endian/lib/ctors.js ***!
  \**********************************************************/
/***/ (function(module) {

"use strict";


var ctors = {
	'uint16': Uint16Array,
	'uint8': Uint8Array
};


// EXPORTS //

module.exports = ctors;


/***/ }),

/***/ 3730:
/*!**********************************************************!*\
  !*** ./node_modules/utils-is-little-endian/lib/index.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


// MODULES //

var ctors = __webpack_require__( /*! ./ctors.js */ 9479 );


// IS LITTLE ENDIAN //

/**
* FUNCTION: isLittleEndian()
*	Returns a boolean indicating if an environment is little endian.
*
* @returns {Boolean} boolean indicating if an environment is little endian
*/
function isLittleEndian() {
	var uint16_view;
	var uint8_view;

	uint16_view = new ctors[ 'uint16' ]( 1 );

	// Set the uint16 view to a value having distinguishable lower and higher order words.
	// 4660 => 0x1234 => 0x12 0x34 => '00010010 00110100' => (0x12,0x34) == (18,52)
	uint16_view[ 0 ] = 0x1234;

	// Create a uint8 view on top of the uint16 buffer:
	uint8_view = new ctors[ 'uint8' ]( uint16_view.buffer );

	// If little endian, the least significant byte will be first...
	return ( uint8_view[ 0 ] === 0x34 );
} // end FUNCTION isLittleEndian()


// EXPORTS //

module.exports = isLittleEndian();


/***/ }),

/***/ 1945:
/*!********************************************************!*\
  !*** ./node_modules/validate.io-infinite/lib/index.js ***!
  \********************************************************/
/***/ (function(module) {

"use strict";


// VARIABLES //

var pinf = Number.POSITIVE_INFINITY;
var ninf = Number.NEGATIVE_INFINITY;


// IS INFINITE //

/**
* FUNCTION: isInfinite( x )
*	Validates if a value is infinite.
*
* @param {*} x - value to validate
* @returns {Boolean} boolean indicating if a value is infinite
*/
function isInfinite( x ) {
	return ( x === pinf || x === ninf );
} // end FUNCTION isInfinite()


// EXPORTS //

module.exports = isInfinite;


/***/ }),

/***/ 2766:
/*!************************************************!*\
  !*** ./node_modules/tiny-hashes/md5/index.mjs ***!
  \************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
for(var r=[],o=0;o<64;)r[o]=0|4294967296*Math.sin(++o%Math.PI);/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(t){var e,f,n,a=[e=1732584193,f=4023233417,~e,~f],c=[],h=unescape(encodeURI(t))+"Â€",u=h.length;for(t=--u/4+2|15,c[--t]=8*u;~u;)c[u>>2]|=h.charCodeAt(u)<<8*u--;for(o=h=0;o<t;o+=16){for(u=a;h<64;u=[n=u[3],e+((n=u[0]+[e&f|~e&n,n&e|~n&f,e^f^n,f^(e|~n)][u=h>>4]+r[h]+~~c[o|15&[h,5*h+1,3*h+5,7*h][u]])<<(u=[7,12,17,22,5,9,14,20,4,11,16,23,6,10,15,21][4*u+h++%4])|n>>>-u),e,f])e=0|u[1],f=u[2];for(h=4;h;)a[--h]+=u[h]}for(t="";h<32;)t+=(a[h>>3]>>4*(1^h++)&15).toString(16);return t}
//# sourceMappingURL=index.mjs.map


/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_segment_tsub_dist_index_js.bundle.9d8e3332eccf0618070f.js.map