{"version":3,"file":"index.js","sources":["../src/inputrules.js","../src/rules.js","../src/rulebuilders.js"],"sourcesContent":["import {Plugin} from \"prosemirror-state\"\n\n// ::- Input rules are regular expressions describing a piece of text\n// that, when typed, causes something to happen. This might be\n// changing two dashes into an emdash, wrapping a paragraph starting\n// with `\"> \"` into a blockquote, or something entirely different.\nexport class InputRule {\n  // :: (RegExp, union<string, (state: EditorState, match: [string], start: number, end: number) → ?Transaction>)\n  // Create an input rule. The rule applies when the user typed\n  // something and the text directly in front of the cursor matches\n  // `match`, which should end with `$`.\n  //\n  // The `handler` can be a string, in which case the matched text, or\n  // the first matched group in the regexp, is replaced by that\n  // string.\n  //\n  // Or a it can be a function, which will be called with the match\n  // array produced by\n  // [`RegExp.exec`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec),\n  // as well as the start and end of the matched range, and which can\n  // return a [transaction](#state.Transaction) that describes the\n  // rule's effect, or null to indicate the input was not handled.\n  constructor(match, handler) {\n    this.match = match\n    this.handler = typeof handler == \"string\" ? stringHandler(handler) : handler\n  }\n}\n\nfunction stringHandler(string) {\n  return function(state, match, start, end) {\n    let insert = string\n    if (match[1]) {\n      let offset = match[0].lastIndexOf(match[1])\n      insert += match[0].slice(offset + match[1].length)\n      start += offset\n      let cutOff = start - end\n      if (cutOff > 0) {\n        insert = match[0].slice(offset - cutOff, offset) + insert\n        start = end\n      }\n    }\n    return state.tr.insertText(insert, start, end)\n  }\n}\n\nconst MAX_MATCH = 500\n\n// :: (config: {rules: [InputRule]}) → Plugin\n// Create an input rules plugin. When enabled, it will cause text\n// input that matches any of the given rules to trigger the rule's\n// action.\nexport function inputRules({rules}) {\n  let plugin = new Plugin({\n    state: {\n      init() { return null },\n      apply(tr, prev) {\n        let stored = tr.getMeta(this)\n        if (stored) return stored\n        return tr.selectionSet || tr.docChanged ? null : prev\n      }\n    },\n\n    props: {\n      handleTextInput(view, from, to, text) {\n        return run(view, from, to, text, rules, plugin)\n      },\n      handleDOMEvents: {\n        compositionend: (view) => {\n          setTimeout(() => {\n            let {$cursor} = view.state.selection\n            if ($cursor) run(view, $cursor.pos, $cursor.pos, \"\", rules, plugin)\n          })\n        }\n      }\n    },\n\n    isInputRules: true\n  })\n  return plugin\n}\n\nfunction run(view, from, to, text, rules, plugin) {\n  if (view.composing) return false\n  let state = view.state, $from = state.doc.resolve(from)\n  if ($from.parent.type.spec.code) return false\n  let textBefore = $from.parent.textBetween(Math.max(0, $from.parentOffset - MAX_MATCH), $from.parentOffset,\n                                            null, \"\\ufffc\") + text\n  for (let i = 0; i < rules.length; i++) {\n    let match = rules[i].match.exec(textBefore)\n    let tr = match && rules[i].handler(state, match, from - (match[0].length - text.length), to)\n    if (!tr) continue\n    view.dispatch(tr.setMeta(plugin, {transform: tr, from, to, text}))\n    return true\n  }\n  return false\n}\n\n// :: (EditorState, ?(Transaction)) → bool\n// This is a command that will undo an input rule, if applying such a\n// rule was the last thing that the user did.\nexport function undoInputRule(state, dispatch) {\n  let plugins = state.plugins\n  for (let i = 0; i < plugins.length; i++) {\n    let plugin = plugins[i], undoable\n    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {\n      if (dispatch) {\n        let tr = state.tr, toUndo = undoable.transform\n        for (let j = toUndo.steps.length - 1; j >= 0; j--)\n          tr.step(toUndo.steps[j].invert(toUndo.docs[j]))\n        if (undoable.text) {\n          let marks = tr.doc.resolve(undoable.from).marks()\n          tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks))\n        } else {\n          tr.delete(undoable.from, undoable.to)\n        }\n        dispatch(tr)\n      }\n      return true\n    }\n  }\n  return false\n}\n","import {InputRule} from \"./inputrules\"\n\n// :: InputRule Converts double dashes to an emdash.\nexport const emDash = new InputRule(/--$/, \"—\")\n// :: InputRule Converts three dots to an ellipsis character.\nexport const ellipsis = new InputRule(/\\.\\.\\.$/, \"…\")\n// :: InputRule “Smart” opening double quotes.\nexport const openDoubleQuote = new InputRule(/(?:^|[\\s\\{\\[\\(\\<'\"\\u2018\\u201C])(\")$/, \"“\")\n// :: InputRule “Smart” closing double quotes.\nexport const closeDoubleQuote = new InputRule(/\"$/, \"”\")\n// :: InputRule “Smart” opening single quotes.\nexport const openSingleQuote = new InputRule(/(?:^|[\\s\\{\\[\\(\\<'\"\\u2018\\u201C])(')$/, \"‘\")\n// :: InputRule “Smart” closing single quotes.\nexport const closeSingleQuote = new InputRule(/'$/, \"’\")\n\n// :: [InputRule] Smart-quote related input rules.\nexport const smartQuotes = [openDoubleQuote, closeDoubleQuote, openSingleQuote, closeSingleQuote]\n","import {InputRule} from \"./inputrules\"\nimport {findWrapping, canJoin} from \"prosemirror-transform\"\n\n// :: (RegExp, NodeType, ?union<Object, ([string]) → ?Object>, ?([string], Node) → bool) → InputRule\n// Build an input rule for automatically wrapping a textblock when a\n// given string is typed. The `regexp` argument is\n// directly passed through to the `InputRule` constructor. You'll\n// probably want the regexp to start with `^`, so that the pattern can\n// only occur at the start of a textblock.\n//\n// `nodeType` is the type of node to wrap in. If it needs attributes,\n// you can either pass them directly, or pass a function that will\n// compute them from the regular expression match.\n//\n// By default, if there's a node with the same type above the newly\n// wrapped node, the rule will try to [join](#transform.Transform.join) those\n// two nodes. You can pass a join predicate, which takes a regular\n// expression match and the node before the wrapped node, and can\n// return a boolean to indicate whether a join should happen.\nexport function wrappingInputRule(regexp, nodeType, getAttrs, joinPredicate) {\n  return new InputRule(regexp, (state, match, start, end) => {\n    let attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs\n    let tr = state.tr.delete(start, end)\n    let $start = tr.doc.resolve(start), range = $start.blockRange(), wrapping = range && findWrapping(range, nodeType, attrs)\n    if (!wrapping) return null\n    tr.wrap(range, wrapping)\n    let before = tr.doc.resolve(start - 1).nodeBefore\n    if (before && before.type == nodeType && canJoin(tr.doc, start - 1) &&\n        (!joinPredicate || joinPredicate(match, before)))\n      tr.join(start - 1)\n    return tr\n  })\n}\n\n// :: (RegExp, NodeType, ?union<Object, ([string]) → ?Object>) → InputRule\n// Build an input rule that changes the type of a textblock when the\n// matched text is typed into it. You'll usually want to start your\n// regexp with `^` to that it is only matched at the start of a\n// textblock. The optional `getAttrs` parameter can be used to compute\n// the new node's attributes, and works the same as in the\n// `wrappingInputRule` function.\nexport function textblockTypeInputRule(regexp, nodeType, getAttrs) {\n  return new InputRule(regexp, (state, match, start, end) => {\n    let $start = state.doc.resolve(start)\n    let attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs\n    if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), nodeType)) return null\n    return state.tr\n      .delete(start, end)\n      .setBlockType(start, start, nodeType, attrs)\n  })\n}\n"],"names":["let","const","Plugin","findWrapping","canJoin"],"mappings":"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"}