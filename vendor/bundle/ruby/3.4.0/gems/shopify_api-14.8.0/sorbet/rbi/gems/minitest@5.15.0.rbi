# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `minitest` gem.
# Please instead update this file by running `bin/tapioca gem minitest`.

::RUBY19 = T.let(T.unsafe(nil), TrueClass)

module Kernel
  private

  def describe(desc, *additional_desc, &block); end
end

module Minitest
  class << self
    def __run(reporter, options); end
    def after_run(&block); end
    def autorun; end
    def backtrace_filter; end
    def backtrace_filter=(_arg0); end
    def clock_time; end
    def extensions; end
    def extensions=(_arg0); end
    def filter_backtrace(bt); end
    def info_signal; end
    def info_signal=(_arg0); end
    def init_plugins(options); end
    def load_plugins; end
    def parallel_executor; end
    def parallel_executor=(_arg0); end
    def process_args(args = T.unsafe(nil)); end
    def reporter; end
    def reporter=(_arg0); end
    def run(args = T.unsafe(nil)); end
    def run_one_method(klass, method_name); end
  end
end

class Minitest::AbstractReporter
  include ::Mutex_m

  def lock; end
  def locked?; end
  def passed?; end
  def prerecord(klass, name); end
  def record(result); end
  def report; end
  def start; end
  def synchronize(&block); end
  def try_lock; end
  def unlock; end
end

class Minitest::Assertion < ::Exception
  def error; end
  def location; end
  def result_code; end
  def result_label; end
end

module Minitest::Assertions
  def _synchronize; end
  def assert(test, msg = T.unsafe(nil)); end
  def assert_empty(obj, msg = T.unsafe(nil)); end
  def assert_equal(exp, act, msg = T.unsafe(nil)); end
  def assert_in_delta(exp, act, delta = T.unsafe(nil), msg = T.unsafe(nil)); end
  def assert_in_epsilon(exp, act, epsilon = T.unsafe(nil), msg = T.unsafe(nil)); end
  def assert_includes(collection, obj, msg = T.unsafe(nil)); end
  def assert_instance_of(cls, obj, msg = T.unsafe(nil)); end
  def assert_kind_of(cls, obj, msg = T.unsafe(nil)); end
  def assert_match(matcher, obj, msg = T.unsafe(nil)); end
  def assert_mock(mock); end
  def assert_nil(obj, msg = T.unsafe(nil)); end
  def assert_operator(o1, op, o2 = T.unsafe(nil), msg = T.unsafe(nil)); end
  def assert_output(stdout = T.unsafe(nil), stderr = T.unsafe(nil)); end
  def assert_path_exists(path, msg = T.unsafe(nil)); end
  def assert_predicate(o1, op, msg = T.unsafe(nil)); end
  def assert_raises(*exp); end
  def assert_respond_to(obj, meth, msg = T.unsafe(nil)); end
  def assert_same(exp, act, msg = T.unsafe(nil)); end
  def assert_send(send_ary, m = T.unsafe(nil)); end
  def assert_silent; end
  def assert_throws(sym, msg = T.unsafe(nil)); end
  def capture_io; end
  def capture_subprocess_io; end
  def diff(exp, act); end
  def exception_details(e, msg); end
  def fail_after(y, m, d, msg); end
  def flunk(msg = T.unsafe(nil)); end
  def message(msg = T.unsafe(nil), ending = T.unsafe(nil), &default); end
  def mu_pp(obj); end
  def mu_pp_for_diff(obj); end
  def pass(_msg = T.unsafe(nil)); end
  def refute(test, msg = T.unsafe(nil)); end
  def refute_empty(obj, msg = T.unsafe(nil)); end
  def refute_equal(exp, act, msg = T.unsafe(nil)); end
  def refute_in_delta(exp, act, delta = T.unsafe(nil), msg = T.unsafe(nil)); end
  def refute_in_epsilon(a, b, epsilon = T.unsafe(nil), msg = T.unsafe(nil)); end
  def refute_includes(collection, obj, msg = T.unsafe(nil)); end
  def refute_instance_of(cls, obj, msg = T.unsafe(nil)); end
  def refute_kind_of(cls, obj, msg = T.unsafe(nil)); end
  def refute_match(matcher, obj, msg = T.unsafe(nil)); end
  def refute_nil(obj, msg = T.unsafe(nil)); end
  def refute_operator(o1, op, o2 = T.unsafe(nil), msg = T.unsafe(nil)); end
  def refute_path_exists(path, msg = T.unsafe(nil)); end
  def refute_predicate(o1, op, msg = T.unsafe(nil)); end
  def refute_respond_to(obj, meth, msg = T.unsafe(nil)); end
  def refute_same(exp, act, msg = T.unsafe(nil)); end
  def skip(msg = T.unsafe(nil), bt = T.unsafe(nil)); end
  def skip_until(y, m, d, msg); end
  def skipped?; end
  def things_to_diff(exp, act); end

  class << self
    def diff; end
    def diff=(o); end
  end
end

Minitest::Assertions::E = T.let(T.unsafe(nil), String)
Minitest::Assertions::UNDEFINED = T.let(T.unsafe(nil), Object)

class Minitest::BacktraceFilter
  def filter(bt); end
end

Minitest::BacktraceFilter::MT_RE = T.let(T.unsafe(nil), Regexp)

class Minitest::CompositeReporter < ::Minitest::AbstractReporter
  def initialize(*reporters); end

  def <<(reporter); end
  def io; end
  def passed?; end
  def prerecord(klass, name); end
  def record(result); end
  def report; end
  def reporters; end
  def reporters=(_arg0); end
  def start; end
end

Minitest::ENCS = T.let(T.unsafe(nil), TrueClass)

class Minitest::Expectation < ::Struct
  def ctx; end
  def ctx=(_); end
  def must_be(*args); end
  def must_be_close_to(*args); end
  def must_be_empty(*args); end
  def must_be_instance_of(*args); end
  def must_be_kind_of(*args); end
  def must_be_nil(*args); end
  def must_be_same_as(*args); end
  def must_be_silent(*args); end
  def must_be_within_delta(*args); end
  def must_be_within_epsilon(*args); end
  def must_equal(*args); end
  def must_include(*args); end
  def must_match(*args); end
  def must_output(*args); end
  def must_raise(*args); end
  def must_respond_to(*args); end
  def must_throw(*args); end
  def path_must_exist(*args); end
  def path_wont_exist(*args); end
  def target; end
  def target=(_); end
  def wont_be(*args); end
  def wont_be_close_to(*args); end
  def wont_be_empty(*args); end
  def wont_be_instance_of(*args); end
  def wont_be_kind_of(*args); end
  def wont_be_nil(*args); end
  def wont_be_same_as(*args); end
  def wont_be_within_delta(*args); end
  def wont_be_within_epsilon(*args); end
  def wont_equal(*args); end
  def wont_include(*args); end
  def wont_match(*args); end
  def wont_respond_to(*args); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

module Minitest::Expectations
  def must_be(*args); end
  def must_be_close_to(*args); end
  def must_be_empty(*args); end
  def must_be_instance_of(*args); end
  def must_be_kind_of(*args); end
  def must_be_nil(*args); end
  def must_be_same_as(*args); end
  def must_be_silent(*args); end
  def must_be_within_delta(*args); end
  def must_be_within_epsilon(*args); end
  def must_equal(*args); end
  def must_include(*args); end
  def must_match(*args); end
  def must_output(*args); end
  def must_raise(*args); end
  def must_respond_to(*args); end
  def must_throw(*args); end
  def path_must_exist(*args); end
  def path_wont_exist(*args); end
  def wont_be(*args); end
  def wont_be_close_to(*args); end
  def wont_be_empty(*args); end
  def wont_be_instance_of(*args); end
  def wont_be_kind_of(*args); end
  def wont_be_nil(*args); end
  def wont_be_same_as(*args); end
  def wont_be_within_delta(*args); end
  def wont_be_within_epsilon(*args); end
  def wont_equal(*args); end
  def wont_include(*args); end
  def wont_match(*args); end
  def wont_respond_to(*args); end
end

module Minitest::Guard
  def jruby?(platform = T.unsafe(nil)); end
  def maglev?(platform = T.unsafe(nil)); end
  def mri?(platform = T.unsafe(nil)); end
  def osx?(platform = T.unsafe(nil)); end
  def rubinius?(platform = T.unsafe(nil)); end
  def windows?(platform = T.unsafe(nil)); end
end

class Minitest::Mock
  def initialize(delegator = T.unsafe(nil)); end

  def ===(*args, &b); end
  def __call(name, data); end
  def __respond_to?(*_arg0); end
  def class(*args, &b); end
  def expect(name, retval, args = T.unsafe(nil), &blk); end
  def inspect(*args, &b); end
  def instance_eval(*args, &b); end
  def instance_variables(*args, &b); end
  def method_missing(sym, *args, &block); end
  def object_id(*args, &b); end
  def public_send(*args, &b); end
  def respond_to?(sym, include_private = T.unsafe(nil)); end
  def send(*args, &b); end
  def to_s(*args, &b); end
  def verify; end

  private

  def respond_to_missing?(*args, &b); end
end

module Minitest::Parallel; end

class Minitest::Parallel::Executor
  def initialize(size); end

  def <<(work); end
  def shutdown; end
  def size; end
  def start; end
end

module Minitest::Parallel::Test
  def _synchronize; end
end

module Minitest::Parallel::Test::ClassMethods
  def run_one_method(klass, method_name, reporter); end
  def test_order; end
end

class Minitest::ProgressReporter < ::Minitest::Reporter
  def prerecord(klass, name); end
  def record(result); end
end

module Minitest::Reportable
  def class_name; end
  def error?; end
  def location; end
  def passed?; end
  def result_code; end
  def skipped?; end
end

class Minitest::Reporter < ::Minitest::AbstractReporter
  def initialize(io = T.unsafe(nil), options = T.unsafe(nil)); end

  def io; end
  def io=(_arg0); end
  def options; end
  def options=(_arg0); end
end

class Minitest::Result < ::Minitest::Runnable
  include ::Minitest::Reportable

  def class_name; end
  def klass; end
  def klass=(_arg0); end
  def source_location; end
  def source_location=(_arg0); end
  def to_s; end

  class << self
    def from(runnable); end
  end
end

class Minitest::Runnable
  def initialize(name); end

  def assertions; end
  def assertions=(_arg0); end
  def failure; end
  def failures; end
  def failures=(_arg0); end
  def marshal_dump; end
  def marshal_load(ary); end
  def name; end
  def name=(o); end
  def passed?; end
  def result_code; end
  def run; end
  def skipped?; end
  def time; end
  def time=(_arg0); end
  def time_it; end

  class << self
    def inherited(klass); end
    def methods_matching(re); end
    def on_signal(name, action); end
    def reset; end
    def run(reporter, options = T.unsafe(nil)); end
    def run_one_method(klass, method_name, reporter); end
    def runnable_methods; end
    def runnables; end
    def with_info_handler(reporter, &block); end
  end
end

Minitest::Runnable::SIGNALS = T.let(T.unsafe(nil), Hash)

class Minitest::Skip < ::Minitest::Assertion
  def result_label; end
end

class Minitest::Spec < ::Minitest::Test
  include ::Minitest::Spec::DSL::InstanceMethods
  extend ::Minitest::Spec::DSL

  def initialize(name); end

  class << self
    def current; end
  end
end

module Minitest::Spec::DSL
  def after(_type = T.unsafe(nil), &block); end
  def before(_type = T.unsafe(nil), &block); end
  def children; end
  def create(name, desc); end
  def desc; end
  def describe_stack; end
  def it(desc = T.unsafe(nil), &block); end
  def let(name, &block); end
  def name; end
  def nuke_test_methods!; end
  def register_spec_type(*args, &block); end
  def spec_type(desc, *additional); end
  def specify(desc = T.unsafe(nil), &block); end
  def subject(&block); end
  def to_s; end

  class << self
    def extended(obj); end
  end
end

module Minitest::Spec::DSL::InstanceMethods
  def _(value = T.unsafe(nil), &block); end
  def before_setup; end
  def expect(value = T.unsafe(nil), &block); end
  def value(value = T.unsafe(nil), &block); end
end

Minitest::Spec::DSL::TYPES = T.let(T.unsafe(nil), Array)
Minitest::Spec::TYPES = T.let(T.unsafe(nil), Array)

class Minitest::StatisticsReporter < ::Minitest::Reporter
  def initialize(io = T.unsafe(nil), options = T.unsafe(nil)); end

  def assertions; end
  def assertions=(_arg0); end
  def count; end
  def count=(_arg0); end
  def errors; end
  def errors=(_arg0); end
  def failures; end
  def failures=(_arg0); end
  def passed?; end
  def record(result); end
  def report; end
  def results; end
  def results=(_arg0); end
  def skips; end
  def skips=(_arg0); end
  def start; end
  def start_time; end
  def start_time=(_arg0); end
  def total_time; end
  def total_time=(_arg0); end
end

class Minitest::SummaryReporter < ::Minitest::StatisticsReporter
  def aggregated_results(io); end
  def old_sync; end
  def old_sync=(_arg0); end
  def report; end
  def start; end
  def statistics; end
  def summary; end
  def sync; end
  def sync=(_arg0); end
  def to_s; end

  private

  def binary_string; end
end

class Minitest::Test < ::Minitest::Runnable
  include ::Minitest::Assertions
  include ::Minitest::Reportable
  include ::Minitest::Test::LifecycleHooks
  include ::Minitest::Guard
  include ::Mocha::ParameterMatchers
  include ::Mocha::Hooks
  include ::Mocha::API
  include ::Mocha::Integration::MiniTest::Adapter
  include ::WebMock::API
  extend ::Minitest::Guard

  def assert_request_not_requested(*args); end
  def assert_request_not_requested_with_assertions_count(*args); end
  def assert_request_requested(*args); end
  def assert_request_requested_with_assertions_count(*args); end
  def capture_exceptions; end
  def class_name; end
  def run; end
  def sanitize_exception(e); end
  def teardown; end
  def teardown_with_webmock; end
  def teardown_without_webmock; end
  def with_info_handler(&block); end

  private

  def assert_request_not_requested_without_assertions_count(request, options = T.unsafe(nil)); end
  def assert_request_requested_without_assertions_count(request, options = T.unsafe(nil)); end

  class << self
    def i_suck_and_my_tests_are_order_dependent!; end
    def io_lock; end
    def io_lock=(_arg0); end
    def make_my_diffs_pretty!; end
    def parallelize_me!; end
    def runnable_methods; end
    def test_order; end
  end
end

module Minitest::Test::LifecycleHooks
  def after_setup; end
  def after_teardown; end
  def before_setup; end
  def before_teardown; end
  def setup; end
  def teardown; end
end

Minitest::Test::PASSTHROUGH_EXCEPTIONS = T.let(T.unsafe(nil), Array)
Minitest::Test::TEARDOWN_METHODS = T.let(T.unsafe(nil), Array)

class Minitest::UnexpectedError < ::Minitest::Assertion
  def initialize(error); end

  def backtrace; end
  def error; end
  def error=(_arg0); end
  def message; end
  def result_label; end
end

class Minitest::Unit
  class << self
    def after_tests(&b); end
    def autorun; end
  end
end

class Minitest::Unit::TestCase < ::Minitest::Test
  class << self
    def inherited(klass); end
  end
end

Minitest::Unit::VERSION = T.let(T.unsafe(nil), String)
Minitest::VERSION = T.let(T.unsafe(nil), String)
class MockExpectationError < ::StandardError; end

class Module
  def infect_an_assertion(meth, new_name, dont_flip = T.unsafe(nil)); end
end

Module::DELEGATION_RESERVED_KEYWORDS = T.let(T.unsafe(nil), Array)
Module::DELEGATION_RESERVED_METHOD_NAMES = T.let(T.unsafe(nil), Set)
Module::RUBY_RESERVED_KEYWORDS = T.let(T.unsafe(nil), Array)

class Object < ::BasicObject
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  include ::Kernel
  include ::JSON::Ext::Generator::GeneratorMethods::Object
  include ::PP::ObjectMixin
  include ::Minitest::Expectations
  include ::Mocha::ParameterMatchers::InstanceMethods
  include ::Mocha::Inspect::ObjectMethods
  include ::Mocha::ObjectMethods

  def stub(name, val_or_callable, *block_args); end
end
