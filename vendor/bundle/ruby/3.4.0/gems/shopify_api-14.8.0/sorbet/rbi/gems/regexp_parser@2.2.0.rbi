# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `regexp_parser` gem.
# Please instead update this file by running `bin/tapioca gem regexp_parser`.

module Regexp::Expression; end

class Regexp::Expression::Alternation < ::Regexp::Expression::SequenceOperation
  def alternatives; end
  def match_length; end
end

Regexp::Expression::Alternation::OPERAND = Regexp::Expression::Alternative
class Regexp::Expression::Alternative < ::Regexp::Expression::Sequence; end
module Regexp::Expression::Anchor; end
Regexp::Expression::Anchor::BOL = Regexp::Expression::Anchor::BeginningOfLine
Regexp::Expression::Anchor::BOS = Regexp::Expression::Anchor::BeginningOfString

class Regexp::Expression::Anchor::Base < ::Regexp::Expression::Base
  def match_length; end
end

class Regexp::Expression::Anchor::BeginningOfLine < ::Regexp::Expression::Anchor::Base; end
class Regexp::Expression::Anchor::BeginningOfString < ::Regexp::Expression::Anchor::Base; end
Regexp::Expression::Anchor::EOL = Regexp::Expression::Anchor::EndOfLine
Regexp::Expression::Anchor::EOS = Regexp::Expression::Anchor::EndOfString
Regexp::Expression::Anchor::EOSobEOL = Regexp::Expression::Anchor::EndOfStringOrBeforeEndOfLine
class Regexp::Expression::Anchor::EndOfLine < ::Regexp::Expression::Anchor::Base; end
class Regexp::Expression::Anchor::EndOfString < ::Regexp::Expression::Anchor::Base; end
class Regexp::Expression::Anchor::EndOfStringOrBeforeEndOfLine < ::Regexp::Expression::Anchor::Base; end
class Regexp::Expression::Anchor::MatchStart < ::Regexp::Expression::Anchor::Base; end
class Regexp::Expression::Anchor::NonWordBoundary < ::Regexp::Expression::Anchor::Base; end
class Regexp::Expression::Anchor::WordBoundary < ::Regexp::Expression::Anchor::Base; end
module Regexp::Expression::Assertion; end

class Regexp::Expression::Assertion::Base < ::Regexp::Expression::Group::Base
  def match_length; end
end

class Regexp::Expression::Assertion::Lookahead < ::Regexp::Expression::Assertion::Base; end
class Regexp::Expression::Assertion::Lookbehind < ::Regexp::Expression::Assertion::Base; end
class Regexp::Expression::Assertion::NegativeLookahead < ::Regexp::Expression::Assertion::Base; end
class Regexp::Expression::Assertion::NegativeLookbehind < ::Regexp::Expression::Assertion::Base; end
module Regexp::Expression::Backreference; end

class Regexp::Expression::Backreference::Base < ::Regexp::Expression::Base
  def match_length; end
  def referenced_expression; end
  def referenced_expression=(_arg0); end

  private

  def initialize_copy(orig); end
end

class Regexp::Expression::Backreference::Name < ::Regexp::Expression::Backreference::Base
  def initialize(token, options = T.unsafe(nil)); end

  def name; end
  def reference; end
end

class Regexp::Expression::Backreference::NameCall < ::Regexp::Expression::Backreference::Name; end

class Regexp::Expression::Backreference::NameRecursionLevel < ::Regexp::Expression::Backreference::Name
  def initialize(token, options = T.unsafe(nil)); end

  def recursion_level; end
end

class Regexp::Expression::Backreference::Number < ::Regexp::Expression::Backreference::Base
  def initialize(token, options = T.unsafe(nil)); end

  def number; end
  def reference; end
end

class Regexp::Expression::Backreference::NumberCall < ::Regexp::Expression::Backreference::Number; end
class Regexp::Expression::Backreference::NumberCallRelative < ::Regexp::Expression::Backreference::NumberRelative; end

class Regexp::Expression::Backreference::NumberRecursionLevel < ::Regexp::Expression::Backreference::Number
  def initialize(token, options = T.unsafe(nil)); end

  def recursion_level; end
end

class Regexp::Expression::Backreference::NumberRelative < ::Regexp::Expression::Backreference::Number
  def effective_number; end
  def effective_number=(_arg0); end
  def reference; end
end

class Regexp::Expression::Base
  include ::RuboCop::Ext::RegexpParser::Expression::Base

  def initialize(token, options = T.unsafe(nil)); end

  def =~(string, offset = T.unsafe(nil)); end
  def a?; end
  def ascii_classes?; end
  def attributes; end
  def base_length; end
  def case_insensitive?; end
  def coded_offset; end
  def conditional_level; end
  def conditional_level=(_arg0); end
  def d?; end
  def default_classes?; end
  def extended?; end
  def free_spacing?; end
  def full_length; end
  def greedy?; end
  def i?; end
  def ignore_case?; end
  def is?(test_token, test_type = T.unsafe(nil)); end
  def lazy?; end
  def level; end
  def level=(_arg0); end
  def m?; end
  def match(string, offset = T.unsafe(nil)); end
  def match?(string); end
  def matches?(string); end
  def multiline?; end
  def nesting_level; end
  def nesting_level=(_arg0); end
  def offset; end
  def one_of?(scope, top = T.unsafe(nil)); end
  def options; end
  def options=(_arg0); end
  def possessive?; end
  def quantified?; end
  def quantifier; end
  def quantifier=(_arg0); end
  def quantifier_affix(expression_format); end
  def quantify(token, text, min = T.unsafe(nil), max = T.unsafe(nil), mode = T.unsafe(nil)); end
  def quantity; end
  def reluctant?; end
  def repetitions; end
  def set_level; end
  def set_level=(_arg0); end
  def starts_at; end
  def strfre(format = T.unsafe(nil), indent_offset = T.unsafe(nil), index = T.unsafe(nil)); end
  def strfregexp(format = T.unsafe(nil), indent_offset = T.unsafe(nil), index = T.unsafe(nil)); end
  def terminal?; end
  def text; end
  def text=(_arg0); end
  def to_h; end
  def to_re(format = T.unsafe(nil)); end
  def to_s(format = T.unsafe(nil)); end
  def token; end
  def token=(_arg0); end
  def ts; end
  def ts=(_arg0); end
  def type; end
  def type=(_arg0); end
  def type?(test_type); end
  def u?; end
  def unicode_classes?; end
  def unquantified_clone; end
  def x?; end

  private

  def initialize_copy(orig); end
end

class Regexp::Expression::CharacterSet < ::Regexp::Expression::Subexpression
  include ::RuboCop::Ext::RegexpParser::Expression::CharacterSet

  def initialize(token, options = T.unsafe(nil)); end

  def close; end
  def closed; end
  def closed=(_arg0); end
  def closed?; end
  def match_length; end
  def negate; end
  def negated?; end
  def negative; end
  def negative=(_arg0); end
  def negative?; end
  def to_s(format = T.unsafe(nil)); end
end

class Regexp::Expression::CharacterSet::IntersectedSequence < ::Regexp::Expression::Sequence
  def match_length; end
end

class Regexp::Expression::CharacterSet::Intersection < ::Regexp::Expression::SequenceOperation
  def match_length; end
end

Regexp::Expression::CharacterSet::Intersection::OPERAND = Regexp::Expression::CharacterSet::IntersectedSequence

class Regexp::Expression::CharacterSet::Range < ::Regexp::Expression::Subexpression
  def <<(exp); end
  def complete?; end
  def match_length; end
  def starts_at; end
  def to_s(_format = T.unsafe(nil)); end
  def ts; end
end

module Regexp::Expression::CharacterType; end
class Regexp::Expression::CharacterType::Any < ::Regexp::Expression::CharacterType::Base; end

class Regexp::Expression::CharacterType::Base < ::Regexp::Expression::Base
  def match_length; end
end

class Regexp::Expression::CharacterType::Digit < ::Regexp::Expression::CharacterType::Base; end
class Regexp::Expression::CharacterType::ExtendedGrapheme < ::Regexp::Expression::CharacterType::Base; end
class Regexp::Expression::CharacterType::Hex < ::Regexp::Expression::CharacterType::Base; end
class Regexp::Expression::CharacterType::Linebreak < ::Regexp::Expression::CharacterType::Base; end
class Regexp::Expression::CharacterType::NonDigit < ::Regexp::Expression::CharacterType::Base; end
class Regexp::Expression::CharacterType::NonHex < ::Regexp::Expression::CharacterType::Base; end
class Regexp::Expression::CharacterType::NonSpace < ::Regexp::Expression::CharacterType::Base; end
class Regexp::Expression::CharacterType::NonWord < ::Regexp::Expression::CharacterType::Base; end
class Regexp::Expression::CharacterType::Space < ::Regexp::Expression::CharacterType::Base; end
class Regexp::Expression::CharacterType::Word < ::Regexp::Expression::CharacterType::Base; end
class Regexp::Expression::Comment < ::Regexp::Expression::FreeSpace; end
module Regexp::Expression::Conditional; end
class Regexp::Expression::Conditional::Branch < ::Regexp::Expression::Sequence; end

class Regexp::Expression::Conditional::Condition < ::Regexp::Expression::Base
  def match_length; end
  def reference; end
  def referenced_expression; end
  def referenced_expression=(_arg0); end

  private

  def initialize_copy(orig); end
end

class Regexp::Expression::Conditional::Expression < ::Regexp::Expression::Subexpression
  def <<(exp); end
  def add_sequence(active_opts = T.unsafe(nil)); end
  def branch(active_opts = T.unsafe(nil)); end
  def branches; end
  def condition; end
  def condition=(exp); end
  def match_length; end
  def reference; end
  def referenced_expression; end
  def referenced_expression=(_arg0); end
  def to_s(format = T.unsafe(nil)); end

  private

  def initialize_copy(orig); end
end

class Regexp::Expression::Conditional::TooManyBranches < ::Regexp::Parser::Error
  def initialize; end
end

module Regexp::Expression::EscapeSequence; end

class Regexp::Expression::EscapeSequence::AbstractMetaControlSequence < ::Regexp::Expression::EscapeSequence::Base
  def char; end

  private

  def control_sequence_to_s(control_sequence); end
  def meta_char_to_codepoint(meta_char); end
end

class Regexp::Expression::EscapeSequence::AsciiEscape < ::Regexp::Expression::EscapeSequence::Base; end
class Regexp::Expression::EscapeSequence::Backspace < ::Regexp::Expression::EscapeSequence::Base; end

class Regexp::Expression::EscapeSequence::Base < ::Regexp::Expression::Base
  def char; end
  def codepoint; end
  def match_length; end
end

class Regexp::Expression::EscapeSequence::Bell < ::Regexp::Expression::EscapeSequence::Base; end
class Regexp::Expression::EscapeSequence::Codepoint < ::Regexp::Expression::EscapeSequence::Base; end

class Regexp::Expression::EscapeSequence::CodepointList < ::Regexp::Expression::EscapeSequence::Base
  def char; end
  def chars; end
  def codepoint; end
  def codepoints; end
  def match_length; end
end

class Regexp::Expression::EscapeSequence::Control < ::Regexp::Expression::EscapeSequence::AbstractMetaControlSequence
  def codepoint; end
end

class Regexp::Expression::EscapeSequence::FormFeed < ::Regexp::Expression::EscapeSequence::Base; end
class Regexp::Expression::EscapeSequence::Hex < ::Regexp::Expression::EscapeSequence::Base; end

class Regexp::Expression::EscapeSequence::Literal < ::Regexp::Expression::EscapeSequence::Base
  def char; end
end

class Regexp::Expression::EscapeSequence::Meta < ::Regexp::Expression::EscapeSequence::AbstractMetaControlSequence
  def codepoint; end
end

class Regexp::Expression::EscapeSequence::MetaControl < ::Regexp::Expression::EscapeSequence::AbstractMetaControlSequence
  def codepoint; end
end

class Regexp::Expression::EscapeSequence::Newline < ::Regexp::Expression::EscapeSequence::Base; end

class Regexp::Expression::EscapeSequence::Octal < ::Regexp::Expression::EscapeSequence::Base
  def char; end
end

class Regexp::Expression::EscapeSequence::Return < ::Regexp::Expression::EscapeSequence::Base; end
class Regexp::Expression::EscapeSequence::Tab < ::Regexp::Expression::EscapeSequence::Base; end
class Regexp::Expression::EscapeSequence::VerticalTab < ::Regexp::Expression::EscapeSequence::Base; end

class Regexp::Expression::FreeSpace < ::Regexp::Expression::Base
  def match_length; end
  def quantify(_token, _text, _min = T.unsafe(nil), _max = T.unsafe(nil), _mode = T.unsafe(nil)); end
end

module Regexp::Expression::Group; end

class Regexp::Expression::Group::Absence < ::Regexp::Expression::Group::Base
  def match_length; end
end

class Regexp::Expression::Group::Atomic < ::Regexp::Expression::Group::Base; end

class Regexp::Expression::Group::Base < ::Regexp::Expression::Subexpression
  def capturing?; end
  def comment?; end
  def to_s(format = T.unsafe(nil)); end
end

class Regexp::Expression::Group::Capture < ::Regexp::Expression::Group::Base
  def capturing?; end
  def identifier; end
  def number; end
  def number=(_arg0); end
  def number_at_level; end
  def number_at_level=(_arg0); end
end

class Regexp::Expression::Group::Comment < ::Regexp::Expression::Group::Base
  def comment?; end
  def to_s(_format = T.unsafe(nil)); end
end

class Regexp::Expression::Group::Named < ::Regexp::Expression::Group::Capture
  def initialize(token, options = T.unsafe(nil)); end

  def identifier; end
  def name; end

  private

  def initialize_copy(orig); end
end

class Regexp::Expression::Group::Options < ::Regexp::Expression::Group::Base
  def option_changes; end
  def option_changes=(_arg0); end

  private

  def initialize_copy(orig); end
end

class Regexp::Expression::Group::Passive < ::Regexp::Expression::Group::Base
  def initialize(*_arg0); end

  def implicit=(_arg0); end
  def implicit?; end
  def to_s(format = T.unsafe(nil)); end
end

module Regexp::Expression::Keep; end

class Regexp::Expression::Keep::Mark < ::Regexp::Expression::Base
  def match_length; end
end

class Regexp::Expression::Literal < ::Regexp::Expression::Base
  def match_length; end
end

Regexp::Expression::MatchLength = Regexp::MatchLength

class Regexp::Expression::PosixClass < ::Regexp::Expression::Base
  def match_length; end
  def name; end
  def negative?; end
end

class Regexp::Expression::Quantifier
  def initialize(token, text, min, max, mode); end

  def ==(other); end
  def eq(other); end
  def greedy?; end
  def lazy?; end
  def max; end
  def min; end
  def mode; end
  def possessive?; end
  def reluctant?; end
  def text; end
  def to_h; end
  def to_s; end
  def to_str; end
  def token; end

  private

  def initialize_copy(orig); end
end

Regexp::Expression::Quantifier::MODES = T.let(T.unsafe(nil), Array)

class Regexp::Expression::Root < ::Regexp::Expression::Subexpression
  class << self
    def build(options = T.unsafe(nil)); end
    def build_token; end
  end
end

class Regexp::Expression::Sequence < ::Regexp::Expression::Subexpression
  def quantify(token, text, min = T.unsafe(nil), max = T.unsafe(nil), mode = T.unsafe(nil)); end
  def starts_at; end
  def ts; end

  class << self
    def add_to(subexpression, params = T.unsafe(nil), active_opts = T.unsafe(nil)); end
    def at_levels(level, set_level, conditional_level); end
  end
end

class Regexp::Expression::SequenceOperation < ::Regexp::Expression::Subexpression
  def <<(exp); end
  def add_sequence(active_opts = T.unsafe(nil)); end
  def operands; end
  def operator; end
  def sequences; end
  def starts_at; end
  def to_s(format = T.unsafe(nil)); end
  def ts; end
end

class Regexp::Expression::Subexpression < ::Regexp::Expression::Base
  include ::Enumerable

  def initialize(token, options = T.unsafe(nil)); end

  def <<(exp); end
  def [](*args, &block); end
  def at(*args, &block); end
  def dig(*indices); end
  def each(*args, &block); end
  def each_expression(include_self = T.unsafe(nil)); end
  def empty?(*args, &block); end
  def expressions; end
  def expressions=(_arg0); end
  def fetch(*args, &block); end
  def flat_map(include_self = T.unsafe(nil)); end
  def index(*args, &block); end
  def inner_match_length; end
  def join(*args, &block); end
  def last(*args, &block); end
  def length(*args, &block); end
  def match_length; end
  def strfre_tree(format = T.unsafe(nil), include_self = T.unsafe(nil), separator = T.unsafe(nil)); end
  def strfregexp_tree(format = T.unsafe(nil), include_self = T.unsafe(nil), separator = T.unsafe(nil)); end
  def te; end
  def to_h; end
  def to_s(format = T.unsafe(nil)); end
  def traverse(include_self = T.unsafe(nil), &block); end
  def values_at(*args, &block); end
  def walk(include_self = T.unsafe(nil), &block); end

  private

  def initialize_copy(orig); end
end

module Regexp::Expression::UnicodeProperty; end
class Regexp::Expression::UnicodeProperty::Age < ::Regexp::Expression::UnicodeProperty::Base; end
class Regexp::Expression::UnicodeProperty::Alnum < ::Regexp::Expression::UnicodeProperty::Base; end
class Regexp::Expression::UnicodeProperty::Alpha < ::Regexp::Expression::UnicodeProperty::Base; end
class Regexp::Expression::UnicodeProperty::Any < ::Regexp::Expression::UnicodeProperty::Base; end
class Regexp::Expression::UnicodeProperty::Ascii < ::Regexp::Expression::UnicodeProperty::Base; end
class Regexp::Expression::UnicodeProperty::Assigned < ::Regexp::Expression::UnicodeProperty::Base; end

class Regexp::Expression::UnicodeProperty::Base < ::Regexp::Expression::Base
  def match_length; end
  def name; end
  def negative?; end
  def shortcut; end
end

class Regexp::Expression::UnicodeProperty::Blank < ::Regexp::Expression::UnicodeProperty::Base; end
class Regexp::Expression::UnicodeProperty::Block < ::Regexp::Expression::UnicodeProperty::Base; end
class Regexp::Expression::UnicodeProperty::Cntrl < ::Regexp::Expression::UnicodeProperty::Base; end
module Regexp::Expression::UnicodeProperty::Codepoint; end
class Regexp::Expression::UnicodeProperty::Codepoint::Any < ::Regexp::Expression::UnicodeProperty::Codepoint::Base; end
class Regexp::Expression::UnicodeProperty::Codepoint::Base < ::Regexp::Expression::UnicodeProperty::Base; end
class Regexp::Expression::UnicodeProperty::Codepoint::Control < ::Regexp::Expression::UnicodeProperty::Codepoint::Base; end
class Regexp::Expression::UnicodeProperty::Codepoint::Format < ::Regexp::Expression::UnicodeProperty::Codepoint::Base; end
class Regexp::Expression::UnicodeProperty::Codepoint::PrivateUse < ::Regexp::Expression::UnicodeProperty::Codepoint::Base; end
class Regexp::Expression::UnicodeProperty::Codepoint::Surrogate < ::Regexp::Expression::UnicodeProperty::Codepoint::Base; end
class Regexp::Expression::UnicodeProperty::Codepoint::Unassigned < ::Regexp::Expression::UnicodeProperty::Codepoint::Base; end
class Regexp::Expression::UnicodeProperty::Derived < ::Regexp::Expression::UnicodeProperty::Base; end
class Regexp::Expression::UnicodeProperty::Digit < ::Regexp::Expression::UnicodeProperty::Base; end
class Regexp::Expression::UnicodeProperty::Emoji < ::Regexp::Expression::UnicodeProperty::Base; end
class Regexp::Expression::UnicodeProperty::Graph < ::Regexp::Expression::UnicodeProperty::Base; end
module Regexp::Expression::UnicodeProperty::Letter; end
class Regexp::Expression::UnicodeProperty::Letter::Any < ::Regexp::Expression::UnicodeProperty::Letter::Base; end
class Regexp::Expression::UnicodeProperty::Letter::Base < ::Regexp::Expression::UnicodeProperty::Base; end
class Regexp::Expression::UnicodeProperty::Letter::Cased < ::Regexp::Expression::UnicodeProperty::Letter::Base; end
class Regexp::Expression::UnicodeProperty::Letter::Lowercase < ::Regexp::Expression::UnicodeProperty::Letter::Base; end
class Regexp::Expression::UnicodeProperty::Letter::Modifier < ::Regexp::Expression::UnicodeProperty::Letter::Base; end
class Regexp::Expression::UnicodeProperty::Letter::Other < ::Regexp::Expression::UnicodeProperty::Letter::Base; end
class Regexp::Expression::UnicodeProperty::Letter::Titlecase < ::Regexp::Expression::UnicodeProperty::Letter::Base; end
class Regexp::Expression::UnicodeProperty::Letter::Uppercase < ::Regexp::Expression::UnicodeProperty::Letter::Base; end
class Regexp::Expression::UnicodeProperty::Lower < ::Regexp::Expression::UnicodeProperty::Base; end
module Regexp::Expression::UnicodeProperty::Mark; end
class Regexp::Expression::UnicodeProperty::Mark::Any < ::Regexp::Expression::UnicodeProperty::Mark::Base; end
class Regexp::Expression::UnicodeProperty::Mark::Base < ::Regexp::Expression::UnicodeProperty::Base; end
class Regexp::Expression::UnicodeProperty::Mark::Combining < ::Regexp::Expression::UnicodeProperty::Mark::Base; end
class Regexp::Expression::UnicodeProperty::Mark::Enclosing < ::Regexp::Expression::UnicodeProperty::Mark::Base; end
class Regexp::Expression::UnicodeProperty::Mark::Nonspacing < ::Regexp::Expression::UnicodeProperty::Mark::Base; end
class Regexp::Expression::UnicodeProperty::Mark::Spacing < ::Regexp::Expression::UnicodeProperty::Mark::Base; end
class Regexp::Expression::UnicodeProperty::Newline < ::Regexp::Expression::UnicodeProperty::Base; end
module Regexp::Expression::UnicodeProperty::Number; end
class Regexp::Expression::UnicodeProperty::Number::Any < ::Regexp::Expression::UnicodeProperty::Number::Base; end
class Regexp::Expression::UnicodeProperty::Number::Base < ::Regexp::Expression::UnicodeProperty::Base; end
class Regexp::Expression::UnicodeProperty::Number::Decimal < ::Regexp::Expression::UnicodeProperty::Number::Base; end
class Regexp::Expression::UnicodeProperty::Number::Letter < ::Regexp::Expression::UnicodeProperty::Number::Base; end
class Regexp::Expression::UnicodeProperty::Number::Other < ::Regexp::Expression::UnicodeProperty::Number::Base; end
class Regexp::Expression::UnicodeProperty::Print < ::Regexp::Expression::UnicodeProperty::Base; end
class Regexp::Expression::UnicodeProperty::Punct < ::Regexp::Expression::UnicodeProperty::Base; end
module Regexp::Expression::UnicodeProperty::Punctuation; end
class Regexp::Expression::UnicodeProperty::Punctuation::Any < ::Regexp::Expression::UnicodeProperty::Punctuation::Base; end
class Regexp::Expression::UnicodeProperty::Punctuation::Base < ::Regexp::Expression::UnicodeProperty::Base; end
class Regexp::Expression::UnicodeProperty::Punctuation::Close < ::Regexp::Expression::UnicodeProperty::Punctuation::Base; end
class Regexp::Expression::UnicodeProperty::Punctuation::Connector < ::Regexp::Expression::UnicodeProperty::Punctuation::Base; end
class Regexp::Expression::UnicodeProperty::Punctuation::Dash < ::Regexp::Expression::UnicodeProperty::Punctuation::Base; end
class Regexp::Expression::UnicodeProperty::Punctuation::Final < ::Regexp::Expression::UnicodeProperty::Punctuation::Base; end
class Regexp::Expression::UnicodeProperty::Punctuation::Initial < ::Regexp::Expression::UnicodeProperty::Punctuation::Base; end
class Regexp::Expression::UnicodeProperty::Punctuation::Open < ::Regexp::Expression::UnicodeProperty::Punctuation::Base; end
class Regexp::Expression::UnicodeProperty::Punctuation::Other < ::Regexp::Expression::UnicodeProperty::Punctuation::Base; end
class Regexp::Expression::UnicodeProperty::Script < ::Regexp::Expression::UnicodeProperty::Base; end
module Regexp::Expression::UnicodeProperty::Separator; end
class Regexp::Expression::UnicodeProperty::Separator::Any < ::Regexp::Expression::UnicodeProperty::Separator::Base; end
class Regexp::Expression::UnicodeProperty::Separator::Base < ::Regexp::Expression::UnicodeProperty::Base; end
class Regexp::Expression::UnicodeProperty::Separator::Line < ::Regexp::Expression::UnicodeProperty::Separator::Base; end
class Regexp::Expression::UnicodeProperty::Separator::Paragraph < ::Regexp::Expression::UnicodeProperty::Separator::Base; end
class Regexp::Expression::UnicodeProperty::Separator::Space < ::Regexp::Expression::UnicodeProperty::Separator::Base; end
class Regexp::Expression::UnicodeProperty::Space < ::Regexp::Expression::UnicodeProperty::Base; end
module Regexp::Expression::UnicodeProperty::Symbol; end
class Regexp::Expression::UnicodeProperty::Symbol::Any < ::Regexp::Expression::UnicodeProperty::Symbol::Base; end
class Regexp::Expression::UnicodeProperty::Symbol::Base < ::Regexp::Expression::UnicodeProperty::Base; end
class Regexp::Expression::UnicodeProperty::Symbol::Currency < ::Regexp::Expression::UnicodeProperty::Symbol::Base; end
class Regexp::Expression::UnicodeProperty::Symbol::Math < ::Regexp::Expression::UnicodeProperty::Symbol::Base; end
class Regexp::Expression::UnicodeProperty::Symbol::Modifier < ::Regexp::Expression::UnicodeProperty::Symbol::Base; end
class Regexp::Expression::UnicodeProperty::Symbol::Other < ::Regexp::Expression::UnicodeProperty::Symbol::Base; end
class Regexp::Expression::UnicodeProperty::Upper < ::Regexp::Expression::UnicodeProperty::Base; end
class Regexp::Expression::UnicodeProperty::Word < ::Regexp::Expression::UnicodeProperty::Base; end
class Regexp::Expression::UnicodeProperty::XPosixPunct < ::Regexp::Expression::UnicodeProperty::Base; end
class Regexp::Expression::UnicodeProperty::Xdigit < ::Regexp::Expression::UnicodeProperty::Base; end

class Regexp::Expression::WhiteSpace < ::Regexp::Expression::FreeSpace
  def merge(exp); end
end

class Regexp::Lexer
  def lex(input, syntax = T.unsafe(nil), options: T.unsafe(nil), &block); end

  private

  def ascend(type, token); end
  def break_codepoint_list(token); end
  def break_literal(token); end
  def conditional_nesting; end
  def conditional_nesting=(_arg0); end
  def descend(type, token); end
  def merge_condition(current); end
  def nesting; end
  def nesting=(_arg0); end
  def set_nesting; end
  def set_nesting=(_arg0); end
  def shift; end
  def shift=(_arg0); end
  def tokens; end
  def tokens=(_arg0); end

  class << self
    def lex(input, syntax = T.unsafe(nil), options: T.unsafe(nil), &block); end
    def scan(input, syntax = T.unsafe(nil), options: T.unsafe(nil), &block); end
  end
end

Regexp::Lexer::CLOSING_TOKENS = T.let(T.unsafe(nil), Array)
Regexp::Lexer::CONDITION_TOKENS = T.let(T.unsafe(nil), Array)
Regexp::Lexer::OPENING_TOKENS = T.let(T.unsafe(nil), Array)

class Regexp::MatchLength
  include ::Enumerable

  def initialize(exp, opts = T.unsafe(nil)); end

  def each(opts = T.unsafe(nil)); end
  def endless_each; end
  def fixed?; end
  def include?(length); end
  def inspect; end
  def max; end
  def min; end
  def minmax; end
  def to_re; end

  private

  def base_max; end
  def base_max=(_arg0); end
  def base_min; end
  def base_min=(_arg0); end
  def exp_class; end
  def exp_class=(_arg0); end
  def max_rep; end
  def max_rep=(_arg0); end
  def min_rep; end
  def min_rep=(_arg0); end
  def reify; end
  def reify=(_arg0); end
  def test_regexp; end

  class << self
    def of(obj); end
  end
end

class Regexp::Parser
  include ::Regexp::Expression
  include ::Regexp::Expression::UnicodeProperty

  def parse(input, syntax = T.unsafe(nil), options: T.unsafe(nil), &block); end

  private

  def active_opts; end
  def anchor(token); end
  def assign_effective_number(exp); end
  def assign_referenced_expressions; end
  def backref(token); end
  def captured_group_count_at_level; end
  def captured_group_counts; end
  def captured_group_counts=(_arg0); end
  def close_completed_character_set_range; end
  def close_group; end
  def close_set; end
  def conditional(token); end
  def conditional_nesting; end
  def conditional_nesting=(_arg0); end
  def count_captured_group; end
  def decrease_nesting; end
  def escape(token); end
  def extract_options(input, options); end
  def free_space(token); end
  def group(token); end
  def increase_level(exp); end
  def intersection(token); end
  def interval(target_node, token); end
  def keep(token); end
  def literal(token); end
  def meta(token); end
  def negate_set; end
  def nest(exp); end
  def nest_conditional(exp); end
  def nesting; end
  def nesting=(_arg0); end
  def node; end
  def node=(_arg0); end
  def open_group(token); end
  def open_set(token); end
  def options_group(token); end
  def options_stack; end
  def options_stack=(_arg0); end
  def parse_token(token); end
  def posixclass(token); end
  def property(token); end
  def quantifier(token); end
  def range(token); end
  def root; end
  def root=(_arg0); end
  def sequence_operation(klass, token); end
  def set(token); end
  def switching_options; end
  def switching_options=(_arg0); end
  def total_captured_group_count; end
  def type(token); end
  def update_transplanted_subtree(exp, new_parent); end

  class << self
    def parse(input, syntax = T.unsafe(nil), options: T.unsafe(nil), &block); end
  end
end

Regexp::Parser::ENC_FLAGS = T.let(T.unsafe(nil), Array)
class Regexp::Parser::Error < ::StandardError; end
Regexp::Parser::MOD_FLAGS = T.let(T.unsafe(nil), Array)
class Regexp::Parser::ParserError < ::Regexp::Parser::Error; end
Regexp::Parser::UPTokens = Regexp::Syntax::Token::UnicodeProperty

class Regexp::Parser::UnknownTokenError < ::Regexp::Parser::ParserError
  def initialize(type, token); end
end

class Regexp::Parser::UnknownTokenTypeError < ::Regexp::Parser::ParserError
  def initialize(type, token); end
end

Regexp::Parser::VERSION = T.let(T.unsafe(nil), String)

class Regexp::Scanner
  def emit(type, token, text); end
  def scan(input_object, options: T.unsafe(nil), &block); end

  private

  def append_literal(data, ts, te); end
  def block; end
  def block=(_arg0); end
  def char_pos; end
  def char_pos=(_arg0); end
  def conditional_stack; end
  def conditional_stack=(_arg0); end
  def copy(data, ts, te); end
  def emit_literal; end
  def emit_meta_control_sequence(data, ts, te, token); end
  def emit_options(text); end
  def free_spacing; end
  def free_spacing=(_arg0); end
  def free_spacing?(input_object, options); end
  def group_depth; end
  def group_depth=(_arg0); end
  def in_group?; end
  def in_set?; end
  def literal; end
  def literal=(_arg0); end
  def set_depth; end
  def set_depth=(_arg0); end
  def spacing_stack; end
  def spacing_stack=(_arg0); end
  def tokens; end
  def tokens=(_arg0); end
  def validation_error(type, what, reason); end

  class << self
    def long_prop_map; end
    def scan(input_object, options: T.unsafe(nil), &block); end
    def short_prop_map; end
  end
end

class Regexp::Scanner::InvalidBackrefError < ::Regexp::Scanner::ValidationError
  def initialize(what, reason); end
end

class Regexp::Scanner::InvalidGroupError < ::Regexp::Scanner::ValidationError
  def initialize(what, reason); end
end

class Regexp::Scanner::InvalidGroupOption < ::Regexp::Scanner::ValidationError
  def initialize(option, text); end
end

class Regexp::Scanner::InvalidSequenceError < ::Regexp::Scanner::ValidationError
  def initialize(what = T.unsafe(nil), where = T.unsafe(nil)); end
end

class Regexp::Scanner::PrematureEndError < ::Regexp::Scanner::ScannerError
  def initialize(where = T.unsafe(nil)); end
end

class Regexp::Scanner::ScannerError < ::Regexp::Parser::Error; end

class Regexp::Scanner::UnknownUnicodePropertyError < ::Regexp::Scanner::ValidationError
  def initialize(name); end
end

class Regexp::Scanner::ValidationError < ::Regexp::Parser::Error
  def initialize(reason); end
end

module Regexp::Syntax
  private

  def comparable_version(name); end
  def const_missing(const_name); end
  def fallback_version_class(version); end
  def inherit_from_version(parent_version, new_version); end
  def new(name); end
  def specified_versions; end
  def supported?(name); end
  def version_class(version); end
  def version_const_name(version_string); end
  def warn_if_future_version(const_name); end

  class << self
    def comparable_version(name); end
    def const_missing(const_name); end
    def fallback_version_class(version); end
    def inherit_from_version(parent_version, new_version); end
    def new(name); end
    def specified_versions; end
    def supported?(name); end
    def version_class(version); end
    def version_const_name(version_string); end
    def warn_if_future_version(const_name); end
  end
end

class Regexp::Syntax::Any < ::Regexp::Syntax::Base
  def initialize; end

  def implements!(_type, _token); end
  def implements?(_type, _token); end
end

class Regexp::Syntax::Base
  include ::Regexp::Syntax::Token

  def initialize; end

  def check!(type, token); end
  def check?(type, token); end
  def excludes(type, tokens); end
  def features; end
  def implementations(type); end
  def implements(type, tokens); end
  def implements!(type, token); end
  def implements?(type, token); end
  def normalize(type, token); end
  def normalize_backref(type, token); end
  def normalize_group(type, token); end

  class << self
    def inspect; end
  end
end

class Regexp::Syntax::InvalidVersionNameError < ::Regexp::Syntax::SyntaxError
  def initialize(name); end
end

class Regexp::Syntax::NotImplementedError < ::Regexp::Syntax::SyntaxError
  def initialize(syntax, type, token); end
end

class Regexp::Syntax::SyntaxError < ::Regexp::Parser::Error; end
module Regexp::Syntax::Token; end
Regexp::Syntax::Token::All = T.let(T.unsafe(nil), Array)
module Regexp::Syntax::Token::Anchor; end
Regexp::Syntax::Token::Anchor::All = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::Anchor::Basic = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::Anchor::Extended = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::Anchor::MatchStart = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::Anchor::String = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::Anchor::Type = T.let(T.unsafe(nil), Symbol)
module Regexp::Syntax::Token::Assertion; end
Regexp::Syntax::Token::Assertion::All = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::Assertion::Lookahead = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::Assertion::Lookbehind = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::Assertion::Type = T.let(T.unsafe(nil), Symbol)
module Regexp::Syntax::Token::Backreference; end
Regexp::Syntax::Token::Backreference::All = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::Backreference::Name = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::Backreference::Number = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::Backreference::Plain = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::Backreference::RecursionLevel = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::Backreference::Type = T.let(T.unsafe(nil), Symbol)
module Regexp::Syntax::Token::CharacterSet; end
Regexp::Syntax::Token::CharacterSet::All = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::CharacterSet::Basic = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::CharacterSet::Extended = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::CharacterSet::Type = T.let(T.unsafe(nil), Symbol)
module Regexp::Syntax::Token::CharacterType; end
Regexp::Syntax::Token::CharacterType::All = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::CharacterType::Basic = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::CharacterType::Clustered = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::CharacterType::Extended = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::CharacterType::Hex = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::CharacterType::Type = T.let(T.unsafe(nil), Symbol)
module Regexp::Syntax::Token::Conditional; end
Regexp::Syntax::Token::Conditional::All = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::Conditional::Condition = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::Conditional::Delimiters = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::Conditional::Separator = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::Conditional::Type = T.let(T.unsafe(nil), Symbol)
module Regexp::Syntax::Token::Escape; end
Regexp::Syntax::Token::Escape::ASCII = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::Escape::All = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::Escape::Basic = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::Escape::Control = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::Escape::Hex = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::Escape::Meta = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::Escape::Octal = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::Escape::Type = T.let(T.unsafe(nil), Symbol)
Regexp::Syntax::Token::Escape::Unicode = T.let(T.unsafe(nil), Array)
module Regexp::Syntax::Token::FreeSpace; end
Regexp::Syntax::Token::FreeSpace::All = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::FreeSpace::Type = T.let(T.unsafe(nil), Symbol)
module Regexp::Syntax::Token::Group; end
Regexp::Syntax::Token::Group::All = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::Group::Atomic = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::Group::Basic = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::Group::Comment = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::Group::Extended = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::Group::Named = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::Group::Passive = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::Group::Type = T.let(T.unsafe(nil), Symbol)
Regexp::Syntax::Token::Group::V1_8_6 = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::Group::V2_4_1 = T.let(T.unsafe(nil), Array)
module Regexp::Syntax::Token::Keep; end
Regexp::Syntax::Token::Keep::All = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::Keep::Mark = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::Keep::Type = T.let(T.unsafe(nil), Symbol)
module Regexp::Syntax::Token::Literal; end
Regexp::Syntax::Token::Literal::All = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::Literal::Type = T.let(T.unsafe(nil), Symbol)
Regexp::Syntax::Token::Map = T.let(T.unsafe(nil), Hash)
module Regexp::Syntax::Token::Meta; end
Regexp::Syntax::Token::Meta::All = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::Meta::Basic = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::Meta::Extended = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::Meta::Type = T.let(T.unsafe(nil), Symbol)
module Regexp::Syntax::Token::PosixClass; end
Regexp::Syntax::Token::PosixClass::All = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::PosixClass::Extensions = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::PosixClass::NonType = T.let(T.unsafe(nil), Symbol)
Regexp::Syntax::Token::PosixClass::Standard = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::PosixClass::Type = T.let(T.unsafe(nil), Symbol)
module Regexp::Syntax::Token::Quantifier; end
Regexp::Syntax::Token::Quantifier::All = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::Quantifier::Greedy = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::Quantifier::Interval = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::Quantifier::IntervalAll = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::Quantifier::IntervalPossessive = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::Quantifier::IntervalReluctant = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::Quantifier::Possessive = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::Quantifier::Reluctant = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::Quantifier::Type = T.let(T.unsafe(nil), Symbol)
module Regexp::Syntax::Token::SubexpressionCall; end
Regexp::Syntax::Token::SubexpressionCall::All = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::SubexpressionCall::Name = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::SubexpressionCall::Number = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::Types = T.let(T.unsafe(nil), Array)
module Regexp::Syntax::Token::UnicodeProperty; end
Regexp::Syntax::Token::UnicodeProperty::Age = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::Age_V1_9_3 = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::Age_V2_0_0 = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::Age_V2_2_0 = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::Age_V2_3_0 = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::Age_V2_4_0 = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::Age_V2_5_0 = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::Age_V2_6_0 = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::Age_V2_6_2 = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::Age_V2_6_3 = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::Age_V3_1_0 = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::All = T.let(T.unsafe(nil), Array)
module Regexp::Syntax::Token::UnicodeProperty::Category; end
Regexp::Syntax::Token::UnicodeProperty::Category::All = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::Category::Codepoint = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::Category::Letter = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::Category::Mark = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::Category::Number = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::Category::Punctuation = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::Category::Separator = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::Category::Symbol = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::CharType_V1_9_0 = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::CharType_V2_5_0 = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::Derived = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::Derived_V1_9_0 = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::Derived_V2_0_0 = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::Derived_V2_4_0 = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::Derived_V2_5_0 = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::Emoji = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::Emoji_V2_5_0 = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::NonType = T.let(T.unsafe(nil), Symbol)
Regexp::Syntax::Token::UnicodeProperty::POSIX = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::Script = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::Script_V1_9_0 = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::Script_V1_9_3 = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::Script_V2_0_0 = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::Script_V2_2_0 = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::Script_V2_3_0 = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::Script_V2_4_0 = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::Script_V2_5_0 = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::Script_V2_6_0 = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::Script_V2_6_2 = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::Script_V3_1_0 = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::Type = T.let(T.unsafe(nil), Symbol)
Regexp::Syntax::Token::UnicodeProperty::UnicodeBlock = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::UnicodeBlock_V1_9_0 = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::UnicodeBlock_V2_0_0 = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::UnicodeBlock_V2_2_0 = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::UnicodeBlock_V2_3_0 = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::UnicodeBlock_V2_4_0 = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::UnicodeBlock_V2_5_0 = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::UnicodeBlock_V2_6_0 = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::UnicodeBlock_V2_6_2 = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::UnicodeBlock_V3_1_0 = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::V1_9_0 = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::V1_9_3 = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::V2_0_0 = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::V2_2_0 = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::V2_3_0 = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::V2_4_0 = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::V2_5_0 = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::V2_6_0 = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::V2_6_2 = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::V2_6_3 = T.let(T.unsafe(nil), Array)
Regexp::Syntax::Token::UnicodeProperty::V3_1_0 = T.let(T.unsafe(nil), Array)

class Regexp::Syntax::UnknownSyntaxNameError < ::Regexp::Syntax::SyntaxError
  def initialize(name); end
end

class Regexp::Syntax::V1_8_6 < ::Regexp::Syntax::Base
  def initialize; end
end

class Regexp::Syntax::V1_9 < ::Regexp::Syntax::V1_9_3; end

class Regexp::Syntax::V1_9_1 < ::Regexp::Syntax::V1_8_6
  def initialize; end
end

class Regexp::Syntax::V1_9_3 < ::Regexp::Syntax::V1_9_1
  def initialize; end
end

class Regexp::Syntax::V2_0_0 < ::Regexp::Syntax::V1_9
  def initialize; end
end

class Regexp::Syntax::V2_1 < ::Regexp::Syntax::V2_0_0; end
class Regexp::Syntax::V2_2 < ::Regexp::Syntax::V2_2_0; end

class Regexp::Syntax::V2_2_0 < ::Regexp::Syntax::V2_1
  def initialize; end
end

class Regexp::Syntax::V2_3 < ::Regexp::Syntax::V2_3_0; end

class Regexp::Syntax::V2_3_0 < ::Regexp::Syntax::V2_2
  def initialize; end
end

class Regexp::Syntax::V2_4 < ::Regexp::Syntax::V2_4_1; end

class Regexp::Syntax::V2_4_0 < ::Regexp::Syntax::V2_3
  def initialize; end
end

class Regexp::Syntax::V2_4_1 < ::Regexp::Syntax::V2_4_0
  def initialize; end
end

class Regexp::Syntax::V2_5 < ::Regexp::Syntax::V2_5_0; end

class Regexp::Syntax::V2_5_0 < ::Regexp::Syntax::V2_4
  def initialize; end
end

class Regexp::Syntax::V2_6_0 < ::Regexp::Syntax::V2_5
  def initialize; end
end

class Regexp::Syntax::V2_6_2 < ::Regexp::Syntax::V2_6_0
  def initialize; end
end

class Regexp::Syntax::V2_6_3 < ::Regexp::Syntax::V2_6_2
  def initialize; end
end

class Regexp::Syntax::V3_1_0 < ::Regexp::Syntax::V2_6_3
  def initialize; end
end

Regexp::Syntax::VERSION_CONST_REGEXP = T.let(T.unsafe(nil), Regexp)
Regexp::Syntax::VERSION_FORMAT = T.let(T.unsafe(nil), String)
Regexp::Syntax::VERSION_REGEXP = T.let(T.unsafe(nil), Regexp)
Regexp::TOKEN_KEYS = T.let(T.unsafe(nil), Array)

class Regexp::Token < ::Struct
  def conditional_level; end
  def conditional_level=(_); end
  def length; end
  def level; end
  def level=(_); end
  def next; end
  def next=(_arg0); end
  def offset; end
  def previous; end
  def previous=(_arg0); end
  def set_level; end
  def set_level=(_); end
  def te; end
  def te=(_); end
  def text; end
  def text=(_); end
  def token; end
  def token=(_); end
  def ts; end
  def ts=(_); end
  def type; end
  def type=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end
