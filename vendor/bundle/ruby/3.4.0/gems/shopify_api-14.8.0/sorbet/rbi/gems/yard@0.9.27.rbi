# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `yard` gem.
# Please instead update this file by running `bin/tapioca gem yard`.

class Array
  include ::Enumerable
  include ::JSON::Ext::Generator::GeneratorMethods::Array
  include ::Mocha::Inspect::ArrayMethods

  def place(*values); end
end

class File < ::IO
  class << self
    def cleanpath(path, rel_root = T.unsafe(nil)); end
    def open!(file, *args, &block); end
    def read_binary(file); end
    def relative_path(from, to); end
  end
end

File::RELATIVE_PARENTDIR = T.let(T.unsafe(nil), String)
File::RELATIVE_SAMEDIR = T.let(T.unsafe(nil), String)

module Gem
  class << self
    def source_index; end
  end
end

Gem::Cache = Gem::SourceIndex
Gem::ConfigMap = T.let(T.unsafe(nil), Hash)

module Gem::DefaultUserInteraction
  include ::Gem::Text
end

Gem::HAVE_OPENSSL = T.let(T.unsafe(nil), String)

class Gem::List
  include ::Enumerable
end

Gem::RbConfigPriorities = T.let(T.unsafe(nil), Array)

class Gem::RequestSet
  include ::TSort
end

class Gem::Resolver
  include ::Gem::Resolver::Molinillo::UI
  include ::Gem::Resolver::Molinillo::SpecificationProvider
end

class Gem::Resolver::CurrentSet < ::Gem::Resolver::Set
  def find_all(req); end
end

class Gem::Resolver::LocalSpecification < ::Gem::Resolver::SpecSpecification
  def installable_platform?; end
  def local?; end
  def pretty_print(q); end
end

class Gem::Resolver::RequirementList
  include ::Enumerable
end

Gem::RubyGemsVersion = T.let(T.unsafe(nil), String)

class Gem::RuntimeRequirementNotMetError < ::Gem::InstallError
  def message; end
  def suggestion; end
  def suggestion=(_arg0); end
end

class Gem::Source
  include ::Comparable
  include ::Gem::Text
end

class Gem::SourceIndex
  include ::Enumerable

  def initialize(specifications = T.unsafe(nil)); end

  def ==(other); end
  def add_spec(gem_spec, name = T.unsafe(nil)); end
  def add_specs(*gem_specs); end
  def all_gems; end
  def dump; end
  def each(&block); end
  def find_name(gem_name, requirement = T.unsafe(nil)); end
  def gem_signature(gem_full_name); end
  def gems; end
  def index_signature; end
  def latest_specs(include_prerelease = T.unsafe(nil)); end
  def length; end
  def load_gems_in(*spec_dirs); end
  def outdated; end
  def prerelease_gems; end
  def prerelease_specs; end
  def refresh!; end
  def released_gems; end
  def released_specs; end
  def remove_spec(full_name); end
  def search(gem_pattern, platform_only = T.unsafe(nil)); end
  def size; end
  def spec_dirs; end
  def spec_dirs=(_arg0); end
  def specification(full_name); end

  class << self
    def from_gems_in(*spec_dirs); end
    def from_installed_gems(*deprecated); end
    def installed_spec_directories; end
    def load_specification(file_name); end
  end
end

class Gem::SpecificationPolicy
  include ::Gem::Text
  include ::Gem::DefaultUserInteraction
  include ::Gem::UserInteraction

  def initialize(specification); end

  def packaging; end
  def packaging=(_arg0); end
  def validate(strict = T.unsafe(nil)); end
  def validate_dependencies; end
  def validate_duplicate_dependencies; end
  def validate_metadata; end
  def validate_optional(strict); end
  def validate_permissions; end
  def validate_required!; end

  private

  def error(statement); end
  def help_text; end
  def validate_array_attribute(field); end
  def validate_array_attributes; end
  def validate_attribute_present(attribute); end
  def validate_authors_field; end
  def validate_extensions; end
  def validate_lazy_metadata; end
  def validate_licenses; end
  def validate_licenses_length; end
  def validate_name; end
  def validate_nil_attributes; end
  def validate_non_files; end
  def validate_platform; end
  def validate_removed_attributes; end
  def validate_require_paths; end
  def validate_required_attributes; end
  def validate_rubygems_version; end
  def validate_self_inclusion_in_files_list; end
  def validate_shebang_line_in(executable); end
  def validate_specification_version; end
  def validate_values; end
  def warning(statement); end
end

Gem::SpecificationPolicy::HOMEPAGE_URI_PATTERN = T.let(T.unsafe(nil), Regexp)
Gem::SpecificationPolicy::LAZY = T.let(T.unsafe(nil), String)
Gem::SpecificationPolicy::LAZY_PATTERN = T.let(T.unsafe(nil), Regexp)
Gem::SpecificationPolicy::METADATA_LINK_KEYS = T.let(T.unsafe(nil), Array)
Gem::SpecificationPolicy::SPECIAL_CHARACTERS = T.let(T.unsafe(nil), Regexp)
Gem::SpecificationPolicy::VALID_NAME_PATTERN = T.let(T.unsafe(nil), Regexp)
Gem::SpecificationPolicy::VALID_URI_PATTERN = T.let(T.unsafe(nil), Regexp)

class Gem::StreamUI
  extend ::Gem::Deprecate
end

class Gem::StreamUI::SilentDownloadReporter
  def initialize(out_stream, *args); end

  def done; end
  def fetch(filename, filesize); end
  def update(current); end
end

class Gem::StreamUI::SilentProgressReporter
  def initialize(out_stream, size, initial_message, terminal_message = T.unsafe(nil)); end

  def count; end
  def done; end
  def updated(message); end
end

class Gem::StreamUI::SimpleProgressReporter
  include ::Gem::Text
  include ::Gem::DefaultUserInteraction

  def initialize(out_stream, size, initial_message, terminal_message = T.unsafe(nil)); end

  def count; end
  def done; end
  def updated(message); end
end

class Gem::StreamUI::ThreadedDownloadReporter
  def initialize(out_stream, *args); end

  def done; end
  def fetch(file_name, *args); end
  def file_name; end
  def update(bytes); end

  private

  def locked_puts(message); end
end

Gem::StreamUI::ThreadedDownloadReporter::MUTEX = T.let(T.unsafe(nil), Thread::Mutex)

class Gem::StreamUI::VerboseProgressReporter
  include ::Gem::Text
  include ::Gem::DefaultUserInteraction

  def initialize(out_stream, size, initial_message, terminal_message = T.unsafe(nil)); end

  def count; end
  def done; end
  def updated(message); end
end

Gem::UNTAINT = T.let(T.unsafe(nil), Proc)

class Gem::UninstallError < ::Gem::Exception
  def spec; end
  def spec=(_arg0); end
end

Gem::UnsatisfiableDepedencyError = Gem::UnsatisfiableDependencyError

module Gem::UserInteraction
  include ::Gem::Text
  include ::Gem::DefaultUserInteraction
end

class Gem::Version
  include ::Comparable
end

Gem::Version::Requirement = Gem::Requirement

class IRB::SLex
  def initialize; end

  def create(token, preproc = T.unsafe(nil), postproc = T.unsafe(nil)); end
  def def_rule(token, preproc = T.unsafe(nil), postproc = T.unsafe(nil), &block); end
  def def_rules(*tokens, &block); end
  def inspect; end
  def match(token); end
  def postproc(token); end
  def preproc(token, proc); end
  def search(token); end
end

IRB::SLex::DOUT = T.let(T.unsafe(nil), IRB::Notifier::CompositeNotifier)
IRB::SLex::D_DEBUG = T.let(T.unsafe(nil), IRB::Notifier::LeveledNotifier)
IRB::SLex::D_DETAIL = T.let(T.unsafe(nil), IRB::Notifier::LeveledNotifier)
IRB::SLex::D_WARN = T.let(T.unsafe(nil), IRB::Notifier::LeveledNotifier)

class IRB::SLex::Node
  def initialize(preproc = T.unsafe(nil), postproc = T.unsafe(nil)); end

  def create_subnode(chrs, preproc = T.unsafe(nil), postproc = T.unsafe(nil)); end
  def match(chrs, op = T.unsafe(nil)); end
  def match_io(io, op = T.unsafe(nil)); end
  def postproc; end
  def postproc=(_arg0); end
  def preproc; end
  def preproc=(_arg0); end
  def search(chrs, opt = T.unsafe(nil)); end
end

class Insertion
  def initialize(list, value); end

  def after(val, recursive = T.unsafe(nil)); end
  def after_any(val); end
  def before(val, recursive = T.unsafe(nil)); end
  def before_any(val); end

  private

  def insertion(val, rel, recursive = T.unsafe(nil), list = T.unsafe(nil)); end
end

class Module
  def class_name; end
end

Module::DELEGATION_RESERVED_KEYWORDS = T.let(T.unsafe(nil), Array)
Module::DELEGATION_RESERVED_METHOD_NAMES = T.let(T.unsafe(nil), Set)
Module::RUBY_RESERVED_KEYWORDS = T.let(T.unsafe(nil), Array)
RUBY19 = T.let(T.unsafe(nil), TrueClass)

class Rack::Request
  include ::Rack::Request::Env
  include ::Rack::Request::Helpers

  def initialize(env); end

  def delete_param(k); end
  def params; end
  def query; end
  def update_param(k, v); end
  def version_supplied; end
  def version_supplied=(_arg0); end
  def xhr?; end

  class << self
    def ip_filter; end
    def ip_filter=(_arg0); end
  end
end

Rack::Request::ALLOWED_SCHEMES = T.let(T.unsafe(nil), Array)
Rack::Request::SCHEME_WHITELIST = T.let(T.unsafe(nil), Array)

class String
  include ::Comparable
  include ::JSON::Ext::Generator::GeneratorMethods::String
  extend ::JSON::Ext::Generator::GeneratorMethods::String::Extend

  def shell_split; end
end

String::BLANK_RE = T.let(T.unsafe(nil), Regexp)
String::ENCODED_BLANKS = T.let(T.unsafe(nil), Concurrent::Map)

class SymbolHash < ::Hash
  def initialize(symbolize_value = T.unsafe(nil)); end

  def [](key); end
  def []=(key, value); end
  def delete(key); end
  def has_key?(key); end
  def key?(key); end
  def merge(hash); end
  def merge!(hash); end
  def update(hash); end

  class << self
    def [](*hsh); end
  end
end

class WEBrick::HTTPRequest
  def version_supplied; end
  def version_supplied=(_arg0); end
  def xhr?; end
end

WEBrick::HTTPRequest::MAX_HEADER_LENGTH = T.let(T.unsafe(nil), Integer)

module YARD
  class << self
    def load_plugins; end
    def parse(*args); end
    def parse_string(*args); end
    def ruby18?; end
    def ruby19?; end
    def ruby2?; end
    def ruby3?; end
    def windows?; end
  end
end

module YARD::CLI; end

class YARD::CLI::Command
  def description; end

  protected

  def common_options(opts); end
  def load_script(file); end
  def parse_options(opts, args); end
  def unrecognized_option(err); end

  class << self
    def run(*args); end
  end
end

class YARD::CLI::CommandParser
  def initialize; end

  def run(*args); end

  private

  def commands; end
  def list_commands; end

  class << self
    def commands; end
    def commands=(_arg0); end
    def default_command; end
    def default_command=(_arg0); end
    def run(*args); end
  end
end

class YARD::CLI::Config < ::YARD::CLI::Command
  def initialize; end

  def append; end
  def append=(_arg0); end
  def as_list; end
  def as_list=(_arg0); end
  def description; end
  def gem_install_cmd; end
  def gem_install_cmd=(_arg0); end
  def key; end
  def key=(_arg0); end
  def reset; end
  def reset=(_arg0); end
  def run(*args); end
  def values; end
  def values=(_arg0); end

  private

  def configure_gemrc; end
  def encode_value(value); end
  def encode_values; end
  def list_configuration; end
  def modify_item; end
  def optparse(*args); end
  def view_item; end
end

class YARD::CLI::Diff < ::YARD::CLI::Command
  def initialize; end

  def description; end
  def run(*args); end

  private

  def added_objects(registry1, registry2); end
  def all_objects; end
  def cleanup(gemfile); end
  def expand_and_parse(gemfile, io); end
  def expand_gem(gemfile, io); end
  def generate_yardoc(dir); end
  def load_gem_data(gemfile); end
  def load_git_commit(commit); end
  def modified_objects(registry1, registry2); end
  def optparse(*args); end
  def removed_objects(registry1, registry2); end
  def require_rubygems; end
end

class YARD::CLI::Display < ::YARD::CLI::Yardoc
  def initialize(*args); end

  def description; end
  def format_objects; end
  def output_options(opts); end
  def parse_arguments(*args); end
  def run(*args); end
  def wrap_layout(contents); end
end

class YARD::CLI::Gems < ::YARD::CLI::Command
  def initialize; end

  def description; end
  def run(*args); end

  private

  def add_gems(gems); end
  def build_gems; end
  def optparse(*args); end
end

class YARD::CLI::Graph < ::YARD::CLI::YardoptsCommand
  def initialize; end

  def description; end
  def objects; end
  def options; end
  def run(*args); end

  private

  def optparse(*args); end
  def unrecognized_option(err); end
end

class YARD::CLI::GraphOptions < ::YARD::Templates::TemplateOptions
  def contents; end
  def contents=(_arg0); end
  def dependencies; end
  def dependencies=(_arg0); end
  def format; end
  def format=(_arg0); end
  def full; end
  def full=(_arg0); end
end

class YARD::CLI::Help < ::YARD::CLI::Command
  def description; end
  def run(*args); end
end

class YARD::CLI::I18n < ::YARD::CLI::Yardoc
  def initialize; end

  def description; end
  def run(*args); end

  private

  def general_options(opts); end
  def generate_pot(relative_base_path); end
end

class YARD::CLI::List < ::YARD::CLI::Command
  def description; end
  def run(*args); end
end

class YARD::CLI::MarkupTypes < ::YARD::CLI::Command
  def description; end
  def run(*args); end
end

class YARD::CLI::Server < ::YARD::CLI::Command
  def initialize; end

  def adapter; end
  def adapter=(_arg0); end
  def description; end
  def libraries; end
  def libraries=(_arg0); end
  def options; end
  def options=(_arg0); end
  def run(*args); end
  def scripts; end
  def scripts=(_arg0); end
  def server_options; end
  def server_options=(_arg0); end
  def template_paths; end
  def template_paths=(_arg0); end

  private

  def add_gems; end
  def add_gems_from_gemfile(gemfile = T.unsafe(nil)); end
  def add_libraries(args); end
  def create_library_version_if_yardopts_exist(library, dir); end
  def extract_db_from_options_file(options_file); end
  def generate_doc_for_first_time(libver); end
  def load_scripts; end
  def load_template_paths; end
  def optparse(*args); end
  def select_adapter; end
end

class YARD::CLI::Stats < ::YARD::CLI::Yardoc
  include ::YARD::Templates::Helpers::BaseHelper

  def initialize(parse = T.unsafe(nil)); end

  def all_objects; end
  def description; end
  def output(name, data, undoc = T.unsafe(nil)); end
  def parse; end
  def parse=(_arg0); end
  def print_statistics; end
  def print_undocumented_objects; end
  def run(*args); end
  def stats_for_attributes; end
  def stats_for_classes; end
  def stats_for_constants; end
  def stats_for_files; end
  def stats_for_methods; end
  def stats_for_modules; end

  private

  def general_options(opts); end
  def optparse(*args); end
  def type_statistics(type); end
end

YARD::CLI::Stats::STATS_ORDER = T.let(T.unsafe(nil), Array)

class YARD::CLI::YRI < ::YARD::CLI::Command
  def initialize; end

  def description; end
  def run(*args); end

  protected

  def cache_object(name, path); end
  def find_object(name); end
  def print_object(object); end
  def print_usage; end

  private

  def add_default_paths; end
  def add_gem_paths; end
  def load_cache; end
  def optparse(*args); end
  def try_load_object(name, cache_path); end

  class << self
    def run(*args); end
  end
end

YARD::CLI::YRI::CACHE_FILE = T.let(T.unsafe(nil), String)
YARD::CLI::YRI::DEFAULT_SEARCH_PATHS = T.let(T.unsafe(nil), Array)
YARD::CLI::YRI::SEARCH_PATHS_FILE = T.let(T.unsafe(nil), String)

class YARD::CLI::Yardoc < ::YARD::CLI::YardoptsCommand
  def initialize; end

  def all_objects; end
  def apis; end
  def apis=(_arg0); end
  def assets; end
  def assets=(_arg0); end
  def description; end
  def excluded; end
  def excluded=(_arg0); end
  def fail_on_warning; end
  def fail_on_warning=(_arg0); end
  def files; end
  def files=(_arg0); end
  def generate; end
  def generate=(_arg0); end
  def has_markup; end
  def has_markup=(_arg0); end
  def hidden_apis; end
  def hidden_apis=(_arg0); end
  def hidden_tags; end
  def hidden_tags=(_arg0); end
  def list; end
  def list=(_arg0); end
  def options; end
  def parse_arguments(*args); end
  def run(*args); end
  def save_yardoc; end
  def save_yardoc=(_arg0); end
  def statistics; end
  def statistics=(_arg0); end
  def use_cache; end
  def use_cache=(_arg0); end
  def visibilities; end
  def visibilities=(_arg0); end

  private

  def add_api_verifier; end
  def add_extra_files(*files); end
  def add_tag(tag_data, factory_method = T.unsafe(nil)); end
  def add_visibility_verifier; end
  def apply_locale; end
  def copy_assets; end
  def extra_file_valid?(file, check_exists = T.unsafe(nil)); end
  def general_options(opts); end
  def optparse(*args); end
  def output_options(opts); end
  def parse_files(*files); end
  def print_list; end
  def run_generate(checksums); end
  def run_verifier(list); end
  def tag_options(opts); end
  def verify_markup_options; end
end

class YARD::CLI::YardocOptions < ::YARD::Templates::TemplateOptions
  def file; end
  def file=(_arg0); end
  def files; end
  def files=(_arg0); end
  def format; end
  def format=(_arg0); end
  def index; end
  def index=(_arg0); end
  def item; end
  def item=(_arg0); end
  def locale; end
  def locale=(_arg0); end
  def objects; end
  def objects=(_arg0); end
  def onefile; end
  def onefile=(_arg0); end
  def readme; end
  def readme=(_arg0); end
  def serializer; end
  def serializer=(_arg0); end
  def title; end
  def title=(_arg0); end
  def verifier; end
  def verifier=(_arg0); end
end

class YARD::CLI::YardoptsCommand < ::YARD::CLI::Command
  def initialize; end

  def options_file; end
  def options_file=(_arg0); end
  def parse_arguments(*args); end
  def use_document_file; end
  def use_document_file=(_arg0); end
  def use_yardopts_file; end
  def use_yardopts_file=(_arg0); end

  protected

  def yardopts_options(opts); end

  private

  def parse_rdoc_document_file(file = T.unsafe(nil)); end
  def parse_yardopts(file = T.unsafe(nil)); end
  def parse_yardopts_options(*args); end
  def support_rdoc_document_file!(file = T.unsafe(nil)); end
  def yardopts(file = T.unsafe(nil)); end
end

YARD::CLI::YardoptsCommand::DEFAULT_YARDOPTS_FILE = T.let(T.unsafe(nil), String)
YARD::CONFIG_DIR = T.let(T.unsafe(nil), String)

module YARD::CodeObjects
  extend ::YARD::CodeObjects::NamespaceMapper
end

YARD::CodeObjects::BUILTIN_ALL = T.let(T.unsafe(nil), Array)
YARD::CodeObjects::BUILTIN_CLASSES = T.let(T.unsafe(nil), Array)
YARD::CodeObjects::BUILTIN_EXCEPTIONS = T.let(T.unsafe(nil), Array)
YARD::CodeObjects::BUILTIN_EXCEPTIONS_HASH = T.let(T.unsafe(nil), Hash)
YARD::CodeObjects::BUILTIN_MODULES = T.let(T.unsafe(nil), Array)

class YARD::CodeObjects::Base
  def initialize(namespace, name, *_arg2); end

  def ==(other); end
  def [](key); end
  def []=(key, value); end
  def add_file(file, line = T.unsafe(nil), has_comments = T.unsafe(nil)); end
  def add_tag(*tags); end
  def base_docstring; end
  def copy_to(other); end
  def docstring(locale = T.unsafe(nil)); end
  def docstring=(comments); end
  def dynamic; end
  def dynamic=(_arg0); end
  def dynamic?; end
  def eql?(other); end
  def equal?(other); end
  def file; end
  def files; end
  def format(options = T.unsafe(nil)); end
  def group; end
  def group=(_arg0); end
  def has_tag?(name); end
  def hash; end
  def inspect; end
  def line; end
  def method_missing(meth, *args, &block); end
  def name(prefix = T.unsafe(nil)); end
  def namespace; end
  def namespace=(obj); end
  def parent; end
  def parent=(obj); end
  def path; end
  def relative_path(other); end
  def root?; end
  def sep; end
  def signature; end
  def signature=(_arg0); end
  def source; end
  def source=(statement); end
  def source_type; end
  def source_type=(_arg0); end
  def tag(name); end
  def tags(name = T.unsafe(nil)); end
  def title; end
  def to_ary; end
  def to_s; end
  def type; end
  def visibility; end
  def visibility=(v); end

  protected

  def copyable_attributes; end

  private

  def format_source(source); end
  def translate_docstring(locale); end

  class << self
    def ===(other); end
    def new(namespace, name, *args, &block); end
  end
end

YARD::CodeObjects::CONSTANTMATCH = T.let(T.unsafe(nil), Regexp)
YARD::CodeObjects::CONSTANTSTART = T.let(T.unsafe(nil), Regexp)
YARD::CodeObjects::CSEP = T.let(T.unsafe(nil), String)
YARD::CodeObjects::CSEPQ = T.let(T.unsafe(nil), String)

class YARD::CodeObjects::ClassObject < ::YARD::CodeObjects::NamespaceObject
  def initialize(namespace, name, *args, &block); end

  def constants(opts = T.unsafe(nil)); end
  def inheritance_tree(include_mods = T.unsafe(nil)); end
  def inherited_constants; end
  def inherited_meths(opts = T.unsafe(nil)); end
  def is_exception?; end
  def meths(opts = T.unsafe(nil)); end
  def superclass; end
  def superclass=(object); end
end

class YARD::CodeObjects::ClassVariableObject < ::YARD::CodeObjects::Base
  def value; end
  def value=(_arg0); end
end

class YARD::CodeObjects::CodeObjectList < ::Array
  def initialize(owner = T.unsafe(nil)); end

  def <<(value); end
  def push(value); end
end

class YARD::CodeObjects::ConstantObject < ::YARD::CodeObjects::Base
  def value; end
  def value=(value); end
end

class YARD::CodeObjects::ExtendedMethodObject
  def initialize(obj); end

  def method_missing(sym, *args, &block); end
  def scope; end
end

class YARD::CodeObjects::ExtraFileObject
  def initialize(filename, contents = T.unsafe(nil)); end

  def ==(other); end
  def attributes; end
  def attributes=(_arg0); end
  def contents; end
  def contents=(contents); end
  def eql?(other); end
  def equal?(other); end
  def filename; end
  def filename=(_arg0); end
  def hash; end
  def inspect; end
  def locale; end
  def locale=(locale); end
  def name; end
  def name=(_arg0); end
  def path; end
  def title; end
  def to_s; end
  def type; end

  private

  def ensure_parsed; end
  def parse_contents(data); end
  def translate(data); end
end

YARD::CodeObjects::ISEP = T.let(T.unsafe(nil), String)
YARD::CodeObjects::ISEPQ = T.let(T.unsafe(nil), String)
YARD::CodeObjects::METHODMATCH = T.let(T.unsafe(nil), Regexp)
YARD::CodeObjects::METHODNAMEMATCH = T.let(T.unsafe(nil), Regexp)

class YARD::CodeObjects::MacroObject < ::YARD::CodeObjects::Base
  def attached?; end
  def expand(call_params = T.unsafe(nil), full_source = T.unsafe(nil), block_source = T.unsafe(nil)); end
  def macro_data; end
  def macro_data=(_arg0); end
  def method_object; end
  def method_object=(_arg0); end
  def path; end
  def sep; end

  class << self
    def apply(docstring, call_params = T.unsafe(nil), full_source = T.unsafe(nil), block_source = T.unsafe(nil), _method_object = T.unsafe(nil)); end
    def apply_macro(macro, docstring, call_params = T.unsafe(nil), full_source = T.unsafe(nil), block_source = T.unsafe(nil)); end
    def create(macro_name, data, method_object = T.unsafe(nil)); end
    def create_docstring(macro_name, data, method_object = T.unsafe(nil)); end
    def expand(macro_data, call_params = T.unsafe(nil), full_source = T.unsafe(nil), block_source = T.unsafe(nil)); end
    def find(macro_name); end
    def find_or_create(macro_name, data, method_object = T.unsafe(nil)); end
  end
end

YARD::CodeObjects::MacroObject::MACRO_MATCH = T.let(T.unsafe(nil), Regexp)

class YARD::CodeObjects::MethodObject < ::YARD::CodeObjects::Base
  def initialize(namespace, name, scope = T.unsafe(nil), &block); end

  def aliases; end
  def attr_info; end
  def constructor?; end
  def explicit; end
  def explicit=(_arg0); end
  def is_alias?; end
  def is_attribute?; end
  def is_explicit?; end
  def module_function?; end
  def name(prefix = T.unsafe(nil)); end
  def overridden_method; end
  def parameters; end
  def parameters=(_arg0); end
  def path; end
  def reader?; end
  def scope; end
  def scope=(v); end
  def sep; end
  def writer?; end

  protected

  def copyable_attributes; end
end

class YARD::CodeObjects::ModuleObject < ::YARD::CodeObjects::NamespaceObject
  def inheritance_tree(include_mods = T.unsafe(nil)); end
end

YARD::CodeObjects::NAMESPACEMATCH = T.let(T.unsafe(nil), Regexp)
YARD::CodeObjects::NSEP = T.let(T.unsafe(nil), String)
YARD::CodeObjects::NSEPQ = T.let(T.unsafe(nil), String)

module YARD::CodeObjects::NamespaceMapper
  def clear_separators; end
  def default_separator(value = T.unsafe(nil)); end
  def register_separator(sep, *valid_types); end
  def separators; end
  def separators_for_type(type); end
  def separators_match; end
  def types_for_separator(sep); end
  def unregister_separator_by_type(type); end

  class << self
    def default_separator; end
    def default_separator=(_arg0); end
    def invalidate; end
    def map; end
    def map_match; end
    def on_invalidate(&block); end
    def rev_map; end
  end
end

class YARD::CodeObjects::NamespaceObject < ::YARD::CodeObjects::Base
  def initialize(namespace, name, *args, &block); end

  def aliases; end
  def attributes; end
  def child(opts = T.unsafe(nil)); end
  def children; end
  def class_attributes; end
  def class_mixins; end
  def constants(opts = T.unsafe(nil)); end
  def cvars; end
  def groups; end
  def groups=(_arg0); end
  def included_constants; end
  def included_meths(opts = T.unsafe(nil)); end
  def instance_attributes; end
  def instance_mixins; end
  def meths(opts = T.unsafe(nil)); end
  def mixins(*scopes); end
end

YARD::CodeObjects::PROXY_MATCH = T.let(T.unsafe(nil), Regexp)

class YARD::CodeObjects::Proxy
  def initialize(namespace, name, type = T.unsafe(nil)); end

  def <=>(other); end
  def ==(other); end
  def ===(other); end
  def class; end
  def equal?(other); end
  def hash; end
  def inspect; end
  def instance_of?(klass); end
  def is_a?(klass); end
  def kind_of?(klass); end
  def method_missing(meth, *args, &block); end
  def name(prefix = T.unsafe(nil)); end
  def namespace; end
  def parent; end
  def path; end
  def respond_to?(meth, include_private = T.unsafe(nil)); end
  def root?; end
  def title; end
  def to_s; end
  def to_str; end
  def type; end
  def type=(type); end

  private

  def proxy_path; end
  def to_ary; end
  def to_obj; end

  class << self
    def ===(other); end
  end
end

class YARD::CodeObjects::ProxyMethodError < ::NoMethodError; end

class YARD::CodeObjects::RootObject < ::YARD::CodeObjects::ModuleObject
  def equal?(other); end
  def hash; end
  def inspect; end
  def path; end
  def root?; end
  def title; end
end

class YARD::Config
  class << self
    def add_ignored_plugins_file; end
    def arguments; end
    def load; end
    def load_autoload_plugins; end
    def load_commandline_plugins; end
    def load_commandline_safemode; end
    def load_gem_plugins; end
    def load_plugin(name); end
    def load_plugin_failed(name, exception); end
    def load_plugins; end
    def options; end
    def options=(_arg0); end
    def read_config_file; end
    def save; end
    def translate_plugin_name(name); end
    def translate_plugin_names; end
    def with_yardopts; end
  end
end

YARD::Config::CONFIG_DIR = T.let(T.unsafe(nil), String)
YARD::Config::CONFIG_FILE = T.let(T.unsafe(nil), String)
YARD::Config::DEFAULT_CONFIG_OPTIONS = T.let(T.unsafe(nil), Hash)
YARD::Config::IGNORED_PLUGINS = T.let(T.unsafe(nil), String)
YARD::Config::YARD_PLUGIN_PREFIX = T.let(T.unsafe(nil), Regexp)

class YARD::Docstring < ::String
  def initialize(content = T.unsafe(nil), object = T.unsafe(nil)); end

  def +(other); end
  def add_tag(*tags); end
  def all; end
  def all=(content, parse = T.unsafe(nil)); end
  def blank?(only_visible_tags = T.unsafe(nil)); end
  def delete_tag_if(&block); end
  def delete_tags(name); end
  def dup; end
  def has_tag?(name); end
  def hash_flag; end
  def hash_flag=(v); end
  def line; end
  def line_range; end
  def line_range=(_arg0); end
  def object; end
  def object=(_arg0); end
  def ref_tags; end
  def replace(content, parse = T.unsafe(nil)); end
  def resolve_reference; end
  def summary; end
  def tag(name); end
  def tags(name = T.unsafe(nil)); end
  def to_raw; end
  def to_s; end

  private

  def convert_ref_tags; end
  def parse_comments(comments); end
  def stable_sort_by(list); end

  class << self
    def default_parser; end
    def default_parser=(_arg0); end
    def new!(text, tags = T.unsafe(nil), object = T.unsafe(nil), raw_data = T.unsafe(nil), ref_object = T.unsafe(nil)); end
    def parser(*args); end
  end
end

YARD::Docstring::META_MATCH = T.let(T.unsafe(nil), Regexp)

class YARD::DocstringParser
  def initialize(library = T.unsafe(nil)); end

  def create_directive(tag_name, tag_buf); end
  def create_ref_tag(tag_name, name, object_name); end
  def create_tag(tag_name, tag_buf = T.unsafe(nil)); end
  def directives; end
  def directives=(_arg0); end
  def handler; end
  def handler=(_arg0); end
  def library; end
  def library=(_arg0); end
  def object; end
  def object=(_arg0); end
  def parse(content, object = T.unsafe(nil), handler = T.unsafe(nil)); end
  def parse_content(content); end
  def post_process; end
  def raw_text; end
  def raw_text=(_arg0); end
  def reference; end
  def reference=(_arg0); end
  def state; end
  def state=(_arg0); end
  def tag_is_directive?(tag_name); end
  def tags; end
  def tags=(_arg0); end
  def text; end
  def text=(_arg0); end
  def to_docstring; end

  private

  def call_after_parse_callbacks; end
  def call_directives_after_parse; end
  def detect_reference(content); end
  def namespace; end

  class << self
    def after_parse(&block); end
    def after_parse_callbacks; end
  end
end

YARD::DocstringParser::META_MATCH = T.let(T.unsafe(nil), Regexp)

module YARD::GemIndex
  private

  def all; end
  def each(&block); end
  def find_all_by_name(*args); end

  class << self
    def all; end
    def each(&block); end
    def find_all_by_name(*args); end
  end
end

module YARD::Handlers; end

class YARD::Handlers::Base
  include ::YARD::CodeObjects
  include ::YARD::Parser

  def initialize(source_parser, stmt); end

  def abort!; end
  def call_params; end
  def caller_method; end
  def ensure_loaded!(object, max_retries = T.unsafe(nil)); end
  def extra_state; end
  def globals; end
  def namespace; end
  def namespace=(v); end
  def owner; end
  def owner=(v); end
  def parse_block(*_arg0); end
  def parser; end
  def process; end
  def push_state(opts = T.unsafe(nil)); end
  def register(*objects); end
  def register_docstring(object, docstring = T.unsafe(nil), stmt = T.unsafe(nil)); end
  def register_dynamic(object); end
  def register_ensure_loaded(object); end
  def register_file_info(object, file = T.unsafe(nil), line = T.unsafe(nil), comments = T.unsafe(nil)); end
  def register_group(object, group = T.unsafe(nil)); end
  def register_module_function(object); end
  def register_source(object, source = T.unsafe(nil), type = T.unsafe(nil)); end
  def register_transitive_tags(object); end
  def register_visibility(object, visibility = T.unsafe(nil)); end
  def scope; end
  def scope=(v); end
  def statement; end
  def visibility; end
  def visibility=(v); end

  class << self
    def clear_subclasses; end
    def handlers; end
    def handles(*matches); end
    def handles?(statement); end
    def in_file(filename); end
    def inherited(subclass); end
    def matches_file?(filename); end
    def namespace_only; end
    def namespace_only?; end
    def process(&block); end
    def subclasses; end
  end
end

module YARD::Handlers::C; end
class YARD::Handlers::C::AliasHandler < ::YARD::Handlers::C::Base; end
YARD::Handlers::C::AliasHandler::MATCH = T.let(T.unsafe(nil), Regexp)
class YARD::Handlers::C::AttributeHandler < ::YARD::Handlers::C::Base; end
YARD::Handlers::C::AttributeHandler::MATCH = T.let(T.unsafe(nil), Regexp)

class YARD::Handlers::C::Base < ::YARD::Handlers::Base
  include ::YARD::Parser::C
  include ::YARD::Handlers::Common::MethodHandler
  include ::YARD::Handlers::C::HandlerMethods

  def ensure_variable_defined!(var, max_retries = T.unsafe(nil)); end
  def namespace_for_variable(var); end
  def namespaces; end
  def override_comments; end
  def parse_block(opts = T.unsafe(nil)); end
  def process_file(file, object); end
  def processed_files; end
  def register_docstring(object, docstring = T.unsafe(nil), stmt = T.unsafe(nil)); end
  def register_file_info(object, file = T.unsafe(nil), line = T.unsafe(nil), comments = T.unsafe(nil)); end
  def register_source(object, source = T.unsafe(nil), type = T.unsafe(nil)); end
  def register_visibility(object, visibility = T.unsafe(nil)); end
  def symbols; end

  private

  def remove_var_prefix(var); end

  class << self
    def handles?(statement, processor); end
    def statement_class(type = T.unsafe(nil)); end
  end
end

YARD::Handlers::C::Base::ERROR_CLASS_NAMES = T.let(T.unsafe(nil), Hash)
class YARD::Handlers::C::ClassHandler < ::YARD::Handlers::C::Base; end
YARD::Handlers::C::ClassHandler::MATCH1 = T.let(T.unsafe(nil), Regexp)
YARD::Handlers::C::ClassHandler::MATCH2 = T.let(T.unsafe(nil), Regexp)
class YARD::Handlers::C::ConstantHandler < ::YARD::Handlers::C::Base; end
YARD::Handlers::C::ConstantHandler::MATCH = T.let(T.unsafe(nil), Regexp)

module YARD::Handlers::C::HandlerMethods
  include ::YARD::Parser::C
  include ::YARD::CodeObjects
  include ::YARD::Handlers::Common::MethodHandler

  def handle_alias(var_name, new_name, old_name); end
  def handle_attribute(var_name, name, read, write); end
  def handle_class(var_name, class_name, parent, in_module = T.unsafe(nil)); end
  def handle_constants(type, var_name, const_name, value); end
  def handle_method(scope, var_name, name, func_name, _source_file = T.unsafe(nil)); end
  def handle_module(var_name, module_name, in_module = T.unsafe(nil)); end

  private

  def find_constant_docstring(object); end
  def find_method_body(object, symbol); end
  def record_parameters(object, symbol, src); end
end

class YARD::Handlers::C::InitHandler < ::YARD::Handlers::C::Base; end
YARD::Handlers::C::InitHandler::MATCH = T.let(T.unsafe(nil), Regexp)
class YARD::Handlers::C::MethodHandler < ::YARD::Handlers::C::Base; end
YARD::Handlers::C::MethodHandler::MATCH1 = T.let(T.unsafe(nil), Regexp)
YARD::Handlers::C::MethodHandler::MATCH2 = T.let(T.unsafe(nil), Regexp)
YARD::Handlers::C::MethodHandler::MATCH3 = T.let(T.unsafe(nil), Regexp)
class YARD::Handlers::C::MixinHandler < ::YARD::Handlers::C::Base; end
YARD::Handlers::C::MixinHandler::MATCH = T.let(T.unsafe(nil), Regexp)
class YARD::Handlers::C::ModuleHandler < ::YARD::Handlers::C::Base; end
YARD::Handlers::C::ModuleHandler::MATCH1 = T.let(T.unsafe(nil), Regexp)
YARD::Handlers::C::ModuleHandler::MATCH2 = T.let(T.unsafe(nil), Regexp)

class YARD::Handlers::C::OverrideCommentHandler < ::YARD::Handlers::C::Base
  def register_docstring(object, docstring = T.unsafe(nil), stmt = T.unsafe(nil)); end
  def register_file_info(object, file = T.unsafe(nil), line = T.unsafe(nil), comments = T.unsafe(nil)); end
end

class YARD::Handlers::C::PathHandler < ::YARD::Handlers::C::Base; end
YARD::Handlers::C::PathHandler::MATCH = T.let(T.unsafe(nil), Regexp)
class YARD::Handlers::C::StructHandler < ::YARD::Handlers::C::Base; end
YARD::Handlers::C::StructHandler::MATCH = T.let(T.unsafe(nil), Regexp)
class YARD::Handlers::C::SymbolHandler < ::YARD::Handlers::C::Base; end
YARD::Handlers::C::SymbolHandler::MATCH = T.let(T.unsafe(nil), Regexp)
module YARD::Handlers::Common; end

module YARD::Handlers::Common::MethodHandler
  def add_predicate_return_tag(obj); end
end

class YARD::Handlers::HandlerAborted < ::RuntimeError; end

class YARD::Handlers::NamespaceMissingError < ::YARD::Parser::UndocumentableError
  def initialize(object); end

  def object; end
  def object=(_arg0); end
end

class YARD::Handlers::Processor
  def initialize(parser); end

  def extra_state; end
  def extra_state=(_arg0); end
  def file; end
  def file=(_arg0); end
  def find_handlers(statement); end
  def globals; end
  def globals=(_arg0); end
  def namespace; end
  def namespace=(_arg0); end
  def owner; end
  def owner=(_arg0); end
  def parse_remaining_files; end
  def parser_type; end
  def parser_type=(_arg0); end
  def process(statements); end
  def scope; end
  def scope=(_arg0); end
  def visibility; end
  def visibility=(_arg0); end

  private

  def handler_base_class; end
  def handler_base_namespace; end
  def handles?(handler, statement); end
  def load_handlers; end

  class << self
    def namespace_for_handler; end
    def register_handler_namespace(type, ns); end
  end
end

module YARD::Handlers::Ruby; end
class YARD::Handlers::Ruby::AliasHandler < ::YARD::Handlers::Ruby::Base; end

class YARD::Handlers::Ruby::AttributeHandler < ::YARD::Handlers::Ruby::Base
  protected

  def validated_attribute_names(params); end
end

class YARD::Handlers::Ruby::Base < ::YARD::Handlers::Base
  include ::YARD::Parser::Ruby
  extend ::YARD::Parser::Ruby

  def call_params; end
  def caller_method; end
  def parse_block(inner_node, opts = T.unsafe(nil)); end

  class << self
    def handles?(node); end
    def meta_type(type); end
    def method_call(name = T.unsafe(nil)); end
  end
end

class YARD::Handlers::Ruby::ClassConditionHandler < ::YARD::Handlers::Ruby::Base
  protected

  def parse_condition; end
  def parse_else_block; end
  def parse_then_block; end
end

class YARD::Handlers::Ruby::ClassHandler < ::YARD::Handlers::Ruby::Base
  include ::YARD::Handlers::Ruby::StructHandlerMethods
  include ::YARDSorbet::Handlers::StructClassHandler

  private

  def create_struct_superclass(superclass, superclass_def); end
  def extract_parameters(superclass); end
  def parse_struct_superclass(klass, superclass); end
  def parse_superclass(superclass); end
  def struct_superclass_name(superclass); end
end

class YARD::Handlers::Ruby::ClassVariableHandler < ::YARD::Handlers::Ruby::Base; end
class YARD::Handlers::Ruby::CommentHandler < ::YARD::Handlers::Ruby::Base; end

class YARD::Handlers::Ruby::ConstantHandler < ::YARD::Handlers::Ruby::Base
  include ::YARD::Handlers::Ruby::StructHandlerMethods

  private

  def extract_parameters(superclass); end
  def process_constant(statement); end
  def process_structclass(statement); end
end

class YARD::Handlers::Ruby::DSLHandler < ::YARD::Handlers::Ruby::Base
  include ::YARD::Handlers::Ruby::DSLHandlerMethods
end

module YARD::Handlers::Ruby::DSLHandlerMethods
  include ::YARD::CodeObjects
  include ::YARD::Parser

  def handle_comments; end
  def register_docstring(object, docstring = T.unsafe(nil), stmt = T.unsafe(nil)); end

  private

  def find_attached_macro; end
  def implicit_docstring?; end
  def macro_name_matches(macro); end
  def method_name; end
  def method_signature; end
end

YARD::Handlers::Ruby::DSLHandlerMethods::IGNORE_METHODS = T.let(T.unsafe(nil), Hash)

module YARD::Handlers::Ruby::DecoratorHandlerMethods
  def process_decorator(*nodes, &block); end

  private

  def process_decorator_parameter(node, opts = T.unsafe(nil), &block); end
end

class YARD::Handlers::Ruby::ExceptionHandler < ::YARD::Handlers::Ruby::Base; end

class YARD::Handlers::Ruby::ExtendHandler < ::YARD::Handlers::Ruby::MixinHandler
  def scope; end

  private

  def process_mixin(mixin); end
end

class YARD::Handlers::Ruby::HandlesExtension
  def initialize(name); end

  def matches?(node); end

  protected

  def name; end
end

module YARD::Handlers::Ruby::Legacy; end
class YARD::Handlers::Ruby::Legacy::AliasHandler < ::YARD::Handlers::Ruby::Legacy::Base; end
class YARD::Handlers::Ruby::Legacy::AttributeHandler < ::YARD::Handlers::Ruby::Legacy::Base; end

class YARD::Handlers::Ruby::Legacy::Base < ::YARD::Handlers::Base
  include ::YARD::Parser::Ruby::Legacy::RubyToken

  def call_params; end
  def caller_method; end
  def parse_block(opts = T.unsafe(nil)); end

  private

  def extract_method_details; end
  def tokval(token, *accepted_types); end
  def tokval_list(tokenlist, *accepted_types); end

  class << self
    def handles?(stmt); end
  end
end

class YARD::Handlers::Ruby::Legacy::ClassConditionHandler < ::YARD::Handlers::Ruby::Legacy::Base
  protected

  def parse_condition; end
  def parse_else_block; end
  def parse_then_block; end
end

class YARD::Handlers::Ruby::Legacy::ClassHandler < ::YARD::Handlers::Ruby::Legacy::Base
  include ::YARD::Handlers::Ruby::StructHandlerMethods

  private

  def create_struct_superclass(superclass, superclass_def); end
  def extract_parameters(superstring); end
  def parse_struct_subclass(klass, superclass_def); end
  def parse_superclass(superclass); end
  def struct_superclass_name(superclass); end
end

class YARD::Handlers::Ruby::Legacy::ClassVariableHandler < ::YARD::Handlers::Ruby::Legacy::Base; end
YARD::Handlers::Ruby::Legacy::ClassVariableHandler::HANDLER_MATCH = T.let(T.unsafe(nil), Regexp)
class YARD::Handlers::Ruby::Legacy::CommentHandler < ::YARD::Handlers::Ruby::Legacy::Base; end

class YARD::Handlers::Ruby::Legacy::ConstantHandler < ::YARD::Handlers::Ruby::Legacy::Base
  include ::YARD::Handlers::Ruby::StructHandlerMethods

  private

  def extract_parameters(parameters); end
  def process_structclass(classname, parameters); end
end

YARD::Handlers::Ruby::Legacy::ConstantHandler::HANDLER_MATCH = T.let(T.unsafe(nil), Regexp)

class YARD::Handlers::Ruby::Legacy::DSLHandler < ::YARD::Handlers::Ruby::Legacy::Base
  include ::YARD::Handlers::Ruby::DSLHandlerMethods
end

class YARD::Handlers::Ruby::Legacy::ExceptionHandler < ::YARD::Handlers::Ruby::Legacy::Base; end

class YARD::Handlers::Ruby::Legacy::ExtendHandler < ::YARD::Handlers::Ruby::Legacy::MixinHandler
  def scope; end

  private

  def process_mixin(mixin); end
end

class YARD::Handlers::Ruby::Legacy::MethodHandler < ::YARD::Handlers::Ruby::Legacy::Base; end

class YARD::Handlers::Ruby::Legacy::MixinHandler < ::YARD::Handlers::Ruby::Legacy::Base
  private

  def process_mixin(mixin); end
end

class YARD::Handlers::Ruby::Legacy::ModuleFunctionHandler < ::YARD::Handlers::Ruby::Legacy::Base; end
class YARD::Handlers::Ruby::Legacy::ModuleHandler < ::YARD::Handlers::Ruby::Legacy::Base; end

class YARD::Handlers::Ruby::Legacy::PrivateClassMethodHandler < ::YARD::Handlers::Ruby::Legacy::Base
  private

  def privatize_class_method(name); end
end

class YARD::Handlers::Ruby::Legacy::PrivateConstantHandler < ::YARD::Handlers::Ruby::Legacy::Base
  private

  def privatize_constant(name); end
end

class YARD::Handlers::Ruby::Legacy::VisibilityHandler < ::YARD::Handlers::Ruby::Legacy::Base; end
class YARD::Handlers::Ruby::Legacy::YieldHandler < ::YARD::Handlers::Ruby::Legacy::Base; end

class YARD::Handlers::Ruby::MethodCallWrapper < ::YARD::Handlers::Ruby::HandlesExtension
  def matches?(node); end
end

class YARD::Handlers::Ruby::MethodConditionHandler < ::YARD::Handlers::Ruby::Base; end

class YARD::Handlers::Ruby::MethodHandler < ::YARD::Handlers::Ruby::Base
  include ::YARD::Handlers::Common::MethodHandler

  def format_args; end
end

class YARD::Handlers::Ruby::MixinHandler < ::YARD::Handlers::Ruby::Base
  protected

  def process_mixin(mixin); end
  def recipient(mixin); end
end

class YARD::Handlers::Ruby::ModuleFunctionHandler < ::YARD::Handlers::Ruby::Base
  include ::YARD::Handlers::Ruby::DecoratorHandlerMethods

  def make_module_function(instance_method, namespace); end
end

class YARD::Handlers::Ruby::ModuleHandler < ::YARD::Handlers::Ruby::Base; end

class YARD::Handlers::Ruby::PrivateClassMethodHandler < ::YARD::Handlers::Ruby::Base
  include ::YARD::Handlers::Ruby::DecoratorHandlerMethods
end

class YARD::Handlers::Ruby::PrivateConstantHandler < ::YARD::Handlers::Ruby::Base
  private

  def privatize_constant(node); end
end

class YARD::Handlers::Ruby::PublicClassMethodHandler < ::YARD::Handlers::Ruby::Base
  include ::YARD::Handlers::Ruby::DecoratorHandlerMethods
end

module YARD::Handlers::Ruby::StructHandlerMethods
  include ::YARD::CodeObjects

  def add_reader_tags(klass, new_method, member); end
  def add_writer_tags(klass, new_method, member); end
  def create_attributes(klass, members); end
  def create_class(classname, superclass); end
  def create_member_method?(klass, member, type = T.unsafe(nil)); end
  def create_reader(klass, member); end
  def create_writer(klass, member); end
  def member_tag_for_member(klass, member, type = T.unsafe(nil)); end
  def members_from_tags(klass); end
  def return_type_from_tag(member_tag); end
end

class YARD::Handlers::Ruby::TestNodeWrapper < ::YARD::Handlers::Ruby::HandlesExtension
  def matches?(node); end
end

class YARD::Handlers::Ruby::VisibilityHandler < ::YARD::Handlers::Ruby::Base
  include ::YARD::Handlers::Ruby::DecoratorHandlerMethods
end

class YARD::Handlers::Ruby::YieldHandler < ::YARD::Handlers::Ruby::Base; end
module YARD::I18n; end

class YARD::I18n::Locale
  def initialize(name); end

  def load(locale_directory); end
  def name; end
  def translate(message); end

  class << self
    def default; end
    def default=(locale); end
  end
end

class YARD::I18n::Message
  def initialize(id); end

  def ==(other); end
  def add_comment(comment); end
  def add_location(path, line); end
  def comments; end
  def id; end
  def locations; end
end

class YARD::I18n::Messages
  include ::Enumerable

  def initialize; end

  def ==(other); end
  def [](id); end
  def each(&block); end
  def register(id); end

  protected

  def messages; end
end

class YARD::I18n::PotGenerator
  def initialize(relative_base_path); end

  def generate; end
  def messages; end
  def parse_files(files); end
  def parse_objects(objects); end

  private

  def current_time; end
  def escape_message_id(message_id); end
  def extract_documents(object); end
  def extract_paragraphs(file); end
  def extract_tag_documents(tag); end
  def extract_tag_name(tag); end
  def extract_tag_text(tag); end
  def generate_message(pot, message); end
  def generate_pot_creation_date_value; end
  def header; end
  def register_message(id); end
end

class YARD::I18n::Text
  def initialize(input, options = T.unsafe(nil)); end

  def extract_messages; end
  def translate(locale); end

  private

  def emit_attribute_event(match_data, line_no); end
  def emit_empty_line_event(line, line_no); end
  def emit_markup_event(line, line_no); end
  def emit_paragraph_event(paragraph, paragraph_start_line, line_no, &block); end
  def parse(&block); end
end

class YARD::Logger < ::Logger
  def initialize(pipe, *args); end

  def <<(msg = T.unsafe(nil)); end
  def backtrace(exc, level_meth = T.unsafe(nil)); end
  def capture(msg, nontty_log = T.unsafe(nil)); end
  def clear_progress; end
  def debug(*args); end
  def enter_level(new_level = T.unsafe(nil)); end
  def io; end
  def io=(pipe); end
  def print(msg = T.unsafe(nil)); end
  def progress(msg, nontty_log = T.unsafe(nil)); end
  def puts(msg = T.unsafe(nil)); end
  def show_backtraces; end
  def show_backtraces=(_arg0); end
  def show_progress; end
  def show_progress=(_arg0); end
  def warn(*args); end
  def warn_no_continuations; end
  def warned; end
  def warned=(_arg0); end

  private

  def add(*args); end
  def clear_line; end
  def format_log(sev, _time, _prog, msg); end
  def print_no_newline(msg); end

  class << self
    def instance(pipe = T.unsafe(nil)); end
  end
end

YARD::Logger::PROGRESS_INDICATORS = T.let(T.unsafe(nil), Array)

class YARD::Options
  def ==(other); end
  def [](key); end
  def []=(key, value); end
  def delete(key); end
  def each; end
  def inspect; end
  def merge(opts); end
  def method_missing(meth, *args, &block); end
  def reset_defaults; end
  def to_hash; end
  def update(opts); end

  class << self
    def default_attr(key, default); end
  end
end

module YARD::Parser; end

class YARD::Parser::Base
  def initialize(source, filename); end

  def enumerator; end
  def parse; end
  def tokenize; end

  class << self
    def parse(source, filename = T.unsafe(nil)); end
  end
end

module YARD::Parser::C; end

class YARD::Parser::C::BodyStatement < ::YARD::Parser::C::Statement
  def comments; end
  def comments=(_arg0); end
end

class YARD::Parser::C::CParser < ::YARD::Parser::Base
  def initialize(source, file = T.unsafe(nil)); end

  def enumerator; end
  def parse; end
  def tokenize; end

  private

  def advance(num = T.unsafe(nil)); end
  def advance_loop; end
  def attach_comment(statement); end
  def back(num = T.unsafe(nil)); end
  def char(num = T.unsafe(nil)); end
  def consume_body_statements; end
  def consume_comment(add_comment = T.unsafe(nil)); end
  def consume_directive; end
  def consume_quote(type = T.unsafe(nil)); end
  def consume_toplevel_statement; end
  def consume_until(end_char, bracket_level = T.unsafe(nil), brace_level = T.unsafe(nil), add_comment = T.unsafe(nil)); end
  def consume_whitespace; end
  def nextchar(num = T.unsafe(nil)); end
  def nextline; end
  def parse_toplevel; end
  def prevchar(num = T.unsafe(nil)); end
  def strip_non_statement_data; end
  def struct; end
end

class YARD::Parser::C::Comment < ::YARD::Parser::C::Statement
  include ::YARD::Parser::C::CommentParser

  def initialize(source, file = T.unsafe(nil), line = T.unsafe(nil)); end

  def comments; end
  def overrides; end
  def overrides=(_arg0); end
  def statement; end
  def statement=(_arg0); end
  def type; end
  def type=(_arg0); end
end

module YARD::Parser::C::CommentParser
  protected

  def parse_comments(comments); end

  private

  def parse_callseq(comments); end
  def parse_overrides(comments); end
  def parse_types(types); end
  def remove_private_comments(comment); end
end

class YARD::Parser::C::Statement
  def initialize(source, file = T.unsafe(nil), line = T.unsafe(nil)); end

  def comments_hash_flag; end
  def comments_hash_flag=(_arg0); end
  def comments_range; end
  def file; end
  def file=(_arg0); end
  def first_line; end
  def group; end
  def group=(_arg0); end
  def line; end
  def line=(_arg0); end
  def line_range; end
  def show; end
  def signature; end
  def source; end
  def source=(_arg0); end
end

class YARD::Parser::C::ToplevelStatement < ::YARD::Parser::C::Statement
  def block; end
  def block=(_arg0); end
  def comments; end
  def comments=(_arg0); end
  def declaration; end
  def declaration=(_arg0); end
end

class YARD::Parser::OrderedParser
  def initialize(global_state, files); end

  def files; end
  def files=(_arg0); end
  def parse; end
end

class YARD::Parser::ParserSyntaxError < ::YARD::Parser::UndocumentableError; end

module YARD::Parser::Ruby
  def s(*args); end
end

class YARD::Parser::Ruby::AstNode < ::Array
  def initialize(type, arr, opts = T.unsafe(nil)); end

  def ==(other); end
  def block?; end
  def call?; end
  def children; end
  def comments; end
  def comments_hash_flag; end
  def comments_range; end
  def condition?; end
  def def?; end
  def docstring; end
  def docstring=(_arg0); end
  def docstring_hash_flag; end
  def docstring_hash_flag=(_arg0); end
  def docstring_range; end
  def docstring_range=(_arg0); end
  def file; end
  def file=(_arg0); end
  def first_line; end
  def full_source; end
  def full_source=(_arg0); end
  def group; end
  def group=(_arg0); end
  def has_line?; end
  def inspect; end
  def jump(*node_types); end
  def kw?; end
  def line; end
  def line_range; end
  def line_range=(_arg0); end
  def literal?; end
  def loop?; end
  def parent; end
  def parent=(_arg0); end
  def pretty_print(q); end
  def ref?; end
  def show; end
  def source; end
  def source=(_arg0); end
  def source_range; end
  def source_range=(_arg0); end
  def to_s; end
  def token?; end
  def traverse; end
  def type; end
  def type=(_arg0); end
  def unfreeze; end

  private

  def reset_line_info; end

  class << self
    def node_class_for(type); end
  end
end

YARD::Parser::Ruby::AstNode::KEYWORDS = T.let(T.unsafe(nil), Hash)

class YARD::Parser::Ruby::ClassNode < ::YARD::Parser::Ruby::KeywordNode
  def block; end
  def class_name; end
  def superclass; end
end

class YARD::Parser::Ruby::CommentNode < ::YARD::Parser::Ruby::AstNode
  def comments; end
  def docstring; end
  def docstring=(value); end
  def first_line; end
  def source; end
end

class YARD::Parser::Ruby::ConditionalNode < ::YARD::Parser::Ruby::KeywordNode
  def condition; end
  def condition?; end
  def else_block; end
  def then_block; end

  private

  def cmod?; end
end

class YARD::Parser::Ruby::KeywordNode < ::YARD::Parser::Ruby::AstNode
  def kw?; end
end

module YARD::Parser::Ruby::Legacy; end

class YARD::Parser::Ruby::Legacy::RubyLex
  include ::YARD::Parser::Ruby::Legacy::RubyToken
  include ::IRB

  def initialize(content); end

  def char_no; end
  def continue; end
  def exception_on_syntax_error; end
  def exception_on_syntax_error=(_arg0); end
  def get_read; end
  def getc; end
  def getc_of_rests; end
  def gets; end
  def identify_comment; end
  def identify_gvar; end
  def identify_here_document; end
  def identify_identifier; end
  def identify_number(start); end
  def identify_quotation(initial_char); end
  def identify_string(ltype, quoted = T.unsafe(nil), opener = T.unsafe(nil), initial_char = T.unsafe(nil)); end
  def indent; end
  def lex; end
  def lex_init; end
  def lex_int2; end
  def lex_state; end
  def line_no; end
  def peek(i = T.unsafe(nil)); end
  def peek_equal?(str); end
  def read_auto_clean_up; end
  def read_auto_clean_up=(_arg0); end
  def read_escape; end
  def skip_inner_expression; end
  def skip_space; end
  def skip_space=(_arg0); end
  def token; end
  def ungetc(c = T.unsafe(nil)); end

  class << self
    def debug?; end
  end
end

YARD::Parser::Ruby::Legacy::RubyLex::ACCEPTS_COLON = T.let(T.unsafe(nil), Array)

class YARD::Parser::Ruby::Legacy::RubyLex::BufferedReader
  def initialize(content); end

  def column; end
  def divert_read_from(reserve); end
  def get_read; end
  def getc; end
  def getc_already_read; end
  def line_num; end
  def peek(at); end
  def peek_equal(str); end
  def ungetc(_ch); end
end

YARD::Parser::Ruby::Legacy::RubyLex::DEINDENT_CLAUSE = T.let(T.unsafe(nil), Array)
YARD::Parser::Ruby::Legacy::RubyLex::DLtype2Token = T.let(T.unsafe(nil), Hash)
YARD::Parser::Ruby::Legacy::RubyLex::ENINDENT_CLAUSE = T.let(T.unsafe(nil), Array)
YARD::Parser::Ruby::Legacy::RubyLex::Ltype2Token = T.let(T.unsafe(nil), Hash)
YARD::Parser::Ruby::Legacy::RubyLex::PERCENT_LTYPE = T.let(T.unsafe(nil), Hash)
YARD::Parser::Ruby::Legacy::RubyLex::PERCENT_PAREN = T.let(T.unsafe(nil), Hash)

class YARD::Parser::Ruby::Legacy::RubyParser < ::YARD::Parser::Base
  def initialize(source, _filename); end

  def encoding_line; end
  def enumerator; end
  def parse; end
  def shebang_line; end
  def tokenize; end
end

module YARD::Parser::Ruby::Legacy::RubyToken
  def Token(token, value = T.unsafe(nil)); end
  def set_token_position(line, char); end

  class << self
    def def_token(token_n, super_token = T.unsafe(nil), reading = T.unsafe(nil), *opts); end
  end
end

YARD::Parser::Ruby::Legacy::RubyToken::EXPR_ARG = T.let(T.unsafe(nil), Symbol)
YARD::Parser::Ruby::Legacy::RubyToken::EXPR_BEG = T.let(T.unsafe(nil), Symbol)
YARD::Parser::Ruby::Legacy::RubyToken::EXPR_CLASS = T.let(T.unsafe(nil), Symbol)
YARD::Parser::Ruby::Legacy::RubyToken::EXPR_DOT = T.let(T.unsafe(nil), Symbol)
YARD::Parser::Ruby::Legacy::RubyToken::EXPR_END = T.let(T.unsafe(nil), Symbol)
YARD::Parser::Ruby::Legacy::RubyToken::EXPR_FNAME = T.let(T.unsafe(nil), Symbol)
YARD::Parser::Ruby::Legacy::RubyToken::EXPR_MID = T.let(T.unsafe(nil), Symbol)
YARD::Parser::Ruby::Legacy::RubyToken::NEWLINE_TOKEN = T.let(T.unsafe(nil), YARD::Parser::Ruby::Legacy::RubyToken::TkNL)

class YARD::Parser::Ruby::Legacy::RubyToken::OPASGN < ::YARD::Parser::Ruby::Legacy::RubyToken::TkOp
  class << self
    def op_name; end
  end
end

class YARD::Parser::Ruby::Legacy::RubyToken::TkALIAS < ::YARD::Parser::Ruby::Legacy::RubyToken::TkKW; end
class YARD::Parser::Ruby::Legacy::RubyToken::TkAMPER < ::YARD::Parser::Ruby::Legacy::RubyToken::Token; end
class YARD::Parser::Ruby::Legacy::RubyToken::TkAND < ::YARD::Parser::Ruby::Legacy::RubyToken::TkKW; end

class YARD::Parser::Ruby::Legacy::RubyToken::TkANDOP < ::YARD::Parser::Ruby::Legacy::RubyToken::TkOp
  class << self
    def op_name; end
  end
end

class YARD::Parser::Ruby::Legacy::RubyToken::TkAREF < ::YARD::Parser::Ruby::Legacy::RubyToken::TkOp
  class << self
    def op_name; end
  end
end

class YARD::Parser::Ruby::Legacy::RubyToken::TkASET < ::YARD::Parser::Ruby::Legacy::RubyToken::TkOp
  class << self
    def op_name; end
  end
end

class YARD::Parser::Ruby::Legacy::RubyToken::TkASSIGN < ::YARD::Parser::Ruby::Legacy::RubyToken::Token; end

class YARD::Parser::Ruby::Legacy::RubyToken::TkASSOC < ::YARD::Parser::Ruby::Legacy::RubyToken::TkOp
  class << self
    def op_name; end
  end
end

class YARD::Parser::Ruby::Legacy::RubyToken::TkAT < ::YARD::Parser::Ruby::Legacy::RubyToken::TkUnknownChar; end

class YARD::Parser::Ruby::Legacy::RubyToken::TkBACKQUOTE < ::YARD::Parser::Ruby::Legacy::RubyToken::TkOp
  class << self
    def op_name; end
  end
end

class YARD::Parser::Ruby::Legacy::RubyToken::TkBACKSLASH < ::YARD::Parser::Ruby::Legacy::RubyToken::TkUnknownChar; end
class YARD::Parser::Ruby::Legacy::RubyToken::TkBACK_REF < ::YARD::Parser::Ruby::Legacy::RubyToken::TkId; end
class YARD::Parser::Ruby::Legacy::RubyToken::TkBEGIN < ::YARD::Parser::Ruby::Legacy::RubyToken::TkKW; end

class YARD::Parser::Ruby::Legacy::RubyToken::TkBITAND < ::YARD::Parser::Ruby::Legacy::RubyToken::TkOp
  class << self
    def op_name; end
  end
end

class YARD::Parser::Ruby::Legacy::RubyToken::TkBITNOT < ::YARD::Parser::Ruby::Legacy::RubyToken::TkOp
  class << self
    def op_name; end
  end
end

class YARD::Parser::Ruby::Legacy::RubyToken::TkBITOR < ::YARD::Parser::Ruby::Legacy::RubyToken::TkOp
  class << self
    def op_name; end
  end
end

class YARD::Parser::Ruby::Legacy::RubyToken::TkBITXOR < ::YARD::Parser::Ruby::Legacy::RubyToken::TkOp
  class << self
    def op_name; end
  end
end

class YARD::Parser::Ruby::Legacy::RubyToken::TkBREAK < ::YARD::Parser::Ruby::Legacy::RubyToken::TkKW; end

class YARD::Parser::Ruby::Legacy::RubyToken::TkBlockContents < ::YARD::Parser::Ruby::Legacy::RubyToken::Token
  def text; end
end

class YARD::Parser::Ruby::Legacy::RubyToken::TkCASE < ::YARD::Parser::Ruby::Legacy::RubyToken::TkKW; end
class YARD::Parser::Ruby::Legacy::RubyToken::TkCLASS < ::YARD::Parser::Ruby::Legacy::RubyToken::TkKW; end

class YARD::Parser::Ruby::Legacy::RubyToken::TkCMP < ::YARD::Parser::Ruby::Legacy::RubyToken::TkOp
  class << self
    def op_name; end
  end
end

class YARD::Parser::Ruby::Legacy::RubyToken::TkCOLON < ::YARD::Parser::Ruby::Legacy::RubyToken::TkOp
  class << self
    def op_name; end
  end
end

class YARD::Parser::Ruby::Legacy::RubyToken::TkCOLON2 < ::YARD::Parser::Ruby::Legacy::RubyToken::TkOp
  class << self
    def op_name; end
  end
end

class YARD::Parser::Ruby::Legacy::RubyToken::TkCOLON3 < ::YARD::Parser::Ruby::Legacy::RubyToken::TkOp
  class << self
    def op_name; end
  end
end

class YARD::Parser::Ruby::Legacy::RubyToken::TkCOMMA < ::YARD::Parser::Ruby::Legacy::RubyToken::Token; end
class YARD::Parser::Ruby::Legacy::RubyToken::TkCOMMENT < ::YARD::Parser::Ruby::Legacy::RubyToken::TkVal; end
class YARD::Parser::Ruby::Legacy::RubyToken::TkCONSTANT < ::YARD::Parser::Ruby::Legacy::RubyToken::TkId; end
class YARD::Parser::Ruby::Legacy::RubyToken::TkDEF < ::YARD::Parser::Ruby::Legacy::RubyToken::TkKW; end
class YARD::Parser::Ruby::Legacy::RubyToken::TkDEFINED < ::YARD::Parser::Ruby::Legacy::RubyToken::TkKW; end

class YARD::Parser::Ruby::Legacy::RubyToken::TkDIV < ::YARD::Parser::Ruby::Legacy::RubyToken::TkOp
  class << self
    def op_name; end
  end
end

class YARD::Parser::Ruby::Legacy::RubyToken::TkDO < ::YARD::Parser::Ruby::Legacy::RubyToken::TkKW; end
class YARD::Parser::Ruby::Legacy::RubyToken::TkDOLLAR < ::YARD::Parser::Ruby::Legacy::RubyToken::TkUnknownChar; end
class YARD::Parser::Ruby::Legacy::RubyToken::TkDOT < ::YARD::Parser::Ruby::Legacy::RubyToken::Token; end

class YARD::Parser::Ruby::Legacy::RubyToken::TkDOT2 < ::YARD::Parser::Ruby::Legacy::RubyToken::TkOp
  class << self
    def op_name; end
  end
end

class YARD::Parser::Ruby::Legacy::RubyToken::TkDOT3 < ::YARD::Parser::Ruby::Legacy::RubyToken::TkOp
  class << self
    def op_name; end
  end
end

class YARD::Parser::Ruby::Legacy::RubyToken::TkDREGEXP < ::YARD::Parser::Ruby::Legacy::RubyToken::TkNode; end
class YARD::Parser::Ruby::Legacy::RubyToken::TkDSTRING < ::YARD::Parser::Ruby::Legacy::RubyToken::TkNode; end
class YARD::Parser::Ruby::Legacy::RubyToken::TkDXSTRING < ::YARD::Parser::Ruby::Legacy::RubyToken::TkNode; end
class YARD::Parser::Ruby::Legacy::RubyToken::TkELSE < ::YARD::Parser::Ruby::Legacy::RubyToken::TkKW; end
class YARD::Parser::Ruby::Legacy::RubyToken::TkELSIF < ::YARD::Parser::Ruby::Legacy::RubyToken::TkKW; end
class YARD::Parser::Ruby::Legacy::RubyToken::TkEND < ::YARD::Parser::Ruby::Legacy::RubyToken::TkKW; end
class YARD::Parser::Ruby::Legacy::RubyToken::TkEND_OF_SCRIPT < ::YARD::Parser::Ruby::Legacy::RubyToken::TkWhitespace; end
class YARD::Parser::Ruby::Legacy::RubyToken::TkENSURE < ::YARD::Parser::Ruby::Legacy::RubyToken::TkKW; end

class YARD::Parser::Ruby::Legacy::RubyToken::TkEQ < ::YARD::Parser::Ruby::Legacy::RubyToken::TkOp
  class << self
    def op_name; end
  end
end

class YARD::Parser::Ruby::Legacy::RubyToken::TkEQQ < ::YARD::Parser::Ruby::Legacy::RubyToken::TkOp
  class << self
    def op_name; end
  end
end

class YARD::Parser::Ruby::Legacy::RubyToken::TkError < ::YARD::Parser::Ruby::Legacy::RubyToken::Token; end
class YARD::Parser::Ruby::Legacy::RubyToken::TkFALSE < ::YARD::Parser::Ruby::Legacy::RubyToken::TkKW; end
class YARD::Parser::Ruby::Legacy::RubyToken::TkFID < ::YARD::Parser::Ruby::Legacy::RubyToken::TkId; end
class YARD::Parser::Ruby::Legacy::RubyToken::TkFLOAT < ::YARD::Parser::Ruby::Legacy::RubyToken::TkVal; end
class YARD::Parser::Ruby::Legacy::RubyToken::TkFOR < ::YARD::Parser::Ruby::Legacy::RubyToken::TkKW; end

class YARD::Parser::Ruby::Legacy::RubyToken::TkGEQ < ::YARD::Parser::Ruby::Legacy::RubyToken::TkOp
  class << self
    def op_name; end
  end
end

class YARD::Parser::Ruby::Legacy::RubyToken::TkGT < ::YARD::Parser::Ruby::Legacy::RubyToken::TkOp
  class << self
    def op_name; end
  end
end

class YARD::Parser::Ruby::Legacy::RubyToken::TkGVAR < ::YARD::Parser::Ruby::Legacy::RubyToken::TkId; end
class YARD::Parser::Ruby::Legacy::RubyToken::TkIDENTIFIER < ::YARD::Parser::Ruby::Legacy::RubyToken::TkId; end
class YARD::Parser::Ruby::Legacy::RubyToken::TkIF < ::YARD::Parser::Ruby::Legacy::RubyToken::TkKW; end
class YARD::Parser::Ruby::Legacy::RubyToken::TkIF_MOD < ::YARD::Parser::Ruby::Legacy::RubyToken::TkKW; end
class YARD::Parser::Ruby::Legacy::RubyToken::TkIN < ::YARD::Parser::Ruby::Legacy::RubyToken::TkKW; end
class YARD::Parser::Ruby::Legacy::RubyToken::TkINTEGER < ::YARD::Parser::Ruby::Legacy::RubyToken::TkVal; end
class YARD::Parser::Ruby::Legacy::RubyToken::TkIVAR < ::YARD::Parser::Ruby::Legacy::RubyToken::TkId; end

class YARD::Parser::Ruby::Legacy::RubyToken::TkId < ::YARD::Parser::Ruby::Legacy::RubyToken::Token
  def initialize(line_no, char_no, name); end

  def name; end
end

class YARD::Parser::Ruby::Legacy::RubyToken::TkKW < ::YARD::Parser::Ruby::Legacy::RubyToken::TkId; end
class YARD::Parser::Ruby::Legacy::RubyToken::TkLABEL < ::YARD::Parser::Ruby::Legacy::RubyToken::TkVal; end
class YARD::Parser::Ruby::Legacy::RubyToken::TkLBRACE < ::YARD::Parser::Ruby::Legacy::RubyToken::Token; end
class YARD::Parser::Ruby::Legacy::RubyToken::TkLBRACK < ::YARD::Parser::Ruby::Legacy::RubyToken::Token; end

class YARD::Parser::Ruby::Legacy::RubyToken::TkLEQ < ::YARD::Parser::Ruby::Legacy::RubyToken::TkOp
  class << self
    def op_name; end
  end
end

class YARD::Parser::Ruby::Legacy::RubyToken::TkLPAREN < ::YARD::Parser::Ruby::Legacy::RubyToken::Token; end

class YARD::Parser::Ruby::Legacy::RubyToken::TkLSHFT < ::YARD::Parser::Ruby::Legacy::RubyToken::TkOp
  class << self
    def op_name; end
  end
end

class YARD::Parser::Ruby::Legacy::RubyToken::TkLT < ::YARD::Parser::Ruby::Legacy::RubyToken::TkOp
  class << self
    def op_name; end
  end
end

class YARD::Parser::Ruby::Legacy::RubyToken::TkMATCH < ::YARD::Parser::Ruby::Legacy::RubyToken::TkOp
  class << self
    def op_name; end
  end
end

class YARD::Parser::Ruby::Legacy::RubyToken::TkMINUS < ::YARD::Parser::Ruby::Legacy::RubyToken::TkOp
  class << self
    def op_name; end
  end
end

class YARD::Parser::Ruby::Legacy::RubyToken::TkMOD < ::YARD::Parser::Ruby::Legacy::RubyToken::TkOp
  class << self
    def op_name; end
  end
end

class YARD::Parser::Ruby::Legacy::RubyToken::TkMODULE < ::YARD::Parser::Ruby::Legacy::RubyToken::TkKW; end

class YARD::Parser::Ruby::Legacy::RubyToken::TkMULT < ::YARD::Parser::Ruby::Legacy::RubyToken::TkOp
  class << self
    def op_name; end
  end
end

class YARD::Parser::Ruby::Legacy::RubyToken::TkNEQ < ::YARD::Parser::Ruby::Legacy::RubyToken::TkOp
  class << self
    def op_name; end
  end
end

class YARD::Parser::Ruby::Legacy::RubyToken::TkNEXT < ::YARD::Parser::Ruby::Legacy::RubyToken::TkKW; end
class YARD::Parser::Ruby::Legacy::RubyToken::TkNIL < ::YARD::Parser::Ruby::Legacy::RubyToken::TkKW; end
class YARD::Parser::Ruby::Legacy::RubyToken::TkNL < ::YARD::Parser::Ruby::Legacy::RubyToken::TkWhitespace; end

class YARD::Parser::Ruby::Legacy::RubyToken::TkNMATCH < ::YARD::Parser::Ruby::Legacy::RubyToken::TkOp
  class << self
    def op_name; end
  end
end

class YARD::Parser::Ruby::Legacy::RubyToken::TkNOT < ::YARD::Parser::Ruby::Legacy::RubyToken::TkKW; end

class YARD::Parser::Ruby::Legacy::RubyToken::TkNOTOP < ::YARD::Parser::Ruby::Legacy::RubyToken::TkOp
  class << self
    def op_name; end
  end
end

class YARD::Parser::Ruby::Legacy::RubyToken::TkNTH_REF < ::YARD::Parser::Ruby::Legacy::RubyToken::TkId; end

class YARD::Parser::Ruby::Legacy::RubyToken::TkNode < ::YARD::Parser::Ruby::Legacy::RubyToken::Token
  def node; end
end

class YARD::Parser::Ruby::Legacy::RubyToken::TkOPASGN < ::YARD::Parser::Ruby::Legacy::RubyToken::TkOp
  def initialize(line_no, char_no, op); end

  def op; end
end

class YARD::Parser::Ruby::Legacy::RubyToken::TkOR < ::YARD::Parser::Ruby::Legacy::RubyToken::TkKW; end

class YARD::Parser::Ruby::Legacy::RubyToken::TkOROP < ::YARD::Parser::Ruby::Legacy::RubyToken::TkOp
  class << self
    def op_name; end
  end
end

class YARD::Parser::Ruby::Legacy::RubyToken::TkOp < ::YARD::Parser::Ruby::Legacy::RubyToken::Token
  def name; end
end

class YARD::Parser::Ruby::Legacy::RubyToken::TkPLUS < ::YARD::Parser::Ruby::Legacy::RubyToken::TkOp
  class << self
    def op_name; end
  end
end

class YARD::Parser::Ruby::Legacy::RubyToken::TkPOW < ::YARD::Parser::Ruby::Legacy::RubyToken::TkOp
  class << self
    def op_name; end
  end
end

class YARD::Parser::Ruby::Legacy::RubyToken::TkQUESTION < ::YARD::Parser::Ruby::Legacy::RubyToken::TkOp
  class << self
    def op_name; end
  end
end

class YARD::Parser::Ruby::Legacy::RubyToken::TkRBRACE < ::YARD::Parser::Ruby::Legacy::RubyToken::Token; end
class YARD::Parser::Ruby::Legacy::RubyToken::TkRBRACK < ::YARD::Parser::Ruby::Legacy::RubyToken::Token; end
class YARD::Parser::Ruby::Legacy::RubyToken::TkREDO < ::YARD::Parser::Ruby::Legacy::RubyToken::TkKW; end
class YARD::Parser::Ruby::Legacy::RubyToken::TkREGEXP < ::YARD::Parser::Ruby::Legacy::RubyToken::TkVal; end
class YARD::Parser::Ruby::Legacy::RubyToken::TkRESCUE < ::YARD::Parser::Ruby::Legacy::RubyToken::TkKW; end
class YARD::Parser::Ruby::Legacy::RubyToken::TkRETRY < ::YARD::Parser::Ruby::Legacy::RubyToken::TkKW; end
class YARD::Parser::Ruby::Legacy::RubyToken::TkRETURN < ::YARD::Parser::Ruby::Legacy::RubyToken::TkKW; end
class YARD::Parser::Ruby::Legacy::RubyToken::TkRPAREN < ::YARD::Parser::Ruby::Legacy::RubyToken::Token; end

class YARD::Parser::Ruby::Legacy::RubyToken::TkRSHFT < ::YARD::Parser::Ruby::Legacy::RubyToken::TkOp
  class << self
    def op_name; end
  end
end

YARD::Parser::Ruby::Legacy::RubyToken::TkReading2Token = T.let(T.unsafe(nil), Hash)
class YARD::Parser::Ruby::Legacy::RubyToken::TkSELF < ::YARD::Parser::Ruby::Legacy::RubyToken::TkKW; end
class YARD::Parser::Ruby::Legacy::RubyToken::TkSEMICOLON < ::YARD::Parser::Ruby::Legacy::RubyToken::Token; end
class YARD::Parser::Ruby::Legacy::RubyToken::TkSPACE < ::YARD::Parser::Ruby::Legacy::RubyToken::TkWhitespace; end
class YARD::Parser::Ruby::Legacy::RubyToken::TkSTAR < ::YARD::Parser::Ruby::Legacy::RubyToken::Token; end
class YARD::Parser::Ruby::Legacy::RubyToken::TkSTRING < ::YARD::Parser::Ruby::Legacy::RubyToken::TkVal; end
class YARD::Parser::Ruby::Legacy::RubyToken::TkSUPER < ::YARD::Parser::Ruby::Legacy::RubyToken::TkKW; end
class YARD::Parser::Ruby::Legacy::RubyToken::TkSYMBEG < ::YARD::Parser::Ruby::Legacy::RubyToken::TkId; end
class YARD::Parser::Ruby::Legacy::RubyToken::TkSYMBOL < ::YARD::Parser::Ruby::Legacy::RubyToken::TkVal; end

class YARD::Parser::Ruby::Legacy::RubyToken::TkStatementEnd < ::YARD::Parser::Ruby::Legacy::RubyToken::Token
  def text; end
end

YARD::Parser::Ruby::Legacy::RubyToken::TkSymbol2Token = T.let(T.unsafe(nil), Hash)
class YARD::Parser::Ruby::Legacy::RubyToken::TkTHEN < ::YARD::Parser::Ruby::Legacy::RubyToken::TkKW; end
class YARD::Parser::Ruby::Legacy::RubyToken::TkTRUE < ::YARD::Parser::Ruby::Legacy::RubyToken::TkKW; end

class YARD::Parser::Ruby::Legacy::RubyToken::TkUMINUS < ::YARD::Parser::Ruby::Legacy::RubyToken::TkOp
  class << self
    def op_name; end
  end
end

class YARD::Parser::Ruby::Legacy::RubyToken::TkUNDEF < ::YARD::Parser::Ruby::Legacy::RubyToken::TkKW; end
class YARD::Parser::Ruby::Legacy::RubyToken::TkUNLESS < ::YARD::Parser::Ruby::Legacy::RubyToken::TkKW; end
class YARD::Parser::Ruby::Legacy::RubyToken::TkUNLESS_MOD < ::YARD::Parser::Ruby::Legacy::RubyToken::TkKW; end
class YARD::Parser::Ruby::Legacy::RubyToken::TkUNTIL < ::YARD::Parser::Ruby::Legacy::RubyToken::TkKW; end
class YARD::Parser::Ruby::Legacy::RubyToken::TkUNTIL_MOD < ::YARD::Parser::Ruby::Legacy::RubyToken::TkKW; end

class YARD::Parser::Ruby::Legacy::RubyToken::TkUPLUS < ::YARD::Parser::Ruby::Legacy::RubyToken::TkOp
  class << self
    def op_name; end
  end
end

class YARD::Parser::Ruby::Legacy::RubyToken::TkUnknownChar < ::YARD::Parser::Ruby::Legacy::RubyToken::Token
  def initialize(line_no, char_no, _id); end

  def name; end
end

class YARD::Parser::Ruby::Legacy::RubyToken::TkVal < ::YARD::Parser::Ruby::Legacy::RubyToken::Token
  def initialize(line_no, char_no, value = T.unsafe(nil)); end
end

class YARD::Parser::Ruby::Legacy::RubyToken::TkWHEN < ::YARD::Parser::Ruby::Legacy::RubyToken::TkKW; end
class YARD::Parser::Ruby::Legacy::RubyToken::TkWHILE < ::YARD::Parser::Ruby::Legacy::RubyToken::TkKW; end
class YARD::Parser::Ruby::Legacy::RubyToken::TkWHILE_MOD < ::YARD::Parser::Ruby::Legacy::RubyToken::TkKW; end
class YARD::Parser::Ruby::Legacy::RubyToken::TkWhitespace < ::YARD::Parser::Ruby::Legacy::RubyToken::Token; end
class YARD::Parser::Ruby::Legacy::RubyToken::TkXSTRING < ::YARD::Parser::Ruby::Legacy::RubyToken::TkVal; end
class YARD::Parser::Ruby::Legacy::RubyToken::TkYIELD < ::YARD::Parser::Ruby::Legacy::RubyToken::TkKW; end
class YARD::Parser::Ruby::Legacy::RubyToken::Tk__FILE__ < ::YARD::Parser::Ruby::Legacy::RubyToken::TkKW; end
class YARD::Parser::Ruby::Legacy::RubyToken::Tk__LINE__ < ::YARD::Parser::Ruby::Legacy::RubyToken::TkKW; end
class YARD::Parser::Ruby::Legacy::RubyToken::TklBEGIN < ::YARD::Parser::Ruby::Legacy::RubyToken::TkKW; end
class YARD::Parser::Ruby::Legacy::RubyToken::TklEND < ::YARD::Parser::Ruby::Legacy::RubyToken::TkKW; end

class YARD::Parser::Ruby::Legacy::RubyToken::Token
  def initialize(line_no, char_no); end

  def char_no; end
  def lex_state; end
  def lex_state=(_arg0); end
  def line_no; end
  def set_text(text); end
  def text; end
end

YARD::Parser::Ruby::Legacy::RubyToken::Token::NO_TEXT = T.let(T.unsafe(nil), String)
YARD::Parser::Ruby::Legacy::RubyToken::TokenDefinitions = T.let(T.unsafe(nil), Array)

class YARD::Parser::Ruby::Legacy::Statement
  def initialize(tokens, block = T.unsafe(nil), comments = T.unsafe(nil)); end

  def block; end
  def comments; end
  def comments_hash_flag; end
  def comments_hash_flag=(_arg0); end
  def comments_range; end
  def comments_range=(_arg0); end
  def first_line; end
  def group; end
  def group=(_arg0); end
  def inspect; end
  def line; end
  def line_range; end
  def show; end
  def signature; end
  def source(include_block = T.unsafe(nil)); end
  def to_s(include_block = T.unsafe(nil)); end
  def tokens; end

  private

  def clean_tokens(tokens); end
end

class YARD::Parser::Ruby::Legacy::StatementList < ::Array
  include ::YARD::Parser::Ruby::Legacy::RubyToken

  def initialize(content); end

  def encoding_line; end
  def encoding_line=(_arg0); end
  def shebang_line; end
  def shebang_line=(_arg0); end

  private

  def balances?(tk); end
  def next_statement; end
  def parse_statements; end
  def peek_no_space; end
  def process_block_token(tk); end
  def process_complex_block_opener(tk); end
  def process_initial_comment(tk); end
  def process_simple_block_opener(tk); end
  def process_statement_end(tk); end
  def process_token(tk); end
  def push_token(tk); end
  def sanitize_block; end
  def sanitize_statement_end; end
end

YARD::Parser::Ruby::Legacy::StatementList::OPEN_BLOCK_TOKENS = T.let(T.unsafe(nil), Array)

class YARD::Parser::Ruby::Legacy::TokenList < ::Array
  include ::YARD::Parser::Ruby::Legacy::RubyToken

  def initialize(content = T.unsafe(nil)); end

  def <<(*tokens); end
  def push(*tokens); end
  def squeeze(type = T.unsafe(nil)); end
  def to_s(full_statement = T.unsafe(nil), show_block = T.unsafe(nil)); end

  private

  def convert_token(lex, tk); end
  def parse_content(content); end
end

class YARD::Parser::Ruby::LiteralNode < ::YARD::Parser::Ruby::AstNode
  def literal?; end
end

class YARD::Parser::Ruby::LoopNode < ::YARD::Parser::Ruby::KeywordNode
  def block; end
  def condition; end
  def loop?; end
end

class YARD::Parser::Ruby::MethodCallNode < ::YARD::Parser::Ruby::AstNode
  def block; end
  def block_param; end
  def call?; end
  def method_name(name_only = T.unsafe(nil)); end
  def namespace; end
  def parameters(include_block_param = T.unsafe(nil)); end

  private

  def call_has_paren?; end
  def index_adjust; end
end

class YARD::Parser::Ruby::MethodDefinitionNode < ::YARD::Parser::Ruby::AstNode
  def block(*_arg0); end
  def def?; end
  def kw?; end
  def method_name(name_only = T.unsafe(nil)); end
  def namespace; end
  def parameters(include_block_param = T.unsafe(nil)); end
  def signature; end

  private

  def index_adjust; end
end

class YARD::Parser::Ruby::ModuleNode < ::YARD::Parser::Ruby::KeywordNode
  def block; end
  def module_name; end
end

class YARD::Parser::Ruby::ParameterNode < ::YARD::Parser::Ruby::AstNode
  def block_param; end
  def double_splat_param; end
  def named_params; end
  def splat_param; end
  def unnamed_end_params; end
  def unnamed_optional_params; end
  def unnamed_required_params; end
end

class YARD::Parser::Ruby::ReferenceNode < ::YARD::Parser::Ruby::AstNode
  def namespace; end
  def path; end
  def ref?; end
end

class YARD::Parser::Ruby::RipperParser < ::Ripper
  def initialize(source, filename, *args); end

  def ast; end
  def charno; end
  def comments; end
  def encoding_line; end
  def enumerator; end
  def file; end
  def file_encoding; end
  def frozen_string_line; end
  def on_BEGIN(*args); end
  def on_CHAR(tok); end
  def on_END(*args); end
  def on___end__(tok); end
  def on_alias(*args); end
  def on_alias_error(*args); end
  def on_arg_ambiguous(*args); end
  def on_arg_paren(*args); end
  def on_args_add(list, item); end
  def on_args_add_block(list, item); end
  def on_args_add_star(list, item); end
  def on_args_forward(*args); end
  def on_args_new(*args); end
  def on_aryptn(*args); end
  def on_assign(*args); end
  def on_assign_error(*args); end
  def on_assoc_splat(*args); end
  def on_backref(tok); end
  def on_backtick(tok); end
  def on_begin(*args); end
  def on_binary(*args); end
  def on_block_var(*args); end
  def on_blockarg(*args); end
  def on_brace_block(*args); end
  def on_break(*args); end
  def on_call(*args); end
  def on_case(*args); end
  def on_class(*args); end
  def on_class_name_error(*args); end
  def on_comma(tok); end
  def on_command(*args); end
  def on_command_call(*args); end
  def on_const(tok); end
  def on_const_path_field(*args); end
  def on_const_ref(*args); end
  def on_cvar(tok); end
  def on_def(*args); end
  def on_defined(*args); end
  def on_defs(*args); end
  def on_do_block(*args); end
  def on_dot2(*args); end
  def on_dot3(*args); end
  def on_else(*args); end
  def on_elsif(*args); end
  def on_embexpr_beg(tok); end
  def on_embexpr_end(tok); end
  def on_embvar(tok); end
  def on_ensure(*args); end
  def on_excessed_comma(*args); end
  def on_fcall(*args); end
  def on_field(*args); end
  def on_float(tok); end
  def on_for(*args); end
  def on_gvar(tok); end
  def on_heredoc_beg(tok); end
  def on_heredoc_dedent(*args); end
  def on_heredoc_end(tok); end
  def on_hshptn(*args); end
  def on_ident(tok); end
  def on_if(*args); end
  def on_if_mod(*args); end
  def on_ifop(*args); end
  def on_ignored_nl(tok); end
  def on_ignored_sp(tok); end
  def on_imaginary(tok); end
  def on_in(*args); end
  def on_int(tok); end
  def on_ivar(tok); end
  def on_kw(tok); end
  def on_kwrest_param(*args); end
  def on_label_end(tok); end
  def on_lbrace(tok); end
  def on_lparen(tok); end
  def on_magic_comment(*args); end
  def on_massign(*args); end
  def on_method_add_arg(list, item); end
  def on_method_add_block(list, item); end
  def on_mlhs_add(list, item); end
  def on_mlhs_add_post(list, item); end
  def on_mlhs_add_star(list, item); end
  def on_mlhs_new(*args); end
  def on_mlhs_paren(*args); end
  def on_module(*args); end
  def on_mrhs_add(list, item); end
  def on_mrhs_add_star(list, item); end
  def on_mrhs_new(*args); end
  def on_mrhs_new_from_args(*args); end
  def on_next(*args); end
  def on_nl(tok); end
  def on_nokw_param(*args); end
  def on_op(tok); end
  def on_opassign(*args); end
  def on_operator_ambiguous(*args); end
  def on_param_error(*args); end
  def on_paren(*args); end
  def on_period(tok); end
  def on_qsymbols_add(list, item); end
  def on_qsymbols_beg(tok); end
  def on_qsymbols_new(*args); end
  def on_qwords_add(list, item); end
  def on_qwords_beg(tok); end
  def on_qwords_new(*args); end
  def on_rational(tok); end
  def on_rbrace(tok); end
  def on_redo(*args); end
  def on_regexp_add(list, item); end
  def on_regexp_beg(tok); end
  def on_regexp_end(tok); end
  def on_regexp_literal(*args); end
  def on_regexp_new(*args); end
  def on_rescue_mod(*args); end
  def on_rest_param(*args); end
  def on_retry(*args); end
  def on_return(*args); end
  def on_return0(*args); end
  def on_rparen(tok); end
  def on_sclass(*args); end
  def on_semicolon(tok); end
  def on_stmts_add(list, item); end
  def on_stmts_new(*args); end
  def on_string_add(list, item); end
  def on_string_concat(*args); end
  def on_string_dvar(*args); end
  def on_string_embexpr(*args); end
  def on_super(*args); end
  def on_symbeg(tok); end
  def on_symbol(*args); end
  def on_symbol_literal(*args); end
  def on_symbols_add(list, item); end
  def on_symbols_beg(tok); end
  def on_symbols_new(*args); end
  def on_tlambda(tok); end
  def on_tlambeg(tok); end
  def on_top_const_field(*args); end
  def on_tstring_beg(tok); end
  def on_tstring_content(tok); end
  def on_tstring_end(tok); end
  def on_undef(*args); end
  def on_unless(*args); end
  def on_unless_mod(*args); end
  def on_until(*args); end
  def on_until_mod(*args); end
  def on_var_alias(*args); end
  def on_var_field(*args); end
  def on_var_ref(*args); end
  def on_vcall(*args); end
  def on_when(*args); end
  def on_while(*args); end
  def on_while_mod(*args); end
  def on_word_add(list, item); end
  def on_word_new(*args); end
  def on_words_add(list, item); end
  def on_words_beg(tok); end
  def on_words_new(*args); end
  def on_words_sep(tok); end
  def on_xstring_add(list, item); end
  def on_xstring_literal(*args); end
  def on_xstring_new(*args); end
  def on_yield(*args); end
  def on_yield0(*args); end
  def on_zsuper(*args); end
  def parse; end
  def root; end
  def shebang_line; end
  def tokens; end

  private

  def add_comment(line, node = T.unsafe(nil), before_node = T.unsafe(nil), into = T.unsafe(nil)); end
  def add_token(token, data); end
  def comment_starts_line?(charno); end
  def compile_error(msg); end
  def freeze_tree(node = T.unsafe(nil)); end
  def insert_comments; end
  def on_aref(*args); end
  def on_aref_field(*args); end
  def on_array(other); end
  def on_assoc_new(*args); end
  def on_assoclist_from_args(*args); end
  def on_bare_assoc_hash(*args); end
  def on_body_stmt(*args); end
  def on_bodystmt(*args); end
  def on_comment(comment); end
  def on_const_path_ref(*args); end
  def on_dyna_symbol(sym); end
  def on_embdoc(text); end
  def on_embdoc_beg(text); end
  def on_embdoc_end(text); end
  def on_hash(*args); end
  def on_label(data); end
  def on_lambda(*args); end
  def on_lbracket(tok); end
  def on_params(*args); end
  def on_parse_error(msg); end
  def on_program(*args); end
  def on_rbracket(tok); end
  def on_rescue(exc, *args); end
  def on_sp(tok); end
  def on_string_content(*args); end
  def on_string_literal(*args); end
  def on_top_const_ref(*args); end
  def on_unary(op, val); end
  def on_void_stmt; end
  def visit_event(node); end
  def visit_event_arr(node); end
  def visit_ns_token(token, data, ast_token = T.unsafe(nil)); end
end

YARD::Parser::Ruby::RipperParser::AST_TOKENS = T.let(T.unsafe(nil), Array)
YARD::Parser::Ruby::RipperParser::MAPPINGS = T.let(T.unsafe(nil), Hash)
YARD::Parser::Ruby::RipperParser::REV_MAPPINGS = T.let(T.unsafe(nil), Hash)

class YARD::Parser::Ruby::RubyParser < ::YARD::Parser::Base
  def initialize(source, filename); end

  def encoding_line; end
  def enumerator; end
  def frozen_string_line; end
  def parse; end
  def shebang_line; end
  def tokenize; end
end

class YARD::Parser::Ruby::TokenResolver
  include ::Enumerable
  include ::YARD::CodeObjects::NamespaceMapper

  def initialize(source, namespace = T.unsafe(nil)); end

  def each; end

  protected

  def last_sep; end
  def last_sep=(v); end
  def next_object; end
  def next_object=(v); end
  def object; end
  def object=(v); end
  def skip_group; end
  def skip_group=(v); end

  private

  def lookup(toktype, name); end
  def object_resolved_types(obj = T.unsafe(nil)); end
  def pop_state; end
  def push_state; end

  class << self
    def state_attr(*attrs); end
  end
end

class YARD::Parser::SourceParser
  def initialize(parser_type = T.unsafe(nil), globals1 = T.unsafe(nil), globals2 = T.unsafe(nil)); end

  def contents; end
  def file; end
  def file=(_arg0); end
  def globals; end
  def parse(content = T.unsafe(nil)); end
  def parser_type; end
  def tokenize(content); end

  private

  def convert_encoding(content); end
  def parser_class; end
  def parser_type=(value); end
  def parser_type_for_filename(filename); end
  def post_process; end

  class << self
    def after_parse_file(&block); end
    def after_parse_file_callbacks; end
    def after_parse_list(&block); end
    def after_parse_list_callbacks; end
    def before_parse_file(&block); end
    def before_parse_file_callbacks; end
    def before_parse_list(&block); end
    def before_parse_list_callbacks; end
    def parse(paths = T.unsafe(nil), excluded = T.unsafe(nil), level = T.unsafe(nil)); end
    def parse_string(content, ptype = T.unsafe(nil)); end
    def parser_type; end
    def parser_type=(value); end
    def parser_type_extensions; end
    def parser_type_extensions=(value); end
    def parser_type_for_extension(extension); end
    def parser_types; end
    def parser_types=(value); end
    def register_parser_type(type, parser_klass, extensions = T.unsafe(nil)); end
    def tokenize(content, ptype = T.unsafe(nil)); end
    def validated_parser_type(type); end

    private

    def parse_in_order(*files); end
  end
end

YARD::Parser::SourceParser::DEFAULT_PATH_GLOB = T.let(T.unsafe(nil), Array)
YARD::Parser::SourceParser::ENCODING_BYTE_ORDER_MARKS = T.let(T.unsafe(nil), Hash)
YARD::Parser::SourceParser::ENCODING_LINE = T.let(T.unsafe(nil), Regexp)
YARD::Parser::SourceParser::FROZEN_STRING_LINE = T.let(T.unsafe(nil), Regexp)
YARD::Parser::SourceParser::SHEBANG_LINE = T.let(T.unsafe(nil), Regexp)
class YARD::Parser::UndocumentableError < ::RuntimeError; end
YARD::ROOT = T.let(T.unsafe(nil), String)
module YARD::Rake; end

class YARD::Rake::YardocTask < ::Rake::TaskLib
  def initialize(name = T.unsafe(nil)); end

  def after; end
  def after=(_arg0); end
  def before; end
  def before=(_arg0); end
  def files; end
  def files=(_arg0); end
  def name; end
  def name=(_arg0); end
  def options; end
  def options=(_arg0); end
  def stats_options; end
  def stats_options=(_arg0); end
  def verifier; end
  def verifier=(_arg0); end

  protected

  def define; end
end

module YARD::Registry
  extend ::Enumerable

  class << self
    def [](path); end
    def all(*types); end
    def at(path); end
    def checksum_for(data); end
    def checksums; end
    def clear; end
    def delete(object); end
    def delete_from_disk; end
    def each(&block); end
    def instance; end
    def load(files = T.unsafe(nil), reparse = T.unsafe(nil)); end
    def load!(file = T.unsafe(nil)); end
    def load_all; end
    def load_yardoc(file = T.unsafe(nil)); end
    def locale(name); end
    def lock_for_writing(file = T.unsafe(nil), &block); end
    def locked_for_writing?(file = T.unsafe(nil)); end
    def paths(reload = T.unsafe(nil)); end
    def po_dir; end
    def po_dir=(dir); end
    def proxy_types; end
    def register(object); end
    def resolve(namespace, name, inheritance = T.unsafe(nil), proxy_fallback = T.unsafe(nil), type = T.unsafe(nil)); end
    def root; end
    def save(merge = T.unsafe(nil), file = T.unsafe(nil)); end
    def single_object_db; end
    def single_object_db=(v); end
    def yardoc_file; end
    def yardoc_file=(v); end
    def yardoc_file_for_gem(gem, ver_require = T.unsafe(nil), for_writing = T.unsafe(nil)); end

    private

    def global_yardoc_file(spec, for_writing = T.unsafe(nil)); end
    def local_yardoc_file(spec, for_writing = T.unsafe(nil)); end
    def old_global_yardoc_file(spec, for_writing = T.unsafe(nil)); end
    def partial_resolve(namespace, name, type = T.unsafe(nil)); end
    def thread_local_resolver; end
    def thread_local_store; end
    def thread_local_store=(value); end
  end
end

YARD::Registry::DEFAULT_PO_DIR = T.let(T.unsafe(nil), String)
YARD::Registry::DEFAULT_YARDOC_FILE = T.let(T.unsafe(nil), String)
YARD::Registry::LOCAL_YARDOC_INDEX = T.let(T.unsafe(nil), String)

class YARD::RegistryResolver
  include ::YARD::CodeObjects::NamespaceMapper

  def initialize(registry = T.unsafe(nil)); end

  def lookup_by_path(path, opts = T.unsafe(nil)); end

  private

  def collect_namespaces(object); end
  def lookup_path_direct(namespace, path, type); end
  def lookup_path_inherited(namespace, path, type); end
  def split_on_separators_match; end
  def starts_with_default_separator_match; end
  def starts_with_separator_match; end
  def validate(obj, type); end
end

class YARD::RegistryStore
  def initialize; end

  def [](key); end
  def []=(key, value); end
  def checksums; end
  def delete(key); end
  def destroy(force = T.unsafe(nil)); end
  def file; end
  def get(key); end
  def keys(reload = T.unsafe(nil)); end
  def load(file = T.unsafe(nil)); end
  def load!(file = T.unsafe(nil)); end
  def load_all; end
  def locale(name); end
  def lock_for_writing(file = T.unsafe(nil), &block); end
  def locked_for_writing?(file = T.unsafe(nil)); end
  def paths_for_type(type, reload = T.unsafe(nil)); end
  def proxy_types; end
  def put(key, value); end
  def root; end
  def save(merge = T.unsafe(nil), file = T.unsafe(nil)); end
  def values(reload = T.unsafe(nil)); end
  def values_for_type(type, reload = T.unsafe(nil)); end

  protected

  def checksums_path; end
  def load_yardoc; end
  def object_types_path; end
  def objects_path; end
  def proxy_types_path; end

  private

  def all_disk_objects; end
  def load_checksums; end
  def load_locale(name); end
  def load_object_types; end
  def load_proxy_types; end
  def load_root; end
  def load_yardoc_old; end
  def write_checksums; end
  def write_complete_lock; end
  def write_object_types; end
  def write_proxy_types; end
end

module YARD::Serializers; end

class YARD::Serializers::Base
  def initialize(opts = T.unsafe(nil)); end

  def after_serialize(data); end
  def before_serialize; end
  def exists?(object); end
  def options; end
  def serialize(object, data); end
  def serialized_path(object); end
end

class YARD::Serializers::FileSystemSerializer < ::YARD::Serializers::Base
  def initialize(opts = T.unsafe(nil)); end

  def basepath; end
  def basepath=(value); end
  def exists?(object); end
  def extension; end
  def extension=(value); end
  def serialize(object, data); end
  def serialized_path(object); end

  private

  def build_filename_map; end
  def encode_path_components(*components); end
  def mapped_name(object); end
end

class YARD::Serializers::ProcessSerializer < ::YARD::Serializers::Base
  def initialize(cmd); end

  def serialize(_object, data); end
end

class YARD::Serializers::StdoutSerializer < ::YARD::Serializers::Base
  def initialize(wrap = T.unsafe(nil)); end

  def serialize(_object, data); end

  private

  def word_wrap(text, _length = T.unsafe(nil)); end
end

class YARD::Serializers::YardocSerializer < ::YARD::Serializers::FileSystemSerializer
  def initialize(yfile); end

  def checksums_path; end
  def complete?; end
  def complete_lock_path; end
  def deserialize(path, is_path = T.unsafe(nil)); end
  def lock_for_writing; end
  def locked_for_writing?; end
  def object_types_path; end
  def objects_path; end
  def processing_path; end
  def proxy_types_path; end
  def serialize(object); end
  def serialized_path(object); end

  private

  def dump(object); end
  def internal_dump(object, first_object = T.unsafe(nil)); end
end

module YARD::Server
  class << self
    def register_static_path(path); end
  end
end

class YARD::Server::Adapter
  def initialize(libs, opts = T.unsafe(nil), server_opts = T.unsafe(nil)); end

  def add_library(library); end
  def document_root; end
  def document_root=(_arg0); end
  def libraries; end
  def libraries=(_arg0); end
  def options; end
  def options=(_arg0); end
  def router; end
  def router=(_arg0); end
  def server_options; end
  def server_options=(_arg0); end
  def start; end

  class << self
    def setup; end
    def shutdown; end
  end
end

module YARD::Server::Commands; end

class YARD::Server::Commands::Base
  def initialize(opts = T.unsafe(nil)); end

  def adapter; end
  def adapter=(_arg0); end
  def body; end
  def body=(_arg0); end
  def caching; end
  def caching=(_arg0); end
  def call(request); end
  def command_options; end
  def command_options=(_arg0); end
  def headers; end
  def headers=(_arg0); end
  def path; end
  def path=(_arg0); end
  def request; end
  def request=(_arg0); end
  def run; end
  def status; end
  def status=(_arg0); end

  protected

  def cache(data); end
  def not_found; end
  def redirect(url); end
  def render(object = T.unsafe(nil)); end

  private

  def add_cache_control; end
end

class YARD::Server::Commands::DisplayFileCommand < ::YARD::Server::Commands::LibraryCommand
  def index; end
  def index=(_arg0); end
  def run; end
end

class YARD::Server::Commands::DisplayObjectCommand < ::YARD::Server::Commands::LibraryCommand
  include ::YARD::Server::DocServerHelper

  def index; end
  def not_found; end
  def run; end

  private

  def object_path; end
end

class YARD::Server::Commands::FramesCommand < ::YARD::Server::Commands::DisplayObjectCommand
  def run; end
end

class YARD::Server::Commands::LibraryCommand < ::YARD::Server::Commands::Base
  def initialize(opts = T.unsafe(nil)); end

  def call(request); end
  def incremental; end
  def incremental=(_arg0); end
  def library; end
  def library=(_arg0); end
  def options; end
  def options=(_arg0); end
  def serializer; end
  def serializer=(_arg0); end
  def single_library; end
  def single_library=(_arg0); end
  def use_fork; end
  def use_fork=(_arg0); end

  private

  def call_with_fork(request, &block); end
  def call_without_fork(request); end
  def can_fork?; end
  def fulldoc_template; end
  def load_yardoc; end
  def not_prepared; end
  def restore_template_info; end
  def save_default_template_info; end
  def setup_library; end
  def setup_yardopts; end
end

YARD::Server::Commands::LibraryCommand::CAN_FORK = T.let(T.unsafe(nil), TrueClass)

class YARD::Server::Commands::LibraryIndexCommand < ::YARD::Server::Commands::Base
  def options; end
  def options=(_arg0); end
  def run; end
end

class YARD::Server::Commands::LibraryIndexOptions < ::YARD::CLI::YardocOptions
  def adapter; end
  def adapter=(_arg0); end
  def libraries; end
  def libraries=(_arg0); end
  def serialize; end
  def serialize=(_arg0); end
  def template; end
  def template=(_arg0); end
  def type; end
  def type=(_arg0); end
end

class YARD::Server::Commands::LibraryOptions < ::YARD::CLI::YardocOptions
  def adapter; end
  def command; end
  def command=(_arg0); end
  def each(&block); end
  def frames; end
  def frames=(_arg0); end
  def library; end
  def serialize; end
  def serializer; end
  def single_library; end
end

class YARD::Server::Commands::ListCommand < ::YARD::Server::Commands::LibraryCommand
  include ::YARD::Templates::Helpers::BaseHelper

  def run; end
end

class YARD::Server::Commands::RootRequestCommand < ::YARD::Server::Commands::Base
  include ::WEBrick::HTTPUtils
  include ::YARD::Server::Commands::StaticFileHelpers

  def run; end
end

class YARD::Server::Commands::SearchCommand < ::YARD::Server::Commands::LibraryCommand
  include ::YARD::Templates::Helpers::BaseHelper
  include ::YARD::Templates::Helpers::ModuleHelper
  include ::YARD::Server::DocServerHelper

  def query; end
  def query=(_arg0); end
  def results; end
  def results=(_arg0); end
  def run; end
  def visible_results; end

  private

  def search_for_object; end
  def serve_normal; end
  def serve_xhr; end
  def url_for(object); end
end

class YARD::Server::Commands::StaticFileCommand < ::YARD::Server::Commands::LibraryCommand
  include ::WEBrick::HTTPUtils
  include ::YARD::Server::Commands::StaticFileHelpers

  def run; end
end

YARD::Server::Commands::StaticFileCommand::STATIC_PATHS = T.let(T.unsafe(nil), Array)

module YARD::Server::Commands::StaticFileHelpers
  include ::WEBrick::HTTPUtils

  def favicon?; end
  def static_template_file?; end

  private

  def find_file(adapter, url); end

  class << self
    def find_file(adapter, url); end
  end
end

module YARD::Server::DocServerHelper
  def abs_url(*path_components); end
  def base_path(path); end
  def mtime(file); end
  def mtime_url(file); end
  def router; end
  def url_for(obj, anchor = T.unsafe(nil), relative = T.unsafe(nil)); end
  def url_for_file(filename, anchor = T.unsafe(nil)); end
  def url_for_frameset; end
  def url_for_index; end
  def url_for_list(type); end
  def url_for_main; end
end

class YARD::Server::DocServerSerializer < ::YARD::Serializers::FileSystemSerializer
  def initialize(_command = T.unsafe(nil)); end

  def serialized_path(object); end

  private

  def urlencode(name); end
end

class YARD::Server::FinishRequest < ::RuntimeError; end
class YARD::Server::LibraryNotPreparedError < ::RuntimeError; end

class YARD::Server::LibraryVersion
  def initialize(name, version = T.unsafe(nil), yardoc = T.unsafe(nil), source = T.unsafe(nil)); end

  def ==(other); end
  def eql?(other); end
  def equal?(other); end
  def gemspec; end
  def hash; end
  def name; end
  def name=(_arg0); end
  def prepare!; end
  def ready?; end
  def source; end
  def source=(_arg0); end
  def source_path; end
  def source_path=(_arg0); end
  def to_s(url_format = T.unsafe(nil)); end
  def version; end
  def version=(_arg0); end
  def yardoc_file; end
  def yardoc_file=(_arg0); end

  protected

  def load_yardoc_from_disk; end
  def load_yardoc_from_gem; end
  def source_path_for_disk; end
  def source_path_for_gem; end
  def yardoc_file_for_gem; end

  private

  def load_source_path; end
  def load_yardoc_file; end
  def serializer; end
end

class YARD::Server::NotFoundError < ::RuntimeError; end

class YARD::Server::RackAdapter < ::YARD::Server::Adapter
  include ::WEBrick::HTTPUtils

  def call(env); end
  def start; end

  private

  def print_start_message(server); end
end

class YARD::Server::RackMiddleware
  def initialize(app, opts = T.unsafe(nil)); end

  def call(env); end
end

class YARD::Server::Router
  include ::YARD::Server::StaticCaching
  include ::YARD::Server::Commands

  def initialize(adapter); end

  def adapter; end
  def adapter=(_arg0); end
  def call(request); end
  def docs_prefix; end
  def list_prefix; end
  def parse_library_from_path(paths); end
  def request; end
  def request=(_arg0); end
  def search_prefix; end
  def static_prefix; end

  protected

  def final_options(library, paths); end
  def route(path = T.unsafe(nil)); end
  def route_docs(library, paths); end
  def route_index; end
  def route_list(library, paths); end
  def route_search(library, paths); end
  def route_static(library, paths); end
end

module YARD::Server::StaticCaching
  def check_static_cache; end
end

class YARD::Server::WebrickAdapter < ::YARD::Server::Adapter
  def start; end
end

class YARD::Server::WebrickServlet < ::WEBrick::HTTPServlet::AbstractServlet
  def initialize(server, adapter); end

  def adapter; end
  def adapter=(_arg0); end
  def do_GET(request, response); end
end

class YARD::StubProxy
  def initialize(path, transient = T.unsafe(nil)); end

  def _dump(_depth); end
  def hash; end
  def method_missing(meth, *args, &block); end

  class << self
    def _load(str); end
  end
end

YARD::StubProxy::FILELEN = T.let(T.unsafe(nil), Integer)
YARD::TEMPLATE_ROOT = T.let(T.unsafe(nil), String)
module YARD::Tags; end

class YARD::Tags::AttributeDirective < ::YARD::Tags::MethodDirective
  def after_parse; end

  protected

  def method_name; end
  def method_signature; end

  private

  def create_attribute_data(object); end
  def readable?; end
  def writable?; end
end

class YARD::Tags::DefaultFactory
  def parse_tag(tag_name, text); end
  def parse_tag_with_name(tag_name, text); end
  def parse_tag_with_options(tag_name, text); end
  def parse_tag_with_title_and_text(tag_name, text); end
  def parse_tag_with_types(tag_name, text); end
  def parse_tag_with_types_and_name(tag_name, text); end
  def parse_tag_with_types_and_title(tag_name, text); end
  def parse_tag_with_types_name_and_default(tag_name, text); end

  private

  def extract_name_from_text(text); end
  def extract_title_and_desc_from_text(text); end
  def extract_types_and_name_from_text(text, opening_types = T.unsafe(nil), closing_types = T.unsafe(nil)); end
  def extract_types_and_name_from_text_unstripped(text, opening_types = T.unsafe(nil), closing_types = T.unsafe(nil)); end
end

YARD::Tags::DefaultFactory::TYPELIST_CLOSING_CHARS = T.let(T.unsafe(nil), String)
YARD::Tags::DefaultFactory::TYPELIST_OPENING_CHARS = T.let(T.unsafe(nil), String)

class YARD::Tags::DefaultTag < ::YARD::Tags::Tag
  def initialize(tag_name, text, types = T.unsafe(nil), name = T.unsafe(nil), defaults = T.unsafe(nil)); end

  def defaults; end
end

class YARD::Tags::Directive
  def initialize(tag, parser); end

  def after_parse; end
  def call; end
  def expanded_text; end
  def expanded_text=(_arg0); end
  def handler; end
  def object; end
  def parser=(_arg0); end
  def tag; end
  def tag=(_arg0); end

  protected

  def inside_directive?; end
  def parser; end
end

class YARD::Tags::EndGroupDirective < ::YARD::Tags::Directive
  def call; end
end

class YARD::Tags::GroupDirective < ::YARD::Tags::Directive
  def call; end
end

class YARD::Tags::Library
  def initialize(factory = T.unsafe(nil)); end

  def abstract_tag(text); end
  def api_tag(text); end
  def attr_reader_tag(text); end
  def attr_tag(text); end
  def attr_writer_tag(text); end
  def attribute_directive(tag, parser); end
  def author_tag(text); end
  def deprecated_tag(text); end
  def directive_create(tag_name, tag_buf, parser); end
  def endgroup_directive(tag, parser); end
  def example_tag(text); end
  def factory; end
  def factory=(_arg0); end
  def group_directive(tag, parser); end
  def has_directive?(tag_name); end
  def has_tag?(tag_name); end
  def macro_directive(tag, parser); end
  def method_directive(tag, parser); end
  def note_tag(text); end
  def option_tag(text); end
  def overload_tag(text); end
  def param_tag(text); end
  def parse_directive(tag, parser); end
  def private_tag(text); end
  def raise_tag(text); end
  def return_tag(text); end
  def scope_directive(tag, parser); end
  def see_tag(text); end
  def since_tag(text); end
  def tag_create(tag_name, tag_buf); end
  def todo_tag(text); end
  def version_tag(text); end
  def visibility_directive(tag, parser); end
  def yield_tag(text); end
  def yieldparam_tag(text); end
  def yieldreturn_tag(text); end

  private

  def directive_call(tag, parser); end
  def send_to_factory(tag_name, meth, text); end

  class << self
    def default_factory; end
    def default_factory=(factory); end
    def define_directive(tag, tag_meth = T.unsafe(nil), directive_class = T.unsafe(nil)); end
    def define_tag(label, tag, meth = T.unsafe(nil)); end
    def directive_method_name(tag_name); end
    def factory_method_for(tag); end
    def factory_method_for_directive(directive); end
    def instance; end
    def labels; end
    def sorted_labels; end
    def tag_method_name(tag_name); end
    def transitive_tags; end
    def transitive_tags=(_arg0); end
    def visible_tags; end
    def visible_tags=(_arg0); end

    private

    def tag_or_directive_method_name(tag_name, type = T.unsafe(nil)); end
  end
end

class YARD::Tags::MacroDirective < ::YARD::Tags::Directive
  def call; end

  private

  def anonymous?; end
  def attach?; end
  def class_method?; end
  def expand(macro_data); end
  def find_or_create; end
  def new?; end
  def warn; end
end

class YARD::Tags::MethodDirective < ::YARD::Tags::Directive
  def after_parse; end
  def call; end

  protected

  def create_object; end
  def method_name; end
  def method_signature; end
  def sanitized_tag_signature; end
  def use_indented_text; end
end

YARD::Tags::MethodDirective::SCOPE_MATCH = T.let(T.unsafe(nil), Regexp)

class YARD::Tags::OptionTag < ::YARD::Tags::Tag
  def initialize(tag_name, name, pair); end

  def pair; end
  def pair=(_arg0); end
end

class YARD::Tags::OverloadTag < ::YARD::Tags::Tag
  def initialize(tag_name, text); end

  def docstring; end
  def has_tag?(name); end
  def is_a?(other); end
  def kind_of?(other); end
  def method_missing(*args, &block); end
  def name(prefix = T.unsafe(nil)); end
  def object=(value); end
  def parameters; end
  def signature; end
  def tag(name); end
  def tags(name = T.unsafe(nil)); end
  def type; end

  private

  def parse_signature; end
  def parse_tag(text); end
end

class YARD::Tags::ParseDirective < ::YARD::Tags::Directive
  def call; end
end

module YARD::Tags::RefTag
  def owner; end
  def owner=(_arg0); end
end

class YARD::Tags::RefTagList
  def initialize(tag_name, owner, name = T.unsafe(nil)); end

  def name; end
  def name=(_arg0); end
  def owner; end
  def owner=(_arg0); end
  def tag_name; end
  def tag_name=(_arg0); end
  def tags; end
end

class YARD::Tags::ScopeDirective < ::YARD::Tags::Directive
  def call; end
end

class YARD::Tags::Tag
  def initialize(tag_name, text, types = T.unsafe(nil), name = T.unsafe(nil)); end

  def explain_types; end
  def name; end
  def name=(_arg0); end
  def object; end
  def object=(_arg0); end
  def tag_name; end
  def tag_name=(_arg0); end
  def text; end
  def text=(_arg0); end
  def type; end
  def types; end
  def types=(_arg0); end
end

class YARD::Tags::TagFormatError < ::RuntimeError; end

class YARD::Tags::TypesExplainer
  class << self
    def explain(*types); end
    def explain!(*types); end
  end
end

class YARD::Tags::TypesExplainer::CollectionType < ::YARD::Tags::TypesExplainer::Type
  def initialize(name, types); end

  def to_s(_singular = T.unsafe(nil)); end
  def types; end
  def types=(_arg0); end
end

class YARD::Tags::TypesExplainer::FixedCollectionType < ::YARD::Tags::TypesExplainer::CollectionType
  def to_s(_singular = T.unsafe(nil)); end
end

class YARD::Tags::TypesExplainer::HashCollectionType < ::YARD::Tags::TypesExplainer::Type
  def initialize(name, key_types, value_types); end

  def key_types; end
  def key_types=(_arg0); end
  def to_s(_singular = T.unsafe(nil)); end
  def value_types; end
  def value_types=(_arg0); end
end

class YARD::Tags::TypesExplainer::Parser
  include ::YARD::CodeObjects

  def initialize(string); end

  def parse; end

  class << self
    def parse(string); end
  end
end

YARD::Tags::TypesExplainer::Parser::TOKENS = T.let(T.unsafe(nil), Hash)

class YARD::Tags::TypesExplainer::Type
  def initialize(name); end

  def name; end
  def name=(_arg0); end
  def to_s(singular = T.unsafe(nil)); end

  private

  def list_join(list); end
end

class YARD::Tags::VisibilityDirective < ::YARD::Tags::Directive
  def call; end
end

module YARD::Templates; end

module YARD::Templates::Engine
  class << self
    def generate(objects, options = T.unsafe(nil)); end
    def register_template_path(path); end
    def render(options = T.unsafe(nil)); end
    def template(*path); end
    def template!(path, full_paths = T.unsafe(nil)); end
    def template_paths; end
    def template_paths=(_arg0); end
    def with_serializer(object, serializer); end

    private

    def find_template_paths(from_template, path); end
    def set_default_options(options = T.unsafe(nil)); end
    def template_module_name(path); end
  end
end

module YARD::Templates::ErbCache
  class << self
    def clear!; end
    def method_for(filename); end
  end
end

module YARD::Templates::Helpers; end

module YARD::Templates::Helpers::BaseHelper
  def format_object_title(object); end
  def format_object_type(object); end
  def format_source(value); end
  def format_types(list, brackets = T.unsafe(nil)); end
  def globals; end
  def h(text); end
  def link_file(filename, title = T.unsafe(nil), anchor = T.unsafe(nil)); end
  def link_include_file(file); end
  def link_include_object(obj); end
  def link_object(obj, title = T.unsafe(nil)); end
  def link_url(url, title = T.unsafe(nil), params = T.unsafe(nil)); end
  def linkify(*args); end
  def object; end
  def object=(_arg0); end
  def owner; end
  def run_verifier(list); end
  def serializer; end
  def serializer=(_arg0); end
end

module YARD::Templates::Helpers::FilterHelper
  def is_class?(object); end
  def is_method?(object); end
  def is_module?(object); end
  def is_namespace?(object); end
end

module YARD::Templates::Helpers::HtmlHelper
  include ::YARD::Templates::Helpers::MarkupHelper
  include ::YARD::Templates::Helpers::ModuleHelper
  include ::YARD::Templates::Helpers::HtmlSyntaxHighlightHelper

  def anchor_for(object); end
  def charset; end
  def format_object_name_list(objects); end
  def format_types(typelist, brackets = T.unsafe(nil)); end
  def h(text); end
  def html_markup_asciidoc(text); end
  def html_markup_html(text); end
  def html_markup_markdown(text); end
  def html_markup_none(text); end
  def html_markup_org(text); end
  def html_markup_pre(text); end
  def html_markup_rdoc(text); end
  def html_markup_ruby(source); end
  def html_markup_text(text); end
  def html_markup_textile(text); end
  def html_markup_textile_strict(text); end
  def html_syntax_highlight(source, type = T.unsafe(nil)); end
  def html_syntax_highlight_plain(source); end
  def htmlify(text, markup = T.unsafe(nil)); end
  def htmlify_line(*args); end
  def insert_include(text, markup = T.unsafe(nil)); end
  def link_file(filename, title = T.unsafe(nil), anchor = T.unsafe(nil)); end
  def link_include_file(file); end
  def link_include_object(obj); end
  def link_object(obj, title = T.unsafe(nil), anchor = T.unsafe(nil), relative = T.unsafe(nil)); end
  def link_url(url, title = T.unsafe(nil), params = T.unsafe(nil)); end
  def mtime(_file); end
  def mtime_url(obj, anchor = T.unsafe(nil), relative = T.unsafe(nil)); end
  def resolve_links(text); end
  def signature(meth, link = T.unsafe(nil), show_extras = T.unsafe(nil), full_attr_name = T.unsafe(nil)); end
  def signature_types(meth, link = T.unsafe(nil)); end
  def url_for(obj, anchor = T.unsafe(nil), relative = T.unsafe(nil)); end
  def url_for_file(filename, anchor = T.unsafe(nil)); end
  def url_for_frameset; end
  def url_for_index; end
  def url_for_list(type); end
  def url_for_main; end

  private

  def convert_method_to_overload(meth); end
  def detect_lang_in_codeblock_attributes(pre_html_attrs, code_html_attrs); end
  def parse_codeblocks(html); end
  def parse_lang_for_codeblock(source); end
  def tag_attrs(opts = T.unsafe(nil)); end
  def urlencode(text); end

  class << self
    def urlencode(text); end
  end
end

YARD::Templates::Helpers::HtmlHelper::ASCIIDOC_ATTRIBUTES = T.let(T.unsafe(nil), Hash)
YARD::Templates::Helpers::HtmlHelper::URLMATCH = T.let(T.unsafe(nil), Regexp)

module YARD::Templates::Helpers::HtmlSyntaxHighlightHelper
  include ::YARD::Templates::Helpers::ModuleHelper

  def html_syntax_highlight_ruby(source); end

  private

  def clean_token_object(token_obj); end
  def html_syntax_highlight_ruby_legacy(source); end
  def html_syntax_highlight_ruby_ripper(source); end
end

module YARD::Templates::Helpers::Markup; end

class YARD::Templates::Helpers::Markup::RDocMarkdown < ::YARD::Templates::Helpers::Markup::RDocMarkup
  def initialize(text); end

  def fix_typewriter(html); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup
  def initialize(text); end

  def from_path; end
  def from_path=(_arg0); end
  def to_html; end

  private

  def fix_dash_dash(text); end
  def fix_typewriter(text); end
end

YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP = RDoc::Markup

class YARD::Templates::Helpers::Markup::RDocMarkupToHtml < ::RDoc::Markup::ToHtml
  def initialize; end

  def accept_paragraph(*args); end
  def from_path; end
  def from_path=(_arg0); end
  def handle_special_HYPERLINK(special); end
end

module YARD::Templates::Helpers::MarkupHelper
  def load_markup_provider(type = T.unsafe(nil)); end
  def markup_class(type = T.unsafe(nil)); end
  def markup_file_contents(contents); end
  def markup_for_file(contents, filename); end
  def markup_provider(type = T.unsafe(nil)); end

  class << self
    def clear_markup_cache; end
    def markup_cache; end
    def markup_cache=(_arg0); end
  end
end

YARD::Templates::Helpers::MarkupHelper::MARKUP_EXTENSIONS = T.let(T.unsafe(nil), Hash)
YARD::Templates::Helpers::MarkupHelper::MARKUP_FILE_SHEBANG = T.let(T.unsafe(nil), Regexp)
YARD::Templates::Helpers::MarkupHelper::MARKUP_PROVIDERS = T.let(T.unsafe(nil), Hash)

module YARD::Templates::Helpers::MethodHelper
  def format_args(object); end
  def format_block(object); end
  def format_code(object, _show_lines = T.unsafe(nil)); end
  def format_constant(value); end
  def format_lines(object); end
  def format_return_types(object); end
end

module YARD::Templates::Helpers::ModuleHelper
  def prune_method_listing(list, hide_attributes = T.unsafe(nil)); end
end

module YARD::Templates::Helpers::TextHelper
  def align_right(text, spacer = T.unsafe(nil), col = T.unsafe(nil)); end
  def h(text); end
  def hr(col = T.unsafe(nil), sep = T.unsafe(nil)); end
  def indent(text, len = T.unsafe(nil)); end
  def signature(meth); end
  def title_align_right(text, col = T.unsafe(nil)); end
  def wrap(text, col = T.unsafe(nil)); end

  private

  def resolve_links(text); end
end

module YARD::Templates::Helpers::UMLHelper
  def format_path(object); end
  def h(text); end
  def tidy(data); end
  def uml_visibility(object); end
end

class YARD::Templates::Section < ::Array
  def initialize(name, *args); end

  def <<(*args); end
  def ==(other); end
  def [](*args); end
  def any(item); end
  def dup; end
  def eql?(other); end
  def inspect; end
  def name; end
  def name=(_arg0); end
  def place(*args); end
  def push(*args); end
  def to_a; end
  def unshift(*args); end

  private

  def parse_sections(args); end
end

module YARD::Templates::Template
  include ::YARD::Templates::ErbCache
  include ::YARD::Templates::Helpers::BaseHelper
  include ::YARD::Templates::Helpers::MethodHelper

  mixes_in_class_methods ::YARD::Templates::Template::ClassMethods

  def initialize(opts = T.unsafe(nil)); end

  def T(*path); end
  def class; end
  def class=(_arg0); end
  def erb(section, &block); end
  def file(basename, allow_inherited = T.unsafe(nil)); end
  def init; end
  def inspect; end
  def options; end
  def options=(value); end
  def run(opts = T.unsafe(nil), sects = T.unsafe(nil), start_at = T.unsafe(nil), break_first = T.unsafe(nil), &block); end
  def section; end
  def section=(_arg0); end
  def sections(*args); end
  def superb(sect = T.unsafe(nil), &block); end
  def yieldall(opts = T.unsafe(nil), &block); end

  protected

  def erb_file_for(section); end
  def erb_with(content, filename = T.unsafe(nil)); end

  private

  def add_options(opts = T.unsafe(nil)); end
  def cache(section); end
  def cache_filename(section); end
  def render_section(section, &block); end
  def set_ivars; end
  def with_section; end

  class << self
    def extra_includes; end
    def extra_includes=(_arg0); end
    def include_extra(template, options); end
    def included(klass); end
  end
end

module YARD::Templates::Template::ClassMethods
  def initialize(path, full_paths); end

  def S(*args); end
  def T(*path); end
  def find_file(basename); end
  def find_nth_file(basename, index = T.unsafe(nil)); end
  def full_path; end
  def full_path=(_arg0); end
  def full_paths; end
  def is_a?(klass); end
  def new(*args); end
  def path; end
  def path=(_arg0); end
  def reset_full_paths; end
  def run(*args); end

  private

  def include_inherited(full_paths); end
  def include_parent; end
  def load_setup_rb; end
end

class YARD::Templates::TemplateOptions < ::YARD::Options
  def __globals; end
  def default_return; end
  def default_return=(_arg0); end
  def embed_mixins; end
  def embed_mixins=(_arg0); end
  def embed_mixins_match?(mixin); end
  def format; end
  def format=(_arg0); end
  def globals; end
  def globals=(_arg0); end
  def hide_void_return; end
  def hide_void_return=(_arg0); end
  def highlight; end
  def highlight=(_arg0); end
  def index; end
  def index=(_arg0); end
  def markup; end
  def markup=(_arg0); end
  def markup_provider; end
  def markup_provider=(_arg0); end
  def no_highlight; end
  def no_highlight=(value); end
  def object; end
  def object=(_arg0); end
  def owner; end
  def owner=(_arg0); end
  def page_title; end
  def page_title=(_arg0); end
  def serialize; end
  def serialize=(_arg0); end
  def serializer; end
  def serializer=(_arg0); end
  def template; end
  def template=(_arg0); end
  def type; end
  def type=(_arg0); end
  def verifier; end
  def verifier=(_arg0); end
end

YARD::VERSION = T.let(T.unsafe(nil), String)

class YARD::Verifier
  def initialize(*expressions); end

  def add_expressions(*expressions); end
  def call(object); end
  def expressions; end
  def expressions=(value); end
  def method_missing(sym, *args, &block); end
  def run(list); end

  protected

  def o; end
  def object; end

  private

  def create_method_from_expressions; end
  def modify_nilclass; end
  def parse_expression(expr); end
  def unmodify_nilclass; end
end

YARD::Verifier::NILCLASS_METHODS = T.let(T.unsafe(nil), Array)
