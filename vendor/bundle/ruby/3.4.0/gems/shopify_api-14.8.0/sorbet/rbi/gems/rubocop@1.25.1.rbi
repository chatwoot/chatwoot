# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rubocop` gem.
# Please instead update this file by running `bin/tapioca gem rubocop`.

module RuboCop; end

class RuboCop::CLI
  def initialize; end

  def config_store; end
  def options; end
  def run(args = T.unsafe(nil)); end

  private

  def act_on_options; end
  def apply_default_formatter; end
  def execute_runners; end
  def handle_exiting_options; end
  def parallel_by_default!; end
  def run_command(name); end
  def set_options_to_config_loader; end
  def suggest_extensions; end
  def validate_options_vs_config; end
end

module RuboCop::CLI::Command
  class << self
    def run(env, name); end

    private

    def class_for(name); end
  end
end

class RuboCop::CLI::Command::AutoGenerateConfig < ::RuboCop::CLI::Command::Base
  def run; end

  private

  def add_formatter; end
  def add_inheritance_from_auto_generated_file(config_file); end
  def execute_runner; end
  def existing_configuration(config_file); end
  def line_length_cop(config); end
  def line_length_enabled?(config); end
  def max_line_length(config); end
  def maybe_run_line_length_cop; end
  def reset_config_and_auto_gen_file; end
  def run_all_cops(line_length_contents); end
  def run_line_length_cop; end
  def same_max_line_length?(config1, config2); end
  def skip_line_length_cop(reason); end
  def write_config_file(file_name, file_string, rubocop_yml_contents); end
end

RuboCop::CLI::Command::AutoGenerateConfig::AUTO_GENERATED_FILE = T.let(T.unsafe(nil), String)
RuboCop::CLI::Command::AutoGenerateConfig::PHASE_1 = T.let(T.unsafe(nil), String)
RuboCop::CLI::Command::AutoGenerateConfig::PHASE_1_DISABLED = T.let(T.unsafe(nil), String)
RuboCop::CLI::Command::AutoGenerateConfig::PHASE_1_OVERRIDDEN = T.let(T.unsafe(nil), String)
RuboCop::CLI::Command::AutoGenerateConfig::PHASE_2 = T.let(T.unsafe(nil), String)
RuboCop::CLI::Command::AutoGenerateConfig::YAML_OPTIONAL_DOC_START = T.let(T.unsafe(nil), Regexp)

class RuboCop::CLI::Command::Base
  def initialize(env); end

  def env; end

  class << self
    def by_command_name(name); end
    def command_name; end
    def command_name=(_arg0); end
    def inherited(subclass); end
  end
end

class RuboCop::CLI::Command::ExecuteRunner < ::RuboCop::CLI::Command::Base
  include ::RuboCop::Formatter::TextUtil

  def run; end

  private

  def display_error_summary(errors); end
  def display_summary(runner); end
  def display_warning_summary(warnings); end
  def execute_runner(paths); end
  def maybe_print_corrected_source; end
  def with_redirect; end
end

RuboCop::CLI::Command::ExecuteRunner::INTEGRATION_FORMATTERS = T.let(T.unsafe(nil), Array)

class RuboCop::CLI::Command::InitDotfile < ::RuboCop::CLI::Command::Base
  def run; end
end

RuboCop::CLI::Command::InitDotfile::DOTFILE = T.let(T.unsafe(nil), String)

class RuboCop::CLI::Command::ShowCops < ::RuboCop::CLI::Command::Base
  def initialize(env); end

  def run; end

  private

  def config_lines(cop); end
  def cops_of_department(cops, department); end
  def print_available_cops; end
  def print_cop_details(cops); end
  def print_cops_of_department(registry, department, show_all); end
  def selected_cops_of_department(cops, department); end
end

class RuboCop::CLI::Command::ShowDocsUrl < ::RuboCop::CLI::Command::Base
  def initialize(env); end

  def run; end

  private

  def cops_array; end
  def print_documentation_url; end
  def registry_hash; end
end

class RuboCop::CLI::Command::SuggestExtensions < ::RuboCop::CLI::Command::Base
  def run; end

  private

  def current_formatter; end
  def dependent_gems; end
  def extensions; end
  def installed_gems; end
  def lockfile; end
  def puts(*args); end
  def skip?; end
end

RuboCop::CLI::Command::SuggestExtensions::INCLUDED_FORMATTERS = T.let(T.unsafe(nil), Array)

class RuboCop::CLI::Command::Version < ::RuboCop::CLI::Command::Base
  def run; end
end

RuboCop::CLI::DEFAULT_PARALLEL_OPTIONS = T.let(T.unsafe(nil), Array)

class RuboCop::CLI::Environment
  def initialize(options, config_store, paths); end

  def config_store; end
  def options; end
  def paths; end
  def run(name); end
end

class RuboCop::CLI::Finished < ::RuntimeError; end
RuboCop::CLI::STATUS_ERROR = T.let(T.unsafe(nil), Integer)
RuboCop::CLI::STATUS_INTERRUPTED = T.let(T.unsafe(nil), Integer)
RuboCop::CLI::STATUS_OFFENSES = T.let(T.unsafe(nil), Integer)
RuboCop::CLI::STATUS_SUCCESS = T.let(T.unsafe(nil), Integer)

class RuboCop::CachedData
  def initialize(filename); end

  def from_json(text); end
  def to_json(offenses); end

  private

  def deserialize_offenses(offenses); end
  def message(offense); end
  def serialize_offense(offense); end
end

class RuboCop::CommentConfig
  def initialize(processed_source); end

  def comment_only_line?(line_number); end
  def cop_disabled_line_ranges; end
  def cop_enabled_at_line?(cop, line_number); end
  def extra_enabled_comments; end
  def processed_source; end

  private

  def analyze; end
  def analyze_cop(analysis, directive); end
  def analyze_disabled(analysis, directive); end
  def analyze_rest(analysis, directive); end
  def analyze_single_line(analysis, directive); end
  def cop_line_ranges(analysis); end
  def each_directive; end
  def extra_enabled_comments_with_names(extras:, names:); end
  def handle_enable_all(directive, names, extras); end
  def handle_switch(directive, names, extras); end
  def non_comment_token_line_numbers; end
  def qualified_cop_name(cop_name); end
end

class RuboCop::CommentConfig::CopAnalysis < ::Struct
  def line_ranges; end
  def line_ranges=(_); end
  def start_line_number; end
  def start_line_number=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class RuboCop::Config
  include ::RuboCop::PathUtil
  include ::RuboCop::FileFinder
  extend ::Forwardable

  def initialize(hash = T.unsafe(nil), loaded_path = T.unsafe(nil)); end

  def [](*args, &block); end
  def []=(*args, &block); end
  def add_excludes_from_higher_level(highest_config); end
  def allowed_camel_case_file?(file); end
  def base_dir_for_path_parameters; end
  def bundler_lock_file_path; end
  def check; end
  def delete(*args, &block); end
  def deprecation_check; end
  def dig(*args, &block); end
  def disabled_new_cops?; end
  def each(*args, &block); end
  def each_key(*args, &block); end
  def enabled_new_cops?; end
  def fetch(*args, &block); end
  def file_to_exclude?(file); end
  def file_to_include?(file); end
  def for_all_cops; end
  def for_badge(badge); end
  def for_cop(cop); end
  def for_department(department_name); end
  def internal?; end
  def key?(*args, &block); end
  def keys(*args, &block); end
  def loaded_features; end
  def loaded_path; end
  def make_excludes_absolute; end
  def map(*args, &block); end
  def merge(*args, &block); end
  def path_relative_to_config(path); end
  def patterns_to_exclude; end
  def patterns_to_include; end
  def pending_cops; end
  def possibly_include_hidden?; end
  def replace(*args, &block); end
  def signature; end
  def smart_loaded_path; end
  def target_rails_version; end
  def target_ruby_version(*args, &block); end
  def to_h(*args, &block); end
  def to_hash(*args, &block); end
  def to_s; end
  def transform_values(*args, &block); end
  def validate(*args, &block); end
  def validate_after_resolution; end

  private

  def department_of(qualified_cop_name); end
  def enable_cop?(qualified_cop_name, cop_options); end
  def read_rails_version_from_bundler_lock_file; end
  def target_rails_version_from_bundler_lock_file; end

  class << self
    def create(hash, path, check: T.unsafe(nil)); end
  end
end

class RuboCop::Config::CopConfig < ::Struct
  def metadata; end
  def metadata=(_); end
  def name; end
  def name=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

RuboCop::Config::DEFAULT_RAILS_VERSION = T.let(T.unsafe(nil), Float)

class RuboCop::ConfigLoader
  extend ::RuboCop::FileFinder

  class << self
    def add_excludes_from_files(config, config_file); end
    def add_loaded_features(loaded_features); end
    def add_missing_namespaces(path, hash); end
    def clear_options; end
    def configuration_file_for(target_dir); end
    def configuration_from_file(config_file, check: T.unsafe(nil)); end
    def debug; end
    def debug=(_arg0); end
    def debug?; end
    def default_configuration; end
    def default_configuration=(_arg0); end
    def disable_pending_cops; end
    def disable_pending_cops=(_arg0); end
    def enable_pending_cops; end
    def enable_pending_cops=(_arg0); end
    def ignore_parent_exclusion; end
    def ignore_parent_exclusion=(_arg0); end
    def ignore_parent_exclusion?; end
    def load_file(file, check: T.unsafe(nil)); end
    def load_yaml_configuration(absolute_path); end
    def loaded_features; end
    def merge(base_hash, derived_hash); end
    def merge_with_default(config, config_file, unset_nil: T.unsafe(nil)); end
    def possible_new_cops?(config); end
    def project_root; end
    def project_root=(_arg0); end
    def warn_on_pending_cops(pending_cops); end
    def warn_pending_cop(cop); end

    private

    def check_duplication(yaml_code, absolute_path); end
    def expand_path(path); end
    def file_path(file); end
    def find_project_dotfile(target_dir); end
    def find_project_root; end
    def find_user_dotfile; end
    def find_user_xdg_config; end
    def read_file(absolute_path); end
    def resolver; end
    def yaml_safe_load(yaml_code, filename); end
    def yaml_safe_load!(yaml_code, filename); end
  end
end

RuboCop::ConfigLoader::DEFAULT_FILE = T.let(T.unsafe(nil), String)
RuboCop::ConfigLoader::DOTFILE = T.let(T.unsafe(nil), String)
RuboCop::ConfigLoader::RUBOCOP_HOME = T.let(T.unsafe(nil), String)
RuboCop::ConfigLoader::XDG_CONFIG = T.let(T.unsafe(nil), String)

class RuboCop::ConfigLoaderResolver
  def fix_include_paths(base_config_path, hash, path, key, value); end
  def merge(base_hash, derived_hash, **opts); end
  def merge_with_default(config, config_file, unset_nil:); end
  def override_department_setting_for_cops(base_hash, derived_hash); end
  def override_enabled_for_disabled_departments(base_hash, derived_hash); end
  def resolve_inheritance(path, hash, file, debug); end
  def resolve_inheritance_from_gems(hash); end
  def resolve_requires(path, hash); end

  private

  def base_configs(path, inherit_from, file); end
  def determine_inherit_mode(hash, key); end
  def disabled?(hash, department); end
  def duplicate_setting?(base_hash, derived_hash, key, inherited_file); end
  def gem_config_path(gem_name, relative_config_path); end
  def handle_disabled_by_default(config, new_default_configuration); end
  def inherited_file(path, inherit_from, file); end
  def merge_hashes?(base_hash, derived_hash, key); end
  def remote_file?(uri); end
  def should_merge?(mode, key); end
  def should_override?(mode, key); end
  def should_union?(derived_hash, base_hash, root_mode, key); end
  def transform(config, &block); end
  def warn_on_duplicate_setting(base_hash, derived_hash, key, **opts); end
end

class RuboCop::ConfigNotFoundError < ::RuboCop::Error; end

class RuboCop::ConfigObsoletion
  def initialize(config); end

  def reject_obsolete!; end
  def rules; end
  def warnings; end

  private

  def load_cop_rules(rules); end
  def load_parameter_rules(rules); end
  def load_rules; end
  def obsoletions; end

  class << self
    def files; end
    def files=(_arg0); end
    def legacy_cop_names; end
  end
end

RuboCop::ConfigObsoletion::COP_RULE_CLASSES = T.let(T.unsafe(nil), Hash)

class RuboCop::ConfigObsoletion::ChangedEnforcedStyles < ::RuboCop::ConfigObsoletion::ParameterRule
  def message; end
  def violated?; end

  private

  def value; end
end

RuboCop::ConfigObsoletion::ChangedEnforcedStyles::BASE_MESSAGE = T.let(T.unsafe(nil), String)

class RuboCop::ConfigObsoletion::ChangedParameter < ::RuboCop::ConfigObsoletion::ParameterRule
  def message; end
end

RuboCop::ConfigObsoletion::ChangedParameter::BASE_MESSAGE = T.let(T.unsafe(nil), String)

class RuboCop::ConfigObsoletion::CopRule < ::RuboCop::ConfigObsoletion::Rule
  def initialize(config, old_name); end

  def cop_rule?; end
  def message; end
  def old_name; end
  def violated?; end
  def warning?; end
end

RuboCop::ConfigObsoletion::DEFAULT_RULES_FILE = T.let(T.unsafe(nil), String)

class RuboCop::ConfigObsoletion::ExtractedCop < ::RuboCop::ConfigObsoletion::CopRule
  def initialize(config, old_name, gem); end

  def department; end
  def gem; end
  def rule_message; end
  def violated?; end

  private

  def affected_cops; end
  def feature_loaded?; end
end

RuboCop::ConfigObsoletion::PARAMETER_RULE_CLASSES = T.let(T.unsafe(nil), Hash)

class RuboCop::ConfigObsoletion::ParameterRule < ::RuboCop::ConfigObsoletion::Rule
  def initialize(config, cop, parameter, metadata); end

  def cop; end
  def metadata; end
  def parameter; end
  def parameter_rule?; end
  def violated?; end
  def warning?; end

  private

  def alternative; end
  def reason; end
  def severity; end
end

class RuboCop::ConfigObsoletion::RemovedCop < ::RuboCop::ConfigObsoletion::CopRule
  def initialize(config, old_name, metadata); end

  def metadata; end
  def old_name; end
  def rule_message; end

  private

  def alternatives; end
  def reason; end
end

RuboCop::ConfigObsoletion::RemovedCop::BASE_MESSAGE = T.let(T.unsafe(nil), String)

class RuboCop::ConfigObsoletion::RenamedCop < ::RuboCop::ConfigObsoletion::CopRule
  def initialize(config, old_name, new_name); end

  def new_name; end
  def rule_message; end

  private

  def moved?; end
  def verb; end
end

class RuboCop::ConfigObsoletion::Rule
  def initialize(config); end

  def cop_rule?; end
  def parameter_rule?; end
  def violated?; end

  private

  def config; end
  def smart_loaded_path; end
  def to_sentence(collection, connector: T.unsafe(nil)); end
end

class RuboCop::ConfigObsoletion::SplitCop < ::RuboCop::ConfigObsoletion::CopRule
  def initialize(config, old_name, metadata); end

  def metadata; end
  def rule_message; end

  private

  def alternatives; end
end

class RuboCop::ConfigRegeneration
  def options; end

  private

  def generation_command; end
  def todo_exists?; end
end

RuboCop::ConfigRegeneration::AUTO_GENERATED_FILE = T.let(T.unsafe(nil), String)
RuboCop::ConfigRegeneration::COMMAND_REGEX = T.let(T.unsafe(nil), Regexp)
RuboCop::ConfigRegeneration::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

class RuboCop::ConfigStore
  def initialize; end

  def for(file_or_dir); end
  def for_dir(dir); end
  def for_file(file); end
  def for_pwd; end
  def force_default_config!; end
  def options_config=(options_config); end
  def unvalidated; end
  def validated; end
  def validated?; end
end

class RuboCop::ConfigValidator
  extend ::Forwardable

  def initialize(config); end

  def for_all_cops(*args, &block); end
  def smart_loaded_path(*args, &block); end
  def target_ruby_version; end
  def validate; end
  def validate_after_resolution; end
  def validate_section_presence(name); end

  private

  def alert_about_unrecognized_cops(invalid_cop_names); end
  def check_cop_config_value(hash, parent = T.unsafe(nil)); end
  def check_obsoletions; end
  def check_target_ruby; end
  def each_invalid_parameter(cop_name); end
  def msg_not_boolean(parent, key, value); end
  def reject_conflicting_safe_settings; end
  def reject_mutually_exclusive_defaults; end
  def suggestion(name); end
  def target_ruby; end
  def validate_enforced_styles(valid_cop_names); end
  def validate_new_cops_parameter; end
  def validate_parameter_names(valid_cop_names); end
  def validate_support_and_has_list(name, formats, valid); end
  def validate_syntax_cop; end
end

RuboCop::ConfigValidator::COMMON_PARAMS = T.let(T.unsafe(nil), Array)
RuboCop::ConfigValidator::CONFIG_CHECK_DEPARTMENTS = T.let(T.unsafe(nil), Array)
RuboCop::ConfigValidator::CONFIG_CHECK_KEYS = T.let(T.unsafe(nil), Set)
RuboCop::ConfigValidator::INTERNAL_PARAMS = T.let(T.unsafe(nil), Array)
RuboCop::ConfigValidator::NEW_COPS_VALUES = T.let(T.unsafe(nil), Array)
module RuboCop::Cop; end

module RuboCop::Cop::Alignment
  private

  def check_alignment(items, base_column = T.unsafe(nil)); end
  def column_delta; end
  def configured_indentation_width; end
  def display_column(range); end
  def each_bad_alignment(items, base_column); end
  def end_of_line_comment(line); end
  def indentation(node); end
  def offset(node); end
  def register_offense(offense_node, message_node); end
  def within?(inner, outer); end
end

RuboCop::Cop::Alignment::SPACE = T.let(T.unsafe(nil), String)

class RuboCop::Cop::AlignmentCorrector
  extend ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::Alignment

  class << self
    def align_end(corrector, processed_source, node, align_to); end
    def correct(corrector, processed_source, node, column_delta); end
    def processed_source; end

    private

    def alignment_column(align_to); end
    def autocorrect_line(corrector, line_begin_pos, expr, column_delta, taboo_ranges); end
    def block_comment_within?(expr); end
    def calculate_range(expr, line_begin_pos, column_delta); end
    def delimited_string_literal?(node); end
    def each_line(expr); end
    def inside_string_range(node); end
    def inside_string_ranges(node); end
    def remove(range, corrector); end
    def whitespace_range(node); end
  end
end

module RuboCop::Cop::AllowedIdentifiers
  def allowed_identifier?(name); end
  def allowed_identifiers; end
end

RuboCop::Cop::AllowedIdentifiers::SIGILS = T.let(T.unsafe(nil), String)

module RuboCop::Cop::AllowedMethods
  private

  def allowed_method?(name); end
  def allowed_methods; end
end

class RuboCop::Cop::AmbiguousCopName < ::RuboCop::Error
  def initialize(name, origin, badges); end
end

RuboCop::Cop::AmbiguousCopName::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::AnnotationComment
  extend ::Forwardable

  def initialize(comment, keywords); end

  def annotation?; end
  def bounds; end
  def colon; end
  def comment; end
  def correct?(colon:); end
  def keyword; end
  def margin; end
  def note; end
  def space; end

  private

  def just_keyword_of_sentence?; end
  def keyword_appearance?; end
  def keywords; end
  def split_comment(comment); end
end

module RuboCop::Cop::ArrayMinSize
  private

  def array_style_detected(style, ary_size); end
  def below_array_length?(node); end
  def largest_brackets_size(style, ary_size); end
  def min_size_config; end
  def smallest_percent_size(style, ary_size); end
end

module RuboCop::Cop::ArraySyntax
  private

  def bracketed_array_of?(element_type, node); end
end

module RuboCop::Cop::AutoCorrector
  def support_autocorrect?; end
end

module RuboCop::Cop::AutocorrectLogic
  def autocorrect?; end
  def autocorrect_enabled?; end
  def autocorrect_requested?; end
  def correctable?; end
  def disable_uncorrectable?; end
  def safe_autocorrect?; end

  private

  def disable_offense(range); end
  def disable_offense_at_end_of_line(range, eol_comment); end
  def disable_offense_before_and_after(range_by_lines); end
  def max_line_length; end
  def range_by_lines(range); end
  def range_of_first_line(range); end
  def surrounding_heredoc(offense_range); end
end

class RuboCop::Cop::Badge
  def initialize(class_name_parts); end

  def ==(other); end
  def cop_name; end
  def department; end
  def eql?(other); end
  def hash; end
  def match?(other); end
  def qualified?; end
  def to_s; end
  def with_department(department); end

  class << self
    def for(class_name); end
    def parse(identifier); end
  end
end

class RuboCop::Cop::Base
  include ::RuboCop::AST::Sexp
  include ::RuboCop::PathUtil
  include ::RuboCop::Cop::Util
  include ::RuboCop::Cop::IgnoredNode
  include ::RuboCop::Cop::AutocorrectLogic
  extend ::RuboCop::AST::Sexp
  extend ::RuboCop::AST::NodePattern::Macros
  extend ::RuboCop::ExcludeLimit

  def initialize(config = T.unsafe(nil), options = T.unsafe(nil)); end

  def add_global_offense(message = T.unsafe(nil), severity: T.unsafe(nil)); end
  def add_offense(node_or_range, message: T.unsafe(nil), severity: T.unsafe(nil), &block); end
  def callbacks_needed; end
  def config; end
  def config_to_allow_offenses; end
  def config_to_allow_offenses=(hash); end
  def cop_config; end
  def cop_name; end
  def excluded_file?(file); end
  def external_dependency_checksum; end
  def message(_range = T.unsafe(nil)); end
  def name; end
  def offenses; end
  def on_investigation_end; end
  def on_new_investigation; end
  def on_other_file; end
  def parse(source, path = T.unsafe(nil)); end
  def processed_source; end
  def ready; end
  def relevant_file?(file); end
  def target_rails_version; end
  def target_ruby_version; end

  private

  def annotate(message); end
  def apply_correction(corrector); end
  def attempt_correction(range, corrector); end
  def begin_investigation(processed_source); end
  def callback_argument(range); end
  def complete_investigation; end
  def correct(range); end
  def current_offense_locations; end
  def currently_disabled_lines; end
  def custom_severity; end
  def default_severity; end
  def disable_uncorrectable(range); end
  def enabled_line?(line_number); end
  def file_name_matches_any?(file, parameter, default_result); end
  def find_message(range, message); end
  def find_severity(_range, severity); end
  def range_from_node_or_range(node_or_range); end
  def reset_investigation; end
  def use_corrector(range, corrector); end

  class << self
    def autocorrect_incompatible_with; end
    def badge; end
    def callbacks_needed; end
    def cop_name; end
    def department; end
    def documentation_url; end
    def exclude_from_registry; end
    def inherited(subclass); end
    def joining_forces; end
    def lint?; end
    def match?(given_names); end
    def support_autocorrect?; end
    def support_multiple_source?; end

    private

    def builtin?; end
    def restrict_on_send; end
  end
end

class RuboCop::Cop::Base::InvestigationReport < ::Struct
  def cop; end
  def cop=(_); end
  def corrector; end
  def corrector=(_); end
  def offenses; end
  def offenses=(_); end
  def processed_source; end
  def processed_source=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

RuboCop::Cop::Base::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Set)
module RuboCop::Cop::Bundler; end

class RuboCop::Cop::Bundler::DuplicatedGem < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp

  def gem_declarations(param0); end
  def on_new_investigation; end

  private

  def conditional_declaration?(nodes); end
  def duplicated_gem_nodes; end
  def register_offense(node, gem_name, line_of_first_occurrence); end
  def within_conditional?(node, conditional_node); end
end

RuboCop::Cop::Bundler::DuplicatedGem::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Bundler::GemComment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::DefNode
  include ::RuboCop::Cop::GemDeclaration

  def on_send(node); end

  private

  def checked_options_present?(node); end
  def commented?(node); end
  def commented_any_descendant?(node); end
  def contains_checked_options?(node); end
  def gem_options(node); end
  def ignored_gem?(node); end
  def precede?(node1, node2); end
  def preceding_comment?(node1, node2); end
  def preceding_lines(node); end
  def restrictive_version_specified_gem?(node); end
  def version_specified_gem?(node); end
end

RuboCop::Cop::Bundler::GemComment::CHECKED_OPTIONS_CONFIG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Bundler::GemComment::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Bundler::GemComment::RESTRICTIVE_VERSION_PATTERN = T.let(T.unsafe(nil), Regexp)
RuboCop::Cop::Bundler::GemComment::RESTRICTIVE_VERSION_SPECIFIERS_OPTION = T.let(T.unsafe(nil), String)
RuboCop::Cop::Bundler::GemComment::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Bundler::GemComment::VERSION_SPECIFIERS_OPTION = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Bundler::GemFilename < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp

  def on_new_investigation; end

  private

  def expected_gemfile?(basename); end
  def gemfile_offense?(basename); end
  def gemfile_required?; end
  def gems_rb_offense?(basename); end
  def gems_rb_required?; end
  def register_gemfile_offense(file_path, basename); end
  def register_gems_rb_offense(file_path, basename); end
  def register_offense(file_path, basename); end
end

RuboCop::Cop::Bundler::GemFilename::GEMFILE_FILES = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Bundler::GemFilename::GEMS_RB_FILES = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Bundler::GemFilename::MSG_GEMFILE_MISMATCHED = T.let(T.unsafe(nil), String)
RuboCop::Cop::Bundler::GemFilename::MSG_GEMFILE_REQUIRED = T.let(T.unsafe(nil), String)
RuboCop::Cop::Bundler::GemFilename::MSG_GEMS_RB_MISMATCHED = T.let(T.unsafe(nil), String)
RuboCop::Cop::Bundler::GemFilename::MSG_GEMS_RB_REQUIRED = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Bundler::GemVersion < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::GemDeclaration

  def includes_commit_reference?(param0 = T.unsafe(nil)); end
  def includes_version_specification?(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def allowed_gem?(node); end
  def allowed_gems; end
  def forbidden_offense?(node); end
  def forbidden_style?; end
  def message(range); end
  def offense?(node); end
  def required_offense?(node); end
  def required_style?; end
  def version_specification?(expression); end
end

RuboCop::Cop::Bundler::GemVersion::FORBIDDEN_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Bundler::GemVersion::REQUIRED_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Bundler::GemVersion::VERSION_SPECIFICATION_REGEX = T.let(T.unsafe(nil), Regexp)

class RuboCop::Cop::Bundler::InsecureProtocolSource < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def insecure_protocol_source?(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def allow_http_protocol?; end
end

RuboCop::Cop::Bundler::InsecureProtocolSource::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Bundler::InsecureProtocolSource::MSG_HTTP_PROTOCOL = T.let(T.unsafe(nil), String)
RuboCop::Cop::Bundler::InsecureProtocolSource::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Bundler::OrderedGems < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::OrderedGemNode
  extend ::RuboCop::Cop::AutoCorrector

  def gem_declarations(param0); end
  def on_new_investigation; end

  private

  def previous_declaration(node); end
end

RuboCop::Cop::Bundler::OrderedGems::MSG = T.let(T.unsafe(nil), String)

module RuboCop::Cop::CheckAssignment
  def on_and_asgn(node); end
  def on_casgn(node); end
  def on_cvasgn(node); end
  def on_gvasgn(node); end
  def on_ivasgn(node); end
  def on_lvasgn(node); end
  def on_masgn(node); end
  def on_op_asgn(node); end
  def on_or_asgn(node); end
  def on_send(node); end

  private

  def extract_rhs(node); end

  class << self
    def extract_rhs(node); end
  end
end

module RuboCop::Cop::CheckLineBreakable
  def extract_breakable_node(node, max); end

  private

  def all_on_same_line?(nodes); end
  def already_on_multiple_lines?(node); end
  def breakable_collection?(node, elements); end
  def children_could_be_broken_up?(children); end
  def contained_by_breakable_collection_on_same_line?(node); end
  def contained_by_multiline_collection_that_could_be_broken_up?(node); end
  def extract_breakable_node_from_elements(node, elements, max); end
  def extract_first_element_over_column_limit(node, elements, max); end
  def first_argument_is_heredoc?(node); end
  def process_args(args); end
  def safe_to_ignore?(node); end
  def shift_elements_for_heredoc_arg(node, elements, index); end
  def within_column_limit?(element, max, line); end
end

module RuboCop::Cop::CodeLength
  extend ::RuboCop::ExcludeLimit

  def max=(value); end

  private

  def build_code_length_calculator(node); end
  def check_code_length(node); end
  def count_as_one; end
  def count_comments?; end
  def irrelevant_line(source_line); end
  def max_length; end
  def message(length, max_length); end
end

RuboCop::Cop::CodeLength::MSG = T.let(T.unsafe(nil), String)

module RuboCop::Cop::CommentsHelp
  include ::RuboCop::Cop::VisibilityHelp

  def source_range_with_comment(node); end

  private

  def begin_pos_with_comment(node); end
  def buffer; end
  def end_position_for(node); end
  def start_line_position(node); end
end

class RuboCop::Cop::Commissioner
  include ::RuboCop::AST::Traversal

  def initialize(cops, forces = T.unsafe(nil), options = T.unsafe(nil)); end

  def errors; end
  def investigate(processed_source); end
  def on___ENCODING__(node); end
  def on___FILE__(node); end
  def on___LINE__(node); end
  def on_alias(node); end
  def on_and(node); end
  def on_and_asgn(node); end
  def on_arg(node); end
  def on_arg_expr(node); end
  def on_args(node); end
  def on_array(node); end
  def on_array_pattern(node); end
  def on_array_pattern_with_tail(node); end
  def on_back_ref(node); end
  def on_begin(node); end
  def on_block(node); end
  def on_block_pass(node); end
  def on_blockarg(node); end
  def on_break(node); end
  def on_case(node); end
  def on_case_match(node); end
  def on_casgn(node); end
  def on_cbase(node); end
  def on_class(node); end
  def on_complex(node); end
  def on_const(node); end
  def on_const_pattern(node); end
  def on_csend(node); end
  def on_cvar(node); end
  def on_cvasgn(node); end
  def on_def(node); end
  def on_defined?(node); end
  def on_defs(node); end
  def on_dstr(node); end
  def on_dsym(node); end
  def on_eflipflop(node); end
  def on_empty_else(node); end
  def on_ensure(node); end
  def on_erange(node); end
  def on_false(node); end
  def on_find_pattern(node); end
  def on_float(node); end
  def on_for(node); end
  def on_forward_arg(node); end
  def on_forward_args(node); end
  def on_forwarded_args(node); end
  def on_gvar(node); end
  def on_gvasgn(node); end
  def on_hash(node); end
  def on_hash_pattern(node); end
  def on_if(node); end
  def on_if_guard(node); end
  def on_iflipflop(node); end
  def on_in_match(node); end
  def on_in_pattern(node); end
  def on_index(node); end
  def on_indexasgn(node); end
  def on_int(node); end
  def on_irange(node); end
  def on_ivar(node); end
  def on_ivasgn(node); end
  def on_kwarg(node); end
  def on_kwargs(node); end
  def on_kwbegin(node); end
  def on_kwnilarg(node); end
  def on_kwoptarg(node); end
  def on_kwrestarg(node); end
  def on_kwsplat(node); end
  def on_lambda(node); end
  def on_lvar(node); end
  def on_lvasgn(node); end
  def on_masgn(node); end
  def on_match_alt(node); end
  def on_match_as(node); end
  def on_match_current_line(node); end
  def on_match_nil_pattern(node); end
  def on_match_pattern(node); end
  def on_match_pattern_p(node); end
  def on_match_rest(node); end
  def on_match_var(node); end
  def on_match_with_lvasgn(node); end
  def on_match_with_trailing_comma(node); end
  def on_mlhs(node); end
  def on_module(node); end
  def on_next(node); end
  def on_nil(node); end
  def on_not(node); end
  def on_nth_ref(node); end
  def on_numblock(node); end
  def on_op_asgn(node); end
  def on_optarg(node); end
  def on_or(node); end
  def on_or_asgn(node); end
  def on_pair(node); end
  def on_pin(node); end
  def on_postexe(node); end
  def on_preexe(node); end
  def on_procarg0(node); end
  def on_rational(node); end
  def on_redo(node); end
  def on_regexp(node); end
  def on_regopt(node); end
  def on_resbody(node); end
  def on_rescue(node); end
  def on_restarg(node); end
  def on_retry(node); end
  def on_return(node); end
  def on_sclass(node); end
  def on_self(node); end
  def on_send(node); end
  def on_shadowarg(node); end
  def on_splat(node); end
  def on_str(node); end
  def on_super(node); end
  def on_sym(node); end
  def on_true(node); end
  def on_undef(node); end
  def on_unless_guard(node); end
  def on_until(node); end
  def on_until_post(node); end
  def on_when(node); end
  def on_while(node); end
  def on_while_post(node); end
  def on_xstr(node); end
  def on_yield(node); end
  def on_zsuper(node); end

  private

  def build_callbacks(cops); end
  def initialize_callbacks; end
  def invoke(callback, cops, *args); end
  def reset; end
  def restrict_callbacks(callbacks); end
  def restricted_map(callbacks); end
  def trigger_responding_cops(callback, node); end
  def trigger_restricted_cops(event, node); end
  def with_cop_error_handling(cop, node = T.unsafe(nil)); end
end

class RuboCop::Cop::Commissioner::InvestigationReport < ::Struct
  def cop_reports; end
  def cop_reports=(_); end
  def cops; end
  def correctors; end
  def errors; end
  def errors=(_); end
  def merge(investigation); end
  def offenses; end
  def offenses_per_cop; end
  def processed_source; end
  def processed_source=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

RuboCop::Cop::Commissioner::RESTRICTED_CALLBACKS = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::ConditionCorrector
  class << self
    def correct_negative_condition(corrector, node); end

    private

    def negated_condition(node); end
  end
end

module RuboCop::Cop::ConfigurableEnforcedStyle
  def alternative_style; end
  def alternative_styles; end
  def ambiguous_style_detected(*possibilities); end
  def conflicting_styles_detected; end
  def correct_style_detected; end
  def detected_style; end
  def detected_style=(style); end
  def no_acceptable_style!; end
  def no_acceptable_style?; end
  def opposite_style_detected; end
  def style; end
  def style_configured?; end
  def style_detected(detected); end
  def style_parameter_name; end
  def supported_styles; end
  def unexpected_style_detected(unexpected); end
  def unrecognized_style_detected; end
end

module RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  def check_name(node, name, name_range); end
  def class_emitter_method?(node, name); end
  def report_opposing_styles(node, name); end
  def valid_name?(node, name, given_style = T.unsafe(nil)); end
end

module RuboCop::Cop::ConfigurableMax
  private

  def max=(value); end
  def max_parameter_name; end
end

module RuboCop::Cop::ConfigurableNaming
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::ConfigurableFormatting
end

RuboCop::Cop::ConfigurableNaming::FORMATS = T.let(T.unsafe(nil), Hash)

module RuboCop::Cop::ConfigurableNumbering
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::ConfigurableFormatting
end

RuboCop::Cop::ConfigurableNumbering::FORMATS = T.let(T.unsafe(nil), Hash)

class RuboCop::Cop::Cop < ::RuboCop::Cop::Base
  def add_offense(node_or_range, location: T.unsafe(nil), message: T.unsafe(nil), severity: T.unsafe(nil), &block); end
  def corrections; end
  def find_location(node, loc); end
  def offenses; end
  def on_investigation_end; end
  def on_new_investigation; end
  def support_autocorrect?; end

  private

  def apply_correction(corrector); end
  def begin_investigation(processed_source); end
  def callback_argument(_range); end
  def correction_lambda; end
  def dedup_on_node(node); end
  def emulate_v0_callsequence(corrector); end
  def suppress_clobbering; end

  class << self
    def all; end
    def joining_forces; end
    def qualified_cop_name(name, origin); end
    def registry; end
    def support_autocorrect?; end
  end
end

class RuboCop::Cop::Cop::Correction < ::Struct
  def call(corrector); end
  def cop; end
  def cop=(_); end
  def lambda; end
  def lambda=(_); end
  def node; end
  def node=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class RuboCop::Cop::Corrector < ::Parser::Source::TreeRewriter
  def initialize(source); end

  def remove_leading(node_or_range, size); end
  def remove_preceding(node_or_range, size); end
  def remove_trailing(node_or_range, size); end
  def rewrite; end

  private

  def check_range_validity(node_or_range); end
  def to_range(node_or_range); end
  def validate_buffer(buffer); end

  class << self
    def source_buffer(source); end
  end
end

RuboCop::Cop::Corrector::NOOP_CONSUMER = T.let(T.unsafe(nil), Proc)

module RuboCop::Cop::DefNode
  extend ::RuboCop::AST::NodePattern::Macros

  def non_public_modifier?(param0 = T.unsafe(nil)); end

  private

  def non_public?(node); end
  def preceding_non_public_modifier?(node); end
  def stripped_source_upto(index); end
end

RuboCop::Cop::DefNode::NON_PUBLIC_MODIFIERS = T.let(T.unsafe(nil), Array)

module RuboCop::Cop::Documentation
  private

  def base_url_for(cop_class, config); end
  def default_base_url; end
  def department_to_basename(department); end
  def url_for(cop_class, config = T.unsafe(nil)); end

  class << self
    def base_url_for(cop_class, config); end
    def default_base_url; end
    def department_to_basename(department); end
    def url_for(cop_class, config = T.unsafe(nil)); end
  end
end

module RuboCop::Cop::DocumentationComment
  extend ::RuboCop::AST::NodePattern::Macros

  private

  def annotation_keywords; end
  def documentation_comment?(node); end
  def interpreter_directive_comment?(comment); end
  def precede?(node1, node2); end
  def preceding_comment?(node1, node2); end
  def preceding_lines(node); end
  def rubocop_directive_comment?(comment); end
end

module RuboCop::Cop::Duplication
  private

  def consecutive_duplicates(collection); end
  def duplicates(collection); end
  def duplicates?(collection); end
  def grouped_duplicates(collection); end
end

class RuboCop::Cop::EachToForCorrector
  extend ::RuboCop::AST::NodePattern::Macros

  def initialize(block_node); end

  def call(corrector); end

  private

  def argument_node; end
  def block_node; end
  def collection_node; end
  def correction; end
  def offending_range; end
  def replacement_range(end_pos); end
end

RuboCop::Cop::EachToForCorrector::CORRECTION_WITHOUT_ARGUMENTS = T.let(T.unsafe(nil), String)
RuboCop::Cop::EachToForCorrector::CORRECTION_WITH_ARGUMENTS = T.let(T.unsafe(nil), String)

class RuboCop::Cop::EmptyLineCorrector
  class << self
    def correct(corrector, node); end
    def insert_before(corrector, node); end
  end
end

module RuboCop::Cop::EmptyParameter
  extend ::RuboCop::AST::NodePattern::Macros

  def empty_arguments?(param0 = T.unsafe(nil)); end

  private

  def check(node); end
end

module RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp

  private

  def accept_end_kw_alignment?(end_loc); end
  def add_offense_for_misalignment(node, align_with); end
  def check_end_kw_alignment(node, align_ranges); end
  def check_end_kw_in_node(node); end
  def line_break_before_keyword?(whole_expression, rhs); end
  def matching_ranges(end_loc, align_ranges); end
  def start_line_range(node); end
  def style_parameter_name; end
  def variable_alignment?(whole_expression, rhs, end_alignment_style); end
end

RuboCop::Cop::EndKeywordAlignment::MSG = T.let(T.unsafe(nil), String)

module RuboCop::Cop::EnforceSuperclass
  def on_class(node); end
  def on_send(node); end

  class << self
    def included(base); end
  end
end

module RuboCop::Cop::FirstElementLineBreak
  private

  def check_children_line_break(node, children, start = T.unsafe(nil)); end
  def check_method_line_break(node, children); end
  def first_by_line(nodes); end
  def last_by_line(nodes); end
  def method_uses_parens?(node, limit); end
end

class RuboCop::Cop::ForToEachCorrector
  extend ::RuboCop::AST::NodePattern::Macros

  def initialize(for_node); end

  def call(corrector); end

  private

  def collection_end; end
  def collection_node; end
  def collection_source; end
  def correction; end
  def end_position; end
  def for_node; end
  def keyword_begin; end
  def offending_range; end
  def replacement_range(end_pos); end
  def requires_parentheses?; end
  def variable_node; end
end

RuboCop::Cop::ForToEachCorrector::CORRECTION = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Force
  def initialize(cops); end

  def cops; end
  def investigate(_processed_source); end
  def name; end
  def run_hook(method_name, *args); end

  class << self
    def all; end
    def force_name; end
    def inherited(subclass); end
  end
end

module RuboCop::Cop::FrozenStringLiteral
  private

  def frozen_heredoc?(node); end
  def frozen_string_literal?(node); end
  def frozen_string_literal_comment_exists?; end
  def frozen_string_literal_specified?; end
  def frozen_string_literals_disabled?; end
  def frozen_string_literals_enabled?; end
  def leading_comment_lines; end
  def uninterpolated_string?(node); end

  class << self
    def frozen_string_literal_comment_exists?; end
  end
end

RuboCop::Cop::FrozenStringLiteral::FROZEN_STRING_LITERAL = T.let(T.unsafe(nil), String)
RuboCop::Cop::FrozenStringLiteral::FROZEN_STRING_LITERAL_ENABLED = T.let(T.unsafe(nil), String)
RuboCop::Cop::FrozenStringLiteral::FROZEN_STRING_LITERAL_TYPES_RUBY27 = T.let(T.unsafe(nil), Array)

module RuboCop::Cop::GemDeclaration
  extend ::RuboCop::AST::NodePattern::Macros

  def gem_declaration?(param0 = T.unsafe(nil)); end
end

module RuboCop::Cop::Gemspec; end

class RuboCop::Cop::Gemspec::DateAssignment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::GemspecHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_block(block_node); end
end

RuboCop::Cop::Gemspec::DateAssignment::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Gemspec::DuplicatedAssignment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::GemspecHelp

  def assignment_method_declarations(param0); end
  def on_new_investigation; end

  private

  def assignment_method?(method_name); end
  def duplicated_assignment_method_nodes; end
  def match_block_variable_name?(receiver_name); end
  def register_offense(node, assignment, line_of_first_occurrence); end
end

RuboCop::Cop::Gemspec::DuplicatedAssignment::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Gemspec::OrderedDependencies < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::OrderedGemNode
  extend ::RuboCop::Cop::AutoCorrector

  def dependency_declarations(param0); end
  def on_new_investigation; end

  private

  def get_dependency_name(node); end
  def previous_declaration(node); end
end

RuboCop::Cop::Gemspec::OrderedDependencies::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Gemspec::RequireMFA < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::GemspecHelp
  extend ::RuboCop::Cop::AutoCorrector

  def metadata(param0 = T.unsafe(nil)); end
  def on_block(node); end
  def rubygems_mfa_required(param0); end
  def true_string?(param0 = T.unsafe(nil)); end

  private

  def autocorrect(corrector, node, block_var, metadata); end
  def change_value(corrector, value); end
  def correct_metadata(corrector, metadata); end
  def insert_mfa_required(corrector, node, block_var); end
  def mfa_value(metadata_value); end
end

RuboCop::Cop::Gemspec::RequireMFA::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Gemspec::RequiredRubyVersion < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp

  def defined_ruby_version(param0 = T.unsafe(nil)); end
  def on_new_investigation; end
  def on_send(node); end
  def required_ruby_version?(param0); end

  private

  def dynamic_version?(node); end
  def extract_ruby_version(required_ruby_version); end
  def not_equal_message(required_ruby_version, target_ruby_version); end
end

RuboCop::Cop::Gemspec::RequiredRubyVersion::MISSING_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Gemspec::RequiredRubyVersion::NOT_EQUAL_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Gemspec::RequiredRubyVersion::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Gemspec::RubyVersionGlobalsUsage < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::GemspecHelp

  def on_const(node); end
  def ruby_version?(param0 = T.unsafe(nil)); end

  private

  def gem_spec_with_ruby_version?(node); end
end

RuboCop::Cop::Gemspec::RubyVersionGlobalsUsage::MSG = T.let(T.unsafe(nil), String)

module RuboCop::Cop::GemspecHelp
  extend ::RuboCop::AST::NodePattern::Macros

  def gem_specification(param0); end
  def gem_specification?(param0 = T.unsafe(nil)); end
end

class RuboCop::Cop::Generator
  def initialize(name, output: T.unsafe(nil)); end

  def inject_config(config_file_path: T.unsafe(nil), version_added: T.unsafe(nil)); end
  def inject_require(root_file_path: T.unsafe(nil)); end
  def todo; end
  def write_source; end
  def write_spec; end

  private

  def badge; end
  def generate(template); end
  def generated_source; end
  def generated_spec; end
  def output; end
  def snake_case(camel_case_string); end
  def source_path; end
  def spec_path; end
  def write_unless_file_exists(path, contents); end
end

RuboCop::Cop::Generator::CONFIGURATION_ADDED_MESSAGE = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Generator::ConfigurationInjector
  def initialize(configuration_file_path:, badge:, version_added: T.unsafe(nil)); end

  def inject; end

  private

  def badge; end
  def configuration_entries; end
  def configuration_file_path; end
  def cop_name_line?(yaml); end
  def find_target_line; end
  def new_configuration_entry; end
  def output; end
  def version_added; end
end

RuboCop::Cop::Generator::ConfigurationInjector::TEMPLATE = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Generator::RequireFileInjector
  def initialize(source_path:, root_file_path:, output: T.unsafe(nil)); end

  def inject; end

  private

  def injectable_require_directive; end
  def output; end
  def require_entries; end
  def require_exists?; end
  def require_path; end
  def require_path_fragments(require_directove); end
  def root_file_path; end
  def source_path; end
  def target_line; end
  def updated_directives; end
end

RuboCop::Cop::Generator::RequireFileInjector::REQUIRE_PATH = T.let(T.unsafe(nil), Regexp)
RuboCop::Cop::Generator::SOURCE_TEMPLATE = T.let(T.unsafe(nil), String)
RuboCop::Cop::Generator::SPEC_TEMPLATE = T.let(T.unsafe(nil), String)
module RuboCop::Cop::HashAlignmentStyles; end

class RuboCop::Cop::HashAlignmentStyles::KeyAlignment
  def checkable_layout?(_node); end
  def deltas(first_pair, current_pair); end
  def deltas_for_first_pair(first_pair, _node); end

  private

  def separator_delta(pair); end
  def value_delta(pair); end
end

class RuboCop::Cop::HashAlignmentStyles::KeywordSplatAlignment
  def deltas(first_pair, current_pair); end
end

class RuboCop::Cop::HashAlignmentStyles::SeparatorAlignment
  include ::RuboCop::Cop::HashAlignmentStyles::ValueAlignment

  def deltas_for_first_pair(*_nodes); end

  private

  def hash_rocket_delta(first_pair, current_pair); end
  def key_delta(first_pair, current_pair); end
  def value_delta(first_pair, current_pair); end
end

class RuboCop::Cop::HashAlignmentStyles::TableAlignment
  include ::RuboCop::Cop::HashAlignmentStyles::ValueAlignment

  def initialize; end

  def deltas_for_first_pair(first_pair, node); end

  private

  def hash_rocket_delta(first_pair, current_pair); end
  def key_delta(first_pair, current_pair); end
  def max_key_width; end
  def max_key_width=(_arg0); end
  def value_delta(first_pair, current_pair); end
end

module RuboCop::Cop::HashAlignmentStyles::ValueAlignment
  def checkable_layout?(node); end
  def deltas(first_pair, current_pair); end

  private

  def separator_delta(first_pair, current_pair, key_delta); end
end

module RuboCop::Cop::HashShorthandSyntax
  def on_pair(node); end

  private

  def enforced_shorthand_syntax; end
  def ignore_hash_shorthand_syntax?(pair_node); end
  def require_hash_value?(hash_key_source, node); end
  def require_hash_value_for_around_hash_literal?(node); end
  def use_element_of_hash_literal_as_receiver?(ancestor, parent); end
  def use_modifier_form_without_parenthesized_method_call?(ancestor); end
  def without_parentheses_call_expr_follows?(ancestor); end
end

RuboCop::Cop::HashShorthandSyntax::EXPLICIT_HASH_VALUE_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::HashShorthandSyntax::OMIT_HASH_VALUE_MSG = T.let(T.unsafe(nil), String)

module RuboCop::Cop::HashTransformMethod
  extend ::RuboCop::AST::NodePattern::Macros

  def array_receiver?(param0 = T.unsafe(nil)); end
  def on_block(node); end
  def on_csend(node); end
  def on_send(node); end

  private

  def execute_correction(corrector, node, correction); end
  def extract_captures(_match); end
  def handle_possible_offense(node, match, match_desc); end
  def new_method_name; end
  def on_bad_each_with_object(_node); end
  def on_bad_hash_brackets_map(_node); end
  def on_bad_map_to_h(_node); end
  def on_bad_to_h(_node); end
  def prepare_correction(node); end
end

class RuboCop::Cop::HashTransformMethod::Autocorrection < ::Struct
  def block_node; end
  def block_node=(_); end
  def leading; end
  def leading=(_); end
  def match; end
  def match=(_); end
  def set_new_arg_name(transformed_argname, corrector); end
  def set_new_body_expression(transforming_body_expr, corrector); end
  def set_new_method_name(new_method_name, corrector); end
  def strip_prefix_and_suffix(node, corrector); end
  def trailing; end
  def trailing=(_); end

  class << self
    def [](*_arg0); end
    def from_each_with_object(node, match); end
    def from_hash_brackets_map(node, match); end
    def from_map_to_h(node, match); end
    def from_to_h(node, match); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class RuboCop::Cop::HashTransformMethod::Captures < ::Struct
  def noop_transformation?; end
  def transformation_uses_both_args?; end
  def transformed_argname; end
  def transformed_argname=(_); end
  def transforming_body_expr; end
  def transforming_body_expr=(_); end
  def unchanged_body_expr; end
  def unchanged_body_expr=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

RuboCop::Cop::HashTransformMethod::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

module RuboCop::Cop::Heredoc
  def on_dstr(node); end
  def on_heredoc(_node); end
  def on_str(node); end
  def on_xstr(node); end

  private

  def delimiter_string(node); end
  def heredoc_type(node); end
  def indent_level(str); end
end

RuboCop::Cop::Heredoc::OPENING_DELIMITER = T.let(T.unsafe(nil), Regexp)

class RuboCop::Cop::IfThenCorrector
  def initialize(if_node, indentation: T.unsafe(nil)); end

  def call(corrector); end

  private

  def branch_body_indentation; end
  def if_node; end
  def indentation; end
  def replacement(node = T.unsafe(nil), indentation = T.unsafe(nil)); end
  def rewrite_else_branch(else_branch, indentation); end
end

RuboCop::Cop::IfThenCorrector::DEFAULT_INDENTATION_WIDTH = T.let(T.unsafe(nil), Integer)

module RuboCop::Cop::IgnoredMethods
  mixes_in_class_methods ::RuboCop::Cop::IgnoredMethods::Config

  def ignored_method?(name); end
  def ignored_methods; end

  private

  def deprecated_key; end

  class << self
    def included(base); end
  end
end

module RuboCop::Cop::IgnoredMethods::Config
  def deprecated_key; end
  def deprecated_key=(_arg0); end
  def ignored_methods(**config); end
end

module RuboCop::Cop::IgnoredNode
  def ignore_node(node); end
  def ignored_node?(node); end
  def part_of_ignored_node?(node); end

  private

  def ignored_nodes; end
end

module RuboCop::Cop::IgnoredPattern
  private

  def ignored_line?(line); end
  def ignored_patterns; end
  def matches_ignored_pattern?(line); end
end

module RuboCop::Cop::IntegerNode
  private

  def integer_part(node); end
end

module RuboCop::Cop::Interpolation
  def on_dstr(node); end
  def on_dsym(node); end
  def on_node_with_interpolations(node); end
  def on_regexp(node); end
  def on_xstr(node); end
end

class RuboCop::Cop::LambdaLiteralToMethodCorrector
  def initialize(block_node); end

  def call(corrector); end

  private

  def arg_to_unparenthesized_call?; end
  def arguments; end
  def arguments_begin_pos; end
  def arguments_end_pos; end
  def block_begin; end
  def block_end; end
  def block_node; end
  def insert_arguments(corrector); end
  def insert_separating_space(corrector); end
  def lambda_arg_string; end
  def method; end
  def needs_separating_space?; end
  def remove_arguments(corrector); end
  def remove_leading_whitespace(corrector); end
  def remove_trailing_whitespace(corrector); end
  def remove_unparenthesized_whitespace(corrector); end
  def replace_delimiters(corrector); end
  def replace_selector(corrector); end
  def selector_end; end
  def separating_space?; end
end

module RuboCop::Cop::Layout; end

class RuboCop::Cop::Layout::AccessModifierIndentation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_block(node); end
  def on_class(node); end
  def on_module(node); end
  def on_sclass(node); end

  private

  def autocorrect(corrector, node); end
  def check_body(body, node); end
  def check_modifier(send_node, end_range); end
  def expected_indent_offset; end
  def message(range); end
  def unexpected_indent_offset; end
end

RuboCop::Cop::Layout::AccessModifierIndentation::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::ArgumentAlignment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  extend ::RuboCop::Cop::AutoCorrector

  def on_csend(node); end
  def on_send(node); end

  private

  def arguments_or_first_arg_pairs(node); end
  def arguments_with_last_arg_pairs(node); end
  def autocorrect(corrector, node); end
  def base_column(node, first_argument); end
  def fixed_indentation?; end
  def flattened_arguments(node); end
  def message(_node); end
  def multiple_arguments?(node); end
  def target_method_lineno(node); end
end

RuboCop::Cop::Layout::ArgumentAlignment::ALIGN_PARAMS_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Layout::ArgumentAlignment::FIXED_INDENT_MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::ArrayAlignment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  extend ::RuboCop::Cop::AutoCorrector

  def on_array(node); end

  private

  def autocorrect(corrector, node); end
  def base_column(node, args); end
  def fixed_indentation?; end
  def message(_range); end
  def target_method_lineno(node); end
end

RuboCop::Cop::Layout::ArrayAlignment::ALIGN_ELEMENTS_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Layout::ArrayAlignment::FIXED_INDENT_MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::AssignmentIndentation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::CheckAssignment
  include ::RuboCop::Cop::Alignment
  extend ::RuboCop::Cop::AutoCorrector

  private

  def autocorrect(corrector, node); end
  def check_assignment(node, rhs); end
  def leftmost_multiple_assignment(node); end
end

RuboCop::Cop::Layout::AssignmentIndentation::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::BeginEndAlignment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::EndKeywordAlignment
  extend ::RuboCop::Cop::AutoCorrector

  def on_kwbegin(node); end

  private

  def alignment_node(node); end
  def autocorrect(corrector, node); end
  def check_begin_alignment(node); end
end

RuboCop::Cop::Layout::BeginEndAlignment::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::BlockAlignment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def block_end_align_target?(param0 = T.unsafe(nil), param1); end
  def on_block(node); end
  def style_parameter_name; end

  private

  def add_space_before(corrector, loc, delta); end
  def alt_start_msg(start_loc, source_line_column); end
  def autocorrect(corrector, node); end
  def block_end_align_target(node); end
  def check_block_alignment(start_node, block_node); end
  def compute_do_source_line_column(node, end_loc); end
  def compute_start_col(ancestor_node, node); end
  def disqualified_parent?(parent, node); end
  def end_align_target?(node, parent); end
  def format_message(start_loc, end_loc, do_source_line_column, error_source_line_column); end
  def format_source_line_column(source_line_column); end
  def loc_to_source_line_column(loc); end
  def register_offense(block_node, start_loc, end_loc, do_source_line_column); end
  def remove_space_before(corrector, end_pos, delta); end
  def start_for_block_node(block_node); end
end

RuboCop::Cop::Layout::BlockAlignment::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::BlockEndNewline < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  extend ::RuboCop::Cop::AutoCorrector

  def on_block(node); end

  private

  def delimiter_range(node); end
  def message(node); end
end

RuboCop::Cop::Layout::BlockEndNewline::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::CaseIndentation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_case(case_node); end
  def on_case_match(case_match_node); end

  private

  def base_column(case_node, base); end
  def check_when(when_node, branch_type); end
  def detect_incorrect_style(when_node); end
  def incorrect_style(when_node, branch_type); end
  def indent_one_step?; end
  def indentation_width; end
  def replacement(node); end
  def whitespace_range(node); end
end

RuboCop::Cop::Layout::CaseIndentation::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::ClassStructure < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::VisibilityHelp
  extend ::RuboCop::Cop::AutoCorrector

  def dynamic_constant?(param0 = T.unsafe(nil)); end
  def on_class(class_node); end

  private

  def autocorrect(corrector, node); end
  def begin_pos_with_comment(node); end
  def buffer; end
  def categories; end
  def class_elements(class_node); end
  def classify(node); end
  def end_position_for(node); end
  def expected_order; end
  def find_category(node); end
  def find_heredoc(node); end
  def humanize_node(node); end
  def ignore?(classification); end
  def ignore_for_autocorrect?(node, sibling); end
  def source_range_with_comment(node); end
  def start_line_position(node); end
  def walk_over_nested_class_definition(class_node); end
  def whole_line_comment_at_line?(line); end
end

RuboCop::Cop::Layout::ClassStructure::HUMANIZED_NODE_TYPE = T.let(T.unsafe(nil), Hash)
RuboCop::Cop::Layout::ClassStructure::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::ClosingHeredocIndentation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Heredoc
  extend ::RuboCop::Cop::AutoCorrector

  def on_heredoc(node); end

  private

  def argument_indentation_correct?(node); end
  def closing_indentation(node); end
  def find_node_used_heredoc_argument(node); end
  def heredoc_closing(node); end
  def heredoc_opening(node); end
  def indent_level(source_line); end
  def indented_end(node); end
  def message(node); end
  def opening_indentation(node); end
end

RuboCop::Cop::Layout::ClosingHeredocIndentation::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Layout::ClosingHeredocIndentation::MSG_ARG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Layout::ClosingHeredocIndentation::SIMPLE_HEREDOC = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::ClosingParenthesisIndentation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  extend ::RuboCop::Cop::AutoCorrector

  def on_begin(node); end
  def on_csend(node); end
  def on_def(node); end
  def on_defs(node); end
  def on_send(node); end

  private

  def all_elements_aligned?(elements); end
  def autocorrect(corrector, node); end
  def check(node, elements); end
  def check_for_elements(node, elements); end
  def check_for_no_elements(node); end
  def correct_column_candidates(node, left_paren); end
  def expected_column(left_paren, elements); end
  def first_argument_line(elements); end
  def indentation_width; end
  def line_break_after_left_paren?(left_paren, elements); end
  def message(correct_column, left_paren, right_paren); end
end

RuboCop::Cop::Layout::ClosingParenthesisIndentation::MSG_ALIGN = T.let(T.unsafe(nil), String)
RuboCop::Cop::Layout::ClosingParenthesisIndentation::MSG_INDENT = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::CommentIndentation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  extend ::RuboCop::Cop::AutoCorrector

  def on_new_investigation; end

  private

  def autocorrect(corrector, comment); end
  def autocorrect_one(corrector, comment); end
  def autocorrect_preceding_comments(corrector, comment); end
  def check(comment, comment_index); end
  def correct_indentation(next_line); end
  def correctly_aligned_with_preceding_comment?(comment_index, column); end
  def less_indented?(line); end
  def line_after_comment(comment); end
  def message(column, correct_comment_indentation); end
  def own_line_comment?(comment); end
  def should_correct?(preceding_comment, reference_comment); end
  def two_alternatives?(line); end
end

RuboCop::Cop::Layout::CommentIndentation::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::ConditionPosition < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_if(node); end
  def on_until(node); end
  def on_while(node); end

  private

  def check(node); end
  def message(condition); end
end

RuboCop::Cop::Layout::ConditionPosition::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::DefEndAlignment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::EndKeywordAlignment
  extend ::RuboCop::Cop::AutoCorrector

  def on_def(node); end
  def on_defs(node); end
  def on_send(node); end

  private

  def autocorrect(corrector, node); end
end

RuboCop::Cop::Layout::DefEndAlignment::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::DotPosition < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_csend(node); end
  def on_send(node); end

  private

  def ampersand_dot?(node); end
  def autocorrect(corrector, dot, node); end
  def correct_dot_position_style?(dot_line, selector_line); end
  def end_range(node); end
  def heredoc?(node); end
  def last_heredoc_line(node); end
  def line_between?(first_line, second_line); end
  def message(dot); end
  def proper_dot_position?(node); end
  def receiver_end_line(node); end
  def selector_range(node); end

  class << self
    def autocorrect_incompatible_with; end
  end
end

class RuboCop::Cop::Layout::ElseAlignment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::CheckAssignment
  extend ::RuboCop::Cop::AutoCorrector

  def on_case(node); end
  def on_case_match(node); end
  def on_if(node, base = T.unsafe(nil)); end
  def on_rescue(node); end

  private

  def assignment_node(node); end
  def autocorrect(corrector, node); end
  def base_for_method_definition(node); end
  def base_range_of_if(node, base); end
  def base_range_of_rescue(node); end
  def check_alignment(base_range, else_range); end
  def check_assignment(node, rhs); end
  def check_nested(node, base); end
end

RuboCop::Cop::Layout::ElseAlignment::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::EmptyComment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_new_investigation; end

  private

  def allow_border_comment?; end
  def allow_margin_comment?; end
  def autocorrect(corrector, node); end
  def comment_text(comment); end
  def concat_consecutive_comments(comments); end
  def current_token(comment); end
  def empty_comment_only?(comment_text); end
  def investigate(comments); end
  def previous_token(node); end
end

RuboCop::Cop::Layout::EmptyComment::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::EmptyLineAfterGuardClause < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::PathUtil
  extend ::RuboCop::Cop::Util

  def on_if(node); end

  private

  def autocorrect(corrector, node); end
  def contains_guard_clause?(node); end
  def correct_style?(node); end
  def heredoc?(node); end
  def heredoc_line(node, heredoc_node); end
  def last_heredoc_argument(node); end
  def last_heredoc_argument_node(node); end
  def multiple_statements_on_line?(node); end
  def next_line_empty?(line); end
  def next_line_empty_or_enable_directive_comment?(line); end
  def next_line_enable_directive_comment?(line); end
  def next_line_rescue_or_ensure?(node); end
  def next_sibling_empty_or_guard_clause?(node); end
  def next_sibling_parent_empty_or_else?(node); end
  def offense_location(node); end
end

RuboCop::Cop::Layout::EmptyLineAfterGuardClause::END_OF_HEREDOC_LINE = T.let(T.unsafe(nil), Integer)
RuboCop::Cop::Layout::EmptyLineAfterGuardClause::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::EmptyLineAfterMagicComment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_new_investigation; end

  private

  def last_magic_comment(source); end
  def offending_range(last_magic_comment); end
end

RuboCop::Cop::Layout::EmptyLineAfterMagicComment::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::EmptyLineAfterMultilineCondition < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_case(node); end
  def on_if(node); end
  def on_rescue(node); end
  def on_until(node); end
  def on_until_post(node); end
  def on_while(node); end
  def on_while_post(node); end

  private

  def autocorrect(node); end
  def check_condition(condition); end
  def multiline_rescue_exceptions?(exception_nodes); end
  def multiline_when_condition?(when_node); end
  def next_line_empty?(line); end
end

RuboCop::Cop::Layout::EmptyLineAfterMultilineCondition::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::EmptyLineBetweenDefs < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def autocorrect(corrector, prev_def, node, count); end
  def check_defs(nodes); end
  def on_begin(node); end

  private

  def allowance_range?; end
  def autocorrect_insert_lines(corrector, newline_pos, count); end
  def autocorrect_remove_lines(corrector, newline_pos, count); end
  def blank_lines_count_between(first_def_node, second_def_node); end
  def candidate?(node); end
  def class_candidate?(node); end
  def def_end(node); end
  def def_start(node); end
  def end_loc(node); end
  def expected_lines; end
  def line_count_allowed?(count); end
  def lines_between_defs(first_def_node, second_def_node); end
  def maximum_empty_lines; end
  def message(node, count: T.unsafe(nil)); end
  def method_candidate?(node); end
  def minimum_empty_lines; end
  def module_candidate?(node); end
  def multiple_blank_lines_groups?(first_def_node, second_def_node); end
  def node_type(node); end

  class << self
    def autocorrect_incompatible_with; end
  end
end

RuboCop::Cop::Layout::EmptyLineBetweenDefs::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::EmptyLines < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_new_investigation; end

  private

  def each_extra_empty_line(lines); end
  def exceeds_line_offset?(line_diff); end
  def previous_and_current_lines_empty?(line); end
end

RuboCop::Cop::Layout::EmptyLines::LINE_OFFSET = T.let(T.unsafe(nil), Integer)
RuboCop::Cop::Layout::EmptyLines::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::EmptyLinesAroundAccessModifier < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def initialize(config = T.unsafe(nil), options = T.unsafe(nil)); end

  def on_block(node); end
  def on_class(node); end
  def on_module(node); end
  def on_sclass(node); end
  def on_send(node); end

  private

  def allowed_only_before_style?(node); end
  def block_start?(line); end
  def body_end?(line); end
  def class_def?(line); end
  def correct_next_line_if_denied_style(corrector, node, line); end
  def empty_lines_around?(node); end
  def expected_empty_lines?(node); end
  def message(node); end
  def message_for_around_style(node); end
  def message_for_only_before_style(node); end
  def next_empty_line_range(node); end
  def next_line_empty?(last_send_line); end
  def previous_line_empty?(send_line); end
  def previous_line_ignoring_comments(processed_source, send_line); end
end

RuboCop::Cop::Layout::EmptyLinesAroundAccessModifier::MSG_AFTER = T.let(T.unsafe(nil), String)
RuboCop::Cop::Layout::EmptyLinesAroundAccessModifier::MSG_AFTER_FOR_ONLY_BEFORE = T.let(T.unsafe(nil), String)
RuboCop::Cop::Layout::EmptyLinesAroundAccessModifier::MSG_BEFORE_AND_AFTER = T.let(T.unsafe(nil), String)
RuboCop::Cop::Layout::EmptyLinesAroundAccessModifier::MSG_BEFORE_FOR_ONLY_BEFORE = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::EmptyLinesAroundArguments < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_csend(node); end
  def on_send(node); end

  private

  def empty_lines(node); end
  def extra_lines(node); end
  def inner_lines(node); end
  def line_numbers(node); end
  def outer_lines(node); end
  def processed_lines(node); end
  def receiver_and_method_call_on_different_lines?(node); end
end

RuboCop::Cop::Layout::EmptyLinesAroundArguments::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::EmptyLinesAroundAttributeAccessor < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::AllowedMethods
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end

  private

  def allow_alias?(node); end
  def allow_alias_syntax?; end
  def attribute_or_allowed_method?(node); end
  def next_line_empty?(line); end
  def next_line_node(node); end
  def require_empty_line?(node); end
end

RuboCop::Cop::Layout::EmptyLinesAroundAttributeAccessor::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::EmptyLinesAroundBeginBody < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  extend ::RuboCop::Cop::AutoCorrector

  def on_kwbegin(node); end

  private

  def style; end
end

RuboCop::Cop::Layout::EmptyLinesAroundBeginBody::KIND = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::EmptyLinesAroundBlockBody < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  extend ::RuboCop::Cop::AutoCorrector

  def on_block(node); end
end

RuboCop::Cop::Layout::EmptyLinesAroundBlockBody::KIND = T.let(T.unsafe(nil), String)

module RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::AST::NodePattern::Macros

  def constant_definition?(param0 = T.unsafe(nil)); end
  def empty_line_required?(param0 = T.unsafe(nil)); end

  private

  def check(node, body, adjusted_first_line: T.unsafe(nil)); end
  def check_beginning(style, first_line); end
  def check_both(style, first_line, last_line); end
  def check_deferred_empty_line(body); end
  def check_empty_lines_except_namespace(body, first_line, last_line); end
  def check_empty_lines_special(body, first_line, last_line); end
  def check_ending(style, last_line); end
  def check_line(style, line, msg); end
  def check_source(style, line_no, desc); end
  def deferred_message(node); end
  def first_child_requires_empty_line?(body); end
  def first_empty_line_required_child(body); end
  def message(type, desc); end
  def namespace?(body, with_one_child: T.unsafe(nil)); end
  def previous_line_ignoring_comments(send_line); end
  def valid_body_style?(body); end
end

RuboCop::Cop::Layout::EmptyLinesAroundBody::MSG_DEFERRED = T.let(T.unsafe(nil), String)
RuboCop::Cop::Layout::EmptyLinesAroundBody::MSG_EXTRA = T.let(T.unsafe(nil), String)
RuboCop::Cop::Layout::EmptyLinesAroundBody::MSG_MISSING = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::EmptyLinesAroundClassBody < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  extend ::RuboCop::Cop::AutoCorrector

  def on_class(node); end
  def on_sclass(node); end
end

RuboCop::Cop::Layout::EmptyLinesAroundClassBody::KIND = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::EmptyLinesAroundExceptionHandlingKeywords < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  extend ::RuboCop::Cop::AutoCorrector

  def on_def(node); end
  def on_defs(node); end
  def on_kwbegin(node); end

  private

  def check_body(body, line_of_def_or_kwbegin); end
  def keyword_locations(node); end
  def keyword_locations_in_ensure(node); end
  def keyword_locations_in_rescue(node); end
  def last_rescue_and_end_on_same_line(body); end
  def message(location, keyword); end
  def style; end
end

RuboCop::Cop::Layout::EmptyLinesAroundExceptionHandlingKeywords::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::EmptyLinesAroundMethodBody < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  extend ::RuboCop::Cop::AutoCorrector

  def on_def(node); end
  def on_defs(node); end

  private

  def style; end
end

RuboCop::Cop::Layout::EmptyLinesAroundMethodBody::KIND = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::EmptyLinesAroundModuleBody < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  extend ::RuboCop::Cop::AutoCorrector

  def on_module(node); end
end

RuboCop::Cop::Layout::EmptyLinesAroundModuleBody::KIND = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::EndAlignment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::CheckAssignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::EndKeywordAlignment
  extend ::RuboCop::Cop::AutoCorrector

  def on_case(node); end
  def on_class(node); end
  def on_if(node); end
  def on_module(node); end
  def on_until(node); end
  def on_while(node); end

  private

  def alignment_node(node); end
  def alignment_node_for_variable_style(node); end
  def asgn_variable_align_with(outer_node, inner_node); end
  def assignment_or_operator_method(node); end
  def autocorrect(corrector, node); end
  def check_asgn_alignment(outer_node, inner_node); end
  def check_assignment(node, rhs); end
  def check_other_alignment(node); end
end

class RuboCop::Cop::Layout::EndOfLine < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp

  def offense_message(line); end
  def on_new_investigation; end
  def unimportant_missing_cr?(index, last_line, line); end

  private

  def last_line(processed_source); end
end

RuboCop::Cop::Layout::EndOfLine::MSG_DETECTED = T.let(T.unsafe(nil), String)
RuboCop::Cop::Layout::EndOfLine::MSG_MISSING = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::ExtraSpacing < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::PrecedingFollowingAlignment
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_new_investigation; end

  private

  def align_column(asgn_token); end
  def align_equal_sign(corrector, token, align_to); end
  def align_equal_signs(range, corrector); end
  def aligned_locations(locs); end
  def aligned_tok?(token); end
  def all_relevant_assignment_lines(line_number); end
  def allow_for_trailing_comments?; end
  def check_assignment(token); end
  def check_other(token1, token2, ast); end
  def check_tokens(ast, token1, token2); end
  def extra_space_range(token1, token2); end
  def force_equal_sign_alignment?; end
  def ignored_range?(ast, start_pos); end
  def ignored_ranges(ast); end
end

RuboCop::Cop::Layout::ExtraSpacing::MSG_UNALIGNED_ASGN = T.let(T.unsafe(nil), String)
RuboCop::Cop::Layout::ExtraSpacing::MSG_UNNECESSARY = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::FirstArgumentIndentation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def eligible_method_call?(param0 = T.unsafe(nil)); end
  def on_csend(node); end
  def on_send(node); end

  private

  def argument_alignment_config; end
  def autocorrect(corrector, node); end
  def bare_operator?(node); end
  def base_indentation(node); end
  def base_range(send_node, arg_node); end
  def column_of(range); end
  def comment_lines; end
  def enforce_first_argument_with_fixed_indentation?; end
  def message(arg_node); end
  def on_new_investigation; end
  def previous_code_line(line_number); end
  def special_inner_call_indentation?(node); end
end

RuboCop::Cop::Layout::FirstArgumentIndentation::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::FirstArrayElementIndentation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MultilineElementIndentation
  extend ::RuboCop::Cop::AutoCorrector

  def on_array(node); end
  def on_csend(node); end
  def on_send(node); end

  private

  def autocorrect(corrector, node); end
  def base_description(left_parenthesis); end
  def brace_alignment_style; end
  def check(array_node, left_parenthesis); end
  def check_right_bracket(right_bracket, left_bracket, left_parenthesis); end
  def message(base_description); end
  def msg(left_parenthesis); end
end

RuboCop::Cop::Layout::FirstArrayElementIndentation::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::FirstArrayElementLineBreak < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::FirstElementLineBreak
  extend ::RuboCop::Cop::AutoCorrector

  def on_array(node); end

  private

  def assignment_on_same_line?(node); end
end

RuboCop::Cop::Layout::FirstArrayElementLineBreak::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::FirstHashElementIndentation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MultilineElementIndentation
  extend ::RuboCop::Cop::AutoCorrector

  def on_csend(node); end
  def on_hash(node); end
  def on_send(node); end

  private

  def argument_alignment_config; end
  def autocorrect(corrector, node); end
  def base_description(left_parenthesis); end
  def brace_alignment_style; end
  def check(hash_node, left_parenthesis); end
  def check_based_on_longest_key(hash_node, left_brace, left_parenthesis); end
  def check_right_brace(right_brace, left_brace, left_parenthesis); end
  def enforce_first_argument_with_fixed_indentation?; end
  def message(base_description); end
  def message_for_right_brace(left_parenthesis); end
  def separator_style?(first_pair); end
end

RuboCop::Cop::Layout::FirstHashElementIndentation::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::FirstHashElementLineBreak < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::FirstElementLineBreak
  extend ::RuboCop::Cop::AutoCorrector

  def on_hash(node); end
end

RuboCop::Cop::Layout::FirstHashElementLineBreak::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::FirstMethodArgumentLineBreak < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::FirstElementLineBreak
  extend ::RuboCop::Cop::AutoCorrector

  def on_csend(node); end
  def on_send(node); end
  def on_super(node); end
end

RuboCop::Cop::Layout::FirstMethodArgumentLineBreak::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::FirstMethodParameterLineBreak < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::FirstElementLineBreak
  extend ::RuboCop::Cop::AutoCorrector

  def on_def(node); end
  def on_defs(node); end
end

RuboCop::Cop::Layout::FirstMethodParameterLineBreak::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::FirstParameterIndentation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MultilineElementIndentation
  extend ::RuboCop::Cop::AutoCorrector

  def on_def(node); end
  def on_defs(node); end

  private

  def autocorrect(corrector, node); end
  def base_description(_); end
  def brace_alignment_style; end
  def check(def_node); end
  def message(base_description); end
end

RuboCop::Cop::Layout::FirstParameterIndentation::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::HashAlignment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::HashAlignmentStyles
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def column_deltas; end
  def column_deltas=(_arg0); end
  def offenses_by; end
  def offenses_by=(_arg0); end
  def on_hash(node); end
  def on_send(node); end
  def on_super(node); end
  def on_yield(node); end

  private

  def add_offenses; end
  def adjust(corrector, delta, range); end
  def alignment_for(pair); end
  def alignment_for_colons; end
  def alignment_for_hash_rockets; end
  def argument_alignment_config; end
  def argument_before_hash(hash_node); end
  def autocorrect_incompatible_with_other_cops?(node); end
  def check_delta(delta, node:, alignment:); end
  def check_pairs(node); end
  def correct_key_value(corrector, delta, key, value, separator); end
  def correct_no_value(corrector, key_delta, key); end
  def correct_node(corrector, node, delta); end
  def double_splat?(node); end
  def enforce_first_argument_with_fixed_indentation?; end
  def good_alignment?(column_deltas); end
  def ignore_hash_argument?(node); end
  def new_alignment(key); end
  def register_offenses_with_format(offenses, format); end
  def reset!; end
end

RuboCop::Cop::Layout::HashAlignment::MESSAGES = T.let(T.unsafe(nil), Hash)

class RuboCop::Cop::Layout::HeredocArgumentClosingParenthesis < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end

  private

  def add_correct_closing_paren(node, corrector); end
  def add_correct_external_trailing_comma(node, corrector); end
  def autocorrect(corrector, node); end
  def exist_argument_between_heredoc_end_and_closing_parentheses?(node); end
  def external_trailing_comma?(node); end
  def external_trailing_comma_offset_from_loc_end(node); end
  def extract_heredoc(node); end
  def extract_heredoc_argument(node); end
  def find_most_bottom_of_heredoc_end(arguments); end
  def fix_closing_parenthesis(node, corrector); end
  def fix_external_trailing_comma(node, corrector); end
  def heredoc_node?(node); end
  def incorrect_parenthesis_removal_begin(node); end
  def incorrect_parenthesis_removal_end(node); end
  def internal_trailing_comma?(node); end
  def internal_trailing_comma_offset_from_last_arg(node); end
  def outermost_send_on_same_line(heredoc); end
  def remove_incorrect_closing_paren(node, corrector); end
  def remove_incorrect_external_trailing_comma(node, corrector); end
  def remove_internal_trailing_comma(node, corrector); end
  def safe_to_remove_line_containing_closing_paren?(node); end
  def send_missing_closing_parens?(parent, child, heredoc); end
  def single_line_send_with_heredoc_receiver?(node); end
  def space?(pos); end
  def subsequent_closing_parentheses_in_same_line?(outermost_send); end

  class << self
    def autocorrect_incompatible_with; end
  end
end

RuboCop::Cop::Layout::HeredocArgumentClosingParenthesis::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::HeredocIndentation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Heredoc
  extend ::RuboCop::Cop::AutoCorrector

  def on_heredoc(node); end

  private

  def adjust_minus(corrector, node); end
  def adjust_squiggly(corrector, node); end
  def base_indent_level(node); end
  def heredoc_body(node); end
  def heredoc_end(node); end
  def heredoc_indent_type(node); end
  def indentation_width; end
  def indented_body(node); end
  def indented_end(node); end
  def line_too_long?(node); end
  def longest_line(lines); end
  def max_line_length; end
  def message(heredoc_indent_type); end
  def register_offense(node, heredoc_indent_type); end
  def type_message(indentation_width, current_indent_type); end
  def unlimited_heredoc_length?; end
  def width_message(indentation_width); end
end

RuboCop::Cop::Layout::HeredocIndentation::TYPE_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Layout::HeredocIndentation::WIDTH_MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::IndentationConsistency < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def on_begin(node); end
  def on_kwbegin(node); end

  private

  def autocorrect(corrector, node); end
  def bare_access_modifier?(node); end
  def base_column_for_normal_style(node); end
  def check(node); end
  def check_indented_internal_methods_style(node); end
  def check_normal_style(node); end
end

RuboCop::Cop::Layout::IndentationConsistency::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::IndentationStyle < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_new_investigation; end

  private

  def autocorrect(corrector, range); end
  def autocorrect_lambda_for_spaces(corrector, range); end
  def autocorrect_lambda_for_tabs(corrector, range); end
  def find_offense(line, lineno); end
  def in_string_literal?(ranges, tabs_range); end
  def message(_node); end
  def string_literal_ranges(ast); end
end

RuboCop::Cop::Layout::IndentationStyle::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::IndentationWidth < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::CheckAssignment
  include ::RuboCop::Cop::IgnoredPattern
  extend ::RuboCop::Cop::AutoCorrector

  def access_modifier?(param0 = T.unsafe(nil)); end
  def on_block(node); end
  def on_case(case_node); end
  def on_case_match(case_match); end
  def on_class(node); end
  def on_csend(node); end
  def on_def(node); end
  def on_defs(node); end
  def on_ensure(node); end
  def on_for(node); end
  def on_if(node, base = T.unsafe(nil)); end
  def on_kwbegin(node); end
  def on_module(node); end
  def on_resbody(node); end
  def on_rescue(node); end
  def on_sclass(node); end
  def on_send(node); end
  def on_until(node, base = T.unsafe(nil)); end
  def on_while(node, base = T.unsafe(nil)); end

  private

  def access_modifier_indentation_style; end
  def autocorrect(corrector, node); end
  def check_assignment(node, rhs); end
  def check_if(node, body, else_clause, base_loc); end
  def check_indentation(base_loc, body_node, style = T.unsafe(nil)); end
  def check_members(base, members); end
  def check_members_for_indented_internal_methods_style(members); end
  def check_members_for_normal_style(base, members); end
  def check_rescue?(rescue_node); end
  def configured_indentation_width; end
  def each_member(members); end
  def indentation_consistency_style; end
  def indentation_to_check?(base_loc, body_node); end
  def indented_internal_methods_style?; end
  def leftmost_modifier_of(node); end
  def message(configured_indentation_width, indentation, name); end
  def offending_range(body_node, indentation); end
  def offense(body_node, indentation, style); end
  def other_offense_in_same_range?(node); end
  def select_check_member(member); end
  def skip_check?(base_loc, body_node); end
  def special_modifier?(node); end
  def starts_with_access_modifier?(body_node); end
end

RuboCop::Cop::Layout::IndentationWidth::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::InitialIndentation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_new_investigation; end

  private

  def first_token; end
  def space_before(token); end
end

RuboCop::Cop::Layout::InitialIndentation::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::LeadingCommentSpace < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_new_investigation; end

  private

  def allow_doxygen_comment?; end
  def allow_gemfile_ruby_comment?; end
  def allowed_on_first_line?(comment); end
  def doxygen_comment_style?(comment); end
  def gemfile?; end
  def gemfile_ruby_comment?(comment); end
  def hash_mark(expr); end
  def rackup_config_file?; end
  def rackup_options?(comment); end
  def ruby_comment_in_gemfile?(comment); end
  def shebang?(comment); end
end

RuboCop::Cop::Layout::LeadingCommentSpace::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::LeadingEmptyLines < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_new_investigation; end
end

RuboCop::Cop::Layout::LeadingEmptyLines::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::LineEndStringConcatenationIndentation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::Alignment
  extend ::RuboCop::Cop::AutoCorrector

  def autocorrect(corrector, node); end
  def on_dstr(node); end

  private

  def add_offense_and_correction(node, message); end
  def always_indented?(dstr_node); end
  def base_column(child); end
  def check_aligned(children, start_index); end
  def check_indented(children); end
  def strings_concatenated_with_backslash?(dstr_node); end
end

RuboCop::Cop::Layout::LineEndStringConcatenationIndentation::MSG_ALIGN = T.let(T.unsafe(nil), String)
RuboCop::Cop::Layout::LineEndStringConcatenationIndentation::MSG_INDENT = T.let(T.unsafe(nil), String)
RuboCop::Cop::Layout::LineEndStringConcatenationIndentation::PARENT_TYPES_FOR_INDENTED = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Layout::LineLength < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::CheckLineBreakable
  include ::RuboCop::Cop::IgnoredPattern
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::LineLengthHelp
  extend ::RuboCop::Cop::AutoCorrector

  def max=(value); end
  def on_array(node); end
  def on_block(node); end
  def on_hash(node); end
  def on_investigation_end; end
  def on_new_investigation; end
  def on_potential_breakable_node(node); end
  def on_send(node); end

  private

  def allow_heredoc?; end
  def allowed_heredoc; end
  def breakable_block_range(block_node); end
  def breakable_range; end
  def breakable_range=(_arg0); end
  def breakable_range_after_semicolon(semicolon_token); end
  def breakable_range_by_line_index; end
  def check_directive_line(line, line_index); end
  def check_for_breakable_block(block_node); end
  def check_for_breakable_node(node); end
  def check_for_breakable_semicolons(processed_source); end
  def check_line(line, line_index); end
  def check_uri_line(line, line_index); end
  def excess_range(uri_range, line, line_index); end
  def extract_heredocs(ast); end
  def heredocs; end
  def highlight_start(line); end
  def ignored_line?(line, line_index); end
  def line_in_heredoc?(line_number); end
  def line_in_permitted_heredoc?(line_number); end
  def max; end
  def register_offense(loc, line, line_index, length: T.unsafe(nil)); end
  def shebang?(line, line_index); end
end

RuboCop::Cop::Layout::LineLength::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::MultilineArrayBraceLayout < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  extend ::RuboCop::Cop::AutoCorrector

  def on_array(node); end
end

RuboCop::Cop::Layout::MultilineArrayBraceLayout::ALWAYS_NEW_LINE_MESSAGE = T.let(T.unsafe(nil), String)
RuboCop::Cop::Layout::MultilineArrayBraceLayout::ALWAYS_SAME_LINE_MESSAGE = T.let(T.unsafe(nil), String)
RuboCop::Cop::Layout::MultilineArrayBraceLayout::NEW_LINE_MESSAGE = T.let(T.unsafe(nil), String)
RuboCop::Cop::Layout::MultilineArrayBraceLayout::SAME_LINE_MESSAGE = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::MultilineArrayLineBreaks < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::MultilineElementLineBreaks
  extend ::RuboCop::Cop::AutoCorrector

  def on_array(node); end
end

RuboCop::Cop::Layout::MultilineArrayLineBreaks::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::MultilineAssignmentLayout < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::CheckAssignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def check_assignment(node, rhs); end
  def check_by_enforced_style(node, rhs); end
  def check_new_line_offense(node, rhs); end
  def check_same_line_offense(node, rhs); end

  private

  def supported_types; end
end

RuboCop::Cop::Layout::MultilineAssignmentLayout::NEW_LINE_OFFENSE = T.let(T.unsafe(nil), String)
RuboCop::Cop::Layout::MultilineAssignmentLayout::SAME_LINE_OFFENSE = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::MultilineBlockLayout < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_block(node); end

  private

  def add_offense_for_expression(node, expr, msg); end
  def args_on_beginning_line?(node); end
  def autocorrect(corrector, node); end
  def autocorrect_arguments(corrector, node); end
  def autocorrect_body(corrector, node, block_body); end
  def block_arg_string(node, args); end
  def characters_needed_for_space_and_pipes(node); end
  def include_trailing_comma?(args); end
  def line_break_necessary_in_args?(node); end
  def needed_length_for_args(node); end
end

RuboCop::Cop::Layout::MultilineBlockLayout::ARG_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Layout::MultilineBlockLayout::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Layout::MultilineBlockLayout::PIPE_SIZE = T.let(T.unsafe(nil), Integer)

class RuboCop::Cop::Layout::MultilineHashBraceLayout < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  extend ::RuboCop::Cop::AutoCorrector

  def on_hash(node); end
end

RuboCop::Cop::Layout::MultilineHashBraceLayout::ALWAYS_NEW_LINE_MESSAGE = T.let(T.unsafe(nil), String)
RuboCop::Cop::Layout::MultilineHashBraceLayout::ALWAYS_SAME_LINE_MESSAGE = T.let(T.unsafe(nil), String)
RuboCop::Cop::Layout::MultilineHashBraceLayout::NEW_LINE_MESSAGE = T.let(T.unsafe(nil), String)
RuboCop::Cop::Layout::MultilineHashBraceLayout::SAME_LINE_MESSAGE = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::MultilineHashKeyLineBreaks < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::MultilineElementLineBreaks
  extend ::RuboCop::Cop::AutoCorrector

  def on_hash(node); end

  private

  def starts_with_curly_brace?(node); end
end

RuboCop::Cop::Layout::MultilineHashKeyLineBreaks::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::MultilineMethodArgumentLineBreaks < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::MultilineElementLineBreaks
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end
end

RuboCop::Cop::Layout::MultilineMethodArgumentLineBreaks::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::MultilineMethodCallBraceLayout < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end

  private

  def children(node); end
  def ignored_literal?(node); end
  def single_line_ignoring_receiver?(node); end
end

RuboCop::Cop::Layout::MultilineMethodCallBraceLayout::ALWAYS_NEW_LINE_MESSAGE = T.let(T.unsafe(nil), String)
RuboCop::Cop::Layout::MultilineMethodCallBraceLayout::ALWAYS_SAME_LINE_MESSAGE = T.let(T.unsafe(nil), String)
RuboCop::Cop::Layout::MultilineMethodCallBraceLayout::NEW_LINE_MESSAGE = T.let(T.unsafe(nil), String)
RuboCop::Cop::Layout::MultilineMethodCallBraceLayout::SAME_LINE_MESSAGE = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::MultilineMethodCallIndentation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::MultilineExpressionIndentation
  extend ::RuboCop::Cop::AutoCorrector

  def validate_config; end

  private

  def align_with_base_message(rhs); end
  def alignment_base(node, rhs, given_style); end
  def autocorrect(corrector, node); end
  def base_source; end
  def extra_indentation(given_style, parent); end
  def message(node, lhs, rhs); end
  def no_base_message(lhs, rhs, node); end
  def offending_range(node, lhs, rhs, given_style); end
  def operation_rhs(node); end
  def operator_rhs?(node, receiver); end
  def receiver_alignment_base(node); end
  def relative_to_receiver_message(rhs); end
  def relevant_node?(send_node); end
  def right_hand_side(send_node); end
  def semantic_alignment_base(node, rhs); end
  def semantic_alignment_node(node); end
  def should_align_with_base?; end
  def should_indent_relative_to_receiver?; end
  def syntactic_alignment_base(lhs, rhs); end
end

class RuboCop::Cop::Layout::MultilineMethodDefinitionBraceLayout < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  extend ::RuboCop::Cop::AutoCorrector

  def on_def(node); end
  def on_defs(node); end
end

RuboCop::Cop::Layout::MultilineMethodDefinitionBraceLayout::ALWAYS_NEW_LINE_MESSAGE = T.let(T.unsafe(nil), String)
RuboCop::Cop::Layout::MultilineMethodDefinitionBraceLayout::ALWAYS_SAME_LINE_MESSAGE = T.let(T.unsafe(nil), String)
RuboCop::Cop::Layout::MultilineMethodDefinitionBraceLayout::NEW_LINE_MESSAGE = T.let(T.unsafe(nil), String)
RuboCop::Cop::Layout::MultilineMethodDefinitionBraceLayout::SAME_LINE_MESSAGE = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::MultilineOperationIndentation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::MultilineExpressionIndentation
  extend ::RuboCop::Cop::AutoCorrector

  def on_and(node); end
  def on_or(node); end
  def validate_config; end

  private

  def autocorrect(corrector, node); end
  def check_and_or(node); end
  def message(node, lhs, rhs); end
  def offending_range(node, lhs, rhs, given_style); end
  def relevant_node?(node); end
  def right_hand_side(send_node); end
  def should_align?(node, rhs, given_style); end
end

class RuboCop::Cop::Layout::ParameterAlignment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  extend ::RuboCop::Cop::AutoCorrector

  def on_def(node); end
  def on_defs(node); end

  private

  def autocorrect(corrector, node); end
  def base_column(node, args); end
  def fixed_indentation?; end
  def message(_node); end
  def target_method_lineno(node); end
end

RuboCop::Cop::Layout::ParameterAlignment::ALIGN_PARAMS_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Layout::ParameterAlignment::FIXED_INDENT_MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::RedundantLineBreak < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::CheckAssignment
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end

  private

  def check_assignment(node, _rhs); end
  def comment_within?(node); end
  def configured_to_not_be_inspected?(node); end
  def convertible_block?(node); end
  def max_line_length; end
  def offense?(node); end
  def other_cop_takes_precedence?(node); end
  def register_offense(node); end
  def single_line_block_chain_enabled?; end
  def suitable_as_single_line?(node); end
  def to_single_line(source); end
  def too_long?(node); end
end

RuboCop::Cop::Layout::RedundantLineBreak::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::RescueEnsureAlignment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::EndKeywordAlignment
  extend ::RuboCop::Cop::AutoCorrector

  def on_ensure(node); end
  def on_new_investigation; end
  def on_resbody(node); end

  private

  def access_modifier?(node); end
  def access_modifier_node(node); end
  def aligned_with_leading_dot?(do_keyword_line, send_node_loc, rescue_keyword_column); end
  def aligned_with_line_break_method?(ancestor_node, node); end
  def alignment_location(alignment_node); end
  def alignment_node(node); end
  def alignment_source(node, starting_loc); end
  def ancestor_node(node); end
  def assignment_node(node); end
  def autocorrect(corrector, node, alignment_location); end
  def begin_end_alignment_style; end
  def check(node); end
  def format_message(alignment_node, alignment_loc, kw_loc); end
  def modifier?(node); end
  def whitespace_range(node); end
end

RuboCop::Cop::Layout::RescueEnsureAlignment::ALTERNATIVE_ACCESS_MODIFIERS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Layout::RescueEnsureAlignment::ANCESTOR_TYPES = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Layout::RescueEnsureAlignment::ANCESTOR_TYPES_WITH_ACCESS_MODIFIERS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Layout::RescueEnsureAlignment::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::SingleLineBlockChain < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end

  private

  def call_method_after_block?(node, dot_range, closing_block_delimiter_line_num); end
  def offending_range(node); end
  def selector_range(node); end
end

RuboCop::Cop::Layout::SingleLineBlockChain::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::SpaceAfterColon < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_kwoptarg(node); end
  def on_pair(node); end

  private

  def followed_by_space?(colon); end
  def register_offense(colon); end
end

RuboCop::Cop::Layout::SpaceAfterColon::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::SpaceAfterComma < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::SpaceAfterPunctuation
  extend ::RuboCop::Cop::AutoCorrector

  def kind(token); end
  def space_style_before_rcurly; end
end

class RuboCop::Cop::Layout::SpaceAfterMethodName < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_def(node); end
  def on_defs(node); end
end

RuboCop::Cop::Layout::SpaceAfterMethodName::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::SpaceAfterNot < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end

  private

  def whitespace_after_operator?(node); end
end

RuboCop::Cop::Layout::SpaceAfterNot::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Layout::SpaceAfterNot::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Layout::SpaceAfterSemicolon < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::SpaceAfterPunctuation
  extend ::RuboCop::Cop::AutoCorrector

  def kind(token); end
  def space_style_before_rcurly; end
end

class RuboCop::Cop::Layout::SpaceAroundBlockParameters < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_block(node); end

  private

  def check_after_closing_pipe(arguments); end
  def check_arg(arg); end
  def check_closing_pipe_space(arguments, closing_pipe); end
  def check_each_arg(args); end
  def check_inside_pipes(arguments); end
  def check_no_space(space_begin_pos, space_end_pos, msg); end
  def check_no_space_style_inside_pipes(arguments); end
  def check_opening_pipe_space(arguments, opening_pipe); end
  def check_space(space_begin_pos, space_end_pos, range, msg, node = T.unsafe(nil)); end
  def check_space_style_inside_pipes(arguments); end
  def last_end_pos_inside_pipes(arguments, range); end
  def pipes(arguments); end
  def pipes?(arguments); end
  def style_parameter_name; end
end

class RuboCop::Cop::Layout::SpaceAroundEqualsInParameterDefault < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def on_optarg(node); end

  private

  def autocorrect(corrector, range); end
  def check_optarg(arg, equals, value); end
  def incorrect_style_detected(arg, value); end
  def message(_node); end
  def no_surrounding_space?(arg, equals); end
  def space_on_both_sides?(arg, equals); end
end

RuboCop::Cop::Layout::SpaceAroundEqualsInParameterDefault::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::SpaceAroundKeyword < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_and(node); end
  def on_block(node); end
  def on_break(node); end
  def on_case(node); end
  def on_case_match(node); end
  def on_defined?(node); end
  def on_ensure(node); end
  def on_for(node); end
  def on_if(node); end
  def on_if_guard(node); end
  def on_in_pattern(node); end
  def on_kwbegin(node); end
  def on_match_pattern(node); end
  def on_match_pattern_p(node); end
  def on_next(node); end
  def on_or(node); end
  def on_postexe(node); end
  def on_preexe(node); end
  def on_resbody(node); end
  def on_rescue(node); end
  def on_return(node); end
  def on_send(node); end
  def on_super(node); end
  def on_unless_guard(node); end
  def on_until(node); end
  def on_when(node); end
  def on_while(node); end
  def on_yield(node); end
  def on_zsuper(node); end

  private

  def accept_left_parenthesis?(range); end
  def accept_left_square_bracket?(range); end
  def accept_namespace_operator?(range); end
  def accepted_opening_delimiter?(range, char); end
  def check(node, locations, begin_keyword = T.unsafe(nil)); end
  def check_begin(node, range, begin_keyword); end
  def check_end(node, range, begin_keyword); end
  def check_keyword(node, range); end
  def do?(node); end
  def namespace_operator?(range, pos); end
  def preceded_by_operator?(node, _range); end
  def safe_navigation_call?(range, pos); end
  def space_after_missing?(range); end
  def space_before_missing?(range); end
end

RuboCop::Cop::Layout::SpaceAroundKeyword::ACCEPT_LEFT_PAREN = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Layout::SpaceAroundKeyword::ACCEPT_LEFT_SQUARE_BRACKET = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Layout::SpaceAroundKeyword::ACCEPT_NAMESPACE_OPERATOR = T.let(T.unsafe(nil), String)
RuboCop::Cop::Layout::SpaceAroundKeyword::DO = T.let(T.unsafe(nil), String)
RuboCop::Cop::Layout::SpaceAroundKeyword::MSG_AFTER = T.let(T.unsafe(nil), String)
RuboCop::Cop::Layout::SpaceAroundKeyword::MSG_BEFORE = T.let(T.unsafe(nil), String)
RuboCop::Cop::Layout::SpaceAroundKeyword::NAMESPACE_OPERATOR = T.let(T.unsafe(nil), String)
RuboCop::Cop::Layout::SpaceAroundKeyword::SAFE_NAVIGATION = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::SpaceAroundMethodCallOperator < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_const(node); end
  def on_csend(node); end
  def on_send(node); end

  private

  def check_space(begin_pos, end_pos); end
  def check_space_after_dot(node); end
  def check_space_after_double_colon(node); end
  def check_space_before_dot(node); end
end

RuboCop::Cop::Layout::SpaceAroundMethodCallOperator::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Layout::SpaceAroundMethodCallOperator::SPACES_REGEXP = T.let(T.unsafe(nil), Regexp)

class RuboCop::Cop::Layout::SpaceAroundOperators < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::PrecedingFollowingAlignment
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::RationalLiteral
  extend ::RuboCop::Cop::AutoCorrector

  def on_and(node); end
  def on_and_asgn(node); end
  def on_assignment(node); end
  def on_binary(node); end
  def on_casgn(node); end
  def on_class(node); end
  def on_cvasgn(node); end
  def on_gvasgn(node); end
  def on_if(node); end
  def on_ivasgn(node); end
  def on_lvasgn(node); end
  def on_masgn(node); end
  def on_match_pattern(node); end
  def on_op_asgn(node); end
  def on_or(node); end
  def on_or_asgn(node); end
  def on_pair(node); end
  def on_resbody(node); end
  def on_sclass(node); end
  def on_send(node); end
  def on_special_asgn(node); end

  private

  def align_hash_cop_config; end
  def autocorrect(corrector, range); end
  def check_operator(type, operator, right_operand); end
  def enclose_operator_with_space(corrector, range); end
  def excess_leading_space?(type, operator, with_space); end
  def excess_trailing_space?(right_operand, with_space); end
  def force_equal_sign_alignment?; end
  def hash_table_style?; end
  def offense(type, operator, with_space, right_operand); end
  def offense_message(type, operator, with_space, right_operand); end
  def operator_with_regular_syntax?(send_node); end
  def regular_operator?(send_node); end
  def should_not_have_surrounding_space?(operator); end
  def space_around_exponent_operator?; end

  class << self
    def autocorrect_incompatible_with; end
  end
end

RuboCop::Cop::Layout::SpaceAroundOperators::EXCESSIVE_SPACE = T.let(T.unsafe(nil), String)
RuboCop::Cop::Layout::SpaceAroundOperators::IRREGULAR_METHODS = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Layout::SpaceBeforeBlockBraces < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_block(node); end

  private

  def autocorrect(corrector, range); end
  def block_delimiters_style; end
  def check_empty(left_brace, space_plus_brace, used_style); end
  def check_non_empty(left_brace, space_plus_brace, used_style); end
  def conflict_with_block_delimiters?(node); end
  def empty_braces?(loc); end
  def space_detected(left_brace, space_plus_brace); end
  def space_missing(left_brace); end
  def style_for_empty_braces; end

  class << self
    def autocorrect_incompatible_with; end
  end
end

RuboCop::Cop::Layout::SpaceBeforeBlockBraces::DETECTED_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Layout::SpaceBeforeBlockBraces::MISSING_MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::SpaceBeforeBrackets < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end

  private

  def offense_range(node, begin_pos); end
  def offense_range_for_assignment(node, begin_pos); end
  def reference_variable_with_brackets?(node); end
  def register_offense(range); end
end

RuboCop::Cop::Layout::SpaceBeforeBrackets::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Layout::SpaceBeforeBrackets::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Layout::SpaceBeforeComma < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::SpaceBeforePunctuation
  extend ::RuboCop::Cop::AutoCorrector

  def kind(token); end
end

class RuboCop::Cop::Layout::SpaceBeforeComment < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_new_investigation; end
end

RuboCop::Cop::Layout::SpaceBeforeComment::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::SpaceBeforeFirstArg < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::PrecedingFollowingAlignment
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_csend(node); end
  def on_send(node); end

  private

  def expect_params_after_method_name?(node); end
  def no_space_between_method_name_and_first_argument?(node); end
  def regular_method_call_with_arguments?(node); end

  class << self
    def autocorrect_incompatible_with; end
  end
end

RuboCop::Cop::Layout::SpaceBeforeFirstArg::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::SpaceBeforeSemicolon < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::SpaceBeforePunctuation
  extend ::RuboCop::Cop::AutoCorrector

  def kind(token); end
end

class RuboCop::Cop::Layout::SpaceInLambdaLiteral < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end

  private

  def arrow_lambda_with_args?(node); end
  def lambda_arguments(node); end
  def range_of_offense(node); end
  def space_after_arrow(lambda_node); end
  def space_after_arrow?(lambda_node); end
end

RuboCop::Cop::Layout::SpaceInLambdaLiteral::MSG_REQUIRE_NO_SPACE = T.let(T.unsafe(nil), String)
RuboCop::Cop::Layout::SpaceInLambdaLiteral::MSG_REQUIRE_SPACE = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::SpaceInsideArrayLiteralBrackets < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def on_array(node); end

  private

  def array_brackets(node); end
  def autocorrect(corrector, node); end
  def compact(corrector, bracket, side); end
  def compact_corrections(corrector, node, left, right); end
  def compact_offense(node, token, side: T.unsafe(nil)); end
  def compact_offenses(node, left, right, start_ok, end_ok); end
  def empty_config; end
  def end_has_own_line?(token); end
  def index_for(node, token); end
  def issue_offenses(node, left, right, start_ok, end_ok); end
  def left_array_bracket(node); end
  def line_and_column_for(token); end
  def multi_dimensional_array?(node, token, side: T.unsafe(nil)); end
  def next_to_bracket?(token, side: T.unsafe(nil)); end
  def next_to_comment?(node, token); end
  def next_to_newline?(node, token); end
  def qualifies_for_compact?(node, token, side: T.unsafe(nil)); end
  def right_array_bracket(node); end
end

RuboCop::Cop::Layout::SpaceInsideArrayLiteralBrackets::EMPTY_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Layout::SpaceInsideArrayLiteralBrackets::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::SpaceInsideArrayPercentLiteral < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::MatchRange
  include ::RuboCop::Cop::PercentLiteral
  extend ::RuboCop::Cop::AutoCorrector

  def on_array(node); end
  def on_percent_literal(node); end

  private

  def each_unnecessary_space_match(node, &blk); end
end

RuboCop::Cop::Layout::SpaceInsideArrayPercentLiteral::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Layout::SpaceInsideArrayPercentLiteral::MULTIPLE_SPACES_BETWEEN_ITEMS_REGEX = T.let(T.unsafe(nil), Regexp)

class RuboCop::Cop::Layout::SpaceInsideBlockBraces < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::SurroundingSpace
  extend ::RuboCop::Cop::AutoCorrector

  def on_block(node); end

  private

  def adjacent_braces(left_brace, right_brace); end
  def aligned_braces?(left_brace, right_brace); end
  def braces_with_contents_inside(node, inner); end
  def check_inside(node, left_brace, right_brace); end
  def check_left_brace(inner, left_brace, args_delimiter); end
  def check_right_brace(inner, left_brace, right_brace, single_line); end
  def multiline_block?(left_brace, right_brace); end
  def no_space(begin_pos, end_pos, msg); end
  def no_space_inside_left_brace(left_brace, args_delimiter); end
  def offense(begin_pos, end_pos, msg, style_param = T.unsafe(nil)); end
  def pipe?(args_delimiter); end
  def space(begin_pos, end_pos, msg); end
  def space_inside_left_brace(left_brace, args_delimiter); end
  def space_inside_right_brace(right_brace); end
  def style_for_empty_braces; end
end

class RuboCop::Cop::Layout::SpaceInsideHashLiteralBraces < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def on_hash(node); end

  private

  def ambiguous_or_unexpected_style_detected(style, is_match); end
  def autocorrect(corrector, range); end
  def check(token1, token2); end
  def expect_space?(token1, token2); end
  def incorrect_style_detected(token1, token2, expect_space, is_empty_braces); end
  def message(brace, is_empty_braces, expect_space); end
  def offense?(token1, expect_space); end
  def range_of_space_to_the_left(range); end
  def range_of_space_to_the_right(range); end
  def space_range(token_range); end
end

RuboCop::Cop::Layout::SpaceInsideHashLiteralBraces::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::SpaceInsideParens < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def on_new_investigation; end

  private

  def can_be_ignored?(token1, token2); end
  def correct_extaneus_space_between_consecutive_parens(token1, token2); end
  def correct_extraneous_space(tokens); end
  def correct_extraneous_space_in_empty_parens(token1, token2); end
  def correct_missing_space(token1, token2); end
  def left_parens?(token1, token2); end
  def parens?(token1, token2); end
  def process_with_compact_style(tokens); end
  def process_with_space_style(tokens); end
  def right_parens?(token1, token2); end
end

RuboCop::Cop::Layout::SpaceInsideParens::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Layout::SpaceInsideParens::MSG_SPACE = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::SpaceInsidePercentLiteralDelimiters < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::MatchRange
  include ::RuboCop::Cop::PercentLiteral
  extend ::RuboCop::Cop::AutoCorrector

  def on_array(node); end
  def on_percent_literal(node); end
  def on_xstr(node); end

  private

  def add_offenses_for_unnecessary_spaces(node); end
  def regex_matches(node, &blk); end
end

RuboCop::Cop::Layout::SpaceInsidePercentLiteralDelimiters::BEGIN_REGEX = T.let(T.unsafe(nil), Regexp)
RuboCop::Cop::Layout::SpaceInsidePercentLiteralDelimiters::END_REGEX = T.let(T.unsafe(nil), Regexp)
RuboCop::Cop::Layout::SpaceInsidePercentLiteralDelimiters::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::SpaceInsideRangeLiteral < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_erange(node); end
  def on_irange(node); end

  private

  def check(node); end
end

RuboCop::Cop::Layout::SpaceInsideRangeLiteral::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::SpaceInsideReferenceBrackets < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end

  private

  def autocorrect(corrector, node); end
  def closing_bracket(tokens, opening_bracket); end
  def empty_config; end
  def left_ref_bracket(node, tokens); end
  def previous_token(current_token); end
  def reference_brackets(node); end
end

RuboCop::Cop::Layout::SpaceInsideReferenceBrackets::EMPTY_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Layout::SpaceInsideReferenceBrackets::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Layout::SpaceInsideReferenceBrackets::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Layout::SpaceInsideStringInterpolation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Interpolation
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def on_interpolation(begin_node); end

  private

  def autocorrect(corrector, begin_node); end
  def delimiters(begin_node); end
end

RuboCop::Cop::Layout::SpaceInsideStringInterpolation::NO_SPACE_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Layout::SpaceInsideStringInterpolation::SPACE_MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Layout::TrailingEmptyLines < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_new_investigation; end

  private

  def ends_in_end?(processed_source); end
  def message(wanted_blank_lines, blank_lines); end
  def offense_detected(buffer, wanted_blank_lines, blank_lines, whitespace_at_end); end
end

class RuboCop::Cop::Layout::TrailingWhitespace < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::Heredoc
  extend ::RuboCop::Cop::AutoCorrector

  def on_heredoc(_node); end
  def on_new_investigation; end

  private

  def extract_heredocs(ast); end
  def find_heredoc(line_number); end
  def offense_range(lineno, line); end
  def process_line(line, lineno); end
  def process_line_in_heredoc(corrector, range, heredoc); end
  def skip_heredoc?; end
  def static?(heredoc); end
  def whitespace_is_indentation?(range, level); end
  def whitespace_only?(range); end
end

RuboCop::Cop::Layout::TrailingWhitespace::MSG = T.let(T.unsafe(nil), String)
module RuboCop::Cop::Legacy; end

class RuboCop::Cop::Legacy::CorrectionsProxy
  def initialize(corrector); end

  def <<(callable); end
  def concat(corrections); end
  def empty?; end

  protected

  def corrector; end

  private

  def suppress_clobbering; end
end

class RuboCop::Cop::LineBreakCorrector
  extend ::RuboCop::Cop::Alignment
  extend ::RuboCop::Cop::TrailingBody
  extend ::RuboCop::PathUtil
  extend ::RuboCop::Cop::Util

  class << self
    def break_line_before(range:, node:, corrector:, configured_width:, indent_steps: T.unsafe(nil)); end
    def correct_trailing_body(configured_width:, corrector:, node:, processed_source:); end
    def move_comment(eol_comment:, node:, corrector:); end
    def processed_source; end

    private

    def remove_semicolon(node, corrector); end
    def semicolon(node); end
  end
end

module RuboCop::Cop::LineLengthHelp
  private

  def allow_uri?; end
  def allowed_uri_position?(line, uri_range); end
  def directive_on_source_line?(line_index); end
  def find_excessive_uri_range(line); end
  def ignore_cop_directives?; end
  def indentation_difference(line); end
  def line_length(line); end
  def line_length_without_directive(line); end
  def match_uris(string); end
  def tab_indentation_width; end
  def uri_regexp; end
  def valid_uri?(uri_ish_string); end
end

module RuboCop::Cop::Lint; end

class RuboCop::Cop::Lint::AmbiguousAssignment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp

  def on_asgn(node); end
  def on_casgn(node); end
  def on_cvasgn(node); end
  def on_gvasgn(node); end
  def on_ivasgn(node); end
  def on_lvasgn(node); end

  private

  def rhs(node); end
end

RuboCop::Cop::Lint::AmbiguousAssignment::MISTAKES = T.let(T.unsafe(nil), Hash)
RuboCop::Cop::Lint::AmbiguousAssignment::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::AmbiguousAssignment::SIMPLE_ASSIGNMENT_TYPES = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::AmbiguousBlockAssociation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::IgnoredMethods
  extend ::RuboCop::Cop::IgnoredMethods::Config

  def on_csend(node); end
  def on_send(node); end

  private

  def allowed_method?(node); end
  def ambiguous_block_association?(send_node); end
  def message(send_node); end
end

RuboCop::Cop::Lint::AmbiguousBlockAssociation::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::AmbiguousOperator < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_new_investigation; end

  private

  def find_offense_node_by(diagnostic); end
  def message(diagnostic); end
  def offense_node(node); end
  def offense_position?(node, diagnostic); end
  def unary_operator?(node, diagnostic); end
end

RuboCop::Cop::Lint::AmbiguousOperator::AMBIGUITIES = T.let(T.unsafe(nil), Hash)
RuboCop::Cop::Lint::AmbiguousOperator::MSG_FORMAT = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::AmbiguousOperatorPrecedence < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_and(node); end
  def on_new_investigation; end
  def on_send(node); end

  private

  def autocorrect(corrector, node); end
  def greater_precedence?(node1, node2); end
  def operator?(node); end
  def operator_name(node); end
  def precedence(node); end
end

RuboCop::Cop::Lint::AmbiguousOperatorPrecedence::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::AmbiguousOperatorPrecedence::PRECEDENCE = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Lint::AmbiguousOperatorPrecedence::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::AmbiguousRange < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_erange(node); end
  def on_irange(node); end

  private

  def acceptable?(node); end
  def acceptable_call?(node); end
  def each_boundary(range); end
  def require_parentheses_for_method_chain?; end
end

RuboCop::Cop::Lint::AmbiguousRange::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::AmbiguousRegexpLiteral < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_new_investigation; end

  private

  def find_offense_node(node, regexp_receiver); end
  def find_offense_node_by(diagnostic); end
  def first_argument_is_regexp?(node); end
  def method_chain_to_regexp_receiver?(node, regexp_receiver); end
end

RuboCop::Cop::Lint::AmbiguousRegexpLiteral::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::AssignmentInCondition < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::SafeAssignment

  def on_if(node); end
  def on_until(node); end
  def on_while(node); end

  private

  def allowed_construct?(asgn_node); end
  def conditional_assignment?(asgn_node); end
  def message(_node); end
  def skip_children?(asgn_node); end
  def traverse_node(node, &block); end
end

RuboCop::Cop::Lint::AssignmentInCondition::ASGN_TYPES = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Lint::AssignmentInCondition::MSG_WITHOUT_SAFE_ASSIGNMENT_ALLOWED = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::AssignmentInCondition::MSG_WITH_SAFE_ASSIGNMENT_ALLOWED = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::BigDecimalNew < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def big_decimal_new(param0 = T.unsafe(nil)); end
  def on_send(node); end
end

RuboCop::Cop::Lint::BigDecimalNew::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::BigDecimalNew::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::BinaryOperatorWithIdenticalOperands < ::RuboCop::Cop::Base
  def on_and(node); end
  def on_or(node); end
  def on_send(node); end
end

RuboCop::Cop::Lint::BinaryOperatorWithIdenticalOperands::ALLOWED_MATH_OPERATORS = T.let(T.unsafe(nil), Set)
RuboCop::Cop::Lint::BinaryOperatorWithIdenticalOperands::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::BooleanSymbol < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def boolean_symbol?(param0 = T.unsafe(nil)); end
  def on_sym(node); end

  private

  def autocorrect(corrector, node); end
end

RuboCop::Cop::Lint::BooleanSymbol::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::CircularArgumentReference < ::RuboCop::Cop::Base
  def on_kwoptarg(node); end
  def on_optarg(node); end

  private

  def check_for_circular_argument_references(arg_name, arg_value); end
end

RuboCop::Cop::Lint::CircularArgumentReference::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::ConstantDefinitionInBlock < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::AllowedMethods

  def constant_assigned_in_block?(param0 = T.unsafe(nil)); end
  def module_defined_in_block?(param0 = T.unsafe(nil)); end
  def on_casgn(node); end
  def on_class(node); end
  def on_module(node); end

  private

  def method_name(node); end
end

RuboCop::Cop::Lint::ConstantDefinitionInBlock::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::ConstantResolution < ::RuboCop::Cop::Base
  def on_const(node); end
  def unqualified_const?(param0 = T.unsafe(nil)); end

  private

  def allowed_names; end
  def const_name?(name); end
  def ignored_names; end
end

RuboCop::Cop::Lint::ConstantResolution::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::Debugger < ::RuboCop::Cop::Base
  def kernel?(param0 = T.unsafe(nil)); end
  def on_send(node); end
  def valid_receiver?(param0 = T.unsafe(nil), param1); end

  private

  def debugger_method?(send_node); end
  def debugger_methods; end
  def message(node); end
end

RuboCop::Cop::Lint::Debugger::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::DeprecatedClassMethods < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end

  private

  def check(node); end
  def replacement(deprecated); end
end

RuboCop::Cop::Lint::DeprecatedClassMethods::CLASS_METHOD_DELIMETER = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::DeprecatedClassMethods::DEPRECATED_METHODS_OBJECT = T.let(T.unsafe(nil), Hash)

class RuboCop::Cop::Lint::DeprecatedClassMethods::DeprecatedClassMethod
  include ::RuboCop::AST::Sexp

  def initialize(method, class_constant: T.unsafe(nil), correctable: T.unsafe(nil)); end

  def class_constant; end
  def class_nodes; end
  def correctable?; end
  def method; end
  def to_s; end

  private

  def delimiter; end
end

RuboCop::Cop::Lint::DeprecatedClassMethods::INSTANCE_METHOD_DELIMETER = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::DeprecatedClassMethods::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::DeprecatedClassMethods::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::DeprecatedClassMethods::Replacement
  def initialize(method, class_constant: T.unsafe(nil), instance_method: T.unsafe(nil)); end

  def class_constant; end
  def method; end
  def to_s; end

  private

  def delimiter; end
  def instance_method?; end
end

class RuboCop::Cop::Lint::DeprecatedConstants < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_const(node); end

  private

  def constant_name(node, nested_constant_name); end
  def deprecated_constants; end
  def message(good, bad, deprecated_version); end
end

RuboCop::Cop::Lint::DeprecatedConstants::DO_NOT_USE_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::DeprecatedConstants::SUGGEST_GOOD_MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::DeprecatedOpenSSLConstant < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def algorithm_const(param0 = T.unsafe(nil)); end
  def digest_const?(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def algorithm_name(node); end
  def autocorrect(corrector, node); end
  def build_cipher_arguments(node, algorithm_name, no_arguments); end
  def correction_range(node); end
  def message(node); end
  def openssl_class(node); end
  def replacement_args(node); end
  def sanitize_arguments(arguments); end
end

RuboCop::Cop::Lint::DeprecatedOpenSSLConstant::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::DeprecatedOpenSSLConstant::NO_ARG_ALGORITHM = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::DisjunctiveAssignmentInConstructor < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_def(node); end

  private

  def check(node); end
  def check_body(body); end
  def check_body_lines(lines); end
  def check_disjunctive_assignment(node); end
end

RuboCop::Cop::Lint::DisjunctiveAssignmentInConstructor::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::DuplicateBranch < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RescueNode

  def on_branching_statement(node); end
  def on_case(node); end
  def on_case_match(node); end
  def on_if(node); end
  def on_rescue(node); end

  private

  def branches(node); end
  def consider_branch?(branch); end
  def const_branch?(branch); end
  def ignore_constant_branches?; end
  def ignore_literal_branches?; end
  def literal_branch?(branch); end
  def offense_range(duplicate_branch); end
end

RuboCop::Cop::Lint::DuplicateBranch::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::DuplicateCaseCondition < ::RuboCop::Cop::Base
  def on_case(case_node); end
end

RuboCop::Cop::Lint::DuplicateCaseCondition::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::DuplicateElsifCondition < ::RuboCop::Cop::Base
  def on_if(node); end
end

RuboCop::Cop::Lint::DuplicateElsifCondition::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::DuplicateHashKey < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Duplication

  def on_hash(node); end
end

RuboCop::Cop::Lint::DuplicateHashKey::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::DuplicateMethods < ::RuboCop::Cop::Base
  def initialize(config = T.unsafe(nil), options = T.unsafe(nil)); end

  def alias_method?(param0 = T.unsafe(nil)); end
  def method_alias?(param0 = T.unsafe(nil)); end
  def on_alias(node); end
  def on_def(node); end
  def on_defs(node); end
  def on_send(node); end
  def sym_name(param0 = T.unsafe(nil)); end

  private

  def check_const_receiver(node, name, const_name); end
  def check_self_receiver(node, name); end
  def found_attr(node, args, readable: T.unsafe(nil), writable: T.unsafe(nil)); end
  def found_instance_method(node, name); end
  def found_method(node, method_name); end
  def lookup_constant(node, const_name); end
  def message_for_dup(node, method_name); end
  def on_attr(node, attr_name, args); end
  def possible_dsl?(node); end
  def qualified_name(enclosing, namespace, mod_name); end
  def source_location(node); end
end

RuboCop::Cop::Lint::DuplicateMethods::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::DuplicateMethods::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::DuplicateRegexpCharacterClassElement < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def each_repeated_character_class_element_loc(node); end
  def on_regexp(node); end

  private

  def interpolation_locs(node); end
  def within_interpolation?(node, child); end
end

RuboCop::Cop::Lint::DuplicateRegexpCharacterClassElement::MSG_REPEATED_ELEMENT = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::DuplicateRequire < ::RuboCop::Cop::Base
  def on_new_investigation; end
  def on_send(node); end
  def require_call?(param0 = T.unsafe(nil)); end
end

RuboCop::Cop::Lint::DuplicateRequire::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::DuplicateRequire::REQUIRE_METHODS = T.let(T.unsafe(nil), Set)
RuboCop::Cop::Lint::DuplicateRequire::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Set)

class RuboCop::Cop::Lint::DuplicateRescueException < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RescueNode

  def on_rescue(node); end
end

RuboCop::Cop::Lint::DuplicateRescueException::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::EachWithObjectArgument < ::RuboCop::Cop::Base
  def each_with_object?(param0 = T.unsafe(nil)); end
  def on_csend(node); end
  def on_send(node); end
end

RuboCop::Cop::Lint::EachWithObjectArgument::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::EachWithObjectArgument::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::ElseLayout < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_if(node); end

  private

  def autocorrect(corrector, node, first_else); end
  def check(node); end
  def check_else(node); end
  def indentation_width; end
end

RuboCop::Cop::Lint::ElseLayout::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::EmptyBlock < ::RuboCop::Cop::Base
  def on_block(node); end

  private

  def allow_comment?(node); end
  def allow_empty_lambdas?; end
  def comment_disables_cop?(comment); end
  def lambda_or_proc?(node); end
end

RuboCop::Cop::Lint::EmptyBlock::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::EmptyClass < ::RuboCop::Cop::Base
  def on_class(node); end
  def on_sclass(node); end

  private

  def body_or_allowed_comment_lines?(node); end
end

RuboCop::Cop::Lint::EmptyClass::CLASS_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::EmptyClass::METACLASS_MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::EmptyConditionalBody < ::RuboCop::Cop::Base
  def on_if(node); end
end

RuboCop::Cop::Lint::EmptyConditionalBody::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::EmptyEnsure < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_ensure(node); end
end

RuboCop::Cop::Lint::EmptyEnsure::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::EmptyExpression < ::RuboCop::Cop::Base
  def on_begin(node); end

  private

  def empty_expression?(begin_node); end
end

RuboCop::Cop::Lint::EmptyExpression::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::EmptyFile < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp

  def on_new_investigation; end

  private

  def contains_only_comments?; end
  def empty_file?; end
  def offending?; end
end

RuboCop::Cop::Lint::EmptyFile::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::EmptyInPattern < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::TargetRubyVersion

  def on_case_match(node); end
end

RuboCop::Cop::Lint::EmptyInPattern::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::EmptyInterpolation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Interpolation
  extend ::RuboCop::Cop::AutoCorrector

  def on_interpolation(begin_node); end
end

RuboCop::Cop::Lint::EmptyInterpolation::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::EmptyWhen < ::RuboCop::Cop::Base
  def on_case(node); end
end

RuboCop::Cop::Lint::EmptyWhen::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::EnsureReturn < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_ensure(node); end
end

RuboCop::Cop::Lint::EnsureReturn::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::ErbNewArguments < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::TargetRubyVersion
  extend ::RuboCop::Cop::AutoCorrector

  def erb_new_with_non_keyword_arguments(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def arguments_range(node); end
  def autocorrect(corrector, node); end
  def build_kwargs(node); end
  def correct_arguments?(arguments); end
  def override_by_legacy_args(kwargs, node); end
end

RuboCop::Cop::Lint::ErbNewArguments::MESSAGES = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Lint::ErbNewArguments::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::FlipFlop < ::RuboCop::Cop::Base
  def on_eflipflop(node); end
  def on_iflipflop(node); end
end

RuboCop::Cop::Lint::FlipFlop::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::FloatComparison < ::RuboCop::Cop::Base
  def on_send(node); end

  private

  def check_numeric_returning_method(node); end
  def check_send(node); end
  def float?(node); end
end

RuboCop::Cop::Lint::FloatComparison::EQUALITY_METHODS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Lint::FloatComparison::FLOAT_INSTANCE_METHODS = T.let(T.unsafe(nil), Set)
RuboCop::Cop::Lint::FloatComparison::FLOAT_RETURNING_METHODS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Lint::FloatComparison::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::FloatComparison::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::FloatOutOfRange < ::RuboCop::Cop::Base
  def on_float(node); end
end

RuboCop::Cop::Lint::FloatOutOfRange::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::FormatParameterMismatch < ::RuboCop::Cop::Base
  def called_on_string?(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def count_format_matches(node); end
  def count_matches(node); end
  def count_percent_matches(node); end
  def countable_format?(node); end
  def countable_percent?(node); end
  def expected_fields_count(node); end
  def format?(node); end
  def format_method?(name, node); end
  def format_string?(node); end
  def heredoc?(node); end
  def invalid_format_string?(node); end
  def matched_arguments_count?(expected, passed); end
  def message(node); end
  def method_with_format_args?(node); end
  def offending_node?(node); end
  def percent?(node); end
  def splat_args?(node); end
  def sprintf?(node); end
end

RuboCop::Cop::Lint::FormatParameterMismatch::KERNEL = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::FormatParameterMismatch::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::FormatParameterMismatch::MSG_INVALID = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::FormatParameterMismatch::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Lint::FormatParameterMismatch::SHOVEL = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::FormatParameterMismatch::STRING_TYPES = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::HashCompareByIdentity < ::RuboCop::Cop::Base
  def id_as_hash_key?(param0 = T.unsafe(nil)); end
  def on_send(node); end
end

RuboCop::Cop::Lint::HashCompareByIdentity::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::HashCompareByIdentity::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::HeredocMethodCallPosition < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_csend(node); end
  def on_send(node); end

  private

  def all_on_same_line?(nodes); end
  def autocorrect(corrector, node, heredoc); end
  def call_after_heredoc_range(heredoc); end
  def call_end_pos(node); end
  def call_line_range(node); end
  def call_range_to_safely_reposition(node, heredoc); end
  def calls_on_multiple_lines?(node, _heredoc); end
  def correctly_positioned?(node, heredoc); end
  def heredoc_begin_line_range(heredoc); end
  def heredoc_end_pos(heredoc); end
  def heredoc_node?(node); end
  def heredoc_node_descendent_receiver(node); end
  def send_node?(node); end
  def trailing_comma?(call_source, call_line_source); end
end

RuboCop::Cop::Lint::HeredocMethodCallPosition::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::IdentityComparison < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end

  private

  def compare_between_object_id_by_double_equal?(node); end
  def object_id_method?(node); end
end

RuboCop::Cop::Lint::IdentityComparison::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::IdentityComparison::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::ImplicitStringConcatenation < ::RuboCop::Cop::Base
  def on_dstr(node); end

  private

  def display_str(node); end
  def each_bad_cons(node); end
  def ending_delimiter(str); end
  def str_content(node); end
  def string_literal?(node); end
  def string_literals?(node1, node2); end
end

RuboCop::Cop::Lint::ImplicitStringConcatenation::FOR_ARRAY = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::ImplicitStringConcatenation::FOR_METHOD = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::ImplicitStringConcatenation::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::IncompatibleIoSelectWithFiberScheduler < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def io_select(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def preferred_method(read, write, timeout); end
  def scheduler_compatible?(io1, io2); end
end

RuboCop::Cop::Lint::IncompatibleIoSelectWithFiberScheduler::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::IncompatibleIoSelectWithFiberScheduler::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::IneffectiveAccessModifier < ::RuboCop::Cop::Base
  def on_class(node); end
  def on_module(node); end
  def private_class_methods(param0); end

  private

  def access_modifier?(node); end
  def check_node(node); end
  def correct_visibility?(node, modifier, ignored_methods); end
  def format_message(modifier); end
  def ineffective_modifier(node, ignored_methods = T.unsafe(nil), modifier = T.unsafe(nil), &block); end
  def private_class_method_names(node); end
end

RuboCop::Cop::Lint::IneffectiveAccessModifier::ALTERNATIVE_PRIVATE = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::IneffectiveAccessModifier::ALTERNATIVE_PROTECTED = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::IneffectiveAccessModifier::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::InheritException < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def class_new_call?(param0 = T.unsafe(nil)); end
  def on_class(node); end
  def on_send(node); end

  private

  def illegal_class_name?(class_node); end
  def message(node); end
  def preferred_base_class; end
end

RuboCop::Cop::Lint::InheritException::ILLEGAL_CLASSES = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Lint::InheritException::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::InheritException::PREFERRED_BASE_CLASS = T.let(T.unsafe(nil), Hash)
RuboCop::Cop::Lint::InheritException::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::InterpolationCheck < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_str(node); end

  private

  def autocorrect(corrector, node); end
  def heredoc?(node); end
end

RuboCop::Cop::Lint::InterpolationCheck::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::LambdaWithoutLiteralBlock < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end
end

RuboCop::Cop::Lint::LambdaWithoutLiteralBlock::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::LambdaWithoutLiteralBlock::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::LiteralAsCondition < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp

  def message(node); end
  def on_case(case_node); end
  def on_case_match(case_match_node); end
  def on_if(node); end
  def on_send(node); end
  def on_until(node); end
  def on_until_post(node); end
  def on_while(node); end
  def on_while_post(node); end

  private

  def basic_literal?(node); end
  def check_case(case_node); end
  def check_for_literal(node); end
  def check_node(node); end
  def condition(node); end
  def handle_node(node); end
  def primitive_array?(node); end
  def when_conditions_range(when_node); end
end

RuboCop::Cop::Lint::LiteralAsCondition::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::LiteralInInterpolation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Interpolation
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::PercentLiteral
  extend ::RuboCop::Cop::AutoCorrector

  def on_interpolation(begin_node); end

  private

  def autocorrected_value(node); end
  def autocorrected_value_for_array(node); end
  def autocorrected_value_for_string(node); end
  def autocorrected_value_for_symbol(node); end
  def ends_heredoc_line?(node); end
  def in_array_percent_literal?(node); end
  def offending?(node); end
  def prints_as_self?(node); end
  def space_literal?(node); end
  def special_keyword?(node); end
end

RuboCop::Cop::Lint::LiteralInInterpolation::COMPOSITE = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Lint::LiteralInInterpolation::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::Loop < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_until_post(node); end
  def on_while_post(node); end

  private

  def build_break_line(node); end
  def keyword_and_condition_range(node); end
  def register_offense(node); end
end

RuboCop::Cop::Lint::Loop::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::MissingCopEnableDirective < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp

  def on_new_investigation; end

  private

  def department_enabled?(cop, comment); end
  def each_missing_enable; end
  def max_range; end
  def message(cop, comment, type = T.unsafe(nil)); end
end

RuboCop::Cop::Lint::MissingCopEnableDirective::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::MissingCopEnableDirective::MSG_BOUND = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::MissingSuper < ::RuboCop::Cop::Base
  def on_def(node); end
  def on_defs(node); end

  private

  def callback_method_def?(node); end
  def contains_super?(node); end
  def inside_class_with_stateful_parent?(node); end
  def offender?(node); end
  def stateless_class?(node); end
end

RuboCop::Cop::Lint::MissingSuper::CALLBACKS = T.let(T.unsafe(nil), Set)
RuboCop::Cop::Lint::MissingSuper::CALLBACK_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::MissingSuper::CLASS_LIFECYCLE_CALLBACKS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Lint::MissingSuper::CONSTRUCTOR_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::MissingSuper::METHOD_LIFECYCLE_CALLBACKS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Lint::MissingSuper::STATELESS_CLASSES = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::MixedRegexpCaptureTypes < ::RuboCop::Cop::Base
  def on_regexp(node); end
end

RuboCop::Cop::Lint::MixedRegexpCaptureTypes::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::MultipleComparison < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def multiple_compare?(param0 = T.unsafe(nil)); end
  def on_send(node); end
end

RuboCop::Cop::Lint::MultipleComparison::COMPARISON_METHODS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Lint::MultipleComparison::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::MultipleComparison::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Lint::MultipleComparison::SET_OPERATION_OPERATORS = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::NestedMethodDefinition < ::RuboCop::Cop::Base
  def class_or_module_or_struct_new_call?(param0 = T.unsafe(nil)); end
  def eval_call?(param0 = T.unsafe(nil)); end
  def exec_call?(param0 = T.unsafe(nil)); end
  def on_def(node); end
  def on_defs(node); end

  private

  def scoping_method_call?(child); end
end

RuboCop::Cop::Lint::NestedMethodDefinition::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::NestedPercentLiteral < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::PercentLiteral

  def on_array(node); end
  def on_percent_literal(node); end

  private

  def contains_percent_literals?(node); end
end

RuboCop::Cop::Lint::NestedPercentLiteral::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::NestedPercentLiteral::PERCENT_LITERAL_TYPES = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Lint::NestedPercentLiteral::REGEXES = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::NextWithoutAccumulator < ::RuboCop::Cop::Base
  def on_block(node); end
  def on_body_of_reduce(param0 = T.unsafe(nil)); end

  private

  def parent_block_node(node); end
end

RuboCop::Cop::Lint::NextWithoutAccumulator::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::NoReturnInBeginEndBlocks < ::RuboCop::Cop::Base
  def on_lvasgn(node); end
  def on_op_asgn(node); end
  def on_or_asgn(node); end
end

RuboCop::Cop::Lint::NoReturnInBeginEndBlocks::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::NonDeterministicRequireOrder < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def loop_variable(param0 = T.unsafe(nil)); end
  def method_require?(param0 = T.unsafe(nil)); end
  def on_block(node); end
  def on_block_pass(node); end
  def unsorted_dir_block?(param0 = T.unsafe(nil)); end
  def unsorted_dir_each?(param0 = T.unsafe(nil)); end
  def unsorted_dir_each_pass?(param0 = T.unsafe(nil)); end
  def unsorted_dir_glob_pass?(param0 = T.unsafe(nil)); end
  def var_is_required?(param0, param1); end

  private

  def correct_block(corrector, node); end
  def correct_block_pass(corrector, node); end
  def last_arg_range(node); end
  def unsorted_dir_loop?(node); end
  def unsorted_dir_pass?(node); end
end

RuboCop::Cop::Lint::NonDeterministicRequireOrder::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::NonLocalExitFromIterator < ::RuboCop::Cop::Base
  def chained_send?(param0 = T.unsafe(nil)); end
  def define_method?(param0 = T.unsafe(nil)); end
  def on_return(return_node); end

  private

  def return_value?(return_node); end
  def scoped_node?(node); end
end

RuboCop::Cop::Lint::NonLocalExitFromIterator::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::NumberConversion < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::IgnoredMethods
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::IgnoredMethods::Config

  def on_send(node); end
  def to_method(param0 = T.unsafe(nil)); end
  def to_method_symbol(param0 = T.unsafe(nil)); end

  private

  def conversion_method?(method_name); end
  def correct_method(node, receiver); end
  def correct_sym_method(to_method); end
  def handle_as_symbol(node); end
  def handle_conversion_method(node); end
  def ignore_receiver?(receiver); end
  def ignored_class?(name); end
  def ignored_classes; end
  def remove_parentheses(corrector, node); end
  def top_receiver(node); end
end

RuboCop::Cop::Lint::NumberConversion::CONVERSION_METHODS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Lint::NumberConversion::CONVERSION_METHOD_CLASS_MAPPING = T.let(T.unsafe(nil), Hash)
RuboCop::Cop::Lint::NumberConversion::METHODS = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::NumberConversion::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::NumberedParameterAssignment < ::RuboCop::Cop::Base
  def on_lvasgn(node); end
end

RuboCop::Cop::Lint::NumberedParameterAssignment::LVAR_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::NumberedParameterAssignment::NUMBERED_PARAMETER_RANGE = T.let(T.unsafe(nil), Range)
RuboCop::Cop::Lint::NumberedParameterAssignment::NUM_PARAM_MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::OrAssignmentToConstant < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_or_asgn(node); end
end

RuboCop::Cop::Lint::OrAssignmentToConstant::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::OrderedMagicComments < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::FrozenStringLiteral
  extend ::RuboCop::Cop::AutoCorrector

  def on_new_investigation; end

  private

  def autocorrect(corrector, encoding_line, frozen_string_literal_line); end
  def magic_comment_lines; end
  def magic_comments; end
end

RuboCop::Cop::Lint::OrderedMagicComments::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::OutOfRangeRegexpRef < ::RuboCop::Cop::Base
  def after_send(node); end
  def on_match_with_lvasgn(node); end
  def on_new_investigation; end
  def on_nth_ref(node); end
  def on_when(node); end

  private

  def check_regexp(node); end
  def nth_ref_receiver?(send_node); end
  def regexp_first_argument?(send_node); end
  def regexp_receiver?(send_node); end
end

RuboCop::Cop::Lint::OutOfRangeRegexpRef::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::OutOfRangeRegexpRef::REGEXP_ARGUMENT_METHODS = T.let(T.unsafe(nil), Set)
RuboCop::Cop::Lint::OutOfRangeRegexpRef::REGEXP_CAPTURE_METHODS = T.let(T.unsafe(nil), Set)
RuboCop::Cop::Lint::OutOfRangeRegexpRef::REGEXP_RECEIVER_METHODS = T.let(T.unsafe(nil), Set)
RuboCop::Cop::Lint::OutOfRangeRegexpRef::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Set)

class RuboCop::Cop::Lint::ParenthesesAsGroupedExpression < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_csend(node); end
  def on_send(node); end

  private

  def chained_calls?(node); end
  def first_argument_starts_with_left_parenthesis?(node); end
  def space_range(expr, space_length); end
  def spaces_before_left_parenthesis(node); end
  def ternary_expression?(node); end
  def valid_context?(node); end
  def valid_first_argument?(first_arg); end
end

RuboCop::Cop::Lint::ParenthesesAsGroupedExpression::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::PercentStringArray < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::PercentLiteral
  extend ::RuboCop::Cop::AutoCorrector

  def on_array(node); end
  def on_percent_literal(node); end

  private

  def contains_quotes_or_commas?(node); end
end

RuboCop::Cop::Lint::PercentStringArray::LEADING_QUOTE = T.let(T.unsafe(nil), Regexp)
RuboCop::Cop::Lint::PercentStringArray::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::PercentStringArray::QUOTES_AND_COMMAS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Lint::PercentStringArray::TRAILING_QUOTE = T.let(T.unsafe(nil), Regexp)

class RuboCop::Cop::Lint::PercentSymbolArray < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::PercentLiteral
  extend ::RuboCop::Cop::AutoCorrector

  def on_array(node); end
  def on_percent_literal(node); end

  private

  def autocorrect(corrector, node); end
  def contains_colons_or_commas?(node); end
  def non_alphanumeric_literal?(literal); end
end

RuboCop::Cop::Lint::PercentSymbolArray::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::RaiseException < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def exception?(param0 = T.unsafe(nil)); end
  def exception_new_with_message?(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def allow_implicit_namespaces; end
  def check(node); end
  def implicit_namespace?(node); end
end

RuboCop::Cop::Lint::RaiseException::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::RaiseException::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::RandOne < ::RuboCop::Cop::Base
  def on_send(node); end
  def rand_one?(param0 = T.unsafe(nil)); end

  private

  def message(node); end
end

RuboCop::Cop::Lint::RandOne::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::RandOne::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::RedundantCopDisableDirective < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def initialize(config = T.unsafe(nil), options = T.unsafe(nil), offenses = T.unsafe(nil)); end

  def offenses_to_check; end
  def offenses_to_check=(_arg0); end
  def on_new_investigation; end

  private

  def add_department_marker(department); end
  def add_offense_for_entire_comment(comment, cops); end
  def add_offense_for_some_cops(comment, cops); end
  def add_offenses(redundant_cops); end
  def all_cop_names; end
  def all_disabled?(comment); end
  def comment_range_with_surrounding_space(directive_comment_range, line_comment_range); end
  def cop_disabled_line_ranges; end
  def cop_range(comment, cop); end
  def department_disabled?(cop, comment); end
  def department_marker?(department); end
  def describe(cop); end
  def directive_count(comment); end
  def directive_range_in_list(range, ranges); end
  def disabled_ranges; end
  def each_already_disabled(cop, line_ranges); end
  def each_line_range(cop, line_ranges); end
  def each_redundant_disable(&block); end
  def ends_its_line?(range); end
  def find_redundant_all(range, next_range); end
  def find_redundant_cop(cop, range); end
  def find_redundant_department(cop, range); end
  def followed_ranges?(range, next_range); end
  def ignore_offense?(line_range); end
  def matching_range(haystack, needle); end
  def message(cop_names); end
  def previous_line_blank?(range); end
  def range_with_offense?(range, offenses = T.unsafe(nil)); end
  def remove_department_marker(department); end
  def trailing_range?(ranges, range); end
end

RuboCop::Cop::Lint::RedundantCopDisableDirective::COP_NAME = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::RedundantCopDisableDirective::DEPARTMENT_MARKER = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::RedundantCopEnableDirective < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::SurroundingSpace
  extend ::RuboCop::Cop::AutoCorrector

  def on_new_investigation; end

  private

  def all_or_name(name); end
  def comment_start(comment); end
  def cop_name_indention(comment, name); end
  def department?(directive, name); end
  def range_of_offense(comment, name); end
  def range_to_remove(begin_pos, end_pos, comment); end
  def range_with_comma(comment, name); end
  def range_with_comma_after(comment, start, begin_pos, end_pos); end
  def range_with_comma_before(start, begin_pos, end_pos); end
  def register_offense(comment, cop_names); end
end

RuboCop::Cop::Lint::RedundantCopEnableDirective::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::RedundantDirGlobSort < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion

  def on_send(node); end
end

RuboCop::Cop::Lint::RedundantDirGlobSort::GLOB_METHODS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Lint::RedundantDirGlobSort::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::RedundantDirGlobSort::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::RedundantRequireStatement < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end
  def unnecessary_require_statement?(param0 = T.unsafe(nil)); end
end

RuboCop::Cop::Lint::RedundantRequireStatement::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::RedundantRequireStatement::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::RedundantSafeNavigation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_csend(node); end
  def respond_to_nil_specific_method?(param0 = T.unsafe(nil)); end

  private

  def check?(node); end
  def condition?(parent, node); end
end

RuboCop::Cop::Lint::RedundantSafeNavigation::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::RedundantSafeNavigation::NIL_SPECIFIC_METHODS = T.let(T.unsafe(nil), Set)

class RuboCop::Cop::Lint::RedundantSplatExpansion < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def array_new?(param0 = T.unsafe(nil)); end
  def literal_expansion(param0 = T.unsafe(nil)); end
  def on_splat(node); end

  private

  def allow_percent_literal_array_argument?; end
  def array_new_inside_array_literal?(array_new_node); end
  def array_splat?(node); end
  def autocorrect(corrector, node); end
  def method_argument?(node); end
  def part_of_an_array?(node); end
  def redundant_brackets?(node); end
  def redundant_splat_expansion(node); end
  def remove_brackets(array); end
  def replacement_range_and_content(node); end
  def use_percent_literal_array_argument?(node); end
end

RuboCop::Cop::Lint::RedundantSplatExpansion::ARRAY_PARAM_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::RedundantSplatExpansion::ASSIGNMENT_TYPES = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Lint::RedundantSplatExpansion::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::RedundantSplatExpansion::PERCENT_CAPITAL_I = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::RedundantSplatExpansion::PERCENT_CAPITAL_W = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::RedundantSplatExpansion::PERCENT_I = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::RedundantSplatExpansion::PERCENT_W = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::RedundantStringCoercion < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Interpolation
  extend ::RuboCop::Cop::AutoCorrector

  def on_interpolation(begin_node); end
  def to_s_without_args?(param0 = T.unsafe(nil)); end
end

RuboCop::Cop::Lint::RedundantStringCoercion::MSG_DEFAULT = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::RedundantStringCoercion::MSG_SELF = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::RedundantWithIndex < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_block(node); end
  def redundant_with_index?(param0 = T.unsafe(nil)); end

  private

  def message(node); end
  def with_index_range(send); end
end

RuboCop::Cop::Lint::RedundantWithIndex::MSG_EACH_WITH_INDEX = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::RedundantWithIndex::MSG_WITH_INDEX = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::RedundantWithObject < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_block(node); end
  def redundant_with_object?(param0 = T.unsafe(nil)); end

  private

  def message(node); end
  def with_object_range(send); end
end

RuboCop::Cop::Lint::RedundantWithObject::MSG_EACH_WITH_OBJECT = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::RedundantWithObject::MSG_WITH_OBJECT = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::RegexpAsCondition < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_match_current_line(node); end
end

RuboCop::Cop::Lint::RegexpAsCondition::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::RequireParentheses < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp

  def on_csend(node); end
  def on_send(node); end

  private

  def check_predicate(predicate, node); end
  def check_ternary(ternary, node); end
end

RuboCop::Cop::Lint::RequireParentheses::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::RequireRelativeSelfPath < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end

  private

  def remove_ext(file_path); end
  def same_file?(file_path, required_feature); end
end

RuboCop::Cop::Lint::RequireRelativeSelfPath::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::RequireRelativeSelfPath::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::RescueException < ::RuboCop::Cop::Base
  def on_resbody(node); end
  def targets_exception?(rescue_arg_node); end
end

RuboCop::Cop::Lint::RescueException::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::RescueType < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def autocorrect(corrector, node); end
  def on_resbody(node); end

  private

  def correction(*exceptions); end
  def invalid_exceptions(exceptions); end
  def valid_exceptions(exceptions); end
end

RuboCop::Cop::Lint::RescueType::INVALID_TYPES = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Lint::RescueType::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::ReturnInVoidContext < ::RuboCop::Cop::Base
  def on_return(return_node); end

  private

  def method_name(context_node); end
  def non_void_context(return_node); end
  def setter_method?(method_name); end
  def void_context_method?(method_name); end
end

RuboCop::Cop::Lint::ReturnInVoidContext::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::SafeNavigationChain < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::NilMethods

  def bad_method?(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def method_chain(node); end
end

RuboCop::Cop::Lint::SafeNavigationChain::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::SafeNavigationConsistency < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::NilMethods
  extend ::RuboCop::Cop::AutoCorrector

  def check(node); end
  def on_csend(node); end

  private

  def autocorrect(corrector, node); end
  def location(node, unsafe_method_call); end
  def top_conditional_ancestor(node); end
  def unsafe_method_calls(method_calls, safe_nav_receiver); end
end

RuboCop::Cop::Lint::SafeNavigationConsistency::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::SafeNavigationWithEmpty < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_if(node); end
  def safe_navigation_empty_in_conditional?(param0 = T.unsafe(nil)); end
end

RuboCop::Cop::Lint::SafeNavigationWithEmpty::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::ScriptPermission < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_new_investigation; end

  private

  def autocorrect(comment); end
  def executable?(processed_source); end
  def format_message_from(processed_source); end
end

RuboCop::Cop::Lint::ScriptPermission::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::ScriptPermission::SHEBANG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::SelfAssignment < ::RuboCop::Cop::Base
  def on_and_asgn(node); end
  def on_casgn(node); end
  def on_cvasgn(node); end
  def on_gvasgn(node); end
  def on_ivasgn(node); end
  def on_lvasgn(node); end
  def on_masgn(node); end
  def on_or_asgn(node); end

  private

  def multiple_self_assignment?(node); end
  def rhs_matches_lhs?(rhs, lhs); end
end

RuboCop::Cop::Lint::SelfAssignment::ASSIGNMENT_TYPE_TO_RHS_TYPE = T.let(T.unsafe(nil), Hash)
RuboCop::Cop::Lint::SelfAssignment::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::SendWithMixinArgument < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end
  def send_with_mixin_argument?(param0 = T.unsafe(nil)); end

  private

  def bad_location(node); end
  def message(method, module_name, bad_method); end
  def mixin_method?(node); end
end

RuboCop::Cop::Lint::SendWithMixinArgument::MIXIN_METHODS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Lint::SendWithMixinArgument::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::SendWithMixinArgument::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Lint::SendWithMixinArgument::SEND_METHODS = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::ShadowedArgument < ::RuboCop::Cop::Base
  def after_leaving_scope(scope, _variable_table); end
  def uses_var?(param0, param1); end

  private

  def argument_references(argument); end
  def assignment_without_argument_usage(argument); end
  def check_argument(argument); end
  def ignore_implicit_references?; end
  def node_within_block_or_conditional?(node, stop_search_node); end
  def reference_pos(node); end
  def shadowing_assignment(argument); end

  class << self
    def joining_forces; end
  end
end

RuboCop::Cop::Lint::ShadowedArgument::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::ShadowedException < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RescueNode
  include ::RuboCop::Cop::RangeHelp

  def on_rescue(node); end

  private

  def compare_exceptions(exception, other_exception); end
  def contains_multiple_levels_of_exceptions?(group); end
  def evaluate_exceptions(group); end
  def find_shadowing_rescue(rescues); end
  def offense_range(rescues); end
  def rescued_exceptions(rescue_group); end
  def rescued_groups_for(rescues); end
  def sorted?(rescued_groups); end
  def system_call_err?(error); end
end

RuboCop::Cop::Lint::ShadowedException::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::ShadowingOuterLocalVariable < ::RuboCop::Cop::Base
  def before_declaring_variable(variable, variable_table); end
  def ractor_block?(param0 = T.unsafe(nil)); end

  class << self
    def joining_forces; end
  end
end

RuboCop::Cop::Lint::ShadowingOuterLocalVariable::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::StructNewOverride < ::RuboCop::Cop::Base
  def on_send(node); end
  def struct_new(param0 = T.unsafe(nil)); end
end

RuboCop::Cop::Lint::StructNewOverride::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::StructNewOverride::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Lint::StructNewOverride::STRUCT_MEMBER_NAME_TYPES = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Lint::StructNewOverride::STRUCT_METHOD_NAMES = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::SuppressedException < ::RuboCop::Cop::Base
  def on_resbody(node); end

  private

  def comment_between_rescue_and_end?(node); end
  def nil_body?(node); end
end

RuboCop::Cop::Lint::SuppressedException::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::SymbolConversion < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::SymbolHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_hash(node); end
  def on_send(node); end
  def on_sym(node); end

  private

  def correct_hash_key(node); end
  def correct_inconsistent_hash_keys(keys); end
  def in_alias?(node); end
  def in_percent_literal_array?(node); end
  def properly_quoted?(source, value); end
  def register_offense(node, correction:, message: T.unsafe(nil)); end
  def requires_quotes?(sym_node); end
end

RuboCop::Cop::Lint::SymbolConversion::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::SymbolConversion::MSG_CONSISTENCY = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::SymbolConversion::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::Syntax < ::RuboCop::Cop::Base
  def on_other_file; end

  private

  def add_offense_from_diagnostic(diagnostic, ruby_version); end
  def add_offense_from_error(error); end
  def beautify_message(message); end
end

class RuboCop::Cop::Lint::ToEnumArguments < ::RuboCop::Cop::Base
  def enum_conversion_call?(param0 = T.unsafe(nil)); end
  def method_name?(param0 = T.unsafe(nil), param1); end
  def on_send(node); end
  def passing_keyword_arg?(param0 = T.unsafe(nil), param1); end

  private

  def argument_match?(send_arg, def_arg); end
  def arguments_match?(arguments, def_node); end
end

RuboCop::Cop::Lint::ToEnumArguments::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::ToEnumArguments::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::ToJSON < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_def(node); end
end

RuboCop::Cop::Lint::ToJSON::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::TopLevelReturnWithArgument < ::RuboCop::Cop::Base
  def on_return(return_node); end

  private

  def ancestors_valid?(return_node); end
end

RuboCop::Cop::Lint::TopLevelReturnWithArgument::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::TrailingCommaInAttributeDeclaration < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end

  private

  def trailing_comma_range(node); end
end

RuboCop::Cop::Lint::TrailingCommaInAttributeDeclaration::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::TripleQuotes < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_dstr(node); end

  private

  def empty_str_nodes(node); end
end

RuboCop::Cop::Lint::TripleQuotes::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::UnderscorePrefixedVariableName < ::RuboCop::Cop::Base
  def after_leaving_scope(scope, _variable_table); end
  def check_variable(variable); end

  private

  def allowed_keyword_block_argument?(variable); end

  class << self
    def joining_forces; end
  end
end

RuboCop::Cop::Lint::UnderscorePrefixedVariableName::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::UnexpectedBlockArity < ::RuboCop::Cop::Base
  def on_block(node); end
  def on_numblock(node); end

  private

  def acceptable?(node); end
  def arg_count(node); end
  def expected_arity(method); end
  def included_method?(name); end
  def methods; end
end

RuboCop::Cop::Lint::UnexpectedBlockArity::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::UnifiedInteger < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def fixnum_or_bignum_const(param0 = T.unsafe(nil)); end
  def on_const(node); end
end

RuboCop::Cop::Lint::UnifiedInteger::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::UnmodifiedReduceAccumulator < ::RuboCop::Cop::Base
  def accumulator_index?(param0 = T.unsafe(nil), param1); end
  def element_modified?(param0, param1); end
  def expression_values(param0); end
  def lvar_used?(param0 = T.unsafe(nil), param1); end
  def on_block(node); end
  def on_numblock(node); end
  def reduce_with_block?(param0 = T.unsafe(nil)); end

  private

  def acceptable_return?(return_val, element_name); end
  def allowed_type?(parent_node); end
  def block_arg_name(node, index); end
  def check_return_values(block_node); end
  def potential_offense?(return_values, block_body, element_name, accumulator_name); end
  def return_values(block_body_node); end
  def returned_accumulator_index(return_values, accumulator_name, element_name); end
  def returns_accumulator_anywhere?(return_values, accumulator_name); end
end

RuboCop::Cop::Lint::UnmodifiedReduceAccumulator::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::UnmodifiedReduceAccumulator::MSG_INDEX = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::UnreachableCode < ::RuboCop::Cop::Base
  def flow_command?(param0 = T.unsafe(nil)); end
  def on_begin(node); end
  def on_kwbegin(node); end

  private

  def check_case(node); end
  def check_if(node); end
  def flow_expression?(node); end
end

RuboCop::Cop::Lint::UnreachableCode::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::UnreachableLoop < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::IgnoredPattern

  def break_command?(param0 = T.unsafe(nil)); end
  def on_block(node); end
  def on_for(node); end
  def on_until(node); end
  def on_until_post(node); end
  def on_while(node); end
  def on_while_post(node); end

  private

  def break_statement?(node); end
  def check(node); end
  def check_case(node); end
  def check_if(node); end
  def conditional_continue_keyword?(break_statement); end
  def loop_method?(node); end
  def preceded_by_continue_statement?(break_statement); end
  def statements(node); end
end

RuboCop::Cop::Lint::UnreachableLoop::CONTINUE_KEYWORDS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Lint::UnreachableLoop::MSG = T.let(T.unsafe(nil), String)

module RuboCop::Cop::Lint::UnusedArgument
  extend ::RuboCop::AST::NodePattern::Macros

  def after_leaving_scope(scope, _variable_table); end

  private

  def check_argument(variable); end
end

class RuboCop::Cop::Lint::UnusedBlockArgument < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Lint::UnusedArgument
  extend ::RuboCop::Cop::AutoCorrector

  private

  def allow_unused_keyword_arguments?; end
  def allowed_block?(variable); end
  def allowed_keyword_argument?(variable); end
  def augment_message(message, variable); end
  def autocorrect(corrector, node); end
  def check_argument(variable); end
  def define_method_call?(variable); end
  def empty_block?(variable); end
  def ignore_empty_blocks?; end
  def message(variable); end
  def message_for_lambda(variable, all_arguments); end
  def message_for_normal_block(variable, all_arguments); end
  def message_for_underscore_prefix(variable); end
  def used_block_local?(variable); end
  def variable_type(variable); end

  class << self
    def joining_forces; end
  end
end

class RuboCop::Cop::Lint::UnusedMethodArgument < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Lint::UnusedArgument
  extend ::RuboCop::Cop::AutoCorrector

  def not_implemented?(param0 = T.unsafe(nil)); end

  private

  def autocorrect(corrector, node); end
  def check_argument(variable); end
  def ignored_method?(body); end
  def message(variable); end

  class << self
    def joining_forces; end
  end
end

class RuboCop::Cop::Lint::UriEscapeUnescape < ::RuboCop::Cop::Base
  def on_send(node); end
  def uri_escape_unescape?(param0 = T.unsafe(nil)); end
end

RuboCop::Cop::Lint::UriEscapeUnescape::ALTERNATE_METHODS_OF_URI_ESCAPE = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Lint::UriEscapeUnescape::ALTERNATE_METHODS_OF_URI_UNESCAPE = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Lint::UriEscapeUnescape::METHOD_NAMES = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Lint::UriEscapeUnescape::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::UriEscapeUnescape::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::UriRegexp < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end
end

RuboCop::Cop::Lint::UriRegexp::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::UriRegexp::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Lint::UriRegexp::URI_CONSTANTS = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::UselessAccessModifier < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def class_or_instance_eval?(param0 = T.unsafe(nil)); end
  def class_or_module_or_struct_new_call?(param0 = T.unsafe(nil)); end
  def dynamic_method_definition?(param0 = T.unsafe(nil)); end
  def on_block(node); end
  def on_class(node); end
  def on_module(node); end
  def on_sclass(node); end
  def static_method_definition?(param0 = T.unsafe(nil)); end

  private

  def access_modifier?(node); end
  def any_context_creating_methods?(child); end
  def any_method_definition?(child); end
  def autocorrect(corrector, node); end
  def check_child_nodes(node, unused, cur_vis); end
  def check_new_visibility(node, unused, new_vis, cur_vis); end
  def check_node(node); end
  def check_scope(node); end
  def check_send_node(node, cur_vis, unused); end
  def eval_call?(child); end
  def method_definition?(child); end
  def start_of_new_scope?(child); end
end

RuboCop::Cop::Lint::UselessAccessModifier::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::UselessAssignment < ::RuboCop::Cop::Base
  def after_leaving_scope(scope, _variable_table); end
  def check_for_unused_assignments(variable); end
  def collect_variable_like_names(scope); end
  def message_for_useless_assignment(assignment); end
  def message_specification(assignment, variable); end
  def multiple_assignment_message(variable_name); end
  def operator_assignment_message(scope, assignment); end
  def return_value_node_of_scope(scope); end
  def similar_name_message(variable); end
  def variable_like_method_invocation?(node); end

  class << self
    def joining_forces; end
  end
end

RuboCop::Cop::Lint::UselessAssignment::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::UselessElseWithoutRescue < ::RuboCop::Cop::Base
  def on_new_investigation; end
end

RuboCop::Cop::Lint::UselessElseWithoutRescue::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::UselessMethodDefinition < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_def(node); end
  def on_defs(node); end

  private

  def delegating?(node, def_node); end
  def optional_args?(node); end
end

RuboCop::Cop::Lint::UselessMethodDefinition::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::UselessRuby2Keywords < ::RuboCop::Cop::Base
  def method_definition(param0 = T.unsafe(nil), param1); end
  def on_send(node); end

  private

  def allowed_arguments(arguments); end
  def inspect_def(node, def_node); end
  def inspect_sym(node, sym_node); end
end

RuboCop::Cop::Lint::UselessRuby2Keywords::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::UselessRuby2Keywords::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::UselessSetterCall < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_def(node); end
  def on_defs(node); end
  def setter_call_to_local_variable?(param0 = T.unsafe(nil)); end

  private

  def last_expression(body); end
end

RuboCop::Cop::Lint::UselessSetterCall::ASSIGNMENT_TYPES = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Lint::UselessSetterCall::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Lint::UselessSetterCall::MethodVariableTracker
  def initialize(body_node); end

  def constructor?(node); end
  def contain_local_object?(variable_name); end
  def process_assignment(asgn_node, rhs_node); end
  def process_assignment_node(node); end
  def process_binary_operator_assignment(op_asgn_node); end
  def process_logical_operator_assignment(asgn_node); end
  def process_multiple_assignment(masgn_node); end
  def scan(node, &block); end
end

class RuboCop::Cop::Lint::UselessTimes < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def block_arg(param0 = T.unsafe(nil)); end
  def block_reassigns_arg?(param0, param1); end
  def on_send(node); end
  def times_call?(param0 = T.unsafe(nil)); end

  private

  def autocorrect_block(corrector, node); end
  def autocorrect_block_pass(corrector, node, proc_name); end
  def fix_indentation(source, range); end
  def never_process?(count, node); end
  def own_line?(node); end
  def remove_node(corrector, node); end
end

RuboCop::Cop::Lint::UselessTimes::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::UselessTimes::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Lint::Void < ::RuboCop::Cop::Base
  def on_begin(node); end
  def on_block(node); end
  def on_kwbegin(node); end

  private

  def check_begin(node); end
  def check_defined(node); end
  def check_expression(expr); end
  def check_literal(node); end
  def check_nonmutating(node); end
  def check_self(node); end
  def check_var(node); end
  def check_void_op(node); end
  def in_void_context?(node); end
end

RuboCop::Cop::Lint::Void::BINARY_OPERATORS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Lint::Void::DEFINED_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::Void::LIT_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::Void::NONMUTATING_METHODS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Lint::Void::NONMUTATING_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::Void::OPERATORS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Lint::Void::OP_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::Void::SELF_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::Void::UNARY_OPERATORS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Lint::Void::VAR_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Lint::Void::VOID_CONTEXT_TYPES = T.let(T.unsafe(nil), Array)

module RuboCop::Cop::MatchRange
  include ::RuboCop::Cop::RangeHelp

  private

  def each_match_range(range, regex); end
  def match_range(range, match); end
end

class RuboCop::Cop::MessageAnnotator
  def initialize(config, cop_name, cop_config, options); end

  def annotate(message); end
  def config; end
  def cop_config; end
  def cop_name; end
  def options; end
  def urls; end

  private

  def debug?; end
  def details; end
  def display_cop_names?; end
  def display_style_guide?; end
  def extra_details?; end
  def reference_urls; end
  def style_guide_base_url; end
  def style_guide_url; end

  class << self
    def style_guide_urls; end
  end
end

module RuboCop::Cop::MethodComplexity
  include ::RuboCop::Cop::IgnoredMethods
  include ::RuboCop::Cop::Metrics::Utils::RepeatedCsendDiscount
  extend ::RuboCop::Cop::IgnoredMethods::Config
  extend ::RuboCop::AST::NodePattern::Macros
  extend ::RuboCop::ExcludeLimit

  mixes_in_class_methods ::RuboCop::Cop::IgnoredMethods::Config

  def define_method?(param0 = T.unsafe(nil)); end
  def max=(value); end
  def on_block(node); end
  def on_def(node); end
  def on_defs(node); end

  private

  def check_complexity(node, method_name); end
  def complexity(body); end

  class << self
    def included(base); end
  end
end

module RuboCop::Cop::MethodPreference
  private

  def default_cop_config; end
  def preferred_method(method); end
  def preferred_methods; end
end

module RuboCop::Cop::Metrics; end

class RuboCop::Cop::Metrics::AbcSize < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::IgnoredMethods
  include ::RuboCop::Cop::Metrics::Utils::RepeatedCsendDiscount
  include ::RuboCop::Cop::MethodComplexity
  extend ::RuboCop::Cop::IgnoredMethods::Config

  private

  def complexity(node); end
end

RuboCop::Cop::Metrics::AbcSize::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Metrics::BlockLength < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::IgnoredMethods
  extend ::RuboCop::Cop::IgnoredMethods::Config

  def on_block(node); end
  def on_numblock(node); end

  private

  def cop_label; end
  def method_receiver_excluded?(node); end
end

RuboCop::Cop::Metrics::BlockLength::LABEL = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Metrics::BlockNesting < ::RuboCop::Cop::Base
  def max=(value); end
  def on_new_investigation; end

  private

  def check_nesting_level(node, max, current_level); end
  def consider_node?(node); end
  def count_blocks?; end
  def message(max); end
end

RuboCop::Cop::Metrics::BlockNesting::NESTING_BLOCKS = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Metrics::ClassLength < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::CodeLength

  def on_casgn(node); end
  def on_class(node); end

  private

  def message(length, max_length); end
end

class RuboCop::Cop::Metrics::CyclomaticComplexity < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::IgnoredMethods
  include ::RuboCop::Cop::Metrics::Utils::RepeatedCsendDiscount
  include ::RuboCop::Cop::MethodComplexity
  include ::RuboCop::Cop::Metrics::Utils::IteratingBlock
  extend ::RuboCop::Cop::IgnoredMethods::Config

  private

  def complexity_score_for(node); end
  def count_block?(block); end
end

RuboCop::Cop::Metrics::CyclomaticComplexity::COUNTED_NODES = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Metrics::CyclomaticComplexity::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Metrics::MethodLength < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::IgnoredMethods
  extend ::RuboCop::Cop::IgnoredMethods::Config

  def on_block(node); end
  def on_def(node); end
  def on_defs(node); end
  def on_numblock(node); end

  private

  def cop_label; end
end

RuboCop::Cop::Metrics::MethodLength::LABEL = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Metrics::ModuleLength < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::CodeLength

  def module_definition?(param0 = T.unsafe(nil)); end
  def on_casgn(node); end
  def on_module(node); end

  private

  def message(length, max_length); end
end

class RuboCop::Cop::Metrics::ParameterLists < ::RuboCop::Cop::Base
  def argument_to_lambda_or_proc?(param0 = T.unsafe(nil)); end
  def max=(value); end
  def max_optional_parameters=(value); end
  def on_args(node); end
  def on_def(node); end
  def on_defs(node); end

  private

  def args_count(node); end
  def count_keyword_args?; end
  def max_optional_parameters; end
  def max_params; end
end

RuboCop::Cop::Metrics::ParameterLists::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Metrics::ParameterLists::NAMED_KEYWORD_TYPES = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Metrics::ParameterLists::OPTIONAL_PARAMETERS_MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Metrics::PerceivedComplexity < ::RuboCop::Cop::Metrics::CyclomaticComplexity
  private

  def complexity_score_for(node); end
end

RuboCop::Cop::Metrics::PerceivedComplexity::COUNTED_NODES = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Metrics::PerceivedComplexity::MSG = T.let(T.unsafe(nil), String)
module RuboCop::Cop::Metrics::Utils; end

class RuboCop::Cop::Metrics::Utils::AbcSizeCalculator
  include ::RuboCop::AST::Sexp
  include ::RuboCop::Cop::Metrics::Utils::RepeatedAttributeDiscount
  include ::RuboCop::Cop::Metrics::Utils::IteratingBlock
  include ::RuboCop::Cop::Metrics::Utils::RepeatedCsendDiscount

  def calculate; end
  def else_branch?(node); end
  def evaluate_condition_node(node); end

  private

  def argument?(node); end
  def assignment?(node); end
  def branch?(node); end
  def capturing_variable?(name); end
  def compound_assignment(node); end
  def condition?(node); end
  def simple_assignment?(node); end
  def visit_depth_last(node, &block); end

  class << self
    def calculate(node, discount_repeated_attributes: T.unsafe(nil)); end
  end
end

RuboCop::Cop::Metrics::Utils::AbcSizeCalculator::ARGUMENT_TYPES = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Metrics::Utils::AbcSizeCalculator::BRANCH_NODES = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Metrics::Utils::AbcSizeCalculator::CONDITION_NODES = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Metrics::Utils::CodeLengthCalculator
  include ::RuboCop::PathUtil
  include ::RuboCop::Cop::Util
  extend ::RuboCop::AST::NodePattern::Macros

  def initialize(node, processed_source, count_comments: T.unsafe(nil), foldable_types: T.unsafe(nil)); end

  def calculate; end

  private

  def build_foldable_checks(types); end
  def classlike_code_length(node); end
  def classlike_node?(node); end
  def code_length(node); end
  def count_comments?; end
  def each_top_level_descendant(node, types, &block); end
  def extract_body(node); end
  def foldable_node?(node); end
  def heredoc_length(node); end
  def heredoc_node?(node); end
  def irrelevant_line?(source_line); end
  def line_numbers_of_inner_nodes(node, *types); end
  def namespace_module?(node); end
  def normalize_foldable_types(types); end
end

RuboCop::Cop::Metrics::Utils::CodeLengthCalculator::CLASSLIKE_TYPES = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Metrics::Utils::CodeLengthCalculator::FOLDABLE_TYPES = T.let(T.unsafe(nil), Array)

module RuboCop::Cop::Metrics::Utils::IteratingBlock
  def block_method_name(node); end
  def iterating_block?(node); end
  def iterating_method?(name); end
end

RuboCop::Cop::Metrics::Utils::IteratingBlock::KNOWN_ITERATING_METHODS = T.let(T.unsafe(nil), Set)

module RuboCop::Cop::Metrics::Utils::RepeatedAttributeDiscount
  include ::RuboCop::AST::Sexp
  extend ::RuboCop::AST::NodePattern::Macros

  def initialize(node, discount_repeated_attributes: T.unsafe(nil)); end

  def attribute_call?(param0 = T.unsafe(nil)); end
  def calculate_node(node); end
  def discount_repeated_attributes?; end
  def evaluate_branch_nodes(node); end
  def root_node?(param0 = T.unsafe(nil)); end

  private

  def discount_repeated_attribute?(send_node); end
  def find_attributes(node, &block); end
  def setter_to_getter(node); end
  def update_repeated_attribute(node); end
end

RuboCop::Cop::Metrics::Utils::RepeatedAttributeDiscount::VAR_SETTER_TO_GETTER = T.let(T.unsafe(nil), Hash)

module RuboCop::Cop::Metrics::Utils::RepeatedCsendDiscount
  def discount_for_repeated_csend?(csend_node); end
  def reset_on_lvasgn(node); end
  def reset_repeated_csend; end
end

module RuboCop::Cop::Migration; end

class RuboCop::Cop::Migration::DepartmentName < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_new_investigation; end

  private

  def check_cop_name(name, comment, offset); end
  def contain_unexpected_character_for_department_name?(name); end
  def disable_comment_offset; end
  def qualified_legacy_cop_name(cop_name); end
  def valid_content_token?(content_token); end
end

RuboCop::Cop::Migration::DepartmentName::DISABLE_COMMENT_FORMAT = T.let(T.unsafe(nil), Regexp)
RuboCop::Cop::Migration::DepartmentName::DISABLING_COPS_CONTENT_TOKEN = T.let(T.unsafe(nil), Regexp)
RuboCop::Cop::Migration::DepartmentName::MSG = T.let(T.unsafe(nil), String)

module RuboCop::Cop::MinBodyLength
  private

  def min_body_length; end
  def min_body_length?(node); end
end

module RuboCop::Cop::MultilineElementIndentation
  private

  def base_column(left_brace, left_parenthesis); end
  def check_expected_style(styles); end
  def check_first(first, left_brace, left_parenthesis, offset); end
  def detected_styles(actual_column, offset, left_parenthesis, left_brace); end
  def detected_styles_for_column(column, left_parenthesis, left_brace); end
  def each_argument_node(node, type); end
  def incorrect_style_detected(styles, first, left_parenthesis); end
end

module RuboCop::Cop::MultilineElementLineBreaks
  private

  def all_on_same_line?(nodes); end
  def check_line_breaks(_node, children); end
end

module RuboCop::Cop::MultilineExpressionIndentation
  def on_send(node); end

  private

  def argument_in_method_call(node, kind); end
  def assignment_rhs(node); end
  def check(range, node, lhs, rhs); end
  def correct_indentation(node); end
  def disqualified_rhs?(candidate, ancestor); end
  def grouped_expression?(node); end
  def incorrect_style_detected(range, node, lhs, rhs); end
  def indentation(node); end
  def indented_keyword_expression(node); end
  def inside_arg_list_parentheses?(node, ancestor); end
  def keyword_message_tail(node); end
  def kw_node_with_special_indentation(node); end
  def left_hand_side(lhs); end
  def not_for_this_cop?(node); end
  def operation_description(node, rhs); end
  def part_of_assignment_rhs(node, candidate); end
  def part_of_block_body?(candidate, block_node); end
  def postfix_conditional?(node); end
  def valid_method_rhs_candidate?(candidate, node); end
  def valid_rhs?(candidate, ancestor); end
  def valid_rhs_candidate?(candidate, node); end
  def within_node?(inner, outer); end
end

RuboCop::Cop::MultilineExpressionIndentation::ASSIGNMENT_MESSAGE_TAIL = T.let(T.unsafe(nil), String)
RuboCop::Cop::MultilineExpressionIndentation::DEFAULT_MESSAGE_TAIL = T.let(T.unsafe(nil), String)
RuboCop::Cop::MultilineExpressionIndentation::KEYWORD_ANCESTOR_TYPES = T.let(T.unsafe(nil), Array)
RuboCop::Cop::MultilineExpressionIndentation::KEYWORD_MESSAGE_TAIL = T.let(T.unsafe(nil), String)
RuboCop::Cop::MultilineExpressionIndentation::UNALIGNED_RHS_TYPES = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::MultilineLiteralBraceCorrector
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::RangeHelp

  def initialize(corrector, node, processed_source); end

  def call; end

  private

  def content_if_comment_present(corrector, node); end
  def correct_next_line_brace(corrector); end
  def correct_same_line_brace(corrector); end
  def corrector; end
  def last_element_range_with_trailing_comma(node); end
  def last_element_trailing_comma_range(node); end
  def node; end
  def processed_source; end
  def remove_trailing_content_of_comment(corrector, range); end
  def select_content_to_be_inserted_after_last_element(corrector, node); end

  class << self
    def correct(corrector, node, processed_source); end
  end
end

module RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  private

  def check(node); end
  def check_brace_layout(node); end
  def check_new_line(node); end
  def check_same_line(node); end
  def check_symmetrical(node); end
  def children(node); end
  def closing_brace_on_same_line?(node); end
  def empty_literal?(node); end
  def ignored_literal?(node); end
  def implicit_literal?(node); end
  def last_line_heredoc?(node, parent = T.unsafe(nil)); end
  def new_line_needed_before_closing_brace?(node); end
  def opening_brace_on_same_line?(node); end
end

module RuboCop::Cop::Naming; end

class RuboCop::Cop::Naming::AccessorMethodName < ::RuboCop::Cop::Base
  def on_def(node); end
  def on_defs(node); end

  private

  def bad_reader_name?(node); end
  def bad_writer_name?(node); end
  def message(node); end
end

RuboCop::Cop::Naming::AccessorMethodName::MSG_READER = T.let(T.unsafe(nil), String)
RuboCop::Cop::Naming::AccessorMethodName::MSG_WRITER = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Naming::AsciiIdentifiers < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp

  def on_new_investigation; end

  private

  def first_non_ascii_chars(string); end
  def first_offense_range(identifier); end
  def should_check?(token); end
end

RuboCop::Cop::Naming::AsciiIdentifiers::CONSTANT_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Naming::AsciiIdentifiers::IDENTIFIER_MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Naming::BinaryOperatorParameterName < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_def(node); end
  def op_method_candidate?(param0 = T.unsafe(nil)); end

  private

  def op_method?(name); end
end

RuboCop::Cop::Naming::BinaryOperatorParameterName::EXCLUDED = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Naming::BinaryOperatorParameterName::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Naming::BinaryOperatorParameterName::OP_LIKE_METHODS = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Naming::BlockForwarding < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion

  def on_def(node); end
  def on_defs(node); end

  private

  def anonymous_block_argument?(node); end
  def block_forwarding_name; end
  def expected_block_forwarding_style?(node, last_argument); end
  def explicit_block_argument?(node); end
  def register_offense(block_argument, node); end
  def use_block_argument_as_local_variable?(node, last_argument); end
  def use_kwarg_in_method_definition?(node); end
end

RuboCop::Cop::Naming::BlockForwarding::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Naming::BlockParameterName < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::UncommunicativeName

  def on_block(node); end
end

class RuboCop::Cop::Naming::ClassAndModuleCamelCase < ::RuboCop::Cop::Base
  def on_class(node); end
  def on_module(node); end
end

RuboCop::Cop::Naming::ClassAndModuleCamelCase::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Naming::ConstantName < ::RuboCop::Cop::Base
  def class_or_struct_return_method?(param0 = T.unsafe(nil)); end
  def literal_receiver?(param0 = T.unsafe(nil)); end
  def on_casgn(node); end

  private

  def allowed_assignment?(value); end
  def allowed_conditional_expression_on_rhs?(node); end
  def allowed_method_call_on_rhs?(node); end
  def contains_contant?(node); end
end

RuboCop::Cop::Naming::ConstantName::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Naming::ConstantName::SNAKE_CASE = T.let(T.unsafe(nil), Regexp)

class RuboCop::Cop::Naming::FileName < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp

  def on_new_investigation; end
  def struct_definition(param0 = T.unsafe(nil)); end

  private

  def allowed_acronyms; end
  def bad_filename_allowed?; end
  def check_definition_path_hierarchy?; end
  def defined_struct(node); end
  def definition_path_hierarchy_roots; end
  def expect_matching_definition?; end
  def filename_good?(basename); end
  def find_class_or_module(node, namespace); end
  def find_definition(node); end
  def for_bad_filename(file_path); end
  def ignore_executable_scripts?; end
  def match?(expected); end
  def match_acronym?(expected, name); end
  def match_namespace(node, namespace, expected); end
  def matching_class?(file_name); end
  def matching_definition?(file_path); end
  def no_definition_message(basename, file_path); end
  def other_message(basename); end
  def partial_matcher!(expected); end
  def perform_class_and_module_naming_checks(file_path, basename); end
  def regex; end
  def to_module_name(basename); end
  def to_namespace(path); end
end

RuboCop::Cop::Naming::FileName::MSG_NO_DEFINITION = T.let(T.unsafe(nil), String)
RuboCop::Cop::Naming::FileName::MSG_REGEX = T.let(T.unsafe(nil), String)
RuboCop::Cop::Naming::FileName::MSG_SNAKE_CASE = T.let(T.unsafe(nil), String)
RuboCop::Cop::Naming::FileName::SNAKE_CASE = T.let(T.unsafe(nil), Regexp)

class RuboCop::Cop::Naming::HeredocDelimiterCase < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Heredoc
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def on_heredoc(node); end

  private

  def correct_case_delimiters?(node); end
  def correct_delimiters(source); end
  def message(_node); end
end

RuboCop::Cop::Naming::HeredocDelimiterCase::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Naming::HeredocDelimiterNaming < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Heredoc

  def on_heredoc(node); end

  private

  def forbidden_delimiters; end
  def meaningful_delimiters?(node); end
end

RuboCop::Cop::Naming::HeredocDelimiterNaming::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Naming::InclusiveLanguage < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp

  def initialize(config = T.unsafe(nil), options = T.unsafe(nil)); end

  def on_new_investigation; end

  private

  def add_offenses_for_token(token, word_locations); end
  def add_to_flagged_term_hash(regex_string, term, term_definition); end
  def array_to_ignorecase_regex(strings); end
  def check_token?(type); end
  def create_message(word, message = T.unsafe(nil)); end
  def create_multiple_word_message_for_file(words); end
  def create_single_word_message_for_file(word); end
  def ensure_regex_string(regex); end
  def extract_regexp(term, term_definition); end
  def find_flagged_term(word); end
  def format_suggestions(suggestions); end
  def investigate_filepath; end
  def investigate_tokens; end
  def mask_input(str); end
  def preprocess_check_config; end
  def preprocess_flagged_terms; end
  def preprocess_suggestions(suggestions); end
  def process_allowed_regex(allowed); end
  def scan_for_words(input); end
  def set_regexes(flagged_term_strings, allowed_strings); end
end

RuboCop::Cop::Naming::InclusiveLanguage::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Naming::InclusiveLanguage::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Naming::InclusiveLanguage::MSG_FOR_FILE_PATH = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Naming::InclusiveLanguage::WordLocation < ::Struct
  def position; end
  def position=(_); end
  def word; end
  def word=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class RuboCop::Cop::Naming::MemoizedInstanceVariableName < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  def defined_memoized?(param0 = T.unsafe(nil), param1); end
  def method_definition?(param0 = T.unsafe(nil)); end
  def on_defined?(node); end
  def on_or_asgn(node); end

  private

  def find_definition(node); end
  def matches?(method_name, ivar_assign); end
  def message(variable); end
  def style_parameter_name; end
  def suggested_var(method_name); end
  def variable_name_candidates(method_name); end
end

RuboCop::Cop::Naming::MemoizedInstanceVariableName::DYNAMIC_DEFINE_METHODS = T.let(T.unsafe(nil), Set)
RuboCop::Cop::Naming::MemoizedInstanceVariableName::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Naming::MemoizedInstanceVariableName::UNDERSCORE_REQUIRED = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Naming::MethodName < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableNaming
  include ::RuboCop::Cop::IgnoredPattern
  include ::RuboCop::Cop::RangeHelp

  def on_def(node); end
  def on_defs(node); end
  def on_send(node); end
  def str_name(param0 = T.unsafe(nil)); end
  def sym_name(param0 = T.unsafe(nil)); end

  private

  def attr_name(name_item); end
  def message(style); end
  def range_position(node); end
end

RuboCop::Cop::Naming::MethodName::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Naming::MethodParameterName < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::UncommunicativeName

  def on_def(node); end
  def on_defs(node); end
end

class RuboCop::Cop::Naming::PredicateName < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::AllowedMethods

  def dynamic_method_define(param0 = T.unsafe(nil)); end
  def on_def(node); end
  def on_defs(node); end
  def on_send(node); end

  private

  def allowed_method_name?(method_name, prefix); end
  def expected_name(method_name, prefix); end
  def forbidden_prefixes; end
  def message(method_name, new_name); end
  def method_definition_macros(macro_name); end
  def predicate_prefixes; end
end

class RuboCop::Cop::Naming::RescuedExceptionsVariableName < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_resbody(node); end

  private

  def correct_node(corrector, node, offending_name, preferred_name); end
  def correct_reassignment(corrector, node, offending_name, preferred_name); end
  def message(node); end
  def offense_range(resbody); end
  def preferred_name(variable_name); end
  def shadowed_variable_name?(node); end
  def variable_name(node); end
  def variable_name_matches?(node, name); end
end

RuboCop::Cop::Naming::RescuedExceptionsVariableName::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Naming::VariableName < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::AllowedIdentifiers
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableNaming

  def on_arg(node); end
  def on_blockarg(node); end
  def on_cvasgn(node); end
  def on_ivasgn(node); end
  def on_kwarg(node); end
  def on_kwoptarg(node); end
  def on_kwrestarg(node); end
  def on_lvar(node); end
  def on_lvasgn(node); end
  def on_optarg(node); end
  def on_restarg(node); end

  private

  def message(style); end
end

RuboCop::Cop::Naming::VariableName::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Naming::VariableNumber < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::AllowedIdentifiers
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableNumbering

  def on_arg(node); end
  def on_cvasgn(node); end
  def on_def(node); end
  def on_defs(node); end
  def on_ivasgn(node); end
  def on_lvasgn(node); end
  def on_sym(node); end

  private

  def message(style); end
end

RuboCop::Cop::Naming::VariableNumber::MSG = T.let(T.unsafe(nil), String)

module RuboCop::Cop::NegativeConditional
  extend ::RuboCop::AST::NodePattern::Macros

  def empty_condition?(param0 = T.unsafe(nil)); end
  def single_negative?(param0 = T.unsafe(nil)); end

  private

  def check_negative_conditional(node, message:, &block); end
end

RuboCop::Cop::NegativeConditional::MSG = T.let(T.unsafe(nil), String)

module RuboCop::Cop::NilMethods
  include ::RuboCop::Cop::AllowedMethods

  private

  def nil_methods; end
  def other_stdlib_methods; end
end

class RuboCop::Cop::Offense
  include ::Comparable

  def initialize(severity, location, message, cop_name, status = T.unsafe(nil), corrector = T.unsafe(nil)); end

  def <=>(other); end
  def ==(other); end
  def column; end
  def column_length; end
  def column_range; end
  def cop_name; end
  def correctable?; end
  def corrected?; end
  def corrected_with_todo?; end
  def corrector; end
  def disabled?; end
  def eql?(other); end
  def first_line; end
  def hash; end
  def highlighted_area; end
  def last_column; end
  def last_line; end
  def line; end
  def location; end
  def message; end
  def real_column; end
  def severity; end
  def source_line; end
  def status; end
  def to_s; end
end

RuboCop::Cop::Offense::COMPARISON_ATTRIBUTES = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Offense::NO_LOCATION = T.let(T.unsafe(nil), RuboCop::Cop::Offense::PseudoSourceRange)

class RuboCop::Cop::Offense::PseudoSourceRange < ::Struct
  def begin_pos; end
  def begin_pos=(_); end
  def column; end
  def column=(_); end
  def column_range; end
  def end_pos; end
  def end_pos=(_); end
  def first_line; end
  def last_column; end
  def last_line; end
  def length; end
  def line; end
  def line=(_); end
  def size; end
  def source_line; end
  def source_line=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

module RuboCop::Cop::OnNormalIfUnless
  def on_if(node); end
end

class RuboCop::Cop::OrderedGemCorrector
  extend ::RuboCop::Cop::OrderedGemNode
  extend ::RuboCop::Cop::RangeHelp

  class << self
    def comments_as_separators; end
    def correct(processed_source, node, previous_declaration, comments_as_separators); end
    def processed_source; end

    private

    def declaration_with_comment(node); end
    def swap_range(corrector, range1, range2); end
  end
end

module RuboCop::Cop::OrderedGemNode
  private

  def case_insensitive_out_of_order?(string_a, string_b); end
  def consecutive_lines(previous, current); end
  def find_gem_name(gem_node); end
  def gem_canonical_name(name); end
  def gem_name(declaration_node); end
  def get_source_range(node, comments_as_separators); end
  def register_offense(previous, current); end
  def treat_comments_as_separators; end
end

module RuboCop::Cop::Parentheses
  private

  def parens_required?(node); end
end

class RuboCop::Cop::ParenthesesCorrector
  class << self
    def correct(corrector, node); end

    private

    def next_char_is_question_mark?(node); end
    def ternary_condition?(node); end
  end
end

module RuboCop::Cop::PercentArray
  private

  def allowed_bracket_array?(node); end
  def check_bracketed_array(node, literal_prefix); end
  def check_percent_array(node); end
  def comments_in_array?(node); end
  def invalid_percent_array_contents?(_node); end
  def invalid_percent_array_context?(node); end
end

module RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp

  private

  def begin_source(node); end
  def percent_literal?(node); end
  def process(node, *types); end
  def type(node); end
end

class RuboCop::Cop::PercentLiteralCorrector
  include ::RuboCop::PathUtil
  include ::RuboCop::Cop::Util

  def initialize(config, preferred_delimiters); end

  def config; end
  def correct(corrector, node, char); end
  def preferred_delimiters; end

  private

  def autocorrect_multiline_words(node, escape, delimiters); end
  def autocorrect_words(node, escape, delimiters); end
  def delimiters_for(type); end
  def end_content(source); end
  def escape_words?(node); end
  def first_line?(node, previous_line_num); end
  def fix_escaped_content(word_node, escape, delimiters); end
  def line_breaks(node, source, previous_line_num, base_line_num, node_indx); end
  def new_contents(node, escape, delimiters); end
  def process_lines(node, previous_line_num, base_line_num, source_in_lines); end
  def process_multiline_words(node, escape, delimiters); end
  def substitute_escaped_delimiters(content, delimiters); end
  def wrap_contents(corrector, node, contents, char, delimiters); end
end

module RuboCop::Cop::PrecedingFollowingAlignment
  private

  def aligned_assignment?(range, line); end
  def aligned_char?(range, line); end
  def aligned_comment_lines; end
  def aligned_identical?(range, line); end
  def aligned_operator?(range, line); end
  def aligned_token?(range, line); end
  def aligned_with_adjacent_line?(range, predicate); end
  def aligned_with_any_line?(line_ranges, range, indent = T.unsafe(nil), &predicate); end
  def aligned_with_any_line_range?(line_ranges, range, &predicate); end
  def aligned_with_append_operator?(range, line); end
  def aligned_with_assignment(token, line_range); end
  def aligned_with_line?(line_nos, range, indent = T.unsafe(nil)); end
  def aligned_with_operator?(range); end
  def aligned_with_preceding_assignment(token); end
  def aligned_with_something?(range); end
  def aligned_with_subsequent_assignment(token); end
  def aligned_words?(range, line); end
  def allow_for_alignment?; end
  def assignment_lines; end
  def assignment_tokens; end
  def relevant_assignment_lines(line_range); end
  def remove_optarg_equals(asgn_tokens, processed_source); end
end

class RuboCop::Cop::PreferredDelimiters
  def initialize(type, config, preferred_delimiters); end

  def config; end
  def delimiters; end
  def type; end

  private

  def ensure_valid_preferred_delimiters; end
  def preferred_delimiters; end
  def preferred_delimiters_config; end
end

RuboCop::Cop::PreferredDelimiters::PERCENT_LITERAL_TYPES = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::PunctuationCorrector
  class << self
    def add_space(corrector, token); end
    def remove_space(corrector, space_before); end
    def swap_comma(corrector, range); end
  end
end

module RuboCop::Cop::RangeHelp
  private

  def column_offset_between(base_range, range); end
  def contents_range(node); end
  def directions(side); end
  def effective_column(range); end
  def final_pos(src, pos, increment, continuations, newlines, whitespace); end
  def move_pos(src, pos, step, condition, regexp); end
  def move_pos_str(src, pos, step, condition, needle); end
  def range_between(start_pos, end_pos); end
  def range_by_whole_lines(range, include_final_newline: T.unsafe(nil)); end
  def range_with_surrounding_comma(range, side = T.unsafe(nil)); end
  def range_with_surrounding_space(range:, side: T.unsafe(nil), newlines: T.unsafe(nil), whitespace: T.unsafe(nil), continuations: T.unsafe(nil)); end
  def source_range(source_buffer, line_number, column, length = T.unsafe(nil)); end
end

RuboCop::Cop::RangeHelp::BYTE_ORDER_MARK = T.let(T.unsafe(nil), Integer)

module RuboCop::Cop::RationalLiteral
  extend ::RuboCop::AST::NodePattern::Macros

  def rational_literal?(param0 = T.unsafe(nil)); end
end

class RuboCop::Cop::Registry
  include ::Enumerable

  def initialize(cops = T.unsafe(nil), options = T.unsafe(nil)); end

  def ==(other); end
  def contains_cop_matching?(names); end
  def cops; end
  def department?(name); end
  def department_missing?(badge, name); end
  def departments; end
  def dismiss(cop); end
  def each(&block); end
  def enabled(config, only = T.unsafe(nil), only_safe: T.unsafe(nil)); end
  def enabled?(cop, config, only_safe); end
  def enabled_pending_cop?(cop_cfg, config); end
  def enlist(cop); end
  def find_by_cop_name(cop_name); end
  def freeze; end
  def length; end
  def names; end
  def names_for_department(department); end
  def options; end
  def print_warning(name, path); end
  def qualified_cop_name(name, path, warn: T.unsafe(nil)); end
  def select(&block); end
  def sort!; end
  def to_h; end
  def unqualified_cop_names; end
  def with_department(department); end
  def without_department(department); end

  private

  def clear_enrollment_queue; end
  def initialize_copy(reg); end
  def qualify_badge(badge); end
  def registered?(badge); end
  def resolve_badge(given_badge, real_badge, source_path); end
  def with(cops); end

  class << self
    def all; end
    def global; end
    def qualified_cop_name(name, origin); end
    def reset!; end
    def with_temporary_global(temp_global = T.unsafe(nil)); end
  end
end

module RuboCop::Cop::RequireLibrary
  extend ::RuboCop::AST::NodePattern::Macros

  def ensure_required(corrector, node, library_name); end
  def on_send(node); end
  def remove_subsequent_requires(corrector, node, library_name); end
  def require_any_library?(param0 = T.unsafe(nil)); end
  def require_library_name?(param0 = T.unsafe(nil), param1); end

  private

  def on_new_investigation; end
end

class RuboCop::Cop::RequireLibraryCorrector
  extend ::RuboCop::Cop::RangeHelp

  class << self
    def correct(corrector, node, library_name); end
    def require_statement(library_name); end
  end
end

module RuboCop::Cop::RescueNode
  def on_new_investigation; end

  private

  def rescue_modifier?(node); end
  def rescued_exceptions(resbody); end
end

module RuboCop::Cop::SafeAssignment
  extend ::RuboCop::AST::NodePattern::Macros

  def empty_condition?(param0 = T.unsafe(nil)); end
  def safe_assignment?(param0 = T.unsafe(nil)); end
  def setter_method?(param0 = T.unsafe(nil)); end

  private

  def safe_assignment_allowed?; end
end

module RuboCop::Cop::Security; end

class RuboCop::Cop::Security::Eval < ::RuboCop::Cop::Base
  def eval?(param0 = T.unsafe(nil)); end
  def on_send(node); end
end

RuboCop::Cop::Security::Eval::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Security::Eval::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Security::IoMethods < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end
end

RuboCop::Cop::Security::IoMethods::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Security::IoMethods::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Security::JSONLoad < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def json_load(param0 = T.unsafe(nil)); end
  def on_send(node); end
end

RuboCop::Cop::Security::JSONLoad::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Security::JSONLoad::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Security::MarshalLoad < ::RuboCop::Cop::Base
  def marshal_load(param0 = T.unsafe(nil)); end
  def on_send(node); end
end

RuboCop::Cop::Security::MarshalLoad::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Security::MarshalLoad::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Security::Open < ::RuboCop::Cop::Base
  def on_send(node); end
  def open?(param0 = T.unsafe(nil)); end

  private

  def composite_string?(node); end
  def concatenated_string?(node); end
  def interpolated_string?(node); end
  def safe?(node); end
  def safe_argument?(argument); end
  def simple_string?(node); end
end

RuboCop::Cop::Security::Open::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Security::Open::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Security::YAMLLoad < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end
  def yaml_load(param0 = T.unsafe(nil)); end
end

RuboCop::Cop::Security::YAMLLoad::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Security::YAMLLoad::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Severity
  include ::Comparable

  def initialize(name_or_code); end

  def <=>(other); end
  def ==(other); end
  def code; end
  def hash; end
  def level; end
  def name; end
  def to_s; end

  class << self
    def name_from_code(code); end
  end
end

RuboCop::Cop::Severity::CODE_TABLE = T.let(T.unsafe(nil), Hash)
RuboCop::Cop::Severity::NAMES = T.let(T.unsafe(nil), Array)

module RuboCop::Cop::SpaceAfterPunctuation
  def on_new_investigation; end

  private

  def allowed_type?(token); end
  def each_missing_space(tokens); end
  def offset; end
  def space_forbidden_before_rcurly?; end
  def space_missing?(token1, token2); end
  def space_required_before?(token); end
end

RuboCop::Cop::SpaceAfterPunctuation::MSG = T.let(T.unsafe(nil), String)

module RuboCop::Cop::SpaceBeforePunctuation
  include ::RuboCop::Cop::RangeHelp

  def on_new_investigation; end

  private

  def each_missing_space(tokens); end
  def space_missing?(token1, token2); end
  def space_required_after?(token); end
  def space_required_after_lcurly?; end
end

RuboCop::Cop::SpaceBeforePunctuation::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::SpaceCorrector
  extend ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::SurroundingSpace

  class << self
    def add_space(processed_source, corrector, left_token, right_token); end
    def empty_corrections(processed_source, corrector, empty_config, left_token, right_token); end
    def processed_source; end
    def remove_space(processed_source, corrector, left_token, right_token); end
  end
end

module RuboCop::Cop::StatementModifier
  include ::RuboCop::Cop::LineLengthHelp

  private

  def code_after(node); end
  def comment_disables_cop?(comment); end
  def first_line_comment(node); end
  def length_in_modifier_form(node); end
  def max_line_length; end
  def modifier_fits_on_single_line?(node); end
  def non_eligible_body?(body); end
  def non_eligible_condition?(condition); end
  def non_eligible_node?(node); end
  def parenthesize?(node); end
  def single_line_as_modifier?(node); end
  def to_modifier_form(node); end
end

module RuboCop::Cop::StringHelp
  def on_regexp(node); end
  def on_str(node); end

  private

  def inside_interpolation?(node); end
end

class RuboCop::Cop::StringLiteralCorrector
  extend ::RuboCop::PathUtil
  extend ::RuboCop::Cop::Util

  class << self
    def correct(corrector, node, style); end
  end
end

module RuboCop::Cop::StringLiteralsHelp
  private

  def wrong_quotes?(src_or_node); end
end

module RuboCop::Cop::Style; end

class RuboCop::Cop::Style::AccessModifierDeclarations < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  def access_modifier_with_symbol?(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def access_modifier_is_inlined?(node); end
  def access_modifier_is_not_inlined?(node); end
  def allow_modifiers_on_symbols?(node); end
  def group_style?; end
  def inline_style?; end
  def message(range); end
  def offense?(node); end
end

RuboCop::Cop::Style::AccessModifierDeclarations::GROUP_STYLE_MESSAGE = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::AccessModifierDeclarations::INLINE_STYLE_MESSAGE = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::AccessModifierDeclarations::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::AccessorGrouping < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::VisibilityHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_class(node); end
  def on_module(node); end
  def on_sclass(node); end

  private

  def accessor?(send_node); end
  def autocorrect(corrector, node); end
  def check(send_node); end
  def class_send_elements(class_node); end
  def group_accessors(node, accessors); end
  def grouped_style?; end
  def message(send_node); end
  def preferred_accessors(node); end
  def previous_line_comment?(node); end
  def separate_accessors(node); end
  def separated_style?; end
  def sibling_accessors(send_node); end
end

RuboCop::Cop::Style::AccessorGrouping::ACCESSOR_METHODS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Style::AccessorGrouping::GROUPED_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::AccessorGrouping::SEPARATED_MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::Alias < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def identifier(param0 = T.unsafe(nil)); end
  def on_alias(node); end
  def on_send(node); end

  private

  def add_offense_for_args(node, &block); end
  def alias_keyword_possible?(node); end
  def alias_method_possible?(node); end
  def autocorrect(corrector, node); end
  def bareword?(sym_node); end
  def correct_alias_method_to_alias(corrector, send_node); end
  def correct_alias_to_alias_method(corrector, node); end
  def correct_alias_with_symbol_args(corrector, node); end
  def lexical_scope_type(node); end
  def scope_type(node); end
end

RuboCop::Cop::Style::Alias::MSG_ALIAS = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::Alias::MSG_ALIAS_METHOD = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::Alias::MSG_SYMBOL_ARGS = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::Alias::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::AndOr < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_and(node); end
  def on_if(node); end
  def on_or(node); end
  def on_until(node); end
  def on_until_post(node); end
  def on_while(node); end
  def on_while_post(node); end

  private

  def correct_not(node, receiver, corrector); end
  def correct_other(node, corrector); end
  def correct_send(node, corrector); end
  def correct_setter(node, corrector); end
  def correctable_send?(node); end
  def keep_operator_precedence(corrector, node); end
  def message(node); end
  def on_conditionals(node); end
  def process_logical_operator(node); end
  def whitespace_before_arg(node); end
end

RuboCop::Cop::Style::AndOr::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::ArgumentsForwarding < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion

  def forwarding_method_arguments?(param0 = T.unsafe(nil), param1, param2, param3); end
  def on_def(node); end
  def on_defs(node); end
  def only_rest_arguments?(param0 = T.unsafe(nil), param1); end
  def use_rest_arguments?(param0 = T.unsafe(nil)); end

  private

  def all_lvars_as_forwarding_method_arguments?(def_node, forwarding_method); end
  def allow_only_rest_arguments?; end
  def arguments_range(node); end
  def extract_argument_names_from(args); end
  def forwarding_method?(node, rest_arg, kwargs, block_arg); end
  def register_offense_to_forwarding_method_arguments(forwarding_method); end
  def register_offense_to_method_definition_arguments(method_definition); end
end

RuboCop::Cop::Style::ArgumentsForwarding::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::ArrayCoercion < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def array_splat?(param0 = T.unsafe(nil)); end
  def on_array(node); end
  def on_if(node); end
  def unless_array?(param0 = T.unsafe(nil)); end
end

RuboCop::Cop::Style::ArrayCoercion::CHECK_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::ArrayCoercion::SPLAT_MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::ArrayJoin < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def join_candidate?(param0 = T.unsafe(nil)); end
  def on_send(node); end
end

RuboCop::Cop::Style::ArrayJoin::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::ArrayJoin::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::AsciiComments < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp

  def on_new_investigation; end

  private

  def allowed_non_ascii_chars; end
  def first_non_ascii_chars(string); end
  def first_offense_range(comment); end
  def only_allowed_non_ascii_chars?(string); end
end

RuboCop::Cop::Style::AsciiComments::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::Attr < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def class_eval?(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def autocorrect(corrector, node); end
  def message(node); end
  def replacement_method(node); end
end

RuboCop::Cop::Style::Attr::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::Attr::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::AutoResourceCleanup < ::RuboCop::Cop::Base
  def on_send(node); end

  private

  def cleanup?(node); end
end

RuboCop::Cop::Style::AutoResourceCleanup::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::AutoResourceCleanup::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Style::AutoResourceCleanup::TARGET_METHODS = T.let(T.unsafe(nil), Hash)

class RuboCop::Cop::Style::BarePercentLiterals < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def on_dstr(node); end
  def on_str(node); end

  private

  def add_offense_for_wrong_style(node, good, bad); end
  def check(node); end
  def requires_bare_percent?(source); end
  def requires_percent_q?(source); end
end

RuboCop::Cop::Style::BarePercentLiterals::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::BeginBlock < ::RuboCop::Cop::Base
  def on_preexe(node); end
end

RuboCop::Cop::Style::BeginBlock::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::BisectedAttrAccessor < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def after_class(class_node); end
  def after_module(class_node); end
  def after_sclass(class_node); end
  def on_class(class_node); end
  def on_module(class_node); end
  def on_new_investigation; end
  def on_sclass(class_node); end

  private

  def correct_reader(corrector, macro, node, range); end
  def correct_writer(corrector, macro, node, range); end
  def find_bisection(macros); end
  def find_macros(class_def); end
  def register_offense(attr); end
end

RuboCop::Cop::Style::BisectedAttrAccessor::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::BisectedAttrAccessor::Macro
  include ::RuboCop::Cop::VisibilityHelp

  def initialize(node); end

  def all_bisected?; end
  def attr_names; end
  def attrs; end
  def bisect(*names); end
  def bisected_names; end
  def bisection; end
  def node; end
  def reader?; end
  def rest; end
  def visibility; end
  def writer?; end

  class << self
    def macro?(node); end
  end
end

class RuboCop::Cop::Style::BlockComments < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_new_investigation; end

  private

  def eq_end_part(comment, expr); end
  def parts(comment); end
end

RuboCop::Cop::Style::BlockComments::BEGIN_LENGTH = T.let(T.unsafe(nil), Integer)
RuboCop::Cop::Style::BlockComments::END_LENGTH = T.let(T.unsafe(nil), Integer)
RuboCop::Cop::Style::BlockComments::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::BlockDelimiters < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::IgnoredMethods
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::IgnoredMethods::Config
  extend ::RuboCop::Cop::AutoCorrector

  def on_block(node); end
  def on_send(node); end

  private

  def array_or_range?(node); end
  def autocorrect(corrector, node); end
  def begin_required?(block_node); end
  def braces_for_chaining_message(node); end
  def braces_for_chaining_style?(node); end
  def braces_required_message(node); end
  def braces_required_method?(method_name); end
  def braces_required_methods; end
  def braces_style?(node); end
  def conditional?(node); end
  def correction_would_break_code?(node); end
  def end_of_chain(node); end
  def functional_block?(node); end
  def functional_method?(method_name); end
  def get_blocks(node, &block); end
  def line_count_based_block_style?(node); end
  def line_count_based_message(node); end
  def message(node); end
  def move_comment_before_block(corrector, comment, block_node, closing_brace); end
  def procedural_method?(method_name); end
  def procedural_oneliners_may_have_braces?; end
  def proper_block_style?(node); end
  def replace_braces_with_do_end(corrector, loc); end
  def replace_do_end_with_braces(corrector, node); end
  def return_value_of_scope?(node); end
  def return_value_used?(node); end
  def semantic_block_style?(node); end
  def semantic_message(node); end
  def special_method?(method_name); end
  def special_method_proper_block_style?(node); end
  def whitespace_after?(range, length = T.unsafe(nil)); end
  def whitespace_before?(range); end
end

RuboCop::Cop::Style::BlockDelimiters::ALWAYS_BRACES_MESSAGE = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::BlockDelimiters::BRACES_REQUIRED_MESSAGE = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::CaseCorrector
  extend ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper

  class << self
    def correct(corrector, cop, node); end
    def move_assignment_inside_condition(corrector, node); end

    private

    def extract_branches(case_node); end
    def extract_tail_branches(node); end
    def move_branch_inside_condition(corrector, branch, condition, assignment, column); end
  end
end

class RuboCop::Cop::Style::CaseEquality < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def case_equality?(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def const?(node); end
  def replacement(lhs, rhs); end
end

RuboCop::Cop::Style::CaseEquality::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::CaseEquality::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::CaseLikeIf < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_if(node); end

  private

  def autocorrect(corrector, node); end
  def branch_conditions(node); end
  def class_reference?(node); end
  def collect_conditions(node, target, conditions); end
  def condition_from_binary_op(lhs, rhs, target); end
  def condition_from_equality_node(node, target); end
  def condition_from_include_or_cover_node(node, target); end
  def condition_from_match_node(node, target); end
  def condition_from_send_node(node, target); end
  def const_reference?(node); end
  def correction_range(node); end
  def deparenthesize(node); end
  def find_target(node); end
  def find_target_in_equality_node(node); end
  def find_target_in_include_or_cover_node(node); end
  def find_target_in_match_node(node); end
  def find_target_in_send_node(node); end
  def regexp_with_named_captures?(node); end
  def regexp_with_working_captures?(node); end
  def should_check?(node); end
end

RuboCop::Cop::Style::CaseLikeIf::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::CharacterLiteral < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::StringHelp
  extend ::RuboCop::Cop::AutoCorrector

  def autocorrect(corrector, node); end
  def correct_style_detected; end
  def offense?(node); end
  def opposite_style_detected; end
end

RuboCop::Cop::Style::CharacterLiteral::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::ClassAndModuleChildren < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_class(node); end
  def on_module(node); end

  private

  def add_trailing_end(corrector, node, padding); end
  def autocorrect(corrector, node); end
  def check_compact_style(node, body); end
  def check_nested_style(node); end
  def check_style(node, body); end
  def compact_definition(corrector, node); end
  def compact_identifier_name(node); end
  def compact_node(corrector, node); end
  def compact_node_name?(node); end
  def compact_replacement(node); end
  def configured_indentation_width; end
  def indent_width; end
  def leading_spaces(node); end
  def needs_compacting?(body); end
  def nest_definition(corrector, node); end
  def nest_or_compact(corrector, node); end
  def remove_end(corrector, body); end
  def replace_namespace_keyword(corrector, node); end
  def split_on_double_colon(corrector, node, padding); end
  def unindent(corrector, node); end
end

RuboCop::Cop::Style::ClassAndModuleChildren::COMPACT_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::ClassAndModuleChildren::NESTED_MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::ClassCheck < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def message(node); end
  def on_send(node); end
end

RuboCop::Cop::Style::ClassCheck::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::ClassCheck::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::ClassEqualityComparison < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::IgnoredMethods
  extend ::RuboCop::Cop::IgnoredMethods::Config
  extend ::RuboCop::Cop::AutoCorrector

  def class_comparison_candidate?(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def class_name(class_node, node); end
  def offense_range(receiver_node, node); end
end

RuboCop::Cop::Style::ClassEqualityComparison::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::ClassEqualityComparison::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::ClassMethods < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_class(node); end
  def on_module(node); end

  private

  def check_defs(name, node); end
end

RuboCop::Cop::Style::ClassMethods::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::ClassMethodsDefinitions < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::VisibilityHelp
  include ::RuboCop::Cop::CommentsHelp
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_defs(node); end
  def on_sclass(node); end

  private

  def all_methods_public?(sclass_node); end
  def autocorrect_sclass(node, corrector); end
  def def_nodes(sclass_node); end
  def def_self_style?; end
  def extract_def_from_sclass(def_node, sclass_node); end
  def indentation_diff(node1, node2); end
  def sclass_only_has_methods?(node); end
end

RuboCop::Cop::Style::ClassMethodsDefinitions::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::ClassMethodsDefinitions::MSG_SCLASS = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::ClassVars < ::RuboCop::Cop::Base
  def on_cvasgn(node); end
  def on_send(node); end
end

RuboCop::Cop::Style::ClassVars::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::ClassVars::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::CollectionCompact < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end
  def reject_method?(param0 = T.unsafe(nil)); end
  def reject_method_with_block_pass?(param0 = T.unsafe(nil)); end
  def select_method?(param0 = T.unsafe(nil)); end

  private

  def good_method_name(method_name); end
  def offense_range(node); end
  def range(begin_pos_node, end_pos_node); end
end

RuboCop::Cop::Style::CollectionCompact::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::CollectionCompact::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::CollectionMethods < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::MethodPreference
  extend ::RuboCop::Cop::AutoCorrector

  def on_block(node); end
  def on_send(node); end

  private

  def check_method_node(node); end
  def implicit_block?(node); end
  def message(node); end
  def methods_accepting_symbol; end
end

RuboCop::Cop::Style::CollectionMethods::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::ColonMethodCall < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def java_type_node?(param0 = T.unsafe(nil)); end
  def on_send(node); end

  class << self
    def autocorrect_incompatible_with; end
  end
end

RuboCop::Cop::Style::ColonMethodCall::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::ColonMethodDefinition < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_defs(node); end
end

RuboCop::Cop::Style::ColonMethodDefinition::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::CombinableLoops < ::RuboCop::Cop::Base
  def on_block(node); end
  def on_for(node); end

  private

  def collection_looping_method?(node); end
  def same_collection_looping?(node, sibling); end
end

RuboCop::Cop::Style::CombinableLoops::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::CommandLiteral < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def on_xstr(node); end

  private

  def allow_inner_backticks?; end
  def allowed_backtick_literal?(node); end
  def allowed_percent_x_literal?(node); end
  def autocorrect(corrector, node); end
  def backtick_literal?(node); end
  def check_backtick_literal(node, message); end
  def check_percent_x_literal(node, message); end
  def command_delimiter; end
  def contains_backtick?(node); end
  def contains_disallowed_backtick?(node); end
  def default_delimiter; end
  def node_body(node); end
  def preferred_delimiter; end
  def preferred_delimiters_config; end
end

RuboCop::Cop::Style::CommandLiteral::MSG_USE_BACKTICKS = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::CommandLiteral::MSG_USE_PERCENT_X = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::CommentAnnotation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_new_investigation; end

  private

  def annotation_range(annotation); end
  def correct_offense(corrector, range, keyword); end
  def first_comment_line?(comments, index); end
  def inline_comment?(comment); end
  def keywords; end
  def register_offense(annotation); end
  def requires_colon?; end
end

RuboCop::Cop::Style::CommentAnnotation::MISSING_NOTE = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::CommentAnnotation::MSG_COLON_STYLE = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::CommentAnnotation::MSG_SPACE_STYLE = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::CommentedKeyword < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_new_investigation; end

  private

  def offensive?(comment); end
  def register_offense(comment, matched_keyword); end
  def source_line(comment); end
end

RuboCop::Cop::Style::CommentedKeyword::ALLOWED_COMMENTS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Style::CommentedKeyword::ALLOWED_COMMENT_REGEXES = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Style::CommentedKeyword::KEYWORDS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Style::CommentedKeyword::KEYWORD_REGEXES = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Style::CommentedKeyword::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::CommentedKeyword::REGEXP = T.let(T.unsafe(nil), Regexp)

class RuboCop::Cop::Style::ConditionalAssignment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def assignment_type?(param0 = T.unsafe(nil)); end
  def candidate_condition?(param0 = T.unsafe(nil)); end
  def on_and_asgn(node); end
  def on_case(node); end
  def on_case_match(node); end
  def on_casgn(node); end
  def on_cvasgn(node); end
  def on_gvasgn(node); end
  def on_if(node); end
  def on_ivasgn(node); end
  def on_lvasgn(node); end
  def on_masgn(node); end
  def on_op_asgn(node); end
  def on_or_asgn(node); end
  def on_send(node); end

  private

  def allowed_single_line?(branches); end
  def allowed_statements?(branches); end
  def allowed_ternary?(assignment); end
  def assignment_node(node); end
  def assignment_types_match?(*nodes); end
  def autocorrect(corrector, node); end
  def candidate_node?(node); end
  def check_assignment_to_condition(node); end
  def check_node(node, branches); end
  def correction_exceeds_line_limit?(node, branches); end
  def include_ternary?; end
  def indentation_width; end
  def lhs_all_match?(branches); end
  def line_length_cop_enabled?; end
  def longest_line(node, assignment); end
  def longest_line_exceeds_line_limit?(node, assignment); end
  def max_line_length; end
  def move_assignment_inside_condition(corrector, node); end
  def move_assignment_outside_condition(corrector, node); end
  def single_line_conditions_only?; end
  def ternary_condition?(node); end
end

RuboCop::Cop::Style::ConditionalAssignment::ASSIGNMENT_TYPES = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Style::ConditionalAssignment::ASSIGN_TO_CONDITION_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::ConditionalAssignment::ENABLED = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::ConditionalAssignment::INDENTATION_WIDTH = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::ConditionalAssignment::LINE_LENGTH = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::ConditionalAssignment::MAX = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::ConditionalAssignment::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::ConditionalAssignment::SINGLE_LINE_CONDITIONS_ONLY = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::ConditionalAssignment::VARIABLE_ASSIGNMENT_TYPES = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Style::ConditionalAssignment::WIDTH = T.let(T.unsafe(nil), String)

module RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::AST::NodePattern::Macros

  def end_with_eq?(sym); end
  def expand_elses(branch); end
  def expand_when_branches(when_branches); end
  def indent(cop, source); end
  def lhs(node); end
  def tail(branch); end

  private

  def assignment_rhs_exist?(node); end
  def expand_elsif(node, elsif_branches = T.unsafe(nil)); end
  def lhs_for_casgn(node); end
  def lhs_for_send(node); end
  def setter_method?(method_name); end
end

RuboCop::Cop::Style::ConditionalAssignmentHelper::ALIGN_WITH = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::ConditionalAssignmentHelper::END_ALIGNMENT = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::ConditionalAssignmentHelper::EQUAL = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::ConditionalAssignmentHelper::KEYWORD = T.let(T.unsafe(nil), String)

module RuboCop::Cop::Style::ConditionalCorrectorHelper
  def assignment(node); end
  def correct_branches(corrector, branches); end
  def correct_if_branches(corrector, cop, node); end
  def remove_whitespace_in_branches(corrector, branch, condition, column); end
  def replace_branch_assignment(corrector, branch); end
  def white_space_range(node, column); end
end

class RuboCop::Cop::Style::ConstantVisibility < ::RuboCop::Cop::Base
  def on_casgn(node); end
  def visibility_declaration_for?(param0 = T.unsafe(nil), param1); end

  private

  def class_or_module_scope?(node); end
  def ignore_modules?; end
  def match_name?(name, constant_name); end
  def message(node); end
  def module?(node); end
  def visibility_declaration?(node); end
end

RuboCop::Cop::Style::ConstantVisibility::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::Copyright < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_new_investigation; end

  private

  def autocorrect_notice; end
  def encoding_token?(processed_source, token_index); end
  def insert_notice_before(processed_source); end
  def notice; end
  def notice_found?(processed_source); end
  def offense_range; end
  def shebang_token?(processed_source, token_index); end
  def verify_autocorrect_notice!; end
end

RuboCop::Cop::Style::Copyright::AUTOCORRECT_EMPTY_WARNING = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::Copyright::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::DateTime < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def date_time?(param0 = T.unsafe(nil)); end
  def historic_date?(param0 = T.unsafe(nil)); end
  def on_send(node); end
  def to_datetime?(param0 = T.unsafe(nil)); end

  private

  def autocorrect(corrector, node); end
  def disallow_coercion?; end
end

RuboCop::Cop::Style::DateTime::CLASS_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::DateTime::COERCION_MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::DefWithParentheses < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_def(node); end
  def on_defs(node); end
end

RuboCop::Cop::Style::DefWithParentheses::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::Dir < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def dir_replacement?(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def file_keyword?(node); end
end

RuboCop::Cop::Style::Dir::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::Dir::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::DisableCopsWithinSourceCodeDirective < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_new_investigation; end

  private

  def allowed_cops; end
  def any_cops_allowed?; end
  def directive_cops(comment); end
  def register_offense(comment, directive_cops, disallowed_cops); end
end

RuboCop::Cop::Style::DisableCopsWithinSourceCodeDirective::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::DisableCopsWithinSourceCodeDirective::MSG_FOR_COPS = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::DocumentDynamicEvalDefinition < ::RuboCop::Cop::Base
  def on_send(node); end

  private

  def comment_block_docs?(arg_node); end
  def comment_regexp(arg_node); end
  def heredoc_comment_blocks(heredoc_body); end
  def inline_comment_docs?(node); end
  def interpolated?(arg_node); end
  def merge_adjacent_comments(line, index, hash); end
  def preceding_comment_blocks(node); end
  def source_to_regexp(source); end
end

RuboCop::Cop::Style::DocumentDynamicEvalDefinition::BLOCK_COMMENT_REGEXP = T.let(T.unsafe(nil), Regexp)
RuboCop::Cop::Style::DocumentDynamicEvalDefinition::COMMENT_REGEXP = T.let(T.unsafe(nil), Regexp)
RuboCop::Cop::Style::DocumentDynamicEvalDefinition::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::DocumentDynamicEvalDefinition::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::Documentation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::DocumentationComment
  include ::RuboCop::Cop::RangeHelp

  def constant_definition?(param0 = T.unsafe(nil)); end
  def constant_visibility_declaration?(param0 = T.unsafe(nil)); end
  def on_class(node); end
  def on_module(node); end
  def outer_module(param0); end

  private

  def allowed_constants; end
  def check(node, body); end
  def compact_namespace?(node); end
  def constant_allowed?(node); end
  def constant_declaration?(node); end
  def identifier(node); end
  def macro_only?(body); end
  def namespace?(node); end
  def nodoc(node); end
  def nodoc?(comment, require_all: T.unsafe(nil)); end
  def nodoc_comment?(node, require_all: T.unsafe(nil)); end
  def nodoc_self_or_outer_module?(node); end
  def qualify_const(node); end
end

RuboCop::Cop::Style::Documentation::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::DocumentationMethod < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::DocumentationComment
  include ::RuboCop::Cop::DefNode

  def module_function_node?(param0 = T.unsafe(nil)); end
  def on_def(node); end
  def on_defs(node); end

  private

  def check(node); end
  def require_for_non_public_methods?; end
end

RuboCop::Cop::Style::DocumentationMethod::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::DoubleCopDisableDirective < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_new_investigation; end
end

RuboCop::Cop::Style::DoubleCopDisableDirective::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::DoubleNegation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def double_negative?(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def allowed_in_returns?(node); end
  def end_of_method_definition?(node); end
  def find_def_node_from_ascendant(node); end
  def find_last_child(node); end
end

RuboCop::Cop::Style::DoubleNegation::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::DoubleNegation::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::EachForSimpleLoop < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def offending_each_range(param0 = T.unsafe(nil)); end
  def on_block(node); end
end

RuboCop::Cop::Style::EachForSimpleLoop::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::EachWithObject < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def each_with_object_candidate?(param0 = T.unsafe(nil)); end
  def on_block(node); end

  private

  def accumulator_param_assigned_to?(body, args); end
  def autocorrect(corrector, node, return_value); end
  def first_argument_returned?(args, return_value); end
  def return_value(body); end
  def return_value_occupies_whole_line?(node); end
  def simple_method_arg?(method_arg); end
  def whole_line_expression(node); end
end

RuboCop::Cop::Style::EachWithObject::METHODS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Style::EachWithObject::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::EmptyBlockParameter < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::EmptyParameter
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_block(node); end

  private

  def autocorrect(corrector, node); end
end

RuboCop::Cop::Style::EmptyBlockParameter::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::EmptyCaseCondition < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_case(case_node); end

  private

  def autocorrect(corrector, case_node); end
  def correct_case_when(corrector, case_node, when_nodes); end
  def correct_when_conditions(corrector, when_nodes); end
  def keep_first_when_comment(case_range, corrector); end
  def replace_then_with_line_break(corrector, conditions, when_node); end
end

RuboCop::Cop::Style::EmptyCaseCondition::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::EmptyElse < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::OnNormalIfUnless
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_case(node); end
  def on_normal_if_unless(node); end

  private

  def autocorrect(corrector, node); end
  def autocorrect_forbidden?(type); end
  def base_node(node); end
  def check(node); end
  def comment_in_else?(loc); end
  def empty_check(node); end
  def empty_style?; end
  def missing_else_style; end
  def nil_check(node); end
  def nil_style?; end
end

RuboCop::Cop::Style::EmptyElse::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::EmptyLambdaParameter < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::EmptyParameter
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_block(node); end

  private

  def autocorrect(corrector, node); end
end

RuboCop::Cop::Style::EmptyLambdaParameter::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::EmptyLiteral < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::FrozenStringLiteral
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def array_node(param0 = T.unsafe(nil)); end
  def array_with_block(param0 = T.unsafe(nil)); end
  def hash_node(param0 = T.unsafe(nil)); end
  def hash_with_block(param0 = T.unsafe(nil)); end
  def on_send(node); end
  def str_node(param0 = T.unsafe(nil)); end

  private

  def correction(node); end
  def enforce_double_quotes?; end
  def first_argument_unparenthesized?(node); end
  def frozen_strings?; end
  def offense_array_node?(node); end
  def offense_hash_node?(node); end
  def offense_message(node); end
  def preferred_string_literal; end
  def replacement_range(node); end
  def string_literals_config; end
end

RuboCop::Cop::Style::EmptyLiteral::ARR_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::EmptyLiteral::HASH_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::EmptyLiteral::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Style::EmptyLiteral::STR_MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::EmptyMethod < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def on_def(node); end
  def on_defs(node); end

  private

  def compact?(node); end
  def compact_style?; end
  def correct_style?(node); end
  def corrected(node); end
  def expanded?(node); end
  def expanded_style?; end
  def joint(node); end
  def message(_range); end
end

RuboCop::Cop::Style::EmptyMethod::MSG_COMPACT = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::EmptyMethod::MSG_EXPANDED = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::Encoding < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_new_investigation; end

  private

  def comments; end
  def offense?(comment); end
  def register_offense(line_number, comment); end
end

RuboCop::Cop::Style::Encoding::ENCODING_PATTERN = T.let(T.unsafe(nil), Regexp)
RuboCop::Cop::Style::Encoding::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::Encoding::SHEBANG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::EndBlock < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_postexe(node); end
end

RuboCop::Cop::Style::EndBlock::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::EndlessMethod < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::TargetRubyVersion
  extend ::RuboCop::Cop::AutoCorrector

  def on_def(node); end

  private

  def arguments(node, missing = T.unsafe(nil)); end
  def correct_to_multiline(corrector, node); end
  def handle_allow_style(node); end
  def handle_disallow_style(node); end
end

RuboCop::Cop::Style::EndlessMethod::CORRECTION_STYLES = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Style::EndlessMethod::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::EndlessMethod::MSG_MULTI_LINE = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::EvalWithLocation < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def line_with_offset?(param0 = T.unsafe(nil), param1, param2); end
  def on_send(node); end
  def valid_eval_receiver?(param0 = T.unsafe(nil)); end

  private

  def add_offense_for_different_line(node, line_node, line_diff); end
  def add_offense_for_incorrect_line(method_name, line_node, sign, line_diff); end
  def add_offense_for_missing_line(node, code); end
  def add_offense_for_missing_location(node, code); end
  def add_offense_for_same_line(node, line_node); end
  def check_file(node, file_node); end
  def check_line(node, code); end
  def check_location(node, code); end
  def expected_line(sign, line_diff); end
  def file_and_line(node); end
  def line_difference(line_node, code); end
  def missing_line(node, code); end
  def register_offense(node, &block); end
  def special_file_keyword?(node); end
  def special_line_keyword?(node); end
  def string_first_line(str_node); end
  def with_binding?(node); end
  def with_lineno?(node); end
end

RuboCop::Cop::Style::EvalWithLocation::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::EvalWithLocation::MSG_EVAL = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::EvalWithLocation::MSG_INCORRECT_FILE = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::EvalWithLocation::MSG_INCORRECT_LINE = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::EvalWithLocation::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::EvenOdd < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def even_odd_candidate?(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def replacement_method(arg, method); end
end

RuboCop::Cop::Style::EvenOdd::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::EvenOdd::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::ExpandPathArguments < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def file_expand_path(param0 = T.unsafe(nil)); end
  def on_send(node); end
  def pathname_new_parent_expand_path(param0 = T.unsafe(nil)); end
  def pathname_parent_expand_path(param0 = T.unsafe(nil)); end

  private

  def arguments_range(node); end
  def autocorrect(corrector, node); end
  def autocorrect_expand_path(corrector, current_path, default_dir); end
  def depth(current_path); end
  def inspect_offense_for_expand_path(node, current_path, default_dir); end
  def parent_path(current_path); end
  def remove_parent_method(corrector, default_dir); end
  def strip_surrounded_quotes!(path_string); end
  def unrecommended_argument?(default_dir); end
end

RuboCop::Cop::Style::ExpandPathArguments::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::ExpandPathArguments::PATHNAME_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::ExpandPathArguments::PATHNAME_NEW_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::ExpandPathArguments::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::ExplicitBlockArgument < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def initialize(config = T.unsafe(nil), options = T.unsafe(nil)); end

  def on_yield(node); end
  def yielding_block?(param0 = T.unsafe(nil)); end

  private

  def add_block_argument(node, corrector, block_name); end
  def block_body_range(block_node, send_node); end
  def call_like?(node); end
  def correct_call_node(node, corrector, block_name); end
  def empty_arguments?(node); end
  def extract_block_name(def_node); end
  def insert_argument(node, corrector, block_name); end
  def yielding_arguments?(block_args, yield_args); end
end

RuboCop::Cop::Style::ExplicitBlockArgument::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::ExponentialNotation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  def on_float(node); end

  private

  def engineering?(node); end
  def integral(node); end
  def message(_node); end
  def offense?(node); end
  def scientific?(node); end
end

RuboCop::Cop::Style::ExponentialNotation::MESSAGES = T.let(T.unsafe(nil), Hash)

class RuboCop::Cop::Style::FileRead < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def block_read?(param0 = T.unsafe(nil)); end
  def file_open?(param0 = T.unsafe(nil)); end
  def on_send(node); end
  def send_read?(param0 = T.unsafe(nil)); end

  private

  def evidence(node); end
  def file_open_read?(node); end
  def read_method(mode); end
  def read_node?(node, block_pass); end
end

RuboCop::Cop::Style::FileRead::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::FileRead::READ_FILE_START_TO_FINISH_MODES = T.let(T.unsafe(nil), Set)
RuboCop::Cop::Style::FileRead::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::FileWrite < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def block_write?(param0 = T.unsafe(nil)); end
  def evidence(node); end
  def file_open?(param0 = T.unsafe(nil)); end
  def on_send(node); end
  def send_write?(param0 = T.unsafe(nil)); end

  private

  def file_open_write?(node); end
  def heredoc?(write_node); end
  def heredoc_range(first_argument); end
  def replacement(mode, filename, content, write_node); end
  def write_method(mode); end
end

RuboCop::Cop::Style::FileWrite::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::FileWrite::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Set)
RuboCop::Cop::Style::FileWrite::TRUNCATING_WRITE_MODES = T.let(T.unsafe(nil), Set)

class RuboCop::Cop::Style::FloatDivision < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def any_coerce?(param0 = T.unsafe(nil)); end
  def both_coerce?(param0 = T.unsafe(nil)); end
  def left_coerce?(param0 = T.unsafe(nil)); end
  def on_send(node); end
  def right_coerce?(param0 = T.unsafe(nil)); end

  private

  def add_to_f_method(corrector, node); end
  def correct_from_slash_to_fdiv(corrector, node, receiver, argument); end
  def extract_receiver_source(node); end
  def message(_node); end
  def offense_condition?(node); end
  def remove_to_f_method(corrector, send_node); end
end

RuboCop::Cop::Style::FloatDivision::MESSAGES = T.let(T.unsafe(nil), Hash)
RuboCop::Cop::Style::FloatDivision::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::For < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_block(node); end
  def on_for(node); end

  private

  def suspect_enumerable?(node); end
end

RuboCop::Cop::Style::For::EACH_LENGTH = T.let(T.unsafe(nil), Integer)
RuboCop::Cop::Style::For::PREFER_EACH = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::For::PREFER_FOR = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::FormatString < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def formatter(param0 = T.unsafe(nil)); end
  def on_send(node); end
  def variable_argument?(param0 = T.unsafe(nil)); end

  private

  def autocorrect(corrector, node); end
  def autocorrect_from_percent(corrector, node); end
  def autocorrect_to_percent(corrector, node); end
  def format_single_parameter(arg); end
  def message(detected_style); end
  def method_name(style_name); end
end

RuboCop::Cop::Style::FormatString::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::FormatString::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::FormatStringToken < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::IgnoredMethods
  extend ::RuboCop::Cop::IgnoredMethods::Config

  def format_string_in_typical_context?(param0 = T.unsafe(nil)); end
  def on_str(node); end

  private

  def allowed_unannotated?(detections); end
  def collect_detections(node); end
  def format_string_token?(node); end
  def max_unannotated_placeholders_allowed; end
  def message(detected_style); end
  def message_text(style); end
  def str_contents(source_map); end
  def token_ranges(contents); end
  def tokens(str_node, &block); end
  def unannotated_format?(node, detected_style); end
  def use_ignored_method?(node); end
end

class RuboCop::Cop::Style::FrozenStringLiteralComment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::FrozenStringLiteral
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_new_investigation; end

  private

  def disabled_offense(processed_source); end
  def enable_comment(corrector); end
  def ensure_comment(processed_source); end
  def ensure_enabled_comment(processed_source); end
  def ensure_no_comment(processed_source); end
  def following_comment; end
  def frozen_string_literal_comment(processed_source); end
  def insert_comment(corrector); end
  def last_special_comment(processed_source); end
  def line_range(line); end
  def missing_offense(processed_source); end
  def missing_true_offense(processed_source); end
  def preceding_comment; end
  def remove_comment(corrector, node); end
  def unnecessary_comment_offense(processed_source); end
end

RuboCop::Cop::Style::FrozenStringLiteralComment::MSG_DISABLED = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::FrozenStringLiteralComment::MSG_MISSING = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::FrozenStringLiteralComment::MSG_MISSING_TRUE = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::FrozenStringLiteralComment::MSG_UNNECESSARY = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::FrozenStringLiteralComment::SHEBANG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::GlobalStdStream < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def const_to_gvar_assignment?(param0 = T.unsafe(nil), param1); end
  def on_const(node); end

  private

  def gvar_name(const_name); end
  def message(const_name); end
end

RuboCop::Cop::Style::GlobalStdStream::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::GlobalStdStream::STD_STREAMS = T.let(T.unsafe(nil), Set)

class RuboCop::Cop::Style::GlobalVars < ::RuboCop::Cop::Base
  def allowed_var?(global_var); end
  def check(node); end
  def on_gvar(node); end
  def on_gvasgn(node); end
  def user_vars; end
end

RuboCop::Cop::Style::GlobalVars::BUILT_IN_VARS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Style::GlobalVars::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::GuardClause < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::MinBodyLength
  include ::RuboCop::Cop::LineLengthHelp
  include ::RuboCop::Cop::StatementModifier

  def on_def(node); end
  def on_defs(node); end
  def on_if(node); end

  private

  def accepted_form?(node, ending: T.unsafe(nil)); end
  def accepted_if?(node, ending); end
  def check_ending_if(node); end
  def guard_clause_source(guard_clause); end
  def opposite_keyword(node); end
  def register_offense(node, scope_exiting_keyword, conditional_keyword); end
  def too_long_for_single_line?(node, example); end
end

RuboCop::Cop::Style::GuardClause::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::HashAsLastArrayItem < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def on_hash(node); end

  private

  def braces_style?; end
  def check_braces(node); end
  def check_no_braces(node); end
  def containing_array(hash_node); end
  def explicit_array?(array); end
  def last_array_item?(array, node); end
  def remove_last_element_trailing_comma(corrector, node); end
end

class RuboCop::Cop::Style::HashConversion < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def hash_from_array?(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def allowed_splat_argument?; end
  def args_to_hash(args); end
  def multi_argument(node); end
  def register_offense_for_hash(node, hash_argument); end
  def register_offense_for_zip_method(node, zip_method); end
  def requires_parens?(node); end
  def single_argument(node); end
  def use_zip_method_without_argument?(first_argument); end
end

RuboCop::Cop::Style::HashConversion::MSG_LITERAL_HASH_ARG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::HashConversion::MSG_LITERAL_MULTI_ARG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::HashConversion::MSG_SPLAT = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::HashConversion::MSG_TO_H = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::HashConversion::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::HashEachMethods < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Lint::UnusedArgument
  extend ::RuboCop::Cop::AutoCorrector

  def kv_each(param0 = T.unsafe(nil)); end
  def on_block(node); end

  private

  def allowed_receiver?(receiver); end
  def allowed_receivers; end
  def check_argument(variable); end
  def correct_args(node, corrector); end
  def correct_implicit(node, corrector, method_name); end
  def correct_key_value_each(node, corrector); end
  def kv_range(outer_node); end
  def register_kv_offense(node); end
  def used?(arg); end
end

RuboCop::Cop::Style::HashEachMethods::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::HashExcept < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::TargetRubyVersion
  extend ::RuboCop::Cop::AutoCorrector

  def bad_method?(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def except_key(node); end
  def offense_range(node); end
  def safe_to_register_offense?(block, except_key); end
  def semantically_except_method?(send, block); end
end

RuboCop::Cop::Style::HashExcept::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::HashExcept::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::HashLikeCase < ::RuboCop::Cop::Base
  def hash_like_case?(param0 = T.unsafe(nil)); end
  def on_case(node); end

  private

  def min_branches_count; end
  def nodes_of_same_type?(nodes); end
end

RuboCop::Cop::Style::HashLikeCase::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::HashSyntax < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::HashShorthandSyntax
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def alternative_style; end
  def hash_rockets_check(pairs); end
  def no_mixed_keys_check(pairs); end
  def on_hash(node); end
  def ruby19_check(pairs); end
  def ruby19_no_mixed_keys_check(pairs); end

  private

  def acceptable_19_syntax_symbol?(sym_name); end
  def argument_without_space?(node); end
  def autocorrect(corrector, node); end
  def autocorrect_hash_rockets(corrector, pair_node); end
  def autocorrect_no_mixed_keys(corrector, pair_node); end
  def autocorrect_ruby19(corrector, pair_node); end
  def check(pairs, delim, msg); end
  def force_hash_rockets?(pairs); end
  def range_for_autocorrect_ruby19(pair_node); end
  def sym_indices?(pairs); end
  def word_symbol_pair?(pair); end
end

RuboCop::Cop::Style::HashSyntax::MSG_19 = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::HashSyntax::MSG_HASH_ROCKETS = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::HashSyntax::MSG_NO_MIXED_KEYS = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::HashTransformKeys < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::HashTransformMethod
  extend ::RuboCop::Cop::AutoCorrector

  def on_bad_each_with_object(param0 = T.unsafe(nil)); end
  def on_bad_hash_brackets_map(param0 = T.unsafe(nil)); end
  def on_bad_map_to_h(param0 = T.unsafe(nil)); end
  def on_bad_to_h(param0 = T.unsafe(nil)); end

  private

  def extract_captures(match); end
  def new_method_name; end
end

class RuboCop::Cop::Style::HashTransformValues < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::HashTransformMethod
  extend ::RuboCop::Cop::AutoCorrector

  def on_bad_each_with_object(param0 = T.unsafe(nil)); end
  def on_bad_hash_brackets_map(param0 = T.unsafe(nil)); end
  def on_bad_map_to_h(param0 = T.unsafe(nil)); end
  def on_bad_to_h(param0 = T.unsafe(nil)); end

  private

  def extract_captures(match); end
  def new_method_name; end
end

class RuboCop::Cop::Style::IdenticalConditionalBranches < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_case(node); end
  def on_case_match(node); end
  def on_if(node); end

  private

  def check_branches(node, branches); end
  def check_expressions(node, expressions, insert_position); end
  def duplicated_expressions?(node, expressions); end
  def expand_elses(branch); end
  def head(node); end
  def message(node); end
  def tail(node); end
end

RuboCop::Cop::Style::IdenticalConditionalBranches::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::IfCorrector
  extend ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper

  class << self
    def correct(corrector, cop, node); end
    def move_assignment_inside_condition(corrector, node); end

    private

    def extract_tail_branches(node); end
    def move_branch_inside_condition(corrector, branch, condition, assignment, column); end
  end
end

class RuboCop::Cop::Style::IfInsideElse < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_if(node); end

  private

  def allow_if_modifier?; end
  def allow_if_modifier_in_else_branch?(else_branch); end
  def autocorrect(corrector, node); end
  def correct_to_elsif_from_if_inside_else_form(corrector, node, condition); end
  def correct_to_elsif_from_modifier_form(corrector, node); end
  def find_end_range(node); end
  def if_condition_range(node, condition); end
  def then?(node); end
end

RuboCop::Cop::Style::IfInsideElse::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::IfUnlessModifier < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::LineLengthHelp
  include ::RuboCop::Cop::StatementModifier
  include ::RuboCop::Cop::IgnoredPattern
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_if(node); end

  private

  def another_statement_on_same_line?(node); end
  def autocorrect(corrector, node); end
  def extract_heredoc_from(last_argument); end
  def ignored_patterns; end
  def line_length_enabled_at_line?(line); end
  def named_capture_in_condition?(node); end
  def non_eligible_node?(node); end
  def non_simple_if_unless?(node); end
  def remove_heredoc(corrector, heredoc); end
  def to_normal_form(node, indentation); end
  def to_normal_form_with_heredoc(node, indentation, heredoc); end
  def too_long_due_to_modifier?(node); end
  def too_long_line_based_on_allow_uri?(line); end
  def too_long_line_based_on_config?(range, line); end
  def too_long_line_based_on_ignore_cop_directives?(range, line); end
  def too_long_single_line?(node); end

  class << self
    def autocorrect_incompatible_with; end
  end
end

RuboCop::Cop::Style::IfUnlessModifier::MSG_USE_MODIFIER = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::IfUnlessModifier::MSG_USE_NORMAL = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::IfUnlessModifierOfIfUnless < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::LineLengthHelp
  include ::RuboCop::Cop::StatementModifier
  extend ::RuboCop::Cop::AutoCorrector

  def on_if(node); end
end

RuboCop::Cop::Style::IfUnlessModifierOfIfUnless::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::IfWithBooleanLiteralBranches < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::AllowedMethods
  extend ::RuboCop::Cop::AutoCorrector

  def double_negative?(param0 = T.unsafe(nil)); end
  def if_with_boolean_literal_branches?(param0 = T.unsafe(nil)); end
  def on_if(node); end

  private

  def assume_boolean_value?(condition); end
  def message(node, keyword); end
  def offense_range_with_keyword(node, condition); end
  def opposite_condition?(node); end
  def replacement_condition(node, condition); end
  def require_parentheses?(condition); end
  def return_boolean_value?(condition); end
end

RuboCop::Cop::Style::IfWithBooleanLiteralBranches::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::IfWithBooleanLiteralBranches::MSG_FOR_ELSIF = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::IfWithSemicolon < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::OnNormalIfUnless
  extend ::RuboCop::Cop::AutoCorrector

  def on_normal_if_unless(node); end

  private

  def autocorrect(node); end
  def build_else_branch(second_condition); end
  def correct_elsif(node); end
end

RuboCop::Cop::Style::IfWithSemicolon::MSG_IF_ELSE = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::IfWithSemicolon::MSG_TERNARY = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::ImplicitRuntimeError < ::RuboCop::Cop::Base
  def implicit_runtime_error_raise_or_fail(param0 = T.unsafe(nil)); end
  def on_send(node); end
end

RuboCop::Cop::Style::ImplicitRuntimeError::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::ImplicitRuntimeError::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::InPatternThen < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion

  def on_in_pattern(node); end

  private

  def alternative_pattern_source(pattern); end
end

RuboCop::Cop::Style::InPatternThen::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::InfiniteLoop < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def after_leaving_scope(scope, _variable_table); end
  def on_until(node); end
  def on_until_post(node); end
  def on_while(node); end
  def on_while_post(node); end

  private

  def assigned_before_loop?(var, range); end
  def assigned_inside_loop?(var, range); end
  def autocorrect(corrector, node); end
  def configured_indent; end
  def modifier_replacement(node); end
  def non_modifier_range(node); end
  def referenced_after_loop?(var, range); end
  def replace_begin_end_with_modifier(corrector, node); end
  def replace_source(corrector, range, replacement); end
  def while_or_until(node); end

  class << self
    def joining_forces; end
  end
end

RuboCop::Cop::Style::InfiniteLoop::LEADING_SPACE = T.let(T.unsafe(nil), Regexp)
RuboCop::Cop::Style::InfiniteLoop::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::InlineComment < ::RuboCop::Cop::Base
  def on_new_investigation; end
end

RuboCop::Cop::Style::InlineComment::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::InverseMethods < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def inverse_block?(param0 = T.unsafe(nil)); end
  def inverse_candidate?(param0 = T.unsafe(nil)); end
  def on_block(node); end
  def on_send(node); end

  private

  def camel_case_constant?(node); end
  def correct_inverse_block(corrector, node); end
  def correct_inverse_method(corrector, node); end
  def correct_inverse_selector(block, corrector); end
  def dot_range(loc); end
  def end_parentheses(node, method_call); end
  def inverse_blocks; end
  def inverse_methods; end
  def message(method, inverse); end
  def negated?(node); end
  def not_to_receiver(node, method_call); end
  def possible_class_hierarchy_check?(lhs, rhs, method); end
  def remove_end_parenthesis(corrector, node, method, method_call); end

  class << self
    def autocorrect_incompatible_with; end
  end
end

RuboCop::Cop::Style::InverseMethods::CAMEL_CASE = T.let(T.unsafe(nil), Regexp)
RuboCop::Cop::Style::InverseMethods::CLASS_COMPARISON_METHODS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Style::InverseMethods::EQUALITY_METHODS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Style::InverseMethods::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::InverseMethods::NEGATED_EQUALITY_METHODS = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::IpAddresses < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::StringHelp

  def correct_style_detected; end
  def offense?(node); end
  def opposite_style_detected; end

  private

  def allowed_addresses; end
  def could_be_ip?(str); end
  def starts_with_hex_or_colon?(str); end
  def too_long?(str); end
end

RuboCop::Cop::Style::IpAddresses::IPV6_MAX_SIZE = T.let(T.unsafe(nil), Integer)
RuboCop::Cop::Style::IpAddresses::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::KeywordParametersOrder < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_kwoptarg(node); end

  private

  def append_newline_to_last_kwoptarg(arguments, corrector); end
  def remove_kwargs(kwarg_nodes, corrector); end
end

RuboCop::Cop::Style::KeywordParametersOrder::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::Lambda < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def on_block(node); end
  def on_numblock(node); end

  private

  def arguments_with_whitespace(node); end
  def autocorrect_method_to_literal(corrector, node); end
  def lambda_arg_string(args); end
  def message(node, selector); end
  def message_line_modifier(node); end
  def offending_selector?(node, selector); end
end

RuboCop::Cop::Style::Lambda::LITERAL_MESSAGE = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::Lambda::METHOD_MESSAGE = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::Lambda::OFFENDING_SELECTORS = T.let(T.unsafe(nil), Hash)

class RuboCop::Cop::Style::LambdaCall < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def autocorrect(corrector, node); end
  def on_send(node); end

  private

  def explicit_style?; end
  def implicit_style?; end
  def message(_node); end
  def offense?(node); end
end

RuboCop::Cop::Style::LambdaCall::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::LineEndConcatenation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_new_investigation; end

  private

  def autocorrect(corrector, operator_range); end
  def check_token_set(index); end
  def eligible_next_successor?(next_successor); end
  def eligible_operator?(operator); end
  def eligible_predecessor?(predecessor); end
  def eligible_successor?(successor); end
  def eligible_token_set?(predecessor, operator, successor); end
  def standard_string_literal?(token); end
  def token_after_last_string(successor, base_index); end

  class << self
    def autocorrect_incompatible_with; end
  end
end

RuboCop::Cop::Style::LineEndConcatenation::COMPLEX_STRING_BEGIN_TOKEN = T.let(T.unsafe(nil), Symbol)
RuboCop::Cop::Style::LineEndConcatenation::COMPLEX_STRING_END_TOKEN = T.let(T.unsafe(nil), Symbol)
RuboCop::Cop::Style::LineEndConcatenation::CONCAT_TOKEN_TYPES = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Style::LineEndConcatenation::HIGH_PRECEDENCE_OP_TOKEN_TYPES = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Style::LineEndConcatenation::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::LineEndConcatenation::QUOTE_DELIMITERS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Style::LineEndConcatenation::SIMPLE_STRING_TOKEN_TYPE = T.let(T.unsafe(nil), Symbol)

class RuboCop::Cop::Style::MapToHash < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion

  def map_to_h?(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def autocorrect(corrector, to_h, map); end
end

RuboCop::Cop::Style::MapToHash::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::MapToHash::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::MethodCallWithArgsParentheses < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::IgnoredMethods
  include ::RuboCop::Cop::IgnoredPattern
  include ::RuboCop::Cop::Style::MethodCallWithArgsParentheses::RequireParentheses
  include ::RuboCop::Cop::Style::MethodCallWithArgsParentheses::OmitParentheses
  extend ::RuboCop::Cop::IgnoredMethods::Config
  extend ::RuboCop::Cop::AutoCorrector

  def on_csend(node); end
  def on_send(node); end
  def on_super(node); end
  def on_yield(node); end

  private

  def args_begin(node); end
  def args_end(node); end
  def args_parenthesized?(node); end

  class << self
    def autocorrect_incompatible_with; end
  end
end

module RuboCop::Cop::Style::MethodCallWithArgsParentheses::OmitParentheses
  private

  def allowed_camel_case_method_call?(node); end
  def allowed_chained_call_with_parentheses?(node); end
  def allowed_multiline_call_with_parentheses?(node); end
  def allowed_string_interpolation_method_call?(node); end
  def ambigious_literal?(node); end
  def assigned_before?(node, target); end
  def auto_correct(corrector, node); end
  def call_as_argument_or_chain?(node); end
  def call_in_literals?(node); end
  def call_in_logical_operators?(node); end
  def call_in_optional_arguments?(node); end
  def call_in_single_line_inheritance?(node); end
  def call_with_ambiguous_arguments?(node); end
  def call_with_braced_block?(node); end
  def exist_next_line_expression?(node); end
  def hash_literal?(node); end
  def hash_literal_in_arguments?(node); end
  def inside_endless_method_def?(node); end
  def inside_string_interpolation?(node); end
  def legitimate_call_with_parentheses?(node); end
  def logical_operator?(node); end
  def modifier_form?(node); end
  def offense_range(node); end
  def omit_parentheses(node); end
  def parentheses_at_the_end_of_multiline_call?(node); end
  def regexp_slash_literal?(node); end
  def require_parentheses_for_hash_value_omission?(node); end
  def splat?(node); end
  def super_call_without_arguments?(node); end
  def syntax_like_method_call?(node); end
  def ternary_if?(node); end
  def unary_literal?(node); end
end

RuboCop::Cop::Style::MethodCallWithArgsParentheses::OmitParentheses::OMIT_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::MethodCallWithArgsParentheses::OmitParentheses::TRAILING_WHITESPACE_REGEX = T.let(T.unsafe(nil), Regexp)

module RuboCop::Cop::Style::MethodCallWithArgsParentheses::RequireParentheses
  private

  def eligible_for_parentheses_omission?(node); end
  def ignored_macro?(node); end
  def included_macros_list; end
  def require_parentheses(node); end
end

RuboCop::Cop::Style::MethodCallWithArgsParentheses::RequireParentheses::REQUIRE_MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::MethodCallWithoutArgsParentheses < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::IgnoredMethods
  extend ::RuboCop::Cop::IgnoredMethods::Config
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end

  private

  def any_assignment?(node); end
  def default_argument?(node); end
  def ineligible_node?(node); end
  def offense_range(node); end
  def register_offense(node); end
  def same_name_assignment?(node); end
  def variable_in_mass_assignment?(variable_name, node); end
end

RuboCop::Cop::Style::MethodCallWithoutArgsParentheses::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::MethodCalledOnDoEndBlock < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp

  def on_block(node); end
  def on_csend(node); end
  def on_send(node); end
end

RuboCop::Cop::Style::MethodCalledOnDoEndBlock::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::MethodDefParentheses < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_def(node); end
  def on_defs(node); end

  private

  def anonymous_block_arg?(node); end
  def arguments_without_parentheses?(node); end
  def correct_arguments(arg_node, corrector); end
  def forced_parentheses?(node); end
  def missing_parentheses(node); end
  def require_parentheses?(args); end
  def unwanted_parentheses(args); end
end

RuboCop::Cop::Style::MethodDefParentheses::MSG_MISSING = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::MethodDefParentheses::MSG_PRESENT = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::MinMax < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def min_max_candidate(param0 = T.unsafe(nil)); end
  def on_array(node); end
  def on_return(node); end

  private

  def argument_range(node); end
  def message(offender, receiver); end
  def offending_range(node); end
end

RuboCop::Cop::Style::MinMax::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::MissingElse < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::OnNormalIfUnless
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  def on_case(node); end
  def on_case_match(node); end
  def on_normal_if_unless(node); end

  private

  def case_style?; end
  def check(node); end
  def empty_else_config; end
  def empty_else_cop_enabled?; end
  def empty_else_style; end
  def if_style?; end
  def message_template; end
  def unless_else_config; end
  def unless_else_cop_enabled?; end
end

RuboCop::Cop::Style::MissingElse::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::MissingElse::MSG_EMPTY = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::MissingElse::MSG_NIL = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::MissingRespondToMissing < ::RuboCop::Cop::Base
  def on_def(node); end
  def on_defs(node); end

  private

  def implements_respond_to_missing?(node); end
end

RuboCop::Cop::Style::MissingRespondToMissing::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::MixinGrouping < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def on_class(node); end
  def on_module(node); end

  private

  def check(send_node); end
  def check_grouped_style(send_node); end
  def check_separated_style(send_node); end
  def group_mixins(node, mixins); end
  def grouped_style?; end
  def range_to_remove_for_subsequent_mixin(mixins, node); end
  def separate_mixins(node); end
  def separated_style?; end
  def sibling_mixins(send_node); end
end

RuboCop::Cop::Style::MixinGrouping::MIXIN_METHODS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Style::MixinGrouping::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::MixinUsage < ::RuboCop::Cop::Base
  def in_top_level_scope?(param0 = T.unsafe(nil)); end
  def include_statement(param0 = T.unsafe(nil)); end
  def on_send(node); end
end

RuboCop::Cop::Style::MixinUsage::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::MixinUsage::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::ModuleFunction < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def extend_self_node?(param0 = T.unsafe(nil)); end
  def module_function_node?(param0 = T.unsafe(nil)); end
  def on_module(node); end
  def private_directive?(param0 = T.unsafe(nil)); end

  private

  def check_extend_self(nodes); end
  def check_forbidden(nodes); end
  def check_module_function(nodes); end
  def each_wrong_style(nodes, &block); end
  def message(_range); end
end

RuboCop::Cop::Style::ModuleFunction::EXTEND_SELF_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::ModuleFunction::FORBIDDEN_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::ModuleFunction::MODULE_FUNCTION_MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::MultilineBlockChain < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp

  def on_block(node); end
end

RuboCop::Cop::Style::MultilineBlockChain::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::MultilineIfModifier < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::LineLengthHelp
  include ::RuboCop::Cop::StatementModifier
  include ::RuboCop::Cop::Alignment
  extend ::RuboCop::Cop::AutoCorrector

  def on_if(node); end

  private

  def configured_indentation_width; end
  def indented_body(body, node); end
  def to_normal_if(node); end
end

RuboCop::Cop::Style::MultilineIfModifier::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::MultilineIfThen < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::OnNormalIfUnless
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_normal_if_unless(node); end

  private

  def non_modifier_then?(node); end
end

RuboCop::Cop::Style::MultilineIfThen::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::MultilineIfThen::NON_MODIFIER_THEN = T.let(T.unsafe(nil), Regexp)

class RuboCop::Cop::Style::MultilineInPatternThen < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion

  def on_in_pattern(node); end

  private

  def require_then?(in_pattern_node); end
end

RuboCop::Cop::Style::MultilineInPatternThen::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::MultilineMemoization < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def message(_node); end
  def on_or_asgn(node); end

  private

  def bad_rhs?(rhs); end
  def keyword_autocorrect(node, corrector); end
  def keyword_begin_str(node, node_buf); end
  def keyword_end_str(node, node_buf); end
end

RuboCop::Cop::Style::MultilineMemoization::BRACES_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::MultilineMemoization::KEYWORD_MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::MultilineMethodSignature < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_def(node); end
  def on_defs(node); end

  private

  def arguments_range(node); end
  def autocorrect(corrector, node); end
  def closing_line(node); end
  def correction_exceeds_max_line_length?(node); end
  def definition_width(node); end
  def indentation_width(node); end
  def last_line_source_of_arguments(arguments); end
  def max_line_length; end
  def opening_line(node); end
end

RuboCop::Cop::Style::MultilineMethodSignature::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::MultilineTernaryOperator < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_if(node); end

  private

  def offense?(node); end
end

RuboCop::Cop::Style::MultilineTernaryOperator::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::MultilineWhenThen < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_when(node); end

  private

  def accept_node_type?(node); end
  def require_then?(when_node); end
end

RuboCop::Cop::Style::MultilineWhenThen::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::MultipleComparison < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_new_investigation; end
  def on_or(node); end
  def simple_comparison_lhs?(param0 = T.unsafe(nil)); end
  def simple_comparison_rhs?(param0 = T.unsafe(nil)); end
  def simple_double_comparison?(param0 = T.unsafe(nil)); end

  private

  def allow_method_comparison?; end
  def comparison?(node); end
  def nested_comparison?(node); end
  def nested_variable_comparison?(node); end
  def reset_comparison; end
  def root_of_or_node(or_node); end
  def switch_comparison?(node); end
  def variable_name(node); end
  def variables_in_node(node); end
  def variables_in_simple_node(node); end
end

RuboCop::Cop::Style::MultipleComparison::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::MutableConstant < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Style::MutableConstant::ShareableConstantValue
  include ::RuboCop::Cop::FrozenStringLiteral
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def on_casgn(node); end
  def operation_produces_immutable_object?(param0 = T.unsafe(nil)); end
  def range_enclosed_in_parentheses?(param0 = T.unsafe(nil)); end
  def splat_value(param0 = T.unsafe(nil)); end

  private

  def autocorrect(corrector, node); end
  def check(value); end
  def correct_splat_expansion(corrector, expr, splat_value); end
  def frozen_regexp_or_range_literals?(node); end
  def immutable_literal?(node); end
  def mutable_literal?(value); end
  def on_assignment(value); end
  def requires_parentheses?(node); end
  def shareable_constant_value?(node); end
  def strict_check(value); end
end

RuboCop::Cop::Style::MutableConstant::MSG = T.let(T.unsafe(nil), String)

module RuboCop::Cop::Style::MutableConstant::ShareableConstantValue
  private

  def magic_comment_in_scope(node); end
  def processed_source_till_node(node); end
  def recent_shareable_value?(node); end
  def shareable_constant_value_enabled?(value); end

  class << self
    def magic_comment_in_scope(node); end
    def recent_shareable_value?(node); end
  end
end

class RuboCop::Cop::Style::NegatedIf < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::NegativeConditional
  extend ::RuboCop::Cop::AutoCorrector

  def on_if(node); end

  private

  def correct_style?(node); end
  def message(node); end
end

class RuboCop::Cop::Style::NegatedIfElseCondition < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def double_negation?(param0 = T.unsafe(nil)); end
  def on_if(node); end
  def on_new_investigation; end

  private

  def correct_negated_condition(corrector, node); end
  def corrected_ancestor?(node); end
  def else_range(node); end
  def if_else?(node); end
  def if_range(node); end
  def negated_condition?(node); end
  def swap_branches(corrector, node); end

  class << self
    def autocorrect_incompatible_with; end
  end
end

RuboCop::Cop::Style::NegatedIfElseCondition::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::NegatedIfElseCondition::NEGATED_EQUALITY_METHODS = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::NegatedUnless < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::NegativeConditional
  extend ::RuboCop::Cop::AutoCorrector

  def on_if(node); end

  private

  def correct_style?(node); end
  def message(node); end
end

class RuboCop::Cop::Style::NegatedWhile < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::NegativeConditional
  extend ::RuboCop::Cop::AutoCorrector

  def on_until(node); end
  def on_while(node); end
end

class RuboCop::Cop::Style::NestedModifier < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_if(node); end
  def on_until(node); end
  def on_while(node); end

  private

  def add_parentheses_to_method_arguments(send_node); end
  def autocorrect(corrector, node); end
  def check(node); end
  def left_hand_operand(node, operator); end
  def modifier?(node); end
  def new_expression(inner_node); end
  def replacement_operator(keyword); end
  def requires_parens?(node); end
  def right_hand_operand(node, left_hand_keyword); end
end

RuboCop::Cop::Style::NestedModifier::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::NestedParenthesizedCalls < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::AllowedMethods
  extend ::RuboCop::Cop::AutoCorrector

  def on_csend(node); end
  def on_send(node); end

  private

  def allowed?(send_node); end
  def allowed_omission?(send_node); end
  def autocorrect(corrector, nested); end

  class << self
    def autocorrect_incompatible_with; end
  end
end

RuboCop::Cop::Style::NestedParenthesizedCalls::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::NestedTernaryOperator < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_if(node); end

  private

  def if_node(node); end
  def remove_parentheses(source); end
end

RuboCop::Cop::Style::NestedTernaryOperator::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::Next < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MinBodyLength
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_block(node); end
  def on_for(node); end
  def on_new_investigation; end
  def on_until(node); end
  def on_while(node); end

  private

  def actual_indent(lines, buffer); end
  def allowed_modifier_if?(node); end
  def autocorrect_block(corrector, node); end
  def autocorrect_modifier(corrector, node); end
  def check(node); end
  def cond_range(node, cond); end
  def end_followed_by_whitespace_only?(source_buffer, end_pos); end
  def end_range(node); end
  def ends_with_condition?(body); end
  def exit_body_type?(node); end
  def heredoc_lines(node); end
  def if_else_children?(node); end
  def if_without_else?(node); end
  def offense_location(offense_node); end
  def offense_node(body); end
  def reindent(lines, node, corrector); end
  def reindent_line(corrector, lineno, delta, buffer); end
  def reindentable_lines(node); end
  def simple_if_without_break?(node); end

  class << self
    def autocorrect_incompatible_with; end
  end
end

RuboCop::Cop::Style::Next::EXIT_TYPES = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Style::Next::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::NilComparison < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def nil_check?(param0 = T.unsafe(nil)); end
  def nil_comparison?(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def message(_node); end
  def prefer_comparison?; end
  def style_check?(node, &block); end
end

RuboCop::Cop::Style::NilComparison::EXPLICIT_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::NilComparison::PREDICATE_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::NilComparison::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::NilLambda < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def nil_return?(param0 = T.unsafe(nil)); end
  def on_block(node); end

  private

  def autocorrect(corrector, node); end
end

RuboCop::Cop::Style::NilLambda::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::NonNilCheck < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def nil_check?(param0 = T.unsafe(nil)); end
  def not_and_nil_check?(param0 = T.unsafe(nil)); end
  def not_equal_to_nil?(param0 = T.unsafe(nil)); end
  def on_def(node); end
  def on_defs(node); end
  def on_send(node); end
  def unless_check?(param0 = T.unsafe(nil)); end

  private

  def autocorrect(corrector, node); end
  def autocorrect_comparison(corrector, node); end
  def autocorrect_non_nil(corrector, node, inner_node); end
  def autocorrect_unless_nil(corrector, node, receiver); end
  def include_semantic_changes?; end
  def message(node); end
  def nil_comparison_style; end
  def register_offense?(node); end
  def unless_and_nil_check?(send_node); end
end

RuboCop::Cop::Style::NonNilCheck::MSG_FOR_REDUNDANCY = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::NonNilCheck::MSG_FOR_REPLACEMENT = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::NonNilCheck::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::Not < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end

  private

  def correct_opposite_method(corrector, range, child); end
  def correct_with_parens(corrector, range, node); end
  def correct_without_parens(corrector, range); end
  def opposite_method?(child); end
  def requires_parens?(child); end
end

RuboCop::Cop::Style::Not::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::Not::OPPOSITE_METHODS = T.let(T.unsafe(nil), Hash)
RuboCop::Cop::Style::Not::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::NumberedParameters < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::TargetRubyVersion

  def on_numblock(node); end
end

RuboCop::Cop::Style::NumberedParameters::MSG_DISALLOW = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::NumberedParameters::MSG_MULTI_LINE = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::NumberedParametersLimit < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::TargetRubyVersion

  def max=(value); end
  def on_numblock(node); end

  private

  def max_count; end
end

RuboCop::Cop::Style::NumberedParametersLimit::DEFAULT_MAX_VALUE = T.let(T.unsafe(nil), Integer)
RuboCop::Cop::Style::NumberedParametersLimit::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::NumericLiteralPrefix < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::IntegerNode
  extend ::RuboCop::Cop::AutoCorrector

  def on_int(node); end

  private

  def format_binary(source); end
  def format_decimal(source); end
  def format_hex(source); end
  def format_octal(source); end
  def format_octal_zero_only(source); end
  def hex_bin_dec_literal_type(literal); end
  def literal_type(node); end
  def message(node); end
  def octal_literal_type(literal); end
  def octal_zero_only?; end
end

RuboCop::Cop::Style::NumericLiteralPrefix::BINARY_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::NumericLiteralPrefix::BINARY_REGEX = T.let(T.unsafe(nil), Regexp)
RuboCop::Cop::Style::NumericLiteralPrefix::DECIMAL_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::NumericLiteralPrefix::DECIMAL_REGEX = T.let(T.unsafe(nil), Regexp)
RuboCop::Cop::Style::NumericLiteralPrefix::HEX_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::NumericLiteralPrefix::HEX_REGEX = T.let(T.unsafe(nil), Regexp)
RuboCop::Cop::Style::NumericLiteralPrefix::OCTAL_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::NumericLiteralPrefix::OCTAL_REGEX = T.let(T.unsafe(nil), Regexp)
RuboCop::Cop::Style::NumericLiteralPrefix::OCTAL_ZERO_ONLY_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::NumericLiteralPrefix::OCTAL_ZERO_ONLY_REGEX = T.let(T.unsafe(nil), Regexp)

class RuboCop::Cop::Style::NumericLiterals < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::IntegerNode
  extend ::RuboCop::Cop::AutoCorrector

  def min_digits=(value); end
  def on_float(node); end
  def on_int(node); end

  private

  def allowed_numbers; end
  def check(node); end
  def format_int_part(int_part); end
  def format_number(node); end
  def min_digits; end
  def register_offense(node, &_block); end
  def short_group_regex; end
end

RuboCop::Cop::Style::NumericLiterals::DELIMITER_REGEXP = T.let(T.unsafe(nil), Regexp)
RuboCop::Cop::Style::NumericLiterals::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::NumericPredicate < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::IgnoredMethods
  extend ::RuboCop::Cop::IgnoredMethods::Config
  extend ::RuboCop::Cop::AutoCorrector

  def comparison(param0 = T.unsafe(nil)); end
  def inverted_comparison(param0 = T.unsafe(nil)); end
  def on_send(node); end
  def predicate(param0 = T.unsafe(nil)); end

  private

  def check(node); end
  def invert; end
  def parenthesized_source(node); end
  def replacement(numeric, operation); end
  def require_parentheses?(node); end
end

RuboCop::Cop::Style::NumericPredicate::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::NumericPredicate::REPLACEMENTS = T.let(T.unsafe(nil), Hash)
RuboCop::Cop::Style::NumericPredicate::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::OneLineConditional < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::OnNormalIfUnless
  extend ::RuboCop::Cop::AutoCorrector

  def on_normal_if_unless(node); end

  private

  def always_multiline?; end
  def autocorrect(corrector, node); end
  def cannot_replace_to_ternary?(node); end
  def expr_replacement(node); end
  def indentation_width; end
  def keyword_with_changed_precedence?(node); end
  def message(node); end
  def method_call_with_changed_precedence?(node); end
  def requires_parentheses?(node); end
  def ternary_correction(node); end
  def ternary_replacement(node); end
end

RuboCop::Cop::Style::OneLineConditional::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::OpenStructUse < ::RuboCop::Cop::Base
  def on_const(node); end
  def uses_open_struct?(param0 = T.unsafe(nil)); end

  private

  def custom_class_or_module_definition?(node); end
end

RuboCop::Cop::Style::OpenStructUse::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::OptionHash < ::RuboCop::Cop::Base
  def on_args(node); end
  def option_hash(param0 = T.unsafe(nil)); end

  private

  def allowlist; end
  def super_used?(node); end
  def suspicious_name?(arg_name); end
end

RuboCop::Cop::Style::OptionHash::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::OptionalArguments < ::RuboCop::Cop::Base
  def on_def(node); end

  private

  def argument_positions(arguments); end
  def each_misplaced_optional_arg(arguments); end
end

RuboCop::Cop::Style::OptionalArguments::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::OptionalBooleanParameter < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::AllowedMethods

  def on_def(node); end
  def on_defs(node); end

  private

  def format_message(argument); end
end

RuboCop::Cop::Style::OptionalBooleanParameter::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::OrAssignment < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_cvasgn(node); end
  def on_gvasgn(node); end
  def on_if(node); end
  def on_ivasgn(node); end
  def on_lvasgn(node); end
  def ternary_assignment?(param0 = T.unsafe(nil)); end
  def unless_assignment?(param0 = T.unsafe(nil)); end

  private

  def autocorrect(corrector, node); end
  def take_variable_and_default_from_ternary(node); end
  def take_variable_and_default_from_unless(node); end
end

RuboCop::Cop::Style::OrAssignment::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::ParallelAssignment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RescueNode
  extend ::RuboCop::Cop::AutoCorrector

  def implicit_self_getter?(param0 = T.unsafe(nil)); end
  def on_masgn(node); end

  private

  def add_self_to_getters(right_elements); end
  def allowed_lhs?(node); end
  def allowed_masign?(lhs_elements, rhs_elements); end
  def allowed_rhs?(node); end
  def assignment_corrector(node, order); end
  def autocorrect(corrector, node); end
  def find_valid_order(left_elements, right_elements); end
  def modifier_statement?(node); end
  def return_of_method_call?(node); end
end

class RuboCop::Cop::Style::ParallelAssignment::AssignmentSorter
  include ::TSort
  extend ::RuboCop::AST::NodePattern::Macros

  def initialize(assignments); end

  def accesses?(rhs, lhs); end
  def dependency?(lhs, rhs); end
  def matching_calls(param0, param1, param2); end
  def tsort_each_child(assignment); end
  def tsort_each_node(&block); end
  def uses_var?(param0, param1); end
  def var_name(param0 = T.unsafe(nil)); end
end

class RuboCop::Cop::Style::ParallelAssignment::GenericCorrector
  include ::RuboCop::Cop::Alignment

  def initialize(node, config, new_elements); end

  def config; end
  def correction; end
  def correction_range; end
  def node; end

  protected

  def assignment; end

  private

  def cop_config; end
  def extract_sources(node); end
  def source(node); end
end

RuboCop::Cop::Style::ParallelAssignment::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::ParallelAssignment::ModifierCorrector < ::RuboCop::Cop::Style::ParallelAssignment::GenericCorrector
  def correction; end
  def correction_range; end

  private

  def modifier_range(node); end
end

class RuboCop::Cop::Style::ParallelAssignment::RescueCorrector < ::RuboCop::Cop::Style::ParallelAssignment::GenericCorrector
  def correction; end
  def correction_range; end

  private

  def begin_correction(rescue_result); end
  def def_correction(rescue_result); end
end

class RuboCop::Cop::Style::ParenthesesAroundCondition < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::SafeAssignment
  include ::RuboCop::Cop::Parentheses
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def control_op_condition(param0 = T.unsafe(nil)); end
  def on_if(node); end
  def on_until(node); end
  def on_while(node); end

  private

  def allow_multiline_conditions?; end
  def message(node); end
  def modifier_op?(node); end
  def parens_allowed?(node); end
  def process_control_op(node); end
  def semicolon_separated_expressions?(first_exp, rest_exps); end
end

class RuboCop::Cop::Style::PercentLiteralDelimiters < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::PercentLiteral
  extend ::RuboCop::Cop::AutoCorrector

  def on_array(node); end
  def on_dstr(node); end
  def on_regexp(node); end
  def on_str(node); end
  def on_sym(node); end
  def on_xstr(node); end

  private

  def contains_delimiter?(node, delimiters); end
  def contains_preferred_delimiter?(node, type); end
  def include_same_character_as_used_for_delimiter?(node, type); end
  def matchpairs(begin_delimiter); end
  def message(type); end
  def on_percent_literal(node); end
  def preferred_delimiters_for(type); end
  def string_source(node); end
  def uses_preferred_delimiter?(node, type); end
end

class RuboCop::Cop::Style::PercentQLiterals < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def on_str(node); end

  private

  def correct_literal_style?(node); end
  def corrected(src); end
  def message(_range); end
  def on_percent_literal(node); end
end

RuboCop::Cop::Style::PercentQLiterals::LOWER_CASE_Q_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::PercentQLiterals::UPPER_CASE_Q_MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::PerlBackrefs < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_back_ref(node); end
  def on_gvar(node); end
  def on_nth_ref(node); end

  private

  def derived_from_braceless_interpolation?(node); end
  def format_message(node:, preferred_expression:); end
  def on_back_ref_or_gvar_or_nth_ref(node); end
  def original_expression_of(node); end
  def preferred_expression_to(node); end
end

RuboCop::Cop::Style::PerlBackrefs::MESSAGE_FORMAT = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::PreferredHashMethods < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def on_csend(node); end
  def on_send(node); end

  private

  def message(method_name); end
  def offending_selector?(method_name); end
  def proper_method_name(method_name); end
end

RuboCop::Cop::Style::PreferredHashMethods::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::PreferredHashMethods::OFFENDING_SELECTORS = T.let(T.unsafe(nil), Hash)
RuboCop::Cop::Style::PreferredHashMethods::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::Proc < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_block(node); end
  def proc_new?(param0 = T.unsafe(nil)); end
end

RuboCop::Cop::Style::Proc::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::QuotedSymbols < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::SymbolHelp
  include ::RuboCop::Cop::StringLiteralsHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_sym(node); end

  private

  def alternative_style; end
  def autocorrect(corrector, node); end
  def correct_quotes(str); end
  def hash_colon_key?(node); end
  def invalid_double_quotes?(source); end
  def quoted?(sym_node); end
  def style; end
  def wrong_quotes?(node); end
end

RuboCop::Cop::Style::QuotedSymbols::MSG_DOUBLE = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::QuotedSymbols::MSG_SINGLE = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::RaiseArgs < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end

  private

  def acceptable_exploded_args?(args); end
  def allowed_non_exploded_type?(arg); end
  def check_compact(node); end
  def check_exploded(node); end
  def correction_compact_to_exploded(node); end
  def correction_exploded_to_compact(node); end
  def requires_parens?(parent); end
end

RuboCop::Cop::Style::RaiseArgs::COMPACT_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::RaiseArgs::EXPLODED_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::RaiseArgs::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::RandomWithOffset < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def integer_op_rand?(param0 = T.unsafe(nil)); end
  def on_send(node); end
  def rand_modified?(param0 = T.unsafe(nil)); end
  def rand_op_integer?(param0 = T.unsafe(nil)); end
  def random_call(param0 = T.unsafe(nil)); end
  def to_int(param0 = T.unsafe(nil)); end

  private

  def autocorrect(corrector, node); end
  def boundaries_from_random_node(random_node); end
  def corrected_integer_op_rand(node); end
  def corrected_rand_modified(node); end
  def corrected_rand_op_integer(node); end
  def prefix_from_prefix_node(node); end
end

RuboCop::Cop::Style::RandomWithOffset::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::RandomWithOffset::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::RedundantArgument < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end

  private

  def argument_range(node); end
  def redundant_arg_for_method(method_name); end
  def redundant_argument?(node); end
end

RuboCop::Cop::Style::RedundantArgument::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::RedundantAssignment < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_def(node); end
  def on_defs(node); end
  def redundant_assignment?(param0 = T.unsafe(nil)); end

  private

  def check_begin_node(node); end
  def check_branch(node); end
  def check_case_node(node); end
  def check_ensure_node(node); end
  def check_if_node(node); end
  def check_rescue_node(node); end
end

RuboCop::Cop::Style::RedundantAssignment::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::RedundantBegin < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_block(node); end
  def on_def(node); end
  def on_defs(node); end
  def on_kwbegin(node); end

  private

  def begin_block_has_multiline_statements?(node); end
  def condition_range(node); end
  def contain_rescue_or_ensure?(node); end
  def correct_modifier_form_after_multiline_begin_block(corrector, node); end
  def empty_begin?(node); end
  def register_offense(node); end
  def replace_begin_with_statement(corrector, offense_range, node); end
  def restore_removed_comments(corrector, offense_range, node, first_child); end
  def use_modifier_form_after_multiline_begin_block?(node); end
  def valid_begin_assignment?(node); end
  def valid_context_using_only_begin?(node); end
end

RuboCop::Cop::Style::RedundantBegin::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::RedundantCapitalW < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::PercentLiteral
  extend ::RuboCop::Cop::AutoCorrector

  def on_array(node); end

  private

  def on_percent_literal(node); end
  def requires_interpolation?(node); end
end

RuboCop::Cop::Style::RedundantCapitalW::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::RedundantCondition < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_if(node); end

  private

  def correct_ternary(corrector, node); end
  def else_source(else_branch); end
  def make_ternary_form(node); end
  def message(node); end
  def offense?(node); end
  def range_of_offense(node); end
  def require_parentheses?(node); end
  def use_hash_key_assignment?(else_branch); end
  def use_if_branch?(else_branch); end
  def without_argument_parentheses_method?(node); end
end

RuboCop::Cop::Style::RedundantCondition::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::RedundantCondition::REDUNDANT_CONDITION = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::RedundantConditional < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  extend ::RuboCop::Cop::AutoCorrector

  def on_if(node); end
  def redundant_condition?(param0 = T.unsafe(nil)); end
  def redundant_condition_inverted?(param0 = T.unsafe(nil)); end

  private

  def configured_indentation_width; end
  def indented_else_node(expression, node); end
  def invert_expression?(node); end
  def message(node); end
  def offense?(node); end
  def replacement_condition(node); end
end

RuboCop::Cop::Style::RedundantConditional::COMPARISON_OPERATOR_MATCHER = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::RedundantConditional::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::RedundantException < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def compact?(param0 = T.unsafe(nil)); end
  def exploded?(param0 = T.unsafe(nil)); end
  def fix_compact(node); end
  def fix_exploded(node); end
  def on_send(node); end
end

RuboCop::Cop::Style::RedundantException::MSG_1 = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::RedundantException::MSG_2 = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::RedundantException::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::RedundantFetchBlock < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::FrozenStringLiteral
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_block(node); end
  def rails_cache?(param0 = T.unsafe(nil)); end
  def redundant_fetch_block_candidate?(param0 = T.unsafe(nil)); end

  private

  def basic_literal?(node); end
  def build_bad_method(send, body); end
  def build_good_method(send, body); end
  def check_for_constant?; end
  def check_for_string?; end
  def const_type?(node); end
  def fetch_range(send, node); end
  def should_not_check?(send, body); end
end

RuboCop::Cop::Style::RedundantFetchBlock::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::RedundantFileExtensionInRequire < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end
  def require_call?(param0 = T.unsafe(nil)); end

  private

  def extension_range(name_node); end
end

RuboCop::Cop::Style::RedundantFileExtensionInRequire::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::RedundantFileExtensionInRequire::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::RedundantFreeze < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::FrozenStringLiteral
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end
  def operation_produces_immutable_object?(param0 = T.unsafe(nil)); end

  private

  def immutable_literal?(node); end
  def strip_parenthesis(node); end
end

RuboCop::Cop::Style::RedundantFreeze::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::RedundantFreeze::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::RedundantInterpolation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::PercentLiteral
  extend ::RuboCop::Cop::AutoCorrector

  def on_dstr(node); end

  private

  def autocorrect_other(corrector, embedded_node, node); end
  def autocorrect_single_variable_interpolation(corrector, embedded_node, node); end
  def autocorrect_variable_interpolation(corrector, embedded_node, node); end
  def embedded_in_percent_array?(node); end
  def implicit_concatenation?(node); end
  def interpolation?(node); end
  def require_parentheses?(node); end
  def single_interpolation?(node); end
  def single_variable_interpolation?(node); end
  def variable_interpolation?(node); end

  class << self
    def autocorrect_incompatible_with; end
  end
end

RuboCop::Cop::Style::RedundantInterpolation::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::RedundantParentheses < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Parentheses
  extend ::RuboCop::Cop::AutoCorrector

  def arg_in_call_with_block?(param0 = T.unsafe(nil)); end
  def first_send_argument?(param0 = T.unsafe(nil)); end
  def first_super_argument?(param0 = T.unsafe(nil)); end
  def first_yield_argument?(param0 = T.unsafe(nil)); end
  def interpolation?(param0 = T.unsafe(nil)); end
  def method_node_and_args(param0 = T.unsafe(nil)); end
  def on_begin(node); end
  def range_end?(param0 = T.unsafe(nil)); end
  def rescue?(param0 = T.unsafe(nil)); end
  def square_brackets?(param0 = T.unsafe(nil)); end

  private

  def allowed_ancestor?(node); end
  def allowed_array_or_hash_element?(node); end
  def allowed_expression?(node); end
  def allowed_method_call?(node); end
  def allowed_multiple_expression?(node); end
  def call_chain_starts_with_int?(begin_node, send_node); end
  def check(begin_node); end
  def check_send(begin_node, node); end
  def check_unary(begin_node, node); end
  def disallowed_literal?(begin_node, node); end
  def empty_parentheses?(node); end
  def first_arg_begins_with_hash_literal?(node); end
  def first_argument?(node); end
  def hash_or_array_element?(node); end
  def ignore_syntax?(node); end
  def keyword_ancestor?(node); end
  def keyword_with_redundant_parentheses?(node); end
  def like_method_argument_parentheses?(node); end
  def method_call_with_redundant_parentheses?(node); end
  def method_chain_begins_with_hash_literal?(node); end
  def offense(node, msg); end
  def only_begin_arg?(args); end
  def only_closing_paren_before_comma?(node); end
  def parens_allowed?(node); end
  def raised_to_power_negative_numeric?(begin_node, node); end
  def suspect_unary?(node); end
end

class RuboCop::Cop::Style::RedundantPercentQ < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_dstr(node); end
  def on_str(node); end

  private

  def acceptable_capital_q?(node); end
  def acceptable_q?(node); end
  def allowed_percent_q?(node); end
  def check(node); end
  def interpolated_quotes?(node); end
  def message(node); end
  def start_with_percent_q_variant?(string); end
  def string_literal?(node); end
end

RuboCop::Cop::Style::RedundantPercentQ::DYNAMIC_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::RedundantPercentQ::EMPTY = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::RedundantPercentQ::ESCAPED_NON_BACKSLASH = T.let(T.unsafe(nil), Regexp)
RuboCop::Cop::Style::RedundantPercentQ::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::RedundantPercentQ::PERCENT_CAPITAL_Q = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::RedundantPercentQ::PERCENT_Q = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::RedundantPercentQ::QUOTE = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::RedundantPercentQ::SINGLE_QUOTE = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::RedundantPercentQ::STRING_INTERPOLATION_REGEXP = T.let(T.unsafe(nil), Regexp)

class RuboCop::Cop::Style::RedundantRegexpCharacterClass < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_regexp(node); end

  private

  def backslash_b?(elem); end
  def each_redundant_character_class(node); end
  def each_single_element_character_class(node); end
  def redundant_single_element_character_class?(node, char_class); end
  def requires_escape_outside_char_class?(elem); end
  def whitespace_in_free_space_mode?(node, elem); end
  def without_character_class(loc); end
end

RuboCop::Cop::Style::RedundantRegexpCharacterClass::MSG_REDUNDANT_CHARACTER_CLASS = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::RedundantRegexpCharacterClass::REQUIRES_ESCAPE_OUTSIDE_CHAR_CLASS_CHARS = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::RedundantRegexpEscape < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_regexp(node); end

  private

  def allowed_escape?(node, char, within_character_class); end
  def delimiter?(node, char); end
  def each_escape(node); end
  def escape_range_at_index(node, index); end
end

RuboCop::Cop::Style::RedundantRegexpEscape::ALLOWED_ALWAYS_ESCAPES = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Style::RedundantRegexpEscape::ALLOWED_OUTSIDE_CHAR_CLASS_METACHAR_ESCAPES = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Style::RedundantRegexpEscape::ALLOWED_WITHIN_CHAR_CLASS_METACHAR_ESCAPES = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Style::RedundantRegexpEscape::MSG_REDUNDANT_ESCAPE = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::RedundantReturn < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_def(node); end
  def on_defs(node); end

  private

  def add_braces(corrector, node); end
  def add_brackets(corrector, node); end
  def allow_multiple_return_values?; end
  def check_begin_node(node); end
  def check_branch(node); end
  def check_case_node(node); end
  def check_ensure_node(node); end
  def check_if_node(node); end
  def check_resbody_node(node); end
  def check_rescue_node(node); end
  def check_return_node(node); end
  def correct_with_arguments(return_node, corrector); end
  def correct_without_arguments(return_node, corrector); end
  def hash_without_braces?(node); end
  def message(node); end
end

RuboCop::Cop::Style::RedundantReturn::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::RedundantReturn::MULTI_RETURN_MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::RedundantSelf < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def initialize(config = T.unsafe(nil), options = T.unsafe(nil)); end

  def on_and_asgn(node); end
  def on_args(node); end
  def on_block(node); end
  def on_blockarg(node); end
  def on_def(node); end
  def on_defs(node); end
  def on_if(node); end
  def on_in_pattern(node); end
  def on_lvasgn(node); end
  def on_masgn(node); end
  def on_op_asgn(node); end
  def on_or_asgn(node); end
  def on_send(node); end
  def on_until(node); end
  def on_while(node); end

  private

  def add_lhs_to_local_variables_scopes(rhs, lhs); end
  def add_masgn_lhs_variables(rhs, lhs); end
  def add_match_var_scopes(in_pattern_node); end
  def add_scope(node, local_variables = T.unsafe(nil)); end
  def allow_self(node); end
  def allowed_send_node?(node); end
  def on_argument(node); end
  def regular_method_call?(node); end

  class << self
    def autocorrect_incompatible_with; end
  end
end

RuboCop::Cop::Style::RedundantSelf::KERNEL_METHODS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Style::RedundantSelf::KEYWORDS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Style::RedundantSelf::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::RedundantSelfAssignment < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_cvasgn(node); end
  def on_gvasgn(node); end
  def on_ivasgn(node); end
  def on_lvasgn(node); end
  def on_send(node); end
  def redundant_nonself_assignment?(param0 = T.unsafe(nil), param1, param2); end
  def redundant_self_assignment?(param0 = T.unsafe(nil), param1); end

  private

  def correction_range(node); end
  def method_returning_self?(method_name); end
  def redundant_assignment?(node); end
end

RuboCop::Cop::Style::RedundantSelfAssignment::ASSIGNMENT_TYPE_TO_RECEIVER_TYPE = T.let(T.unsafe(nil), Hash)
RuboCop::Cop::Style::RedundantSelfAssignment::METHODS_RETURNING_SELF = T.let(T.unsafe(nil), Set)
RuboCop::Cop::Style::RedundantSelfAssignment::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::RedundantSelfAssignmentBranch < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def bad_method?(param0 = T.unsafe(nil)); end
  def on_lvasgn(node); end

  private

  def inconvertible_to_modifier?(if_branch, else_branch); end
  def multiple_statements?(branch); end
  def register_offense(if_node, offense_branch, opposite_branch, keyword); end
  def self_assign?(variable, branch); end
  def use_if_and_else_branch?(expression); end
end

RuboCop::Cop::Style::RedundantSelfAssignmentBranch::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::RedundantSort < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end
  def redundant_sort?(param0 = T.unsafe(nil)); end

  private

  def accessor_start(node); end
  def arg_node(node); end
  def arg_value(node); end
  def base(accessor, arg); end
  def find_redundant_sort(*nodes); end
  def message(node, sorter, accessor); end
  def offense_range(sort_node, node); end
  def register_offense(node, sort_node, sorter, accessor); end
  def suffix(sorter); end
  def suggestion(sorter, accessor, arg); end
end

RuboCop::Cop::Style::RedundantSort::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::RedundantSort::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::RedundantSortBy < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_block(node); end
  def redundant_sort_by(param0 = T.unsafe(nil)); end

  private

  def sort_by_range(send, node); end
end

RuboCop::Cop::Style::RedundantSortBy::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::RegexpLiteral < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_regexp(node); end

  private

  def allow_inner_slashes?; end
  def allowed_mixed_percent_r?(node); end
  def allowed_mixed_slash?(node); end
  def allowed_omit_parentheses_with_percent_r_literal?(node); end
  def allowed_percent_r_literal?(node); end
  def allowed_slash_literal?(node); end
  def calculate_replacement(node); end
  def contains_disallowed_slash?(node); end
  def contains_slash?(node); end
  def correct_delimiters(node, corrector); end
  def correct_inner_slashes(node, corrector); end
  def inner_slash_after_correction(node); end
  def inner_slash_before_correction(node); end
  def inner_slash_for(opening_delimiter); end
  def inner_slash_indices(node); end
  def node_body(node, include_begin_nodes: T.unsafe(nil)); end
  def preferred_delimiters; end
  def slash_literal?(node); end
end

RuboCop::Cop::Style::RegexpLiteral::MSG_USE_PERCENT_R = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::RegexpLiteral::MSG_USE_SLASHES = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::RescueModifier < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::RescueNode
  extend ::RuboCop::Cop::AutoCorrector

  def on_resbody(node); end

  private

  def correct_rescue_block(corrector, node, parenthesized); end
  def indentation_and_offset(node, parenthesized); end
  def parenthesized?(node); end

  class << self
    def autocorrect_incompatible_with; end
  end
end

RuboCop::Cop::Style::RescueModifier::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::RescueStandardError < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RescueNode
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_resbody(node); end
  def rescue_standard_error?(param0 = T.unsafe(nil)); end
  def rescue_without_error_class?(param0 = T.unsafe(nil)); end

  private

  def offense_for_exlicit_enforced_style(node); end
  def offense_for_implicit_enforced_style(node, error); end
end

RuboCop::Cop::Style::RescueStandardError::MSG_EXPLICIT = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::RescueStandardError::MSG_IMPLICIT = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::ReturnNil < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def chained_send?(param0 = T.unsafe(nil)); end
  def define_method?(param0 = T.unsafe(nil)); end
  def on_return(node); end
  def return_nil_node?(param0 = T.unsafe(nil)); end
  def return_node?(param0 = T.unsafe(nil)); end

  private

  def correct_style?(node); end
  def message(_node); end
  def scoped_node?(node); end
end

RuboCop::Cop::Style::ReturnNil::RETURN_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::ReturnNil::RETURN_NIL_MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::SafeNavigation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::NilMethods
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def check_node(node); end
  def modifier_if_safe_navigation_candidate(param0 = T.unsafe(nil)); end
  def not_nil_check?(param0 = T.unsafe(nil)); end
  def on_and(node); end
  def on_if(node); end
  def use_var_only_in_unless_modifier?(node, variable); end

  private

  def add_safe_nav_to_all_methods_in_chain(corrector, start_method, method_chain); end
  def allowed_if_condition?(node); end
  def autocorrect(corrector, node); end
  def begin_range(node, method_call); end
  def chain_size(method_chain, method); end
  def comments(node); end
  def end_range(node, method_call); end
  def extract_common_parts(method_chain, checked_variable); end
  def extract_parts(node); end
  def extract_parts_from_and(node); end
  def extract_parts_from_if(node); end
  def find_matching_receiver_invocation(method_chain, checked_variable); end
  def handle_comments(corrector, node, method_call); end
  def method_call(node); end
  def method_called?(send_node); end
  def negated?(send_node); end
  def relevant_comment_ranges(node); end
  def unsafe_method?(send_node); end
  def unsafe_method_used?(method_chain, method); end
end

RuboCop::Cop::Style::SafeNavigation::LOGIC_JUMP_KEYWORDS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Style::SafeNavigation::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::Sample < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end
  def sample_candidate?(param0 = T.unsafe(nil)); end

  private

  def correction(shuffle_arg, method, method_args); end
  def extract_source(args); end
  def message(shuffle_arg, method, method_args, range); end
  def offensive?(method, method_args); end
  def range_size(range_node); end
  def sample_arg(method, method_args); end
  def sample_size(method_args); end
  def sample_size_for_one_arg(arg); end
  def sample_size_for_two_args(first, second); end
  def source_range(shuffle_node, node); end
end

RuboCop::Cop::Style::Sample::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::Sample::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::SelectByRegexp < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def calls_lvar?(param0 = T.unsafe(nil), param1); end
  def creates_hash?(param0 = T.unsafe(nil)); end
  def on_send(node); end
  def regexp_match?(param0 = T.unsafe(nil)); end

  private

  def extract_send_node(block_node); end
  def find_regexp(node, block); end
  def match_predicate_without_receiver?(node); end
  def receiver_allowed?(node); end
  def register_offense(node, block_node, regexp); end
end

RuboCop::Cop::Style::SelectByRegexp::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::SelectByRegexp::REGEXP_METHODS = T.let(T.unsafe(nil), Set)
RuboCop::Cop::Style::SelectByRegexp::REPLACEMENTS = T.let(T.unsafe(nil), Hash)
RuboCop::Cop::Style::SelectByRegexp::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::SelfAssignment < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_cvasgn(node); end
  def on_ivasgn(node); end
  def on_lvasgn(node); end

  private

  def apply_autocorrect(corrector, node, rhs, operator, new_rhs); end
  def autocorrect(corrector, node); end
  def autocorrect_boolean_node(corrector, node, rhs); end
  def autocorrect_send_node(corrector, node, rhs); end
  def check(node, var_type); end
  def check_boolean_node(node, rhs, var_name, var_type); end
  def check_send_node(node, rhs, var_name, var_type); end

  class << self
    def autocorrect_incompatible_with; end
  end
end

RuboCop::Cop::Style::SelfAssignment::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::SelfAssignment::OPS = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::Semicolon < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_begin(node); end
  def on_new_investigation; end

  private

  def check_for_line_terminator_or_opener; end
  def each_semicolon; end
  def expressions_per_line(exprs); end
  def find_semicolon_positions(line); end
  def register_semicolon(line, column, after_expression); end
  def tokens_for_lines; end

  class << self
    def autocorrect_incompatible_with; end
  end
end

RuboCop::Cop::Style::Semicolon::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::Send < ::RuboCop::Cop::Base
  def on_csend(node); end
  def on_send(node); end
end

RuboCop::Cop::Style::Send::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::Send::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::SignalException < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def custom_fail_methods(param0); end
  def kernel_call?(param0 = T.unsafe(nil), param1); end
  def on_new_investigation; end
  def on_rescue(node); end
  def on_send(node); end

  private

  def allow(method_name, node); end
  def autocorrect(corrector, node); end
  def check_scope(method_name, node); end
  def check_send(method_name, node); end
  def command_or_kernel_call?(name, node); end
  def each_command_or_kernel_call(method_name, node); end
  def message(method_name); end
end

RuboCop::Cop::Style::SignalException::FAIL_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::SignalException::RAISE_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::SignalException::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::SingleArgumentDig < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end
  def single_argument_dig?(param0 = T.unsafe(nil)); end
end

RuboCop::Cop::Style::SingleArgumentDig::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::SingleArgumentDig::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::SingleLineBlockParams < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_block(node); end

  private

  def args_match?(method_name, args); end
  def autocorrect(corrector, node, preferred_block_arguments, joined_block_arguments); end
  def build_preferred_arguments_map(node, preferred_arguments); end
  def eligible_arguments?(node); end
  def eligible_method?(node); end
  def method_name(method); end
  def method_names; end
  def methods; end
  def target_args(method_name); end
end

RuboCop::Cop::Style::SingleLineBlockParams::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::SingleLineMethods < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  extend ::RuboCop::Cop::AutoCorrector

  def on_def(node); end
  def on_defs(node); end

  private

  def allow_empty?; end
  def autocorrect(corrector, node); end
  def break_line_before(corrector, node, range, indent_steps: T.unsafe(nil)); end
  def correct_to_endless(corrector, node); end
  def correct_to_endless?(body_node); end
  def correct_to_multiline(corrector, node); end
  def disallow_endless_method_style?; end
  def each_part(body); end
  def method_body_source(method_body); end
  def move_comment(node, corrector); end
  def require_parentheses?(method_body); end
end

RuboCop::Cop::Style::SingleLineMethods::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::SingleLineMethods::NOT_SUPPORTED_ENDLESS_METHOD_BODY_TYPES = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::SlicingWithRange < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion

  def on_send(node); end
  def range_till_minus_one?(param0 = T.unsafe(nil)); end
end

RuboCop::Cop::Style::SlicingWithRange::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::SlicingWithRange::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::SoleNestedConditional < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_if(node); end

  private

  def allow_modifier?; end
  def arguments_range(node); end
  def assigned_variables(condition); end
  def autocorrect(corrector, node, if_branch); end
  def correct_for_basic_condition_style(corrector, node, if_branch, and_operator); end
  def correct_for_comment(corrector, node, if_branch); end
  def correct_for_guard_condition_style(corrector, node, if_branch, and_operator); end
  def correct_from_unless_to_if(corrector, node); end
  def correct_outer_condition(corrector, condition); end
  def offending_branch?(branch); end
  def replacement_condition(and_operator, condition); end
  def requrie_parentheses?(condition); end
  def use_variable_assignment_in_condition?(condition, if_branch); end
  def wrap_condition?(node); end

  class << self
    def autocorrect_incompatible_with; end
  end
end

RuboCop::Cop::Style::SoleNestedConditional::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::SpecialGlobalVars < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::RequireLibrary
  extend ::RuboCop::Cop::AutoCorrector

  def autocorrect(corrector, node, global_var); end
  def message(global_var); end
  def on_gvar(node); end

  private

  def add_require_english?; end
  def english_name_replacement(preferred_name, node); end
  def format_english_message(global_var); end
  def format_list(items); end
  def format_message(english, regular, global); end
  def preferred_names(global); end
  def replacement(node, global_var); end
  def should_require_english?(global_var); end
end

RuboCop::Cop::Style::SpecialGlobalVars::ENGLISH_VARS = T.let(T.unsafe(nil), Hash)
RuboCop::Cop::Style::SpecialGlobalVars::LIBRARY_NAME = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::SpecialGlobalVars::MSG_BOTH = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::SpecialGlobalVars::MSG_ENGLISH = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::SpecialGlobalVars::MSG_REGULAR = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::SpecialGlobalVars::NON_ENGLISH_VARS = T.let(T.unsafe(nil), Set)
RuboCop::Cop::Style::SpecialGlobalVars::PERL_VARS = T.let(T.unsafe(nil), Hash)

class RuboCop::Cop::Style::StabbyLambdaParentheses < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end

  private

  def message(_node); end
  def missing_parentheses?(node); end
  def missing_parentheses_corrector(corrector, node); end
  def parentheses?(node); end
  def redundant_parentheses?(node); end
  def stabby_lambda_with_args?(node); end
  def unwanted_parentheses_corrector(corrector, node); end
end

RuboCop::Cop::Style::StabbyLambdaParentheses::MSG_NO_REQUIRE = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::StabbyLambdaParentheses::MSG_REQUIRE = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::StaticClass < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::VisibilityHelp

  def on_class(class_node); end

  private

  def class_convertible_to_module?(class_node); end
  def class_elements(class_node); end
  def extend_call?(node); end
  def sclass_convertible_to_module?(node); end
end

RuboCop::Cop::Style::StaticClass::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::StderrPuts < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end
  def stderr_puts?(param0 = T.unsafe(nil)); end

  private

  def message(node); end
  def stderr_gvar?(sym); end
  def stderr_puts_range(send); end
end

RuboCop::Cop::Style::StderrPuts::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::StderrPuts::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::StringChars < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end
end

RuboCop::Cop::Style::StringChars::BAD_ARGUMENTS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Style::StringChars::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::StringChars::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::StringConcatenation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_new_investigation; end
  def on_send(node); end
  def string_concatenation?(param0 = T.unsafe(nil)); end

  private

  def collect_parts(node, parts = T.unsafe(nil)); end
  def corrected_ancestor?(node); end
  def find_topmost_plus_node(node); end
  def handle_quotes(parts); end
  def line_end_concatenation?(node); end
  def offensive_for_mode?(receiver_node); end
  def plus_node?(node); end
  def register_offense(topmost_plus_node, parts); end
  def replacement(parts); end
  def single_quoted?(str_node); end
  def uncorrectable?(part); end
end

RuboCop::Cop::Style::StringConcatenation::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::StringConcatenation::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::StringHashKeys < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_pair(node); end
  def receive_environments_method?(param0 = T.unsafe(nil)); end
  def string_hash_key?(param0 = T.unsafe(nil)); end
end

RuboCop::Cop::Style::StringHashKeys::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::StringLiterals < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::StringLiteralsHelp
  include ::RuboCop::Cop::StringHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_dstr(node); end

  private

  def accept_child_double_quotes?(nodes); end
  def all_string_literals?(nodes); end
  def autocorrect(corrector, node); end
  def check_multiline_quote_style(node, quote); end
  def consistent_multiline?; end
  def detect_quote_styles(node); end
  def message(_node); end
  def offense?(node); end
  def register_offense(node, message: T.unsafe(nil)); end
  def unexpected_double_quotes?(quote); end
  def unexpected_single_quotes?(quote); end
end

RuboCop::Cop::Style::StringLiterals::MSG_INCONSISTENT = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::StringLiteralsInInterpolation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::StringLiteralsHelp
  include ::RuboCop::Cop::StringHelp
  extend ::RuboCop::Cop::AutoCorrector

  def autocorrect(corrector, node); end

  private

  def message(_node); end
  def offense?(node); end
end

class RuboCop::Cop::Style::StringMethods < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::MethodPreference
  extend ::RuboCop::Cop::AutoCorrector

  def on_csend(node); end
  def on_send(node); end
end

RuboCop::Cop::Style::StringMethods::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::Strip < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def lstrip_rstrip(param0 = T.unsafe(nil)); end
  def on_send(node); end
end

RuboCop::Cop::Style::Strip::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::Strip::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::StructInheritance < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_class(node); end
  def struct_constructor?(param0 = T.unsafe(nil)); end

  private

  def correct_parent(parent, corrector); end
  def range_for_empty_class_body(class_node, struct_new); end
end

RuboCop::Cop::Style::StructInheritance::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::SwapValues < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_asgn(node); end
  def on_casgn(node); end
  def on_cvasgn(node); end
  def on_gvasgn(node); end
  def on_ivasgn(node); end
  def on_lvasgn(node); end

  private

  def allowed_assignment?(node); end
  def correction_range(tmp_assign, y_assign); end
  def lhs(node); end
  def message(x_assign, y_assign); end
  def replacement(x_assign); end
  def rhs(node); end
  def simple_assignment?(node); end
  def swapping_values?(tmp_assign, x_assign, y_assign); end
end

RuboCop::Cop::Style::SwapValues::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::SwapValues::SIMPLE_ASSIGNMENT_TYPES = T.let(T.unsafe(nil), Set)

class RuboCop::Cop::Style::SymbolArray < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ArrayMinSize
  include ::RuboCop::Cop::ArraySyntax
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::PercentArray
  extend ::RuboCop::Cop::AutoCorrector

  def on_array(node); end

  private

  def build_bracketed_array(node); end
  def symbol_without_quote?(string); end
  def symbols_contain_spaces?(node); end
  def to_symbol_literal(string); end

  class << self
    def largest_brackets; end
    def largest_brackets=(_arg0); end
  end
end

RuboCop::Cop::Style::SymbolArray::ARRAY_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::SymbolArray::PERCENT_MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::SymbolLiteral < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_sym(node); end
end

RuboCop::Cop::Style::SymbolLiteral::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::SymbolProc < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::IgnoredMethods
  extend ::RuboCop::Cop::IgnoredMethods::Config
  extend ::RuboCop::Cop::AutoCorrector

  def destructuring_block_argument?(argument_node); end
  def on_block(node); end
  def on_numblock(node); end
  def proc_node?(param0 = T.unsafe(nil)); end
  def symbol_proc?(param0 = T.unsafe(nil)); end
  def symbol_proc_receiver?(param0 = T.unsafe(nil)); end

  private

  def allow_if_method_has_argument?(node); end
  def autocorrect(corrector, node); end
  def autocorrect_with_args(corrector, node, args, method_name); end
  def autocorrect_without_args(corrector, node); end
  def begin_pos_for_replacement(node); end
  def block_range_with_space(node); end
  def register_offense(node, method_name, block_method_name); end

  class << self
    def autocorrect_incompatible_with; end
  end
end

RuboCop::Cop::Style::SymbolProc::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::SymbolProc::SUPER_TYPES = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::TernaryCorrector
  extend ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper

  class << self
    def correct(corrector, node); end
    def move_assignment_inside_condition(corrector, node); end

    private

    def correction(node); end
    def element_assignment?(node); end
    def extract_branches(node); end
    def move_branch_inside_condition(corrector, branch, assignment); end
    def remove_parentheses(corrector, node); end
    def ternary(node); end
  end
end

class RuboCop::Cop::Style::TernaryParentheses < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::SafeAssignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::SurroundingSpace
  extend ::RuboCop::Cop::AutoCorrector

  def method_name(param0 = T.unsafe(nil)); end
  def on_if(node); end

  private

  def autocorrect(corrector, node); end
  def below_ternary_precedence?(child); end
  def complex_condition?(condition); end
  def condition_as_parenthesized_one_line_pattern_matching?(condition); end
  def correct_parenthesized(corrector, condition); end
  def correct_unparenthesized(corrector, condition); end
  def infinite_loop?; end
  def message(node); end
  def non_complex_expression?(condition); end
  def non_complex_send?(node); end
  def offense?(node); end
  def only_closing_parenthesis_is_last_line?(condition); end
  def parenthesized?(node); end
  def redundant_parentheses_enabled?; end
  def require_parentheses?; end
  def require_parentheses_when_complex?; end
  def unparenthesized_method_call?(child); end
  def unsafe_autocorrect?(condition); end
  def whitespace_after?(node); end
end

RuboCop::Cop::Style::TernaryParentheses::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::TernaryParentheses::MSG_COMPLEX = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::TernaryParentheses::NON_COMPLEX_TYPES = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Style::TernaryParentheses::VARIABLE_TYPES = T.let(T.unsafe(nil), Set)

class RuboCop::Cop::Style::TopLevelMethodDefinition < ::RuboCop::Cop::Base
  def define_method_block?(param0 = T.unsafe(nil)); end
  def on_block(node); end
  def on_def(node); end
  def on_defs(node); end
  def on_send(node); end

  private

  def top_level_method_definition?(node); end
end

RuboCop::Cop::Style::TopLevelMethodDefinition::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::TopLevelMethodDefinition::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::TrailingBodyOnClass < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::TrailingBody
  extend ::RuboCop::Cop::AutoCorrector

  def on_class(node); end
end

RuboCop::Cop::Style::TrailingBodyOnClass::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::TrailingBodyOnMethodDefinition < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::TrailingBody
  extend ::RuboCop::Cop::AutoCorrector

  def on_def(node); end
  def on_defs(node); end
end

RuboCop::Cop::Style::TrailingBodyOnMethodDefinition::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::TrailingBodyOnModule < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::TrailingBody
  extend ::RuboCop::Cop::AutoCorrector

  def on_module(node); end
end

RuboCop::Cop::Style::TrailingBodyOnModule::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::TrailingCommaInArguments < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::TrailingComma
  extend ::RuboCop::Cop::AutoCorrector

  def on_csend(node); end
  def on_send(node); end

  class << self
    def autocorrect_incompatible_with; end
  end
end

class RuboCop::Cop::Style::TrailingCommaInArrayLiteral < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::TrailingComma
  extend ::RuboCop::Cop::AutoCorrector

  def on_array(node); end
end

class RuboCop::Cop::Style::TrailingCommaInBlockArgs < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_block(node); end

  private

  def arg_count(node); end
  def argument_tokens(node); end
  def last_comma(node); end
  def trailing_comma?(node); end
  def useless_trailing_comma?(node); end
end

RuboCop::Cop::Style::TrailingCommaInBlockArgs::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::TrailingCommaInHashLiteral < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::TrailingComma
  extend ::RuboCop::Cop::AutoCorrector

  def on_hash(node); end
end

class RuboCop::Cop::Style::TrailingMethodEndStatement < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_def(node); end

  private

  def body_and_end_on_same_line?(node); end
  def trailing_end?(node); end
end

RuboCop::Cop::Style::TrailingMethodEndStatement::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::TrailingUnderscoreVariable < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::SurroundingSpace
  extend ::RuboCop::Cop::AutoCorrector

  def on_masgn(node); end

  private

  def allow_named_underscore_variables; end
  def children_offenses(variables); end
  def find_first_offense(variables); end
  def find_first_possible_offense(variables); end
  def main_node_offense(node); end
  def range_for_parentheses(offense, left); end
  def reverse_index(collection, item); end
  def splat_variable_before?(first_offense, variables); end
  def unneeded_ranges(node); end
  def unused_range(node_type, mlhs_node, right); end
  def unused_variables_only?(offense, variables); end
end

RuboCop::Cop::Style::TrailingUnderscoreVariable::DISALLOW = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Style::TrailingUnderscoreVariable::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::TrailingUnderscoreVariable::UNDERSCORE = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::TrivialAccessors < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::AllowedMethods
  extend ::RuboCop::Cop::AutoCorrector

  def looks_like_trivial_writer?(param0 = T.unsafe(nil)); end
  def on_def(node); end
  def on_defs(node); end

  private

  def accessor(kind, method_name); end
  def allow_dsl_writers?; end
  def allow_predicates?; end
  def allowed_method_name?(node); end
  def allowed_method_names; end
  def allowed_reader?(node); end
  def allowed_writer?(method_name); end
  def autocorrect(corrector, node); end
  def autocorrect_class(corrector, node); end
  def autocorrect_instance(corrector, node); end
  def dsl_writer?(method_name); end
  def exact_name_match?; end
  def ignore_class_methods?; end
  def in_module_or_instance_eval?(node); end
  def looks_like_trivial_reader?(node); end
  def names_match?(node); end
  def on_method_def(node); end
  def top_level_node?(node); end
  def trivial_accessor_kind(node); end
  def trivial_reader?(node); end
  def trivial_writer?(node); end
end

RuboCop::Cop::Style::TrivialAccessors::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::UnlessElse < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def on_if(node); end
  def range_between_condition_and_else(node, condition); end
  def range_between_else_and_end(node); end
end

RuboCop::Cop::Style::UnlessElse::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::UnlessLogicalOperators < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  def and_with_or?(param0 = T.unsafe(nil)); end
  def logical_operator?(param0 = T.unsafe(nil)); end
  def on_if(node); end
  def or_with_and?(param0 = T.unsafe(nil)); end

  private

  def mixed_logical_operator?(node); end
  def mixed_precedence_and?(node); end
  def mixed_precedence_or?(node); end
end

RuboCop::Cop::Style::UnlessLogicalOperators::FORBID_LOGICAL_OPERATORS = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::UnlessLogicalOperators::FORBID_MIXED_LOGICAL_OPERATORS = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::UnpackFirst < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_send(node); end
  def unpack_and_first_element?(param0 = T.unsafe(nil)); end

  private

  def first_element_range(node, unpack_call); end
end

RuboCop::Cop::Style::UnpackFirst::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::UnpackFirst::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::Style::VariableInterpolation < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::Interpolation
  extend ::RuboCop::Cop::AutoCorrector

  def on_node_with_interpolations(node); end

  private

  def message(range); end
  def var_nodes(nodes); end
end

RuboCop::Cop::Style::VariableInterpolation::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::WhenThen < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_when(node); end
end

RuboCop::Cop::Style::WhenThen::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::WhileUntilDo < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def on_until(node); end
  def on_while(node); end
end

RuboCop::Cop::Style::WhileUntilDo::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::WhileUntilModifier < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::LineLengthHelp
  include ::RuboCop::Cop::StatementModifier
  extend ::RuboCop::Cop::AutoCorrector

  def on_until(node); end
  def on_while(node); end
end

RuboCop::Cop::Style::WhileUntilModifier::MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::WordArray < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ArrayMinSize
  include ::RuboCop::Cop::ArraySyntax
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::PercentArray
  extend ::RuboCop::Cop::AutoCorrector

  def on_array(node); end

  private

  def build_bracketed_array(node); end
  def complex_content?(strings, complex_regex: T.unsafe(nil)); end
  def invalid_percent_array_contents?(node); end
  def word_regex; end

  class << self
    def largest_brackets; end
    def largest_brackets=(_arg0); end
  end
end

RuboCop::Cop::Style::WordArray::ARRAY_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::WordArray::PERCENT_MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::Style::YodaCondition < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  def file_constant_equal_program_name?(param0 = T.unsafe(nil)); end
  def on_send(node); end

  private

  def actual_code_range(node); end
  def corrected_code(node); end
  def enforce_yoda?; end
  def equality_only?; end
  def interpolation?(node); end
  def message(node); end
  def non_equality_operator?(node); end
  def noncommutative_operator?(node); end
  def program_name?(name); end
  def reverse_comparison(operator); end
  def source_file_path_constant?(node); end
  def valid_yoda?(node); end
  def yoda_compatible_condition?(node); end
end

RuboCop::Cop::Style::YodaCondition::EQUALITY_OPERATORS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Style::YodaCondition::MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::YodaCondition::NONCOMMUTATIVE_OPERATORS = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Style::YodaCondition::PROGRAM_NAMES = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Style::YodaCondition::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Set)
RuboCop::Cop::Style::YodaCondition::REVERSE_COMPARISON = T.let(T.unsafe(nil), Hash)

class RuboCop::Cop::Style::ZeroLengthPredicate < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  def non_polymorphic_collection?(param0 = T.unsafe(nil)); end
  def nonzero_length_predicate(param0 = T.unsafe(nil)); end
  def on_send(node); end
  def other_receiver(param0 = T.unsafe(nil)); end
  def zero_length_predicate(param0 = T.unsafe(nil)); end
  def zero_length_receiver(param0 = T.unsafe(nil)); end

  private

  def check_nonzero_length_predicate(node); end
  def check_zero_length_predicate(node); end
  def replacement(node); end
end

RuboCop::Cop::Style::ZeroLengthPredicate::NONZERO_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::Style::ZeroLengthPredicate::RESTRICT_ON_SEND = T.let(T.unsafe(nil), Array)
RuboCop::Cop::Style::ZeroLengthPredicate::ZERO_MSG = T.let(T.unsafe(nil), String)

module RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp

  private

  def empty_brackets?(left_bracket_token, right_bracket_token); end
  def empty_offense(node, range, message, command); end
  def empty_offenses(node, left, right, message); end
  def extra_space?(token, side); end
  def no_space_between?(left_bracket_token, right_bracket_token); end
  def no_space_offenses(node, left_token, right_token, message, start_ok: T.unsafe(nil), end_ok: T.unsafe(nil)); end
  def offending_empty_no_space?(config, left_token, right_token); end
  def offending_empty_space?(config, left_token, right_token); end
  def on_new_investigation; end
  def reposition(src, pos, step); end
  def side_space_range(range:, side:); end
  def space_between?(left_bracket_token, right_bracket_token); end
  def space_offense(node, token, side, message, command); end
  def space_offenses(node, left_token, right_token, message, start_ok: T.unsafe(nil), end_ok: T.unsafe(nil)); end
end

RuboCop::Cop::SurroundingSpace::NO_SPACE_COMMAND = T.let(T.unsafe(nil), String)
RuboCop::Cop::SurroundingSpace::SINGLE_SPACE_REGEXP = T.let(T.unsafe(nil), Regexp)
RuboCop::Cop::SurroundingSpace::SPACE_COMMAND = T.let(T.unsafe(nil), String)

module RuboCop::Cop::SymbolHelp
  def hash_key?(node); end
end

module RuboCop::Cop::TargetRubyVersion
  def minimum_target_ruby_version(version); end
  def required_minimum_ruby_version; end
  def support_target_ruby_version?(version); end
end

class RuboCop::Cop::Team
  def initialize(cops, config = T.unsafe(nil), options = T.unsafe(nil)); end

  def autocorrect?; end
  def cops; end
  def debug?; end
  def errors; end
  def external_dependency_checksum; end
  def forces; end
  def inspect_file(processed_source); end
  def investigate(processed_source); end
  def updated_source_file; end
  def updated_source_file?; end
  def warnings; end

  private

  def autocorrect(processed_source, report); end
  def autocorrect_report(report); end
  def be_ready; end
  def collate_corrections(report); end
  def each_corrector(report); end
  def handle_error(error, location, cop); end
  def handle_warning(error, location); end
  def investigate_partial(cops, processed_source); end
  def process_errors(file, errors); end
  def reset; end
  def roundup_relevant_cops(filename); end
  def support_target_rails_version?(cop); end
  def support_target_ruby_version?(cop); end
  def suppress_clobbering; end
  def validate_config; end

  class << self
    def forces_for(cops); end
    def mobilize(cop_classes, config, options = T.unsafe(nil)); end
    def mobilize_cops(cop_classes, config, options = T.unsafe(nil)); end
    def new(cop_or_classes, config, options = T.unsafe(nil)); end
  end
end

module RuboCop::Cop::TrailingBody
  def body_on_first_line?(node, body); end
  def first_part_of(body); end
  def trailing_body?(node); end
end

module RuboCop::Cop::TrailingComma
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp

  private

  def allowed_multiline_argument?(node); end
  def any_heredoc?(items); end
  def autocorrect_range(item); end
  def avoid_comma(kind, comma_begin_pos, extra_info); end
  def brackets?(node); end
  def check(node, items, kind, begin_pos, end_pos); end
  def check_comma(node, kind, comma_pos); end
  def check_literal(node, kind); end
  def comma_offset(items, range); end
  def elements(node); end
  def extra_avoid_comma_info; end
  def heredoc?(node); end
  def heredoc_send?(node); end
  def inside_comment?(range, comma_offset); end
  def method_name_and_arguments_on_same_line?(node); end
  def multiline?(node); end
  def no_elements_on_same_line?(node); end
  def on_same_line?(range1, range2); end
  def put_comma(items, kind); end
  def should_have_comma?(style, node); end
  def style_parameter_name; end
end

RuboCop::Cop::TrailingComma::MSG = T.let(T.unsafe(nil), String)

module RuboCop::Cop::UncommunicativeName
  def check(node, args); end

  private

  def allow_nums; end
  def allowed_names; end
  def arg_range(arg, length); end
  def case_offense(node, range); end
  def ends_with_num?(name); end
  def forbidden_names; end
  def forbidden_offense(node, range, name); end
  def issue_offenses(node, range, name); end
  def length_offense(node, range); end
  def long_enough?(name); end
  def min_length; end
  def name_type(node); end
  def num_offense(node, range); end
  def uppercase?(name); end
end

RuboCop::Cop::UncommunicativeName::CASE_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::UncommunicativeName::FORBIDDEN_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::UncommunicativeName::LENGTH_MSG = T.let(T.unsafe(nil), String)
RuboCop::Cop::UncommunicativeName::NUM_MSG = T.let(T.unsafe(nil), String)

class RuboCop::Cop::UnusedArgCorrector
  extend ::RuboCop::Cop::RangeHelp

  class << self
    def correct(corrector, processed_source, node); end
    def correct_for_blockarg_type(corrector, node); end
    def processed_source; end
  end
end

module RuboCop::Cop::Util
  include ::RuboCop::PathUtil

  private

  def add_parentheses(node, corrector); end
  def args_begin(node); end
  def args_end(node); end
  def begins_its_line?(range); end
  def comment_line?(line_source); end
  def comment_lines?(node); end
  def compatible_external_encoding_for?(src); end
  def double_quotes_required?(string); end
  def escape_string(string); end
  def first_part_of_call_chain(node); end
  def indent(node, offset: T.unsafe(nil)); end
  def interpret_string_escapes(string); end
  def line(node_or_range); end
  def line_range(node); end
  def needs_escaping?(string); end
  def on_node(syms, sexp, excludes = T.unsafe(nil), &block); end
  def parentheses?(node); end
  def same_line?(node1, node2); end
  def to_string_literal(string); end
  def to_supported_styles(enforced_style); end
  def trim_string_interporation_escape_character(str); end

  class << self
    def add_parentheses(node, corrector); end
    def args_begin(node); end
    def args_end(node); end
    def begins_its_line?(range); end
    def comment_line?(line_source); end
    def comment_lines?(node); end
    def double_quotes_required?(string); end
    def escape_string(string); end
    def first_part_of_call_chain(node); end
    def indent(node, offset: T.unsafe(nil)); end
    def interpret_string_escapes(string); end
    def line(node_or_range); end
    def line_range(node); end
    def needs_escaping?(string); end
    def on_node(syms, sexp, excludes = T.unsafe(nil), &block); end
    def parentheses?(node); end
    def same_line?(node1, node2); end
    def to_string_literal(string); end
    def to_supported_styles(enforced_style); end
    def trim_string_interporation_escape_character(str); end
  end
end

RuboCop::Cop::Util::LITERAL_REGEX = T.let(T.unsafe(nil), Regexp)
module RuboCop::Cop::Utils; end

class RuboCop::Cop::Utils::FormatString
  def initialize(string); end

  def format_sequences; end
  def max_digit_dollar_num; end
  def named_interpolation?; end
  def valid?; end

  private

  def mixed_formats?; end
  def parse; end
end

RuboCop::Cop::Utils::FormatString::DIGIT_DOLLAR = T.let(T.unsafe(nil), Regexp)
RuboCop::Cop::Utils::FormatString::FLAG = T.let(T.unsafe(nil), Regexp)

class RuboCop::Cop::Utils::FormatString::FormatSequence
  def initialize(match); end

  def annotated?; end
  def arity; end
  def begin_pos; end
  def end_pos; end
  def flags; end
  def max_digit_dollar_num; end
  def name; end
  def percent?; end
  def precision; end
  def style; end
  def template?; end
  def type; end
  def width; end
end

RuboCop::Cop::Utils::FormatString::NAME = T.let(T.unsafe(nil), Regexp)
RuboCop::Cop::Utils::FormatString::NUMBER = T.let(T.unsafe(nil), Regexp)
RuboCop::Cop::Utils::FormatString::NUMBER_ARG = T.let(T.unsafe(nil), Regexp)
RuboCop::Cop::Utils::FormatString::PRECISION = T.let(T.unsafe(nil), Regexp)
RuboCop::Cop::Utils::FormatString::SEQUENCE = T.let(T.unsafe(nil), Regexp)
RuboCop::Cop::Utils::FormatString::TEMPLATE_NAME = T.let(T.unsafe(nil), Regexp)
RuboCop::Cop::Utils::FormatString::TYPE = T.let(T.unsafe(nil), Regexp)
RuboCop::Cop::Utils::FormatString::WIDTH = T.let(T.unsafe(nil), Regexp)

class RuboCop::Cop::VariableForce < ::RuboCop::Cop::Force
  def investigate(processed_source); end
  def process_node(node); end
  def variable_table; end

  private

  def after_declaring_variable(arg); end
  def after_entering_scope(arg); end
  def after_leaving_scope(arg); end
  def before_declaring_variable(arg); end
  def before_entering_scope(arg); end
  def before_leaving_scope(arg); end
  def descendant_reference(node); end
  def each_descendant_reference(loop_node); end
  def find_variables_in_loop(loop_node); end
  def inspect_variables_in_scope(scope_node); end
  def mark_assignments_as_referenced_in_loop(node); end
  def node_handler_method_name(node); end
  def process_children(origin_node); end
  def process_loop(node); end
  def process_regexp_named_captures(node); end
  def process_rescue(node); end
  def process_scope(node); end
  def process_send(node); end
  def process_variable_assignment(node); end
  def process_variable_declaration(node); end
  def process_variable_multiple_assignment(node); end
  def process_variable_operator_assignment(node); end
  def process_variable_referencing(node); end
  def process_zero_arity_super(node); end
  def regexp_captured_names(node); end
  def scanned_node?(node); end
  def scanned_nodes; end
  def skip_children!; end
  def twisted_nodes(node); end
end

RuboCop::Cop::VariableForce::ARGUMENT_DECLARATION_TYPES = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::VariableForce::Assignment
  include ::RuboCop::Cop::VariableForce::Branchable

  def initialize(node, variable); end

  def meta_assignment_node; end
  def multiple_assignment?; end
  def name; end
  def node; end
  def operator; end
  def operator_assignment?; end
  def reference!(node); end
  def referenced; end
  def referenced?; end
  def references; end
  def regexp_named_capture?; end
  def scope; end
  def used?; end
  def variable; end

  private

  def multiple_assignment_node; end
  def operator_assignment_node; end
end

RuboCop::Cop::VariableForce::Assignment::MULTIPLE_LEFT_HAND_SIDE_TYPE = T.let(T.unsafe(nil), Symbol)

class RuboCop::Cop::VariableForce::AssignmentReference < ::Struct
  def assignment?; end
  def node; end
  def node=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

module RuboCop::Cop::VariableForce::Branch
  class << self
    def of(target_node, scope: T.unsafe(nil)); end
  end
end

class RuboCop::Cop::VariableForce::Branch::And < ::RuboCop::Cop::VariableForce::Branch::Base
  include ::RuboCop::Cop::VariableForce::Branch::LogicalOperator

  def left_body?; end
  def right_body?; end
end

class RuboCop::Cop::VariableForce::Branch::Base < ::Struct
  def ==(other); end
  def always_run?; end
  def branched?; end
  def child_node; end
  def child_node=(_); end
  def control_node; end
  def each_ancestor(include_self: T.unsafe(nil), &block); end
  def eql?(other); end
  def exclusive_with?(other); end
  def hash; end
  def may_jump_to_other_branch?; end
  def may_run_incompletely?; end
  def parent; end
  def scope; end
  def scope=(_); end

  private

  def scan_ancestors; end

  class << self
    def [](*_arg0); end
    def classes; end
    def define_predicate(name, child_index: T.unsafe(nil)); end
    def inherited(subclass); end
    def inspect; end
    def members; end
    def new(*_arg0); end
    def type; end
  end
end

RuboCop::Cop::VariableForce::Branch::CLASSES_BY_TYPE = T.let(T.unsafe(nil), Hash)

class RuboCop::Cop::VariableForce::Branch::Case < ::RuboCop::Cop::VariableForce::Branch::Base
  def always_run?; end
  def else_body?; end
  def target?; end
  def when_clause?; end
end

class RuboCop::Cop::VariableForce::Branch::CaseMatch < ::RuboCop::Cop::VariableForce::Branch::Base
  def always_run?; end
  def else_body?; end
  def in_pattern?; end
  def target?; end
end

class RuboCop::Cop::VariableForce::Branch::Ensure < ::RuboCop::Cop::VariableForce::Branch::Base
  include ::RuboCop::Cop::VariableForce::Branch::ExceptionHandler

  def always_run?; end
  def ensure_body?; end
  def main_body?; end
end

module RuboCop::Cop::VariableForce::Branch::ExceptionHandler
  def may_jump_to_other_branch?; end
  def may_run_incompletely?; end
end

class RuboCop::Cop::VariableForce::Branch::For < ::RuboCop::Cop::VariableForce::Branch::Base
  def always_run?; end
  def collection?; end
  def element?; end
  def loop_body?; end
end

class RuboCop::Cop::VariableForce::Branch::If < ::RuboCop::Cop::VariableForce::Branch::Base
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional

  def conditional_clause?; end
  def falsey_body?; end
  def truthy_body?; end
end

module RuboCop::Cop::VariableForce::Branch::LogicalOperator
  def always_run?; end
end

class RuboCop::Cop::VariableForce::Branch::Or < ::RuboCop::Cop::VariableForce::Branch::Base
  include ::RuboCop::Cop::VariableForce::Branch::LogicalOperator

  def left_body?; end
  def right_body?; end
end

class RuboCop::Cop::VariableForce::Branch::Rescue < ::RuboCop::Cop::VariableForce::Branch::Base
  include ::RuboCop::Cop::VariableForce::Branch::ExceptionHandler

  def always_run?; end
  def else_body?; end
  def main_body?; end
  def rescue_clause?; end
end

module RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def always_run?; end
  def conditional_clause?; end
end

class RuboCop::Cop::VariableForce::Branch::Until < ::RuboCop::Cop::VariableForce::Branch::Base
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional

  def conditional_clause?; end
  def loop_body?; end
end

class RuboCop::Cop::VariableForce::Branch::UntilPost < ::RuboCop::Cop::VariableForce::Branch::Base
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional

  def conditional_clause?; end
  def loop_body?; end
end

class RuboCop::Cop::VariableForce::Branch::While < ::RuboCop::Cop::VariableForce::Branch::Base
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional

  def conditional_clause?; end
  def loop_body?; end
end

class RuboCop::Cop::VariableForce::Branch::WhilePost < ::RuboCop::Cop::VariableForce::Branch::Base
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional

  def conditional_clause?; end
  def loop_body?; end
end

module RuboCop::Cop::VariableForce::Branchable
  def branch; end
  def run_exclusively_with?(other); end
end

RuboCop::Cop::VariableForce::LOGICAL_OPERATOR_ASSIGNMENT_TYPES = T.let(T.unsafe(nil), Array)
RuboCop::Cop::VariableForce::LOOP_TYPES = T.let(T.unsafe(nil), Array)
RuboCop::Cop::VariableForce::MULTIPLE_ASSIGNMENT_TYPE = T.let(T.unsafe(nil), Symbol)
RuboCop::Cop::VariableForce::OPERATOR_ASSIGNMENT_TYPES = T.let(T.unsafe(nil), Array)
RuboCop::Cop::VariableForce::POST_CONDITION_LOOP_TYPES = T.let(T.unsafe(nil), Array)
RuboCop::Cop::VariableForce::REGEXP_NAMED_CAPTURE_TYPE = T.let(T.unsafe(nil), Symbol)
RuboCop::Cop::VariableForce::RESCUE_TYPE = T.let(T.unsafe(nil), Symbol)

class RuboCop::Cop::VariableForce::Reference
  include ::RuboCop::Cop::VariableForce::Branchable

  def initialize(node, scope); end

  def explicit?; end
  def node; end
  def scope; end
end

RuboCop::Cop::VariableForce::Reference::VARIABLE_REFERENCE_TYPES = T.let(T.unsafe(nil), Array)
RuboCop::Cop::VariableForce::SCOPE_TYPES = T.let(T.unsafe(nil), Array)
RuboCop::Cop::VariableForce::SEND_TYPE = T.let(T.unsafe(nil), Symbol)

class RuboCop::Cop::VariableForce::Scope
  def initialize(node); end

  def ==(other); end
  def body_node; end
  def each_node(&block); end
  def include?(target_node); end
  def naked_top_level; end
  def naked_top_level?; end
  def name; end
  def node; end
  def variables; end

  private

  def ancestor_node?(target_node); end
  def belong_to_inner_scope?(target_node); end
  def belong_to_outer_scope?(target_node); end
  def scan_node(node, &block); end
end

RuboCop::Cop::VariableForce::Scope::OUTER_SCOPE_CHILD_INDICES = T.let(T.unsafe(nil), Hash)
RuboCop::Cop::VariableForce::TWISTED_SCOPE_TYPES = T.let(T.unsafe(nil), Array)
RuboCop::Cop::VariableForce::VARIABLE_ASSIGNMENT_TYPE = T.let(T.unsafe(nil), Symbol)
RuboCop::Cop::VariableForce::VARIABLE_ASSIGNMENT_TYPES = T.let(T.unsafe(nil), Array)
RuboCop::Cop::VariableForce::VARIABLE_REFERENCE_TYPE = T.let(T.unsafe(nil), Symbol)

class RuboCop::Cop::VariableForce::Variable
  def initialize(name, declaration_node, scope); end

  def argument?; end
  def assign(node); end
  def assignments; end
  def block_argument?; end
  def capture_with_block!; end
  def captured_by_block; end
  def captured_by_block?; end
  def declaration_node; end
  def explicit_block_local_variable?; end
  def in_modifier_if?(assignment); end
  def keyword_argument?; end
  def method_argument?; end
  def name; end
  def reference!(node); end
  def referenced?; end
  def references; end
  def scope; end
  def should_be_unused?; end
  def used?; end
end

RuboCop::Cop::VariableForce::Variable::VARIABLE_DECLARATION_TYPES = T.let(T.unsafe(nil), Array)

class RuboCop::Cop::VariableForce::VariableReference < ::Struct
  def assignment?; end
  def name; end
  def name=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class RuboCop::Cop::VariableForce::VariableTable
  def initialize(hook_receiver = T.unsafe(nil)); end

  def accessible_variables; end
  def assign_to_variable(name, node); end
  def current_scope; end
  def current_scope_level; end
  def declare_variable(name, node); end
  def find_variable(name); end
  def invoke_hook(hook_name, *args); end
  def pop_scope; end
  def push_scope(scope_node); end
  def reference_variable(name, node); end
  def scope_stack; end
  def variable_exist?(name); end

  private

  def mark_variable_as_captured_by_block_if_so(variable); end
end

RuboCop::Cop::VariableForce::ZERO_ARITY_SUPER_TYPE = T.let(T.unsafe(nil), Symbol)

module RuboCop::Cop::VisibilityHelp
  extend ::RuboCop::AST::NodePattern::Macros

  def visibility_block?(param0 = T.unsafe(nil)); end

  private

  def find_visibility_end(node); end
  def find_visibility_start(node); end
  def node_visibility(node); end
end

RuboCop::Cop::VisibilityHelp::VISIBILITY_SCOPES = T.let(T.unsafe(nil), Array)

class RuboCop::DirectiveComment
  def initialize(comment, cop_registry = T.unsafe(nil)); end

  def all_cops?; end
  def comment; end
  def cop_names; end
  def cop_registry; end
  def cops; end
  def department_names; end
  def directive_count; end
  def disabled?; end
  def disabled_all?; end
  def enabled?; end
  def enabled_all?; end
  def in_directive_department?(cop); end
  def line_number; end
  def match?(cop_names); end
  def match_captures; end
  def mode; end
  def overridden_by_department?(cop); end
  def range; end
  def single_line?; end

  private

  def all_cop_names; end
  def cop_names_for_department(department); end
  def department?(name); end
  def exclude_redundant_directive_cop(cops); end
  def parsed_cop_names; end
  def splitted_cops_string; end

  class << self
    def before_comment(line); end
  end
end

RuboCop::DirectiveComment::COPS_PATTERN = T.let(T.unsafe(nil), String)
RuboCop::DirectiveComment::COP_NAMES_PATTERN = T.let(T.unsafe(nil), String)
RuboCop::DirectiveComment::COP_NAME_PATTERN = T.let(T.unsafe(nil), String)
RuboCop::DirectiveComment::DIRECTIVE_COMMENT_REGEXP = T.let(T.unsafe(nil), Regexp)
RuboCop::DirectiveComment::REDUNDANT_DIRECTIVE_COP = T.let(T.unsafe(nil), String)
RuboCop::DirectiveComment::REDUNDANT_DIRECTIVE_COP_DEPARTMENT = T.let(T.unsafe(nil), String)
class RuboCop::Error < ::StandardError; end

class RuboCop::ErrorWithAnalyzedFileLocation < ::RuboCop::Error
  def initialize(cause:, node:, cop:); end

  def cause; end
  def column; end
  def cop; end
  def line; end
  def message; end
end

module RuboCop::ExcludeLimit
  def exclude_limit(parameter_name, method_name: T.unsafe(nil)); end

  private

  def transform(parameter_name); end
end

module RuboCop::Ext; end

module RuboCop::Ext::ProcessedSource
  def comment_config; end
  def disabled_line_ranges; end
end

module RuboCop::Ext::RegexpNode
  def assign_properties(*_arg0); end
  def each_capture(named: T.unsafe(nil)); end
  def parsed_tree; end

  private

  def with_interpolations_blanked; end
end

RuboCop::Ext::RegexpNode::ANY = T.let(T.unsafe(nil), Object)
module RuboCop::Ext::RegexpParser; end
module RuboCop::Ext::RegexpParser::Expression; end

module RuboCop::Ext::RegexpParser::Expression::Base
  def expression; end
  def loc; end
  def origin; end
  def origin=(_arg0); end

  private

  def build_location; end
end

module RuboCop::Ext::RegexpParser::Expression::CharacterSet
  def build_location; end
end

class RuboCop::Ext::RegexpParser::Map < ::Parser::Source::Map
  def initialize(expression, body:, quantifier: T.unsafe(nil), begin_l: T.unsafe(nil), end_l: T.unsafe(nil)); end

  def begin; end
  def body; end
  def end; end
  def quantifier; end
end

module RuboCop::FileFinder
  def find_file_upwards(filename, start_dir, stop_dir = T.unsafe(nil)); end
  def find_last_file_upwards(filename, start_dir, stop_dir = T.unsafe(nil)); end

  private

  def traverse_files_upwards(filename, start_dir, stop_dir); end

  class << self
    def root_level=(level); end
    def root_level?(path, stop_dir); end
  end
end

module RuboCop::Formatter; end

class RuboCop::Formatter::AutoGenConfigFormatter < ::RuboCop::Formatter::ProgressFormatter
  def finished(inspected_files); end
end

class RuboCop::Formatter::BaseFormatter
  def initialize(output, options = T.unsafe(nil)); end

  def file_finished(file, offenses); end
  def file_started(file, options); end
  def finished(inspected_files); end
  def options; end
  def output; end
  def started(target_files); end
end

class RuboCop::Formatter::ClangStyleFormatter < ::RuboCop::Formatter::SimpleTextFormatter
  def report_file(file, offenses); end

  private

  def report_highlighted_area(highlighted_area); end
  def report_line(location); end
  def report_offense(file, offense); end
  def valid_line?(offense); end
end

RuboCop::Formatter::ClangStyleFormatter::ELLIPSES = T.let(T.unsafe(nil), String)

module RuboCop::Formatter::Colorizable
  def black(string); end
  def blue(string); end
  def colorize(string, *args); end
  def cyan(string); end
  def green(string); end
  def magenta(string); end
  def rainbow; end
  def red(string); end
  def white(string); end
  def yellow(string); end
end

class RuboCop::Formatter::DisabledConfigFormatter < ::RuboCop::Formatter::BaseFormatter
  include ::RuboCop::PathUtil

  def initialize(output, options = T.unsafe(nil)); end

  def file_finished(file, offenses); end
  def file_started(_file, _file_info); end
  def finished(_inspected_files); end

  private

  def command; end
  def cop_config_params(default_cfg, cfg); end
  def default_config(cop_name); end
  def excludes(offending_files, cop_name, parent); end
  def merge_mode_for_exclude?(cfg); end
  def output_cop(cop_name, offense_count); end
  def output_cop_comments(output_buffer, cfg, cop_name, offense_count); end
  def output_cop_config(output_buffer, cfg, cop_name); end
  def output_cop_param_comments(output_buffer, params, default_cfg); end
  def output_exclude_list(output_buffer, offending_files, cop_name); end
  def output_exclude_path(output_buffer, exclude_path, parent); end
  def output_offending_files(output_buffer, cfg, cop_name); end
  def output_offenses; end
  def set_max(cfg, cop_name); end
  def show_offense_counts?; end
  def show_timestamp?; end
  def supports_safe_auto_correct?(cop_class, default_cfg); end
  def supports_unsafe_autocorrect?(cop_class, default_cfg); end
  def timestamp; end

  class << self
    def config_to_allow_offenses; end
    def config_to_allow_offenses=(_arg0); end
    def detected_styles; end
    def detected_styles=(_arg0); end
  end
end

RuboCop::Formatter::DisabledConfigFormatter::HEADING = T.let(T.unsafe(nil), String)

class RuboCop::Formatter::EmacsStyleFormatter < ::RuboCop::Formatter::BaseFormatter
  def file_finished(file, offenses); end

  private

  def message(offense); end
end

class RuboCop::Formatter::FileListFormatter < ::RuboCop::Formatter::BaseFormatter
  def file_finished(file, offenses); end
end

class RuboCop::Formatter::FormatterSet < ::Array
  def initialize(options = T.unsafe(nil)); end

  def add_formatter(formatter_type, output_path = T.unsafe(nil)); end
  def close_output_files; end
  def file_finished(file, offenses); end
  def file_started(file, options); end
  def finished(*args); end
  def started(*args); end

  private

  def builtin_formatter_class(specified_key); end
  def custom_formatter_class(specified_class_name); end
  def formatter_class(formatter_type); end
end

RuboCop::Formatter::FormatterSet::BUILTIN_FORMATTERS_FOR_KEYS = T.let(T.unsafe(nil), Hash)
RuboCop::Formatter::FormatterSet::FORMATTER_APIS = T.let(T.unsafe(nil), Array)

class RuboCop::Formatter::FuubarStyleFormatter < ::RuboCop::Formatter::ClangStyleFormatter
  def initialize(*output); end

  def count_stats(offenses); end
  def file_finished(file, offenses); end
  def progressbar_color; end
  def started(target_files); end
  def with_color; end
end

RuboCop::Formatter::FuubarStyleFormatter::RESET_SEQUENCE = T.let(T.unsafe(nil), String)

class RuboCop::Formatter::GitHubActionsFormatter < ::RuboCop::Formatter::BaseFormatter
  def file_finished(file, offenses); end

  private

  def github_escape(string); end
  def github_severity(offense); end
  def minimum_severity_to_fail; end
  def report_offense(file, offense); end
end

RuboCop::Formatter::GitHubActionsFormatter::ESCAPE_MAP = T.let(T.unsafe(nil), Hash)

class RuboCop::Formatter::HTMLFormatter < ::RuboCop::Formatter::BaseFormatter
  def initialize(output, options = T.unsafe(nil)); end

  def file_finished(file, offenses); end
  def files; end
  def finished(inspected_files); end
  def render_html; end
  def started(target_files); end
  def summary; end
end

class RuboCop::Formatter::HTMLFormatter::Color < ::Struct
  def alpha; end
  def alpha=(_); end
  def blue; end
  def blue=(_); end
  def fade_out(amount); end
  def green; end
  def green=(_); end
  def red; end
  def red=(_); end
  def to_s; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

RuboCop::Formatter::HTMLFormatter::ELLIPSES = T.let(T.unsafe(nil), String)

class RuboCop::Formatter::HTMLFormatter::ERBContext
  include ::RuboCop::PathUtil
  include ::RuboCop::Formatter::TextUtil

  def initialize(files, summary); end

  def base64_encoded_logo_image; end
  def binding; end
  def decorated_message(offense); end
  def escape(string); end
  def files; end
  def highlighted_source_line(offense); end
  def hightlight_source_tag(offense); end
  def possible_ellipses(location); end
  def source_after_highlight(offense); end
  def source_before_highlight(offense); end
  def summary; end
end

RuboCop::Formatter::HTMLFormatter::ERBContext::LOGO_IMAGE_PATH = T.let(T.unsafe(nil), String)
RuboCop::Formatter::HTMLFormatter::ERBContext::SEVERITY_COLORS = T.let(T.unsafe(nil), Hash)

class RuboCop::Formatter::HTMLFormatter::FileOffenses < ::Struct
  def offenses; end
  def offenses=(_); end
  def path; end
  def path=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

class RuboCop::Formatter::HTMLFormatter::Summary < ::Struct
  def inspected_files; end
  def inspected_files=(_); end
  def offense_count; end
  def offense_count=(_); end
  def target_files; end
  def target_files=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

RuboCop::Formatter::HTMLFormatter::TEMPLATE_PATH = T.let(T.unsafe(nil), String)

class RuboCop::Formatter::JSONFormatter < ::RuboCop::Formatter::BaseFormatter
  include ::RuboCop::PathUtil

  def initialize(output, options = T.unsafe(nil)); end

  def file_finished(file, offenses); end
  def finished(inspected_files); end
  def hash_for_file(file, offenses); end
  def hash_for_location(offense); end
  def hash_for_offense(offense); end
  def metadata_hash; end
  def output_hash; end
  def started(target_files); end
end

class RuboCop::Formatter::JUnitFormatter < ::RuboCop::Formatter::BaseFormatter
  def initialize(output, options = T.unsafe(nil)); end

  def add_testcase_element_to_testsuite_element(file, target_offenses, cop); end
  def classname_attribute_value(file); end
  def file_finished(file, offenses); end
  def finished(_inspected_files); end
  def offenses_for_cop(all_offenses, cop); end
  def relevant_for_output?(options, target_offenses); end

  private

  def add_failure_to(testcase, offenses, cop_name); end
  def reset_count; end
end

class RuboCop::Formatter::OffenseCountFormatter < ::RuboCop::Formatter::BaseFormatter
  def file_finished(_file, offenses); end
  def finished(_inspected_files); end
  def offense_counts; end
  def ordered_offense_counts(offense_counts); end
  def report_summary(offense_counts); end
  def started(target_files); end
  def total_offense_count(offense_counts); end
end

class RuboCop::Formatter::PacmanFormatter < ::RuboCop::Formatter::ClangStyleFormatter
  include ::RuboCop::Formatter::TextUtil

  def initialize(output, options = T.unsafe(nil)); end

  def cols; end
  def file_finished(file, offenses); end
  def file_started(_file, _options); end
  def next_step(offenses); end
  def pacdots(number); end
  def progress_line; end
  def progress_line=(_arg0); end
  def started(target_files); end
  def step(character); end
  def update_progress_line; end
end

RuboCop::Formatter::PacmanFormatter::FALLBACK_TERMINAL_WIDTH = T.let(T.unsafe(nil), Integer)
RuboCop::Formatter::PacmanFormatter::GHOST = T.let(T.unsafe(nil), String)
RuboCop::Formatter::PacmanFormatter::PACDOT = T.let(T.unsafe(nil), Rainbow::Presenter)
RuboCop::Formatter::PacmanFormatter::PACMAN = T.let(T.unsafe(nil), Rainbow::Presenter)

class RuboCop::Formatter::ProgressFormatter < ::RuboCop::Formatter::ClangStyleFormatter
  include ::RuboCop::Formatter::TextUtil

  def initialize(output, options = T.unsafe(nil)); end

  def file_finished(file, offenses); end
  def finished(inspected_files); end
  def report_file_as_mark(offenses); end
  def started(target_files); end
end

RuboCop::Formatter::ProgressFormatter::DOT = T.let(T.unsafe(nil), String)

class RuboCop::Formatter::QuietFormatter < ::RuboCop::Formatter::SimpleTextFormatter
  def report_summary(file_count, offense_count, correction_count, correctable_count); end
end

class RuboCop::Formatter::SimpleTextFormatter < ::RuboCop::Formatter::BaseFormatter
  include ::RuboCop::Formatter::Colorizable
  include ::RuboCop::PathUtil

  def file_finished(file, offenses); end
  def finished(inspected_files); end
  def report_file(file, offenses); end
  def report_summary(file_count, offense_count, correction_count, correctable_count); end
  def started(_target_files); end

  private

  def annotate_message(msg); end
  def colored_severity_code(offense); end
  def count_stats(offenses); end
  def message(offense); end
end

RuboCop::Formatter::SimpleTextFormatter::COLOR_FOR_SEVERITY = T.let(T.unsafe(nil), Hash)

class RuboCop::Formatter::SimpleTextFormatter::Report
  include ::RuboCop::Formatter::Colorizable
  include ::RuboCop::Formatter::TextUtil

  def initialize(file_count, offense_count, correction_count, correctable_count, rainbow, safe_auto_correct: T.unsafe(nil)); end

  def summary; end

  private

  def correctable; end
  def corrections; end
  def files; end
  def offenses; end
  def rainbow; end
end

class RuboCop::Formatter::TapFormatter < ::RuboCop::Formatter::ClangStyleFormatter
  def file_finished(file, offenses); end
  def started(target_files); end

  private

  def annotate_message(msg); end
  def message(offense); end
  def report_highlighted_area(highlighted_area); end
  def report_line(location); end
  def report_offense(file, offense); end
end

module RuboCop::Formatter::TextUtil
  private

  def pluralize(number, thing, options = T.unsafe(nil)); end

  class << self
    def pluralize(number, thing, options = T.unsafe(nil)); end
  end
end

class RuboCop::Formatter::WorstOffendersFormatter < ::RuboCop::Formatter::BaseFormatter
  def file_finished(file, offenses); end
  def finished(_inspected_files); end
  def offense_counts; end
  def ordered_offense_counts(offense_counts); end
  def report_summary(offense_counts); end
  def started(target_files); end
  def total_offense_count(offense_counts); end
end

class RuboCop::IncorrectCopNameError < ::StandardError; end

class RuboCop::Lockfile
  def dependencies; end
  def gems; end
  def includes_gem?(name); end

  private

  def parser; end
end

class RuboCop::MagicComment
  def initialize(comment); end

  def any?; end
  def encoding_specified?; end
  def frozen_string_literal; end
  def frozen_string_literal?; end
  def frozen_string_literal_specified?; end
  def shareable_constant_value; end
  def shareable_constant_value_specified?; end
  def valid?; end
  def valid_literal_value?; end
  def valid_shareable_constant_value?; end

  private

  def extract(pattern); end
  def specified?(value); end

  class << self
    def parse(comment); end
  end
end

class RuboCop::MagicComment::EditorComment < ::RuboCop::MagicComment
  def encoding; end
  def without(type); end

  private

  def match(keyword); end
  def tokens; end
end

class RuboCop::MagicComment::EmacsComment < ::RuboCop::MagicComment::EditorComment
  private

  def extract_frozen_string_literal; end
  def extract_shareable_constant_value; end
end

RuboCop::MagicComment::EmacsComment::FORMAT = T.let(T.unsafe(nil), String)
RuboCop::MagicComment::EmacsComment::OPERATOR = T.let(T.unsafe(nil), String)
RuboCop::MagicComment::EmacsComment::REGEXP = T.let(T.unsafe(nil), Regexp)
RuboCop::MagicComment::EmacsComment::SEPARATOR = T.let(T.unsafe(nil), String)
RuboCop::MagicComment::KEYWORDS = T.let(T.unsafe(nil), Hash)

class RuboCop::MagicComment::SimpleComment < ::RuboCop::MagicComment
  def encoding; end
  def without(type); end

  private

  def extract_frozen_string_literal; end
  def extract_shareable_constant_value; end
end

RuboCop::MagicComment::TOKEN = T.let(T.unsafe(nil), Regexp)

class RuboCop::MagicComment::VimComment < ::RuboCop::MagicComment::EditorComment
  def encoding; end
  def frozen_string_literal; end
  def shareable_constant_value; end
end

RuboCop::MagicComment::VimComment::FORMAT = T.let(T.unsafe(nil), String)
RuboCop::MagicComment::VimComment::KEYWORDS = T.let(T.unsafe(nil), Hash)
RuboCop::MagicComment::VimComment::OPERATOR = T.let(T.unsafe(nil), String)
RuboCop::MagicComment::VimComment::REGEXP = T.let(T.unsafe(nil), Regexp)
RuboCop::MagicComment::VimComment::SEPARATOR = T.let(T.unsafe(nil), String)

module RuboCop::NameSimilarity
  private

  def find_similar_name(target_name, names); end
  def find_similar_names(target_name, names); end

  class << self
    def find_similar_name(target_name, names); end
    def find_similar_names(target_name, names); end
  end
end

RuboCop::NodePattern = RuboCop::AST::NodePattern
class RuboCop::OptionArgumentError < ::StandardError; end

class RuboCop::Options
  def initialize; end

  def parse(command_line_args); end

  private

  def add_additional_modes(opts); end
  def add_autocorrection_options(opts); end
  def add_cache_options(opts); end
  def add_check_options(opts); end
  def add_config_generation_options(opts); end
  def add_cop_selection_csv_option(option, opts); end
  def add_general_options(opts); end
  def add_output_options(opts); end
  def add_severity_option(opts); end
  def args_from_env; end
  def args_from_file; end
  def define_options; end
  def long_opt_symbol(args); end
  def option(opts, *args); end
  def rainbow; end
  def require_feature(file); end
  def section(opts, heading, &_block); end
end

RuboCop::Options::DEFAULT_MAXIMUM_EXCLUSION_ITEMS = T.let(T.unsafe(nil), Integer)
RuboCop::Options::EXITING_OPTIONS = T.let(T.unsafe(nil), Array)
RuboCop::Options::E_STDIN_NO_PATH = T.let(T.unsafe(nil), String)
module RuboCop::OptionsHelp; end
RuboCop::OptionsHelp::FORMATTER_OPTION_LIST = T.let(T.unsafe(nil), Array)
RuboCop::OptionsHelp::MAX_EXCL = T.let(T.unsafe(nil), String)
RuboCop::OptionsHelp::TEXT = T.let(T.unsafe(nil), Hash)

class RuboCop::OptionsValidator
  def initialize(options); end

  def boolean_or_empty_cache?; end
  def disable_parallel_when_invalid_option_combo; end
  def display_only_fail_level_offenses_with_autocorrect?; end
  def except_syntax?; end
  def incompatible_options; end
  def only_includes_redundant_disable?; end
  def validate_auto_correct; end
  def validate_auto_gen_config; end
  def validate_cache_enabled_for_cache_root; end
  def validate_compatibility; end
  def validate_cop_options; end
  def validate_display_only_failed; end
  def validate_exclude_limit_option; end

  class << self
    def validate_cop_list(names); end

    private

    def format_message_from(name, cop_names); end
  end
end

module RuboCop::PathUtil
  private

  def absolute?(path); end
  def hidden_dir?(path); end
  def hidden_file?(path); end
  def hidden_file_in_not_hidden_dir?(pattern, path); end
  def match_path?(pattern, path); end
  def maybe_hidden_file?(path); end
  def relative_path(path, base_dir = T.unsafe(nil)); end
  def smart_path(path); end

  class << self
    def absolute?(path); end
    def hidden_dir?(path); end
    def hidden_file?(path); end
    def hidden_file_in_not_hidden_dir?(pattern, path); end
    def match_path?(pattern, path); end
    def maybe_hidden_file?(path); end
    def relative_path(path, base_dir = T.unsafe(nil)); end
    def smart_path(path); end
  end
end

module RuboCop::Platform
  class << self
    def windows?; end
  end
end

RuboCop::ProcessedSource = RuboCop::AST::ProcessedSource

class RuboCop::RemoteConfig
  def initialize(url, base_dir); end

  def file; end
  def inherit_from_remote(file, path); end
  def uri; end

  private

  def cache_name_from_uri; end
  def cache_path; end
  def cache_path_exists?; end
  def cache_path_expired?; end
  def cloned_url; end
  def generate_request(uri); end
  def handle_response(response, limit, &block); end
  def request(uri = T.unsafe(nil), limit = T.unsafe(nil), &block); end
end

RuboCop::RemoteConfig::CACHE_LIFETIME = T.let(T.unsafe(nil), Integer)

class RuboCop::ResultCache
  def initialize(file, team, options, config_store, cache_root = T.unsafe(nil)); end

  def debug?; end
  def load; end
  def path; end
  def save(offenses); end
  def valid?; end

  private

  def any_symlink?(path); end
  def context_checksum(team, options); end
  def file_checksum(file, config_store); end
  def relevant_options_digest(options); end
  def rubocop_checksum; end
  def rubocop_extra_features; end
  def symlink_protection_triggered?(path); end
  def team_checksum(team); end

  class << self
    def allow_symlinks_in_cache_location?(config_store); end
    def cache_root(config_store); end
    def cleanup(config_store, verbose, cache_root = T.unsafe(nil)); end
    def inhibit_cleanup; end
    def inhibit_cleanup=(_arg0); end
    def rubocop_required_features; end
    def rubocop_required_features=(_arg0); end
    def source_checksum; end
    def source_checksum=(_arg0); end

    private

    def remove_files(files, dirs, remove_count); end
    def remove_oldest_files(files, dirs, cache_root, verbose); end
    def requires_file_removal?(file_count, config_store); end
  end
end

RuboCop::ResultCache::NON_CHANGING = T.let(T.unsafe(nil), Array)

class RuboCop::Runner
  def initialize(options, config_store); end

  def aborting=(_arg0); end
  def aborting?; end
  def errors; end
  def run(paths); end
  def warnings; end

  private

  def add_redundant_disables(file, offenses, source); end
  def cached_result(file, team); end
  def cached_run?; end
  def check_for_infinite_loop(processed_source, offenses_by_iteration); end
  def check_for_redundant_disables?(source); end
  def considered_failure?(offense); end
  def do_inspection_loop(file); end
  def each_inspected_file(files); end
  def file_finished(file, offenses); end
  def file_offense_cache(file); end
  def file_offenses(file); end
  def file_started(file); end
  def filter_cop_classes(cop_classes, config); end
  def filtered_run?; end
  def find_target_files(paths); end
  def formatter_set; end
  def get_processed_source(file); end
  def inspect_file(processed_source, team = T.unsafe(nil)); end
  def inspect_files(files); end
  def iterate_until_no_changes(source, offenses_by_iteration); end
  def list_files(paths); end
  def minimum_severity_to_fail; end
  def mobilize_team(processed_source); end
  def mobilized_cop_classes(config); end
  def process_file(file); end
  def qualify_option_cop_names; end
  def redundant_cop_disable_directive(file); end
  def save_in_cache(cache, offenses); end
  def standby_team(config); end
  def style_guide_cops_only?(config); end
  def team_for_redundant_disables(file, offenses, source); end
  def warm_cache(target_files); end
end

class RuboCop::Runner::InfiniteCorrectionLoop < ::RuntimeError
  def initialize(path, offenses_by_iteration, loop_start: T.unsafe(nil)); end

  def offenses; end
end

RuboCop::Runner::MAX_ITERATIONS = T.let(T.unsafe(nil), Integer)

class RuboCop::StringInterpreter
  class << self
    def interpret(string); end

    private

    def interpret_hex(escape); end
    def interpret_octal(escape); end
    def interpret_string_escape(escape); end
    def interpret_unicode(escape); end
  end
end

RuboCop::StringInterpreter::STRING_ESCAPES = T.let(T.unsafe(nil), Hash)
RuboCop::StringInterpreter::STRING_ESCAPE_REGEX = T.let(T.unsafe(nil), Regexp)

class RuboCop::TargetFinder
  def initialize(config_store, options = T.unsafe(nil)); end

  def all_cops_include; end
  def combined_exclude_glob_patterns(base_dir); end
  def configured_include?(file); end
  def debug?; end
  def fail_fast?; end
  def find(args, mode); end
  def find_files(base_dir, flags); end
  def force_exclusion?; end
  def included_file?(file); end
  def process_explicit_path(path, mode); end
  def ruby_executable?(file); end
  def ruby_extension?(file); end
  def ruby_extensions; end
  def ruby_file?(file); end
  def ruby_filename?(file); end
  def ruby_filenames; end
  def ruby_interpreters(file); end
  def stdin?; end
  def symlink_excluded_or_infinite_loop?(base_dir, current_dir, exclude_pattern, flags); end
  def target_files_in_dir(base_dir = T.unsafe(nil)); end
  def to_inspect?(file, hidden_files, base_dir_config); end
  def wanted_dir_patterns(base_dir, exclude_pattern, flags); end

  private

  def order; end
end

RuboCop::TargetFinder::HIDDEN_PATH_SUBSTRING = T.let(T.unsafe(nil), String)

class RuboCop::TargetRuby
  def initialize(config); end

  def rubocop_version_with_support; end
  def source; end
  def supported?; end
  def version; end

  class << self
    def supported_versions; end
  end
end

class RuboCop::TargetRuby::BundlerLockFile < ::RuboCop::TargetRuby::Source
  def name; end

  private

  def bundler_lock_file_path; end
  def find_version; end
end

RuboCop::TargetRuby::DEFAULT_VERSION = T.let(T.unsafe(nil), Float)

class RuboCop::TargetRuby::Default < ::RuboCop::TargetRuby::Source
  def name; end

  private

  def find_version; end
end

class RuboCop::TargetRuby::GemspecFile < ::RuboCop::TargetRuby::Source
  extend ::RuboCop::AST::NodePattern::Macros

  def gem_requirement?(param0 = T.unsafe(nil)); end
  def name; end
  def required_ruby_version(param0); end

  private

  def find_minimal_known_ruby(right_hand_side); end
  def find_version; end
  def gemspec_filename; end
  def gemspec_filepath; end
  def version_from_array(array); end
  def version_from_gemspec_file(file); end
  def version_from_right_hand_side(right_hand_side); end
end

RuboCop::TargetRuby::GemspecFile::GEMSPEC_EXTENSION = T.let(T.unsafe(nil), String)
RuboCop::TargetRuby::KNOWN_RUBIES = T.let(T.unsafe(nil), Array)
RuboCop::TargetRuby::OBSOLETE_RUBIES = T.let(T.unsafe(nil), Hash)

class RuboCop::TargetRuby::RuboCopConfig < ::RuboCop::TargetRuby::Source
  def name; end

  private

  def find_version; end
end

class RuboCop::TargetRuby::RubyVersionFile < ::RuboCop::TargetRuby::Source
  def name; end

  private

  def filename; end
  def find_version; end
  def pattern; end
  def version_file; end
end

RuboCop::TargetRuby::RubyVersionFile::RUBY_VERSION_FILENAME = T.let(T.unsafe(nil), String)
RuboCop::TargetRuby::RubyVersionFile::RUBY_VERSION_PATTERN = T.let(T.unsafe(nil), Regexp)
RuboCop::TargetRuby::SOURCES = T.let(T.unsafe(nil), Array)

class RuboCop::TargetRuby::Source
  def initialize(config); end

  def name; end
  def to_s; end
  def version; end
end

class RuboCop::TargetRuby::ToolVersionsFile < ::RuboCop::TargetRuby::RubyVersionFile
  def name; end

  private

  def filename; end
  def pattern; end
end

RuboCop::TargetRuby::ToolVersionsFile::TOOL_VERSIONS_FILENAME = T.let(T.unsafe(nil), String)
RuboCop::TargetRuby::ToolVersionsFile::TOOL_VERSIONS_PATTERN = T.let(T.unsafe(nil), Regexp)
RuboCop::Token = RuboCop::AST::Token

module RuboCop::Util
  class << self
    def silence_warnings; end
  end
end

class RuboCop::ValidationError < ::RuboCop::Error; end

module RuboCop::Version
  class << self
    def document_version; end
    def extension_versions(env); end
    def feature_version(feature); end
    def version(debug: T.unsafe(nil), env: T.unsafe(nil)); end
  end
end

RuboCop::Version::CANONICAL_FEATURE_NAMES = T.let(T.unsafe(nil), Hash)
RuboCop::Version::MSG = T.let(T.unsafe(nil), String)
RuboCop::Version::STRING = T.let(T.unsafe(nil), String)
class RuboCop::Warning < ::StandardError; end

module RuboCop::YAMLDuplicationChecker
  class << self
    def check(yaml_string, filename, &on_duplicated); end

    private

    def traverse(tree, &on_duplicated); end
  end
end

class String
  include ::Comparable
  include ::JSON::Ext::Generator::GeneratorMethods::String
  extend ::JSON::Ext::Generator::GeneratorMethods::String::Extend
end

String::BLANK_RE = T.let(T.unsafe(nil), Regexp)
String::ENCODED_BLANKS = T.let(T.unsafe(nil), Concurrent::Map)
