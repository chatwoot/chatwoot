# This file is generated by the templates/template.rb script and should not be
# modified manually. See templates/sig/prism/node.rbs.erb
# if you are looking to modify the template

module Prism
  # Methods implemented on every subclass of a singleton of Node
  interface _NodeSingleton
    def type: () -> Symbol
  end

  class Node
    extend _NodeSingleton

    attr_reader source: Source
    attr_reader node_id: Integer
    attr_reader location: Location
    attr_reader flags: Integer

    def newline?: () -> bool
    def static_literal?: () -> bool

    def start_offset: () -> Integer
    def end_offset: () -> Integer
    def source_lines: () -> Array[String]
    alias script_lines source_lines
    def slice: () -> String
    def slice_lines: () -> String
    def pretty_print: (untyped q) -> untyped
    def to_dot: () -> String
    def tunnel: (Integer line, Integer column) -> Array[Prism::node]
    def breadth_first_search: () { (Prism::node) -> bool } -> Prism::node?
    def deprecated: (*String) -> void
    def newline!: (Array[untyped]) -> void
  end

  type node_singleton = singleton(Node) & _NodeSingleton

  # Methods implemented by every subclass of Node
  interface _Node
    def accept: (_Visitor) -> void
    def child_nodes: () -> Array[Prism::node?]
    def deconstruct: () -> Array[Prism::node?]
    def compact_child_nodes: () -> Array[Prism::node]
    def comment_targets: () -> Array[Prism::node | Location]
    def fields: () -> Array[Prism::Reflection::Field]
    def inspect: () -> String
    def type: () -> Symbol
  end

  type node = Node & _Node


  # Represents the use of the `alias` keyword to alias a global variable.
  #
  #     alias $foo $bar
  #     ^^^^^^^^^^^^^^^
  class AliasGlobalVariableNode < Node
    include _Node

    attr_reader new_name: GlobalVariableReadNode | BackReferenceReadNode | NumberedReferenceReadNode
    attr_reader old_name: GlobalVariableReadNode | BackReferenceReadNode | NumberedReferenceReadNode | SymbolNode | MissingNode
    attr_reader keyword_loc: Location

    def initialize: (Source source, Integer node_id, Location location, Integer flags, GlobalVariableReadNode | BackReferenceReadNode | NumberedReferenceReadNode new_name, GlobalVariableReadNode | BackReferenceReadNode | NumberedReferenceReadNode | SymbolNode | MissingNode old_name, Location keyword_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?new_name: GlobalVariableReadNode | BackReferenceReadNode | NumberedReferenceReadNode, ?old_name: GlobalVariableReadNode | BackReferenceReadNode | NumberedReferenceReadNode | SymbolNode | MissingNode, ?keyword_loc: Location) -> AliasGlobalVariableNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, new_name: GlobalVariableReadNode | BackReferenceReadNode | NumberedReferenceReadNode, old_name: GlobalVariableReadNode | BackReferenceReadNode | NumberedReferenceReadNode | SymbolNode | MissingNode, keyword_loc: Location }
    def keyword: () -> String
    def type: () -> :alias_global_variable_node
            | ...
    def self.type: () -> :alias_global_variable_node
  end

  # Represents the use of the `alias` keyword to alias a method.
  #
  #     alias foo bar
  #     ^^^^^^^^^^^^^
  class AliasMethodNode < Node
    include _Node

    attr_reader new_name: SymbolNode | InterpolatedSymbolNode
    attr_reader old_name: SymbolNode | InterpolatedSymbolNode | GlobalVariableReadNode | MissingNode
    attr_reader keyword_loc: Location

    def initialize: (Source source, Integer node_id, Location location, Integer flags, SymbolNode | InterpolatedSymbolNode new_name, SymbolNode | InterpolatedSymbolNode | GlobalVariableReadNode | MissingNode old_name, Location keyword_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?new_name: SymbolNode | InterpolatedSymbolNode, ?old_name: SymbolNode | InterpolatedSymbolNode | GlobalVariableReadNode | MissingNode, ?keyword_loc: Location) -> AliasMethodNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, new_name: SymbolNode | InterpolatedSymbolNode, old_name: SymbolNode | InterpolatedSymbolNode | GlobalVariableReadNode | MissingNode, keyword_loc: Location }
    def keyword: () -> String
    def type: () -> :alias_method_node
            | ...
    def self.type: () -> :alias_method_node
  end

  # Represents an alternation pattern in pattern matching.
  #
  #     foo => bar | baz
  #            ^^^^^^^^^
  class AlternationPatternNode < Node
    include _Node

    attr_reader left: Prism::node
    attr_reader right: Prism::node
    attr_reader operator_loc: Location

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Prism::node left, Prism::node right, Location operator_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?left: Prism::node, ?right: Prism::node, ?operator_loc: Location) -> AlternationPatternNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, left: Prism::node, right: Prism::node, operator_loc: Location }
    def operator: () -> String
    def type: () -> :alternation_pattern_node
            | ...
    def self.type: () -> :alternation_pattern_node
  end

  # Represents the use of the `&&` operator or the `and` keyword.
  #
  #     left and right
  #     ^^^^^^^^^^^^^^
  class AndNode < Node
    include _Node

    attr_reader left: Prism::node
    attr_reader right: Prism::node
    attr_reader operator_loc: Location

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Prism::node left, Prism::node right, Location operator_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?left: Prism::node, ?right: Prism::node, ?operator_loc: Location) -> AndNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, left: Prism::node, right: Prism::node, operator_loc: Location }
    def operator: () -> String
    def type: () -> :and_node
            | ...
    def self.type: () -> :and_node
  end

  # Represents a set of arguments to a method or a keyword.
  #
  #     return foo, bar, baz
  #            ^^^^^^^^^^^^^
  class ArgumentsNode < Node
    include _Node

    def contains_forwarding?: () -> bool
    def contains_keywords?: () -> bool
    def contains_keyword_splat?: () -> bool
    def contains_splat?: () -> bool
    def contains_multiple_splats?: () -> bool

    attr_reader arguments: Array[Prism::node]

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Array[Prism::node] arguments) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?arguments: Array[Prism::node]) -> ArgumentsNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, arguments: Array[Prism::node] }
    def type: () -> :arguments_node
            | ...
    def self.type: () -> :arguments_node
  end

  # Represents an array literal. This can be a regular array using brackets or a special array using % like %w or %i.
  #
  #     [1, 2, 3]
  #     ^^^^^^^^^
  class ArrayNode < Node
    include _Node

    def contains_splat?: () -> bool

    attr_reader elements: Array[Prism::node]
    attr_reader opening_loc: Location?
    attr_reader closing_loc: Location?

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Array[Prism::node] elements, Location? opening_loc, Location? closing_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?elements: Array[Prism::node], ?opening_loc: Location?, ?closing_loc: Location?) -> ArrayNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, elements: Array[Prism::node], opening_loc: Location?, closing_loc: Location? }
    def opening: () -> String?
    def closing: () -> String?
    def type: () -> :array_node
            | ...
    def self.type: () -> :array_node
  end

  # Represents an array pattern in pattern matching.
  #
  #     foo in 1, 2
  #     ^^^^^^^^^^^
  #
  #     foo in [1, 2]
  #     ^^^^^^^^^^^^^
  #
  #     foo in *bar
  #     ^^^^^^^^^^^
  #
  #     foo in Bar[]
  #     ^^^^^^^^^^^^
  #
  #     foo in Bar[1, 2, 3]
  #     ^^^^^^^^^^^^^^^^^^^
  class ArrayPatternNode < Node
    include _Node

    attr_reader constant: ConstantReadNode | ConstantPathNode | nil
    attr_reader requireds: Array[Prism::node]
    attr_reader rest: Prism::node?
    attr_reader posts: Array[Prism::node]
    attr_reader opening_loc: Location?
    attr_reader closing_loc: Location?

    def initialize: (Source source, Integer node_id, Location location, Integer flags, ConstantReadNode | ConstantPathNode | nil constant, Array[Prism::node] requireds, Prism::node? rest, Array[Prism::node] posts, Location? opening_loc, Location? closing_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?constant: ConstantReadNode | ConstantPathNode | nil, ?requireds: Array[Prism::node], ?rest: Prism::node?, ?posts: Array[Prism::node], ?opening_loc: Location?, ?closing_loc: Location?) -> ArrayPatternNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, constant: ConstantReadNode | ConstantPathNode | nil, requireds: Array[Prism::node], rest: Prism::node?, posts: Array[Prism::node], opening_loc: Location?, closing_loc: Location? }
    def opening: () -> String?
    def closing: () -> String?
    def type: () -> :array_pattern_node
            | ...
    def self.type: () -> :array_pattern_node
  end

  # Represents a hash key/value pair.
  #
  #     { a => b }
  #       ^^^^^^
  class AssocNode < Node
    include _Node

    attr_reader key: Prism::node
    attr_reader value: Prism::node
    attr_reader operator_loc: Location?

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Prism::node key, Prism::node value, Location? operator_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?key: Prism::node, ?value: Prism::node, ?operator_loc: Location?) -> AssocNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, key: Prism::node, value: Prism::node, operator_loc: Location? }
    def operator: () -> String?
    def type: () -> :assoc_node
            | ...
    def self.type: () -> :assoc_node
  end

  # Represents a splat in a hash literal.
  #
  #     { **foo }
  #       ^^^^^
  class AssocSplatNode < Node
    include _Node

    attr_reader value: Prism::node?
    attr_reader operator_loc: Location

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Prism::node? value, Location operator_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?value: Prism::node?, ?operator_loc: Location) -> AssocSplatNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, value: Prism::node?, operator_loc: Location }
    def operator: () -> String
    def type: () -> :assoc_splat_node
            | ...
    def self.type: () -> :assoc_splat_node
  end

  # Represents reading a reference to a field in the previous match.
  #
  #     $'
  #     ^^
  class BackReferenceReadNode < Node
    include _Node

    attr_reader name: Symbol

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol) -> BackReferenceReadNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol }
    def type: () -> :back_reference_read_node
            | ...
    def self.type: () -> :back_reference_read_node
  end

  # Represents a begin statement.
  #
  #     begin
  #       foo
  #     end
  #     ^^^^^
  class BeginNode < Node
    include _Node

    attr_reader begin_keyword_loc: Location?
    attr_reader statements: StatementsNode?
    attr_reader rescue_clause: RescueNode?
    attr_reader else_clause: ElseNode?
    attr_reader ensure_clause: EnsureNode?
    attr_reader end_keyword_loc: Location?

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location? begin_keyword_loc, StatementsNode? statements, RescueNode? rescue_clause, ElseNode? else_clause, EnsureNode? ensure_clause, Location? end_keyword_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?begin_keyword_loc: Location?, ?statements: StatementsNode?, ?rescue_clause: RescueNode?, ?else_clause: ElseNode?, ?ensure_clause: EnsureNode?, ?end_keyword_loc: Location?) -> BeginNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, begin_keyword_loc: Location?, statements: StatementsNode?, rescue_clause: RescueNode?, else_clause: ElseNode?, ensure_clause: EnsureNode?, end_keyword_loc: Location? }
    def begin_keyword: () -> String?
    def end_keyword: () -> String?
    def type: () -> :begin_node
            | ...
    def self.type: () -> :begin_node
  end

  # Represents a block argument using `&`.
  #
  #     bar(&args)
  #     ^^^^^^^^^^
  class BlockArgumentNode < Node
    include _Node

    attr_reader expression: Prism::node?
    attr_reader operator_loc: Location

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Prism::node? expression, Location operator_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?expression: Prism::node?, ?operator_loc: Location) -> BlockArgumentNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, expression: Prism::node?, operator_loc: Location }
    def operator: () -> String
    def type: () -> :block_argument_node
            | ...
    def self.type: () -> :block_argument_node
  end

  # Represents a block local variable.
  #
  #     a { |; b| }
  #            ^
  class BlockLocalVariableNode < Node
    include _Node

    def repeated_parameter?: () -> bool

    attr_reader name: Symbol

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol) -> BlockLocalVariableNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol }
    def type: () -> :block_local_variable_node
            | ...
    def self.type: () -> :block_local_variable_node
  end

  # Represents a block of ruby code.
  #
  #     [1, 2, 3].each { |i| puts x }
  #                    ^^^^^^^^^^^^^^
  class BlockNode < Node
    include _Node

    attr_reader locals: Array[Symbol]
    attr_reader parameters: BlockParametersNode | NumberedParametersNode | ItParametersNode | nil
    attr_reader body: StatementsNode | BeginNode | nil
    attr_reader opening_loc: Location
    attr_reader closing_loc: Location

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Array[Symbol] locals, BlockParametersNode | NumberedParametersNode | ItParametersNode | nil parameters, StatementsNode | BeginNode | nil body, Location opening_loc, Location closing_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?locals: Array[Symbol], ?parameters: BlockParametersNode | NumberedParametersNode | ItParametersNode | nil, ?body: StatementsNode | BeginNode | nil, ?opening_loc: Location, ?closing_loc: Location) -> BlockNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, locals: Array[Symbol], parameters: BlockParametersNode | NumberedParametersNode | ItParametersNode | nil, body: StatementsNode | BeginNode | nil, opening_loc: Location, closing_loc: Location }
    def opening: () -> String
    def closing: () -> String
    def type: () -> :block_node
            | ...
    def self.type: () -> :block_node
  end

  # Represents a block parameter of a method, block, or lambda definition.
  #
  #     def a(&b)
  #           ^^
  #     end
  class BlockParameterNode < Node
    include _Node

    def repeated_parameter?: () -> bool

    attr_reader name: Symbol?
    attr_reader name_loc: Location?
    attr_reader operator_loc: Location

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol? name, Location? name_loc, Location operator_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol?, ?name_loc: Location?, ?operator_loc: Location) -> BlockParameterNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol?, name_loc: Location?, operator_loc: Location }
    def operator: () -> String
    def type: () -> :block_parameter_node
            | ...
    def self.type: () -> :block_parameter_node
  end

  # Represents a block's parameters declaration.
  #
  #     -> (a, b = 1; local) { }
  #        ^^^^^^^^^^^^^^^^^
  #
  #     foo do |a, b = 1; local|
  #            ^^^^^^^^^^^^^^^^^
  #     end
  class BlockParametersNode < Node
    include _Node

    attr_reader parameters: ParametersNode?
    attr_reader locals: Array[BlockLocalVariableNode]
    attr_reader opening_loc: Location?
    attr_reader closing_loc: Location?

    def initialize: (Source source, Integer node_id, Location location, Integer flags, ParametersNode? parameters, Array[BlockLocalVariableNode] locals, Location? opening_loc, Location? closing_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?parameters: ParametersNode?, ?locals: Array[BlockLocalVariableNode], ?opening_loc: Location?, ?closing_loc: Location?) -> BlockParametersNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, parameters: ParametersNode?, locals: Array[BlockLocalVariableNode], opening_loc: Location?, closing_loc: Location? }
    def opening: () -> String?
    def closing: () -> String?
    def type: () -> :block_parameters_node
            | ...
    def self.type: () -> :block_parameters_node
  end

  # Represents the use of the `break` keyword.
  #
  #     break foo
  #     ^^^^^^^^^
  class BreakNode < Node
    include _Node

    attr_reader arguments: ArgumentsNode?
    attr_reader keyword_loc: Location

    def initialize: (Source source, Integer node_id, Location location, Integer flags, ArgumentsNode? arguments, Location keyword_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?arguments: ArgumentsNode?, ?keyword_loc: Location) -> BreakNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, arguments: ArgumentsNode?, keyword_loc: Location }
    def keyword: () -> String
    def type: () -> :break_node
            | ...
    def self.type: () -> :break_node
  end

  # Represents the use of the `&&=` operator on a call.
  #
  #     foo.bar &&= value
  #     ^^^^^^^^^^^^^^^^^
  class CallAndWriteNode < Node
    include _Node

    def safe_navigation?: () -> bool
    def variable_call?: () -> bool
    def attribute_write?: () -> bool
    def ignore_visibility?: () -> bool

    attr_reader receiver: Prism::node?
    attr_reader call_operator_loc: Location?
    attr_reader message_loc: Location?
    attr_reader read_name: Symbol
    attr_reader write_name: Symbol
    attr_reader operator_loc: Location
    attr_reader value: Prism::node

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Prism::node? receiver, Location? call_operator_loc, Location? message_loc, Symbol read_name, Symbol write_name, Location operator_loc, Prism::node value) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?receiver: Prism::node?, ?call_operator_loc: Location?, ?message_loc: Location?, ?read_name: Symbol, ?write_name: Symbol, ?operator_loc: Location, ?value: Prism::node) -> CallAndWriteNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, receiver: Prism::node?, call_operator_loc: Location?, message_loc: Location?, read_name: Symbol, write_name: Symbol, operator_loc: Location, value: Prism::node }
    def call_operator: () -> String?
    def message: () -> String?
    def operator: () -> String
    def type: () -> :call_and_write_node
            | ...
    def self.type: () -> :call_and_write_node
  end

  # Represents a method call, in all of the various forms that can take.
  #
  #     foo
  #     ^^^
  #
  #     foo()
  #     ^^^^^
  #
  #     +foo
  #     ^^^^
  #
  #     foo + bar
  #     ^^^^^^^^^
  #
  #     foo.bar
  #     ^^^^^^^
  #
  #     foo&.bar
  #     ^^^^^^^^
  class CallNode < Node
    include _Node

    def safe_navigation?: () -> bool
    def variable_call?: () -> bool
    def attribute_write?: () -> bool
    def ignore_visibility?: () -> bool

    attr_reader receiver: Prism::node?
    attr_reader call_operator_loc: Location?
    attr_reader name: Symbol
    attr_reader message_loc: Location?
    attr_reader opening_loc: Location?
    attr_reader arguments: ArgumentsNode?
    attr_reader closing_loc: Location?
    attr_reader block: BlockNode | BlockArgumentNode | nil

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Prism::node? receiver, Location? call_operator_loc, Symbol name, Location? message_loc, Location? opening_loc, ArgumentsNode? arguments, Location? closing_loc, BlockNode | BlockArgumentNode | nil block) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?receiver: Prism::node?, ?call_operator_loc: Location?, ?name: Symbol, ?message_loc: Location?, ?opening_loc: Location?, ?arguments: ArgumentsNode?, ?closing_loc: Location?, ?block: BlockNode | BlockArgumentNode | nil) -> CallNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, receiver: Prism::node?, call_operator_loc: Location?, name: Symbol, message_loc: Location?, opening_loc: Location?, arguments: ArgumentsNode?, closing_loc: Location?, block: BlockNode | BlockArgumentNode | nil }
    def call_operator: () -> String?
    def message: () -> String?
    def opening: () -> String?
    def closing: () -> String?
    def type: () -> :call_node
            | ...
    def self.type: () -> :call_node
  end

  # Represents the use of an assignment operator on a call.
  #
  #     foo.bar += baz
  #     ^^^^^^^^^^^^^^
  class CallOperatorWriteNode < Node
    include _Node

    def safe_navigation?: () -> bool
    def variable_call?: () -> bool
    def attribute_write?: () -> bool
    def ignore_visibility?: () -> bool

    attr_reader receiver: Prism::node?
    attr_reader call_operator_loc: Location?
    attr_reader message_loc: Location?
    attr_reader read_name: Symbol
    attr_reader write_name: Symbol
    attr_reader binary_operator: Symbol
    attr_reader binary_operator_loc: Location
    attr_reader value: Prism::node

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Prism::node? receiver, Location? call_operator_loc, Location? message_loc, Symbol read_name, Symbol write_name, Symbol binary_operator, Location binary_operator_loc, Prism::node value) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?receiver: Prism::node?, ?call_operator_loc: Location?, ?message_loc: Location?, ?read_name: Symbol, ?write_name: Symbol, ?binary_operator: Symbol, ?binary_operator_loc: Location, ?value: Prism::node) -> CallOperatorWriteNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, receiver: Prism::node?, call_operator_loc: Location?, message_loc: Location?, read_name: Symbol, write_name: Symbol, binary_operator: Symbol, binary_operator_loc: Location, value: Prism::node }
    def call_operator: () -> String?
    def message: () -> String?
    def type: () -> :call_operator_write_node
            | ...
    def self.type: () -> :call_operator_write_node
  end

  # Represents the use of the `||=` operator on a call.
  #
  #     foo.bar ||= value
  #     ^^^^^^^^^^^^^^^^^
  class CallOrWriteNode < Node
    include _Node

    def safe_navigation?: () -> bool
    def variable_call?: () -> bool
    def attribute_write?: () -> bool
    def ignore_visibility?: () -> bool

    attr_reader receiver: Prism::node?
    attr_reader call_operator_loc: Location?
    attr_reader message_loc: Location?
    attr_reader read_name: Symbol
    attr_reader write_name: Symbol
    attr_reader operator_loc: Location
    attr_reader value: Prism::node

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Prism::node? receiver, Location? call_operator_loc, Location? message_loc, Symbol read_name, Symbol write_name, Location operator_loc, Prism::node value) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?receiver: Prism::node?, ?call_operator_loc: Location?, ?message_loc: Location?, ?read_name: Symbol, ?write_name: Symbol, ?operator_loc: Location, ?value: Prism::node) -> CallOrWriteNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, receiver: Prism::node?, call_operator_loc: Location?, message_loc: Location?, read_name: Symbol, write_name: Symbol, operator_loc: Location, value: Prism::node }
    def call_operator: () -> String?
    def message: () -> String?
    def operator: () -> String
    def type: () -> :call_or_write_node
            | ...
    def self.type: () -> :call_or_write_node
  end

  # Represents assigning to a method call.
  #
  #     foo.bar, = 1
  #     ^^^^^^^
  #
  #     begin
  #     rescue => foo.bar
  #               ^^^^^^^
  #     end
  #
  #     for foo.bar in baz do end
  #         ^^^^^^^
  class CallTargetNode < Node
    include _Node

    def safe_navigation?: () -> bool
    def variable_call?: () -> bool
    def attribute_write?: () -> bool
    def ignore_visibility?: () -> bool

    attr_reader receiver: Prism::node
    attr_reader call_operator_loc: Location
    attr_reader name: Symbol
    attr_reader message_loc: Location

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Prism::node receiver, Location call_operator_loc, Symbol name, Location message_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?receiver: Prism::node, ?call_operator_loc: Location, ?name: Symbol, ?message_loc: Location) -> CallTargetNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, receiver: Prism::node, call_operator_loc: Location, name: Symbol, message_loc: Location }
    def call_operator: () -> String
    def message: () -> String
    def type: () -> :call_target_node
            | ...
    def self.type: () -> :call_target_node
  end

  # Represents assigning to a local variable in pattern matching.
  #
  #     foo => [bar => baz]
  #            ^^^^^^^^^^^^
  class CapturePatternNode < Node
    include _Node

    attr_reader value: Prism::node
    attr_reader target: LocalVariableTargetNode
    attr_reader operator_loc: Location

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Prism::node value, LocalVariableTargetNode target, Location operator_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?value: Prism::node, ?target: LocalVariableTargetNode, ?operator_loc: Location) -> CapturePatternNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, value: Prism::node, target: LocalVariableTargetNode, operator_loc: Location }
    def operator: () -> String
    def type: () -> :capture_pattern_node
            | ...
    def self.type: () -> :capture_pattern_node
  end

  # Represents the use of a case statement for pattern matching.
  #
  #     case true
  #     in false
  #     end
  #     ^^^^^^^^^
  class CaseMatchNode < Node
    include _Node

    attr_reader predicate: Prism::node?
    attr_reader conditions: Array[InNode]
    attr_reader else_clause: ElseNode?
    attr_reader case_keyword_loc: Location
    attr_reader end_keyword_loc: Location

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Prism::node? predicate, Array[InNode] conditions, ElseNode? else_clause, Location case_keyword_loc, Location end_keyword_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?predicate: Prism::node?, ?conditions: Array[InNode], ?else_clause: ElseNode?, ?case_keyword_loc: Location, ?end_keyword_loc: Location) -> CaseMatchNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, predicate: Prism::node?, conditions: Array[InNode], else_clause: ElseNode?, case_keyword_loc: Location, end_keyword_loc: Location }
    def case_keyword: () -> String
    def end_keyword: () -> String
    def type: () -> :case_match_node
            | ...
    def self.type: () -> :case_match_node
  end

  # Represents the use of a case statement.
  #
  #     case true
  #     when false
  #     end
  #     ^^^^^^^^^^
  class CaseNode < Node
    include _Node

    attr_reader predicate: Prism::node?
    attr_reader conditions: Array[WhenNode]
    attr_reader else_clause: ElseNode?
    attr_reader case_keyword_loc: Location
    attr_reader end_keyword_loc: Location

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Prism::node? predicate, Array[WhenNode] conditions, ElseNode? else_clause, Location case_keyword_loc, Location end_keyword_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?predicate: Prism::node?, ?conditions: Array[WhenNode], ?else_clause: ElseNode?, ?case_keyword_loc: Location, ?end_keyword_loc: Location) -> CaseNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, predicate: Prism::node?, conditions: Array[WhenNode], else_clause: ElseNode?, case_keyword_loc: Location, end_keyword_loc: Location }
    def case_keyword: () -> String
    def end_keyword: () -> String
    def type: () -> :case_node
            | ...
    def self.type: () -> :case_node
  end

  # Represents a class declaration involving the `class` keyword.
  #
  #     class Foo end
  #     ^^^^^^^^^^^^^
  class ClassNode < Node
    include _Node

    attr_reader locals: Array[Symbol]
    attr_reader class_keyword_loc: Location
    attr_reader constant_path: ConstantReadNode | ConstantPathNode | CallNode
    attr_reader inheritance_operator_loc: Location?
    attr_reader superclass: Prism::node?
    attr_reader body: StatementsNode | BeginNode | nil
    attr_reader end_keyword_loc: Location
    attr_reader name: Symbol

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Array[Symbol] locals, Location class_keyword_loc, ConstantReadNode | ConstantPathNode | CallNode constant_path, Location? inheritance_operator_loc, Prism::node? superclass, StatementsNode | BeginNode | nil body, Location end_keyword_loc, Symbol name) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?locals: Array[Symbol], ?class_keyword_loc: Location, ?constant_path: ConstantReadNode | ConstantPathNode | CallNode, ?inheritance_operator_loc: Location?, ?superclass: Prism::node?, ?body: StatementsNode | BeginNode | nil, ?end_keyword_loc: Location, ?name: Symbol) -> ClassNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, locals: Array[Symbol], class_keyword_loc: Location, constant_path: ConstantReadNode | ConstantPathNode | CallNode, inheritance_operator_loc: Location?, superclass: Prism::node?, body: StatementsNode | BeginNode | nil, end_keyword_loc: Location, name: Symbol }
    def class_keyword: () -> String
    def inheritance_operator: () -> String?
    def end_keyword: () -> String
    def type: () -> :class_node
            | ...
    def self.type: () -> :class_node
  end

  # Represents the use of the `&&=` operator for assignment to a class variable.
  #
  #     @@target &&= value
  #     ^^^^^^^^^^^^^^^^^^
  class ClassVariableAndWriteNode < Node
    include _Node

    attr_reader name: Symbol
    attr_reader name_loc: Location
    attr_reader operator_loc: Location
    attr_reader value: Prism::node

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc, Location operator_loc, Prism::node value) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?operator_loc: Location, ?value: Prism::node) -> ClassVariableAndWriteNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol, name_loc: Location, operator_loc: Location, value: Prism::node }
    def operator: () -> String
    def type: () -> :class_variable_and_write_node
            | ...
    def self.type: () -> :class_variable_and_write_node
  end

  # Represents assigning to a class variable using an operator that isn't `=`.
  #
  #     @@target += value
  #     ^^^^^^^^^^^^^^^^^
  class ClassVariableOperatorWriteNode < Node
    include _Node

    attr_reader name: Symbol
    attr_reader name_loc: Location
    attr_reader binary_operator_loc: Location
    attr_reader value: Prism::node
    attr_reader binary_operator: Symbol

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc, Location binary_operator_loc, Prism::node value, Symbol binary_operator) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?binary_operator_loc: Location, ?value: Prism::node, ?binary_operator: Symbol) -> ClassVariableOperatorWriteNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol, name_loc: Location, binary_operator_loc: Location, value: Prism::node, binary_operator: Symbol }
    def type: () -> :class_variable_operator_write_node
            | ...
    def self.type: () -> :class_variable_operator_write_node
  end

  # Represents the use of the `||=` operator for assignment to a class variable.
  #
  #     @@target ||= value
  #     ^^^^^^^^^^^^^^^^^^
  class ClassVariableOrWriteNode < Node
    include _Node

    attr_reader name: Symbol
    attr_reader name_loc: Location
    attr_reader operator_loc: Location
    attr_reader value: Prism::node

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc, Location operator_loc, Prism::node value) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?operator_loc: Location, ?value: Prism::node) -> ClassVariableOrWriteNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol, name_loc: Location, operator_loc: Location, value: Prism::node }
    def operator: () -> String
    def type: () -> :class_variable_or_write_node
            | ...
    def self.type: () -> :class_variable_or_write_node
  end

  # Represents referencing a class variable.
  #
  #     @@foo
  #     ^^^^^
  class ClassVariableReadNode < Node
    include _Node

    attr_reader name: Symbol

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol) -> ClassVariableReadNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol }
    def type: () -> :class_variable_read_node
            | ...
    def self.type: () -> :class_variable_read_node
  end

  # Represents writing to a class variable in a context that doesn't have an explicit value.
  #
  #     @@foo, @@bar = baz
  #     ^^^^^  ^^^^^
  class ClassVariableTargetNode < Node
    include _Node

    attr_reader name: Symbol

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol) -> ClassVariableTargetNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol }
    def type: () -> :class_variable_target_node
            | ...
    def self.type: () -> :class_variable_target_node
  end

  # Represents writing to a class variable.
  #
  #     @@foo = 1
  #     ^^^^^^^^^
  class ClassVariableWriteNode < Node
    include _Node

    attr_reader name: Symbol
    attr_reader name_loc: Location
    attr_reader value: Prism::node
    attr_reader operator_loc: Location

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc, Prism::node value, Location operator_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?value: Prism::node, ?operator_loc: Location) -> ClassVariableWriteNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol, name_loc: Location, value: Prism::node, operator_loc: Location }
    def operator: () -> String
    def type: () -> :class_variable_write_node
            | ...
    def self.type: () -> :class_variable_write_node
  end

  # Represents the use of the `&&=` operator for assignment to a constant.
  #
  #     Target &&= value
  #     ^^^^^^^^^^^^^^^^
  class ConstantAndWriteNode < Node
    include _Node

    attr_reader name: Symbol
    attr_reader name_loc: Location
    attr_reader operator_loc: Location
    attr_reader value: Prism::node

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc, Location operator_loc, Prism::node value) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?operator_loc: Location, ?value: Prism::node) -> ConstantAndWriteNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol, name_loc: Location, operator_loc: Location, value: Prism::node }
    def operator: () -> String
    def type: () -> :constant_and_write_node
            | ...
    def self.type: () -> :constant_and_write_node
  end

  # Represents assigning to a constant using an operator that isn't `=`.
  #
  #     Target += value
  #     ^^^^^^^^^^^^^^^
  class ConstantOperatorWriteNode < Node
    include _Node

    attr_reader name: Symbol
    attr_reader name_loc: Location
    attr_reader binary_operator_loc: Location
    attr_reader value: Prism::node
    attr_reader binary_operator: Symbol

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc, Location binary_operator_loc, Prism::node value, Symbol binary_operator) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?binary_operator_loc: Location, ?value: Prism::node, ?binary_operator: Symbol) -> ConstantOperatorWriteNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol, name_loc: Location, binary_operator_loc: Location, value: Prism::node, binary_operator: Symbol }
    def type: () -> :constant_operator_write_node
            | ...
    def self.type: () -> :constant_operator_write_node
  end

  # Represents the use of the `||=` operator for assignment to a constant.
  #
  #     Target ||= value
  #     ^^^^^^^^^^^^^^^^
  class ConstantOrWriteNode < Node
    include _Node

    attr_reader name: Symbol
    attr_reader name_loc: Location
    attr_reader operator_loc: Location
    attr_reader value: Prism::node

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc, Location operator_loc, Prism::node value) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?operator_loc: Location, ?value: Prism::node) -> ConstantOrWriteNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol, name_loc: Location, operator_loc: Location, value: Prism::node }
    def operator: () -> String
    def type: () -> :constant_or_write_node
            | ...
    def self.type: () -> :constant_or_write_node
  end

  # Represents the use of the `&&=` operator for assignment to a constant path.
  #
  #     Parent::Child &&= value
  #     ^^^^^^^^^^^^^^^^^^^^^^^
  class ConstantPathAndWriteNode < Node
    include _Node

    attr_reader target: ConstantPathNode
    attr_reader operator_loc: Location
    attr_reader value: Prism::node

    def initialize: (Source source, Integer node_id, Location location, Integer flags, ConstantPathNode target, Location operator_loc, Prism::node value) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?target: ConstantPathNode, ?operator_loc: Location, ?value: Prism::node) -> ConstantPathAndWriteNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, target: ConstantPathNode, operator_loc: Location, value: Prism::node }
    def operator: () -> String
    def type: () -> :constant_path_and_write_node
            | ...
    def self.type: () -> :constant_path_and_write_node
  end

  # Represents accessing a constant through a path of `::` operators.
  #
  #     Foo::Bar
  #     ^^^^^^^^
  class ConstantPathNode < Node
    include _Node

    attr_reader parent: Prism::node?
    attr_reader name: Symbol?
    attr_reader delimiter_loc: Location
    attr_reader name_loc: Location

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Prism::node? parent, Symbol? name, Location delimiter_loc, Location name_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?parent: Prism::node?, ?name: Symbol?, ?delimiter_loc: Location, ?name_loc: Location) -> ConstantPathNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, parent: Prism::node?, name: Symbol?, delimiter_loc: Location, name_loc: Location }
    def delimiter: () -> String
    def type: () -> :constant_path_node
            | ...
    def self.type: () -> :constant_path_node
  end

  # Represents assigning to a constant path using an operator that isn't `=`.
  #
  #     Parent::Child += value
  #     ^^^^^^^^^^^^^^^^^^^^^^
  class ConstantPathOperatorWriteNode < Node
    include _Node

    attr_reader target: ConstantPathNode
    attr_reader binary_operator_loc: Location
    attr_reader value: Prism::node
    attr_reader binary_operator: Symbol

    def initialize: (Source source, Integer node_id, Location location, Integer flags, ConstantPathNode target, Location binary_operator_loc, Prism::node value, Symbol binary_operator) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?target: ConstantPathNode, ?binary_operator_loc: Location, ?value: Prism::node, ?binary_operator: Symbol) -> ConstantPathOperatorWriteNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, target: ConstantPathNode, binary_operator_loc: Location, value: Prism::node, binary_operator: Symbol }
    def type: () -> :constant_path_operator_write_node
            | ...
    def self.type: () -> :constant_path_operator_write_node
  end

  # Represents the use of the `||=` operator for assignment to a constant path.
  #
  #     Parent::Child ||= value
  #     ^^^^^^^^^^^^^^^^^^^^^^^
  class ConstantPathOrWriteNode < Node
    include _Node

    attr_reader target: ConstantPathNode
    attr_reader operator_loc: Location
    attr_reader value: Prism::node

    def initialize: (Source source, Integer node_id, Location location, Integer flags, ConstantPathNode target, Location operator_loc, Prism::node value) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?target: ConstantPathNode, ?operator_loc: Location, ?value: Prism::node) -> ConstantPathOrWriteNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, target: ConstantPathNode, operator_loc: Location, value: Prism::node }
    def operator: () -> String
    def type: () -> :constant_path_or_write_node
            | ...
    def self.type: () -> :constant_path_or_write_node
  end

  # Represents writing to a constant path in a context that doesn't have an explicit value.
  #
  #     Foo::Foo, Bar::Bar = baz
  #     ^^^^^^^^  ^^^^^^^^
  class ConstantPathTargetNode < Node
    include _Node

    attr_reader parent: Prism::node?
    attr_reader name: Symbol?
    attr_reader delimiter_loc: Location
    attr_reader name_loc: Location

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Prism::node? parent, Symbol? name, Location delimiter_loc, Location name_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?parent: Prism::node?, ?name: Symbol?, ?delimiter_loc: Location, ?name_loc: Location) -> ConstantPathTargetNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, parent: Prism::node?, name: Symbol?, delimiter_loc: Location, name_loc: Location }
    def delimiter: () -> String
    def type: () -> :constant_path_target_node
            | ...
    def self.type: () -> :constant_path_target_node
  end

  # Represents writing to a constant path.
  #
  #     ::Foo = 1
  #     ^^^^^^^^^
  #
  #     Foo::Bar = 1
  #     ^^^^^^^^^^^^
  #
  #     ::Foo::Bar = 1
  #     ^^^^^^^^^^^^^^
  class ConstantPathWriteNode < Node
    include _Node

    attr_reader target: ConstantPathNode
    attr_reader operator_loc: Location
    attr_reader value: Prism::node

    def initialize: (Source source, Integer node_id, Location location, Integer flags, ConstantPathNode target, Location operator_loc, Prism::node value) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?target: ConstantPathNode, ?operator_loc: Location, ?value: Prism::node) -> ConstantPathWriteNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, target: ConstantPathNode, operator_loc: Location, value: Prism::node }
    def operator: () -> String
    def type: () -> :constant_path_write_node
            | ...
    def self.type: () -> :constant_path_write_node
  end

  # Represents referencing a constant.
  #
  #     Foo
  #     ^^^
  class ConstantReadNode < Node
    include _Node

    attr_reader name: Symbol

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol) -> ConstantReadNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol }
    def type: () -> :constant_read_node
            | ...
    def self.type: () -> :constant_read_node
  end

  # Represents writing to a constant in a context that doesn't have an explicit value.
  #
  #     Foo, Bar = baz
  #     ^^^  ^^^
  class ConstantTargetNode < Node
    include _Node

    attr_reader name: Symbol

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol) -> ConstantTargetNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol }
    def type: () -> :constant_target_node
            | ...
    def self.type: () -> :constant_target_node
  end

  # Represents writing to a constant.
  #
  #     Foo = 1
  #     ^^^^^^^
  class ConstantWriteNode < Node
    include _Node

    attr_reader name: Symbol
    attr_reader name_loc: Location
    attr_reader value: Prism::node
    attr_reader operator_loc: Location

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc, Prism::node value, Location operator_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?value: Prism::node, ?operator_loc: Location) -> ConstantWriteNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol, name_loc: Location, value: Prism::node, operator_loc: Location }
    def operator: () -> String
    def type: () -> :constant_write_node
            | ...
    def self.type: () -> :constant_write_node
  end

  # Represents a method definition.
  #
  #     def method
  #     end
  #     ^^^^^^^^^^
  class DefNode < Node
    include _Node

    attr_reader name: Symbol
    attr_reader name_loc: Location
    attr_reader receiver: Prism::node?
    attr_reader parameters: ParametersNode?
    attr_reader body: StatementsNode | BeginNode | nil
    attr_reader locals: Array[Symbol]
    attr_reader def_keyword_loc: Location
    attr_reader operator_loc: Location?
    attr_reader lparen_loc: Location?
    attr_reader rparen_loc: Location?
    attr_reader equal_loc: Location?
    attr_reader end_keyword_loc: Location?

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc, Prism::node? receiver, ParametersNode? parameters, StatementsNode | BeginNode | nil body, Array[Symbol] locals, Location def_keyword_loc, Location? operator_loc, Location? lparen_loc, Location? rparen_loc, Location? equal_loc, Location? end_keyword_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?receiver: Prism::node?, ?parameters: ParametersNode?, ?body: StatementsNode | BeginNode | nil, ?locals: Array[Symbol], ?def_keyword_loc: Location, ?operator_loc: Location?, ?lparen_loc: Location?, ?rparen_loc: Location?, ?equal_loc: Location?, ?end_keyword_loc: Location?) -> DefNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol, name_loc: Location, receiver: Prism::node?, parameters: ParametersNode?, body: StatementsNode | BeginNode | nil, locals: Array[Symbol], def_keyword_loc: Location, operator_loc: Location?, lparen_loc: Location?, rparen_loc: Location?, equal_loc: Location?, end_keyword_loc: Location? }
    def def_keyword: () -> String
    def operator: () -> String?
    def lparen: () -> String?
    def rparen: () -> String?
    def equal: () -> String?
    def end_keyword: () -> String?
    def type: () -> :def_node
            | ...
    def self.type: () -> :def_node
  end

  # Represents the use of the `defined?` keyword.
  #
  #     defined?(a)
  #     ^^^^^^^^^^^
  class DefinedNode < Node
    include _Node

    attr_reader lparen_loc: Location?
    attr_reader value: Prism::node
    attr_reader rparen_loc: Location?
    attr_reader keyword_loc: Location

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location? lparen_loc, Prism::node value, Location? rparen_loc, Location keyword_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?lparen_loc: Location?, ?value: Prism::node, ?rparen_loc: Location?, ?keyword_loc: Location) -> DefinedNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, lparen_loc: Location?, value: Prism::node, rparen_loc: Location?, keyword_loc: Location }
    def lparen: () -> String?
    def rparen: () -> String?
    def keyword: () -> String
    def type: () -> :defined_node
            | ...
    def self.type: () -> :defined_node
  end

  # Represents an `else` clause in a `case`, `if`, or `unless` statement.
  #
  #     if a then b else c end
  #                 ^^^^^^^^^^
  class ElseNode < Node
    include _Node

    attr_reader else_keyword_loc: Location
    attr_reader statements: StatementsNode?
    attr_reader end_keyword_loc: Location?

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location else_keyword_loc, StatementsNode? statements, Location? end_keyword_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?else_keyword_loc: Location, ?statements: StatementsNode?, ?end_keyword_loc: Location?) -> ElseNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, else_keyword_loc: Location, statements: StatementsNode?, end_keyword_loc: Location? }
    def else_keyword: () -> String
    def end_keyword: () -> String?
    def type: () -> :else_node
            | ...
    def self.type: () -> :else_node
  end

  # Represents an interpolated set of statements.
  #
  #     "foo #{bar}"
  #          ^^^^^^
  class EmbeddedStatementsNode < Node
    include _Node

    attr_reader opening_loc: Location
    attr_reader statements: StatementsNode?
    attr_reader closing_loc: Location

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location opening_loc, StatementsNode? statements, Location closing_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?opening_loc: Location, ?statements: StatementsNode?, ?closing_loc: Location) -> EmbeddedStatementsNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, opening_loc: Location, statements: StatementsNode?, closing_loc: Location }
    def opening: () -> String
    def closing: () -> String
    def type: () -> :embedded_statements_node
            | ...
    def self.type: () -> :embedded_statements_node
  end

  # Represents an interpolated variable.
  #
  #     "foo #@bar"
  #          ^^^^^
  class EmbeddedVariableNode < Node
    include _Node

    attr_reader operator_loc: Location
    attr_reader variable: InstanceVariableReadNode | ClassVariableReadNode | GlobalVariableReadNode | BackReferenceReadNode | NumberedReferenceReadNode

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location operator_loc, InstanceVariableReadNode | ClassVariableReadNode | GlobalVariableReadNode | BackReferenceReadNode | NumberedReferenceReadNode variable) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?operator_loc: Location, ?variable: InstanceVariableReadNode | ClassVariableReadNode | GlobalVariableReadNode | BackReferenceReadNode | NumberedReferenceReadNode) -> EmbeddedVariableNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, operator_loc: Location, variable: InstanceVariableReadNode | ClassVariableReadNode | GlobalVariableReadNode | BackReferenceReadNode | NumberedReferenceReadNode }
    def operator: () -> String
    def type: () -> :embedded_variable_node
            | ...
    def self.type: () -> :embedded_variable_node
  end

  # Represents an `ensure` clause in a `begin` statement.
  #
  #     begin
  #       foo
  #     ensure
  #     ^^^^^^
  #       bar
  #     end
  class EnsureNode < Node
    include _Node

    attr_reader ensure_keyword_loc: Location
    attr_reader statements: StatementsNode?
    attr_reader end_keyword_loc: Location

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location ensure_keyword_loc, StatementsNode? statements, Location end_keyword_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?ensure_keyword_loc: Location, ?statements: StatementsNode?, ?end_keyword_loc: Location) -> EnsureNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, ensure_keyword_loc: Location, statements: StatementsNode?, end_keyword_loc: Location }
    def ensure_keyword: () -> String
    def end_keyword: () -> String
    def type: () -> :ensure_node
            | ...
    def self.type: () -> :ensure_node
  end

  # Represents the use of the literal `false` keyword.
  #
  #     false
  #     ^^^^^
  class FalseNode < Node
    include _Node


    def initialize: (Source source, Integer node_id, Location location, Integer flags) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer) -> FalseNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location }
    def type: () -> :false_node
            | ...
    def self.type: () -> :false_node
  end

  # Represents a find pattern in pattern matching.
  #
  #     foo in *bar, baz, *qux
  #            ^^^^^^^^^^^^^^^
  #
  #     foo in [*bar, baz, *qux]
  #            ^^^^^^^^^^^^^^^^^
  #
  #     foo in Foo(*bar, baz, *qux)
  #            ^^^^^^^^^^^^^^^^^^^^
  class FindPatternNode < Node
    include _Node

    attr_reader constant: ConstantReadNode | ConstantPathNode | nil
    attr_reader left: SplatNode
    attr_reader requireds: Array[Prism::node]
    attr_reader right: SplatNode | MissingNode
    attr_reader opening_loc: Location?
    attr_reader closing_loc: Location?

    def initialize: (Source source, Integer node_id, Location location, Integer flags, ConstantReadNode | ConstantPathNode | nil constant, SplatNode left, Array[Prism::node] requireds, SplatNode | MissingNode right, Location? opening_loc, Location? closing_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?constant: ConstantReadNode | ConstantPathNode | nil, ?left: SplatNode, ?requireds: Array[Prism::node], ?right: SplatNode | MissingNode, ?opening_loc: Location?, ?closing_loc: Location?) -> FindPatternNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, constant: ConstantReadNode | ConstantPathNode | nil, left: SplatNode, requireds: Array[Prism::node], right: SplatNode | MissingNode, opening_loc: Location?, closing_loc: Location? }
    def opening: () -> String?
    def closing: () -> String?
    def type: () -> :find_pattern_node
            | ...
    def self.type: () -> :find_pattern_node
  end

  # Represents the use of the `..` or `...` operators to create flip flops.
  #
  #     baz if foo .. bar
  #            ^^^^^^^^^^
  class FlipFlopNode < Node
    include _Node

    def exclude_end?: () -> bool

    attr_reader left: Prism::node?
    attr_reader right: Prism::node?
    attr_reader operator_loc: Location

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Prism::node? left, Prism::node? right, Location operator_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?left: Prism::node?, ?right: Prism::node?, ?operator_loc: Location) -> FlipFlopNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, left: Prism::node?, right: Prism::node?, operator_loc: Location }
    def operator: () -> String
    def type: () -> :flip_flop_node
            | ...
    def self.type: () -> :flip_flop_node
  end

  # Represents a floating point number literal.
  #
  #     1.0
  #     ^^^
  class FloatNode < Node
    include _Node

    attr_reader value: Float

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Float value) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?value: Float) -> FloatNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, value: Float }
    def type: () -> :float_node
            | ...
    def self.type: () -> :float_node
  end

  # Represents the use of the `for` keyword.
  #
  #     for i in a end
  #     ^^^^^^^^^^^^^^
  class ForNode < Node
    include _Node

    attr_reader index: LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | BackReferenceReadNode | NumberedReferenceReadNode | MissingNode
    attr_reader collection: Prism::node
    attr_reader statements: StatementsNode?
    attr_reader for_keyword_loc: Location
    attr_reader in_keyword_loc: Location
    attr_reader do_keyword_loc: Location?
    attr_reader end_keyword_loc: Location

    def initialize: (Source source, Integer node_id, Location location, Integer flags, LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | BackReferenceReadNode | NumberedReferenceReadNode | MissingNode index, Prism::node collection, StatementsNode? statements, Location for_keyword_loc, Location in_keyword_loc, Location? do_keyword_loc, Location end_keyword_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?index: LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | BackReferenceReadNode | NumberedReferenceReadNode | MissingNode, ?collection: Prism::node, ?statements: StatementsNode?, ?for_keyword_loc: Location, ?in_keyword_loc: Location, ?do_keyword_loc: Location?, ?end_keyword_loc: Location) -> ForNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, index: LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | BackReferenceReadNode | NumberedReferenceReadNode | MissingNode, collection: Prism::node, statements: StatementsNode?, for_keyword_loc: Location, in_keyword_loc: Location, do_keyword_loc: Location?, end_keyword_loc: Location }
    def for_keyword: () -> String
    def in_keyword: () -> String
    def do_keyword: () -> String?
    def end_keyword: () -> String
    def type: () -> :for_node
            | ...
    def self.type: () -> :for_node
  end

  # Represents forwarding all arguments to this method to another method.
  #
  #     def foo(...)
  #       bar(...)
  #           ^^^
  #     end
  class ForwardingArgumentsNode < Node
    include _Node


    def initialize: (Source source, Integer node_id, Location location, Integer flags) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer) -> ForwardingArgumentsNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location }
    def type: () -> :forwarding_arguments_node
            | ...
    def self.type: () -> :forwarding_arguments_node
  end

  # Represents the use of the forwarding parameter in a method, block, or lambda declaration.
  #
  #     def foo(...)
  #             ^^^
  #     end
  class ForwardingParameterNode < Node
    include _Node


    def initialize: (Source source, Integer node_id, Location location, Integer flags) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer) -> ForwardingParameterNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location }
    def type: () -> :forwarding_parameter_node
            | ...
    def self.type: () -> :forwarding_parameter_node
  end

  # Represents the use of the `super` keyword without parentheses or arguments.
  #
  #     super
  #     ^^^^^
  class ForwardingSuperNode < Node
    include _Node

    attr_reader block: BlockNode?

    def initialize: (Source source, Integer node_id, Location location, Integer flags, BlockNode? block) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?block: BlockNode?) -> ForwardingSuperNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, block: BlockNode? }
    def type: () -> :forwarding_super_node
            | ...
    def self.type: () -> :forwarding_super_node
  end

  # Represents the use of the `&&=` operator for assignment to a global variable.
  #
  #     $target &&= value
  #     ^^^^^^^^^^^^^^^^^
  class GlobalVariableAndWriteNode < Node
    include _Node

    attr_reader name: Symbol
    attr_reader name_loc: Location
    attr_reader operator_loc: Location
    attr_reader value: Prism::node

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc, Location operator_loc, Prism::node value) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?operator_loc: Location, ?value: Prism::node) -> GlobalVariableAndWriteNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol, name_loc: Location, operator_loc: Location, value: Prism::node }
    def operator: () -> String
    def type: () -> :global_variable_and_write_node
            | ...
    def self.type: () -> :global_variable_and_write_node
  end

  # Represents assigning to a global variable using an operator that isn't `=`.
  #
  #     $target += value
  #     ^^^^^^^^^^^^^^^^
  class GlobalVariableOperatorWriteNode < Node
    include _Node

    attr_reader name: Symbol
    attr_reader name_loc: Location
    attr_reader binary_operator_loc: Location
    attr_reader value: Prism::node
    attr_reader binary_operator: Symbol

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc, Location binary_operator_loc, Prism::node value, Symbol binary_operator) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?binary_operator_loc: Location, ?value: Prism::node, ?binary_operator: Symbol) -> GlobalVariableOperatorWriteNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol, name_loc: Location, binary_operator_loc: Location, value: Prism::node, binary_operator: Symbol }
    def type: () -> :global_variable_operator_write_node
            | ...
    def self.type: () -> :global_variable_operator_write_node
  end

  # Represents the use of the `||=` operator for assignment to a global variable.
  #
  #     $target ||= value
  #     ^^^^^^^^^^^^^^^^^
  class GlobalVariableOrWriteNode < Node
    include _Node

    attr_reader name: Symbol
    attr_reader name_loc: Location
    attr_reader operator_loc: Location
    attr_reader value: Prism::node

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc, Location operator_loc, Prism::node value) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?operator_loc: Location, ?value: Prism::node) -> GlobalVariableOrWriteNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol, name_loc: Location, operator_loc: Location, value: Prism::node }
    def operator: () -> String
    def type: () -> :global_variable_or_write_node
            | ...
    def self.type: () -> :global_variable_or_write_node
  end

  # Represents referencing a global variable.
  #
  #     $foo
  #     ^^^^
  class GlobalVariableReadNode < Node
    include _Node

    attr_reader name: Symbol

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol) -> GlobalVariableReadNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol }
    def type: () -> :global_variable_read_node
            | ...
    def self.type: () -> :global_variable_read_node
  end

  # Represents writing to a global variable in a context that doesn't have an explicit value.
  #
  #     $foo, $bar = baz
  #     ^^^^  ^^^^
  class GlobalVariableTargetNode < Node
    include _Node

    attr_reader name: Symbol

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol) -> GlobalVariableTargetNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol }
    def type: () -> :global_variable_target_node
            | ...
    def self.type: () -> :global_variable_target_node
  end

  # Represents writing to a global variable.
  #
  #     $foo = 1
  #     ^^^^^^^^
  class GlobalVariableWriteNode < Node
    include _Node

    attr_reader name: Symbol
    attr_reader name_loc: Location
    attr_reader value: Prism::node
    attr_reader operator_loc: Location

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc, Prism::node value, Location operator_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?value: Prism::node, ?operator_loc: Location) -> GlobalVariableWriteNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol, name_loc: Location, value: Prism::node, operator_loc: Location }
    def operator: () -> String
    def type: () -> :global_variable_write_node
            | ...
    def self.type: () -> :global_variable_write_node
  end

  # Represents a hash literal.
  #
  #     { a => b }
  #     ^^^^^^^^^^
  class HashNode < Node
    include _Node

    attr_reader opening_loc: Location
    attr_reader elements: Array[AssocNode | AssocSplatNode]
    attr_reader closing_loc: Location

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location opening_loc, Array[AssocNode | AssocSplatNode] elements, Location closing_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?opening_loc: Location, ?elements: Array[AssocNode | AssocSplatNode], ?closing_loc: Location) -> HashNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, opening_loc: Location, elements: Array[AssocNode | AssocSplatNode], closing_loc: Location }
    def opening: () -> String
    def closing: () -> String
    def type: () -> :hash_node
            | ...
    def self.type: () -> :hash_node
  end

  # Represents a hash pattern in pattern matching.
  #
  #     foo => { a: 1, b: 2 }
  #            ^^^^^^^^^^^^^^
  #
  #     foo => { a: 1, b: 2, **c }
  #            ^^^^^^^^^^^^^^^^^^^
  class HashPatternNode < Node
    include _Node

    attr_reader constant: ConstantReadNode | ConstantPathNode | nil
    attr_reader elements: Array[AssocNode]
    attr_reader rest: AssocSplatNode | NoKeywordsParameterNode | nil
    attr_reader opening_loc: Location?
    attr_reader closing_loc: Location?

    def initialize: (Source source, Integer node_id, Location location, Integer flags, ConstantReadNode | ConstantPathNode | nil constant, Array[AssocNode] elements, AssocSplatNode | NoKeywordsParameterNode | nil rest, Location? opening_loc, Location? closing_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?constant: ConstantReadNode | ConstantPathNode | nil, ?elements: Array[AssocNode], ?rest: AssocSplatNode | NoKeywordsParameterNode | nil, ?opening_loc: Location?, ?closing_loc: Location?) -> HashPatternNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, constant: ConstantReadNode | ConstantPathNode | nil, elements: Array[AssocNode], rest: AssocSplatNode | NoKeywordsParameterNode | nil, opening_loc: Location?, closing_loc: Location? }
    def opening: () -> String?
    def closing: () -> String?
    def type: () -> :hash_pattern_node
            | ...
    def self.type: () -> :hash_pattern_node
  end

  # Represents the use of the `if` keyword, either in the block form or the modifier form, or a ternary expression.
  #
  #     bar if foo
  #     ^^^^^^^^^^
  #
  #     if foo then bar end
  #     ^^^^^^^^^^^^^^^^^^^
  #
  #     foo ? bar : baz
  #     ^^^^^^^^^^^^^^^
  class IfNode < Node
    include _Node

    attr_reader if_keyword_loc: Location?
    attr_reader predicate: Prism::node
    attr_reader then_keyword_loc: Location?
    attr_reader statements: StatementsNode?
    attr_reader subsequent: ElseNode | IfNode | nil
    attr_reader end_keyword_loc: Location?

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location? if_keyword_loc, Prism::node predicate, Location? then_keyword_loc, StatementsNode? statements, ElseNode | IfNode | nil subsequent, Location? end_keyword_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?if_keyword_loc: Location?, ?predicate: Prism::node, ?then_keyword_loc: Location?, ?statements: StatementsNode?, ?subsequent: ElseNode | IfNode | nil, ?end_keyword_loc: Location?) -> IfNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, if_keyword_loc: Location?, predicate: Prism::node, then_keyword_loc: Location?, statements: StatementsNode?, subsequent: ElseNode | IfNode | nil, end_keyword_loc: Location? }
    def if_keyword: () -> String?
    def then_keyword: () -> String?
    def end_keyword: () -> String?
    def type: () -> :if_node
            | ...
    def self.type: () -> :if_node
  end

  # Represents an imaginary number literal.
  #
  #     1.0i
  #     ^^^^
  class ImaginaryNode < Node
    include _Node

    attr_reader numeric: FloatNode | IntegerNode | RationalNode

    def initialize: (Source source, Integer node_id, Location location, Integer flags, FloatNode | IntegerNode | RationalNode numeric) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?numeric: FloatNode | IntegerNode | RationalNode) -> ImaginaryNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, numeric: FloatNode | IntegerNode | RationalNode }
    def type: () -> :imaginary_node
            | ...
    def self.type: () -> :imaginary_node
  end

  # Represents a node that is implicitly being added to the tree but doesn't correspond directly to a node in the source.
  #
  #     { foo: }
  #       ^^^^
  #
  #     { Foo: }
  #       ^^^^
  #
  #     foo in { bar: }
  #              ^^^^
  class ImplicitNode < Node
    include _Node

    attr_reader value: LocalVariableReadNode | CallNode | ConstantReadNode | LocalVariableTargetNode

    def initialize: (Source source, Integer node_id, Location location, Integer flags, LocalVariableReadNode | CallNode | ConstantReadNode | LocalVariableTargetNode value) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?value: LocalVariableReadNode | CallNode | ConstantReadNode | LocalVariableTargetNode) -> ImplicitNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, value: LocalVariableReadNode | CallNode | ConstantReadNode | LocalVariableTargetNode }
    def type: () -> :implicit_node
            | ...
    def self.type: () -> :implicit_node
  end

  # Represents using a trailing comma to indicate an implicit rest parameter.
  #
  #     foo { |bar,| }
  #               ^
  #
  #     foo in [bar,]
  #                ^
  #
  #     for foo, in bar do end
  #            ^
  #
  #     foo, = bar
  #        ^
  class ImplicitRestNode < Node
    include _Node


    def initialize: (Source source, Integer node_id, Location location, Integer flags) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer) -> ImplicitRestNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location }
    def type: () -> :implicit_rest_node
            | ...
    def self.type: () -> :implicit_rest_node
  end

  # Represents the use of the `in` keyword in a case statement.
  #
  #     case a; in b then c end
  #             ^^^^^^^^^^^
  class InNode < Node
    include _Node

    attr_reader pattern: Prism::node
    attr_reader statements: StatementsNode?
    attr_reader in_loc: Location
    attr_reader then_loc: Location?

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Prism::node pattern, StatementsNode? statements, Location in_loc, Location? then_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?pattern: Prism::node, ?statements: StatementsNode?, ?in_loc: Location, ?then_loc: Location?) -> InNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, pattern: Prism::node, statements: StatementsNode?, in_loc: Location, then_loc: Location? }
    def in: () -> String
    def then: () -> String?
    def type: () -> :in_node
            | ...
    def self.type: () -> :in_node
  end

  # Represents the use of the `&&=` operator on a call to the `[]` method.
  #
  #     foo.bar[baz] &&= value
  #     ^^^^^^^^^^^^^^^^^^^^^^
  class IndexAndWriteNode < Node
    include _Node

    def safe_navigation?: () -> bool
    def variable_call?: () -> bool
    def attribute_write?: () -> bool
    def ignore_visibility?: () -> bool

    attr_reader receiver: Prism::node?
    attr_reader call_operator_loc: Location?
    attr_reader opening_loc: Location
    attr_reader arguments: ArgumentsNode?
    attr_reader closing_loc: Location
    attr_reader block: BlockArgumentNode?
    attr_reader operator_loc: Location
    attr_reader value: Prism::node

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Prism::node? receiver, Location? call_operator_loc, Location opening_loc, ArgumentsNode? arguments, Location closing_loc, BlockArgumentNode? block, Location operator_loc, Prism::node value) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?receiver: Prism::node?, ?call_operator_loc: Location?, ?opening_loc: Location, ?arguments: ArgumentsNode?, ?closing_loc: Location, ?block: BlockArgumentNode?, ?operator_loc: Location, ?value: Prism::node) -> IndexAndWriteNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, receiver: Prism::node?, call_operator_loc: Location?, opening_loc: Location, arguments: ArgumentsNode?, closing_loc: Location, block: BlockArgumentNode?, operator_loc: Location, value: Prism::node }
    def call_operator: () -> String?
    def opening: () -> String
    def closing: () -> String
    def operator: () -> String
    def type: () -> :index_and_write_node
            | ...
    def self.type: () -> :index_and_write_node
  end

  # Represents the use of an assignment operator on a call to `[]`.
  #
  #     foo.bar[baz] += value
  #     ^^^^^^^^^^^^^^^^^^^^^
  class IndexOperatorWriteNode < Node
    include _Node

    def safe_navigation?: () -> bool
    def variable_call?: () -> bool
    def attribute_write?: () -> bool
    def ignore_visibility?: () -> bool

    attr_reader receiver: Prism::node?
    attr_reader call_operator_loc: Location?
    attr_reader opening_loc: Location
    attr_reader arguments: ArgumentsNode?
    attr_reader closing_loc: Location
    attr_reader block: BlockArgumentNode?
    attr_reader binary_operator: Symbol
    attr_reader binary_operator_loc: Location
    attr_reader value: Prism::node

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Prism::node? receiver, Location? call_operator_loc, Location opening_loc, ArgumentsNode? arguments, Location closing_loc, BlockArgumentNode? block, Symbol binary_operator, Location binary_operator_loc, Prism::node value) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?receiver: Prism::node?, ?call_operator_loc: Location?, ?opening_loc: Location, ?arguments: ArgumentsNode?, ?closing_loc: Location, ?block: BlockArgumentNode?, ?binary_operator: Symbol, ?binary_operator_loc: Location, ?value: Prism::node) -> IndexOperatorWriteNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, receiver: Prism::node?, call_operator_loc: Location?, opening_loc: Location, arguments: ArgumentsNode?, closing_loc: Location, block: BlockArgumentNode?, binary_operator: Symbol, binary_operator_loc: Location, value: Prism::node }
    def call_operator: () -> String?
    def opening: () -> String
    def closing: () -> String
    def type: () -> :index_operator_write_node
            | ...
    def self.type: () -> :index_operator_write_node
  end

  # Represents the use of the `||=` operator on a call to `[]`.
  #
  #     foo.bar[baz] ||= value
  #     ^^^^^^^^^^^^^^^^^^^^^^
  class IndexOrWriteNode < Node
    include _Node

    def safe_navigation?: () -> bool
    def variable_call?: () -> bool
    def attribute_write?: () -> bool
    def ignore_visibility?: () -> bool

    attr_reader receiver: Prism::node?
    attr_reader call_operator_loc: Location?
    attr_reader opening_loc: Location
    attr_reader arguments: ArgumentsNode?
    attr_reader closing_loc: Location
    attr_reader block: BlockArgumentNode?
    attr_reader operator_loc: Location
    attr_reader value: Prism::node

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Prism::node? receiver, Location? call_operator_loc, Location opening_loc, ArgumentsNode? arguments, Location closing_loc, BlockArgumentNode? block, Location operator_loc, Prism::node value) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?receiver: Prism::node?, ?call_operator_loc: Location?, ?opening_loc: Location, ?arguments: ArgumentsNode?, ?closing_loc: Location, ?block: BlockArgumentNode?, ?operator_loc: Location, ?value: Prism::node) -> IndexOrWriteNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, receiver: Prism::node?, call_operator_loc: Location?, opening_loc: Location, arguments: ArgumentsNode?, closing_loc: Location, block: BlockArgumentNode?, operator_loc: Location, value: Prism::node }
    def call_operator: () -> String?
    def opening: () -> String
    def closing: () -> String
    def operator: () -> String
    def type: () -> :index_or_write_node
            | ...
    def self.type: () -> :index_or_write_node
  end

  # Represents assigning to an index.
  #
  #     foo[bar], = 1
  #     ^^^^^^^^
  #
  #     begin
  #     rescue => foo[bar]
  #               ^^^^^^^^
  #     end
  #
  #     for foo[bar] in baz do end
  #         ^^^^^^^^
  class IndexTargetNode < Node
    include _Node

    def safe_navigation?: () -> bool
    def variable_call?: () -> bool
    def attribute_write?: () -> bool
    def ignore_visibility?: () -> bool

    attr_reader receiver: Prism::node
    attr_reader opening_loc: Location
    attr_reader arguments: ArgumentsNode?
    attr_reader closing_loc: Location
    attr_reader block: BlockArgumentNode?

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Prism::node receiver, Location opening_loc, ArgumentsNode? arguments, Location closing_loc, BlockArgumentNode? block) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?receiver: Prism::node, ?opening_loc: Location, ?arguments: ArgumentsNode?, ?closing_loc: Location, ?block: BlockArgumentNode?) -> IndexTargetNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, receiver: Prism::node, opening_loc: Location, arguments: ArgumentsNode?, closing_loc: Location, block: BlockArgumentNode? }
    def opening: () -> String
    def closing: () -> String
    def type: () -> :index_target_node
            | ...
    def self.type: () -> :index_target_node
  end

  # Represents the use of the `&&=` operator for assignment to an instance variable.
  #
  #     @target &&= value
  #     ^^^^^^^^^^^^^^^^^
  class InstanceVariableAndWriteNode < Node
    include _Node

    attr_reader name: Symbol
    attr_reader name_loc: Location
    attr_reader operator_loc: Location
    attr_reader value: Prism::node

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc, Location operator_loc, Prism::node value) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?operator_loc: Location, ?value: Prism::node) -> InstanceVariableAndWriteNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol, name_loc: Location, operator_loc: Location, value: Prism::node }
    def operator: () -> String
    def type: () -> :instance_variable_and_write_node
            | ...
    def self.type: () -> :instance_variable_and_write_node
  end

  # Represents assigning to an instance variable using an operator that isn't `=`.
  #
  #     @target += value
  #     ^^^^^^^^^^^^^^^^
  class InstanceVariableOperatorWriteNode < Node
    include _Node

    attr_reader name: Symbol
    attr_reader name_loc: Location
    attr_reader binary_operator_loc: Location
    attr_reader value: Prism::node
    attr_reader binary_operator: Symbol

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc, Location binary_operator_loc, Prism::node value, Symbol binary_operator) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?binary_operator_loc: Location, ?value: Prism::node, ?binary_operator: Symbol) -> InstanceVariableOperatorWriteNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol, name_loc: Location, binary_operator_loc: Location, value: Prism::node, binary_operator: Symbol }
    def type: () -> :instance_variable_operator_write_node
            | ...
    def self.type: () -> :instance_variable_operator_write_node
  end

  # Represents the use of the `||=` operator for assignment to an instance variable.
  #
  #     @target ||= value
  #     ^^^^^^^^^^^^^^^^^
  class InstanceVariableOrWriteNode < Node
    include _Node

    attr_reader name: Symbol
    attr_reader name_loc: Location
    attr_reader operator_loc: Location
    attr_reader value: Prism::node

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc, Location operator_loc, Prism::node value) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?operator_loc: Location, ?value: Prism::node) -> InstanceVariableOrWriteNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol, name_loc: Location, operator_loc: Location, value: Prism::node }
    def operator: () -> String
    def type: () -> :instance_variable_or_write_node
            | ...
    def self.type: () -> :instance_variable_or_write_node
  end

  # Represents referencing an instance variable.
  #
  #     @foo
  #     ^^^^
  class InstanceVariableReadNode < Node
    include _Node

    attr_reader name: Symbol

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol) -> InstanceVariableReadNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol }
    def type: () -> :instance_variable_read_node
            | ...
    def self.type: () -> :instance_variable_read_node
  end

  # Represents writing to an instance variable in a context that doesn't have an explicit value.
  #
  #     @foo, @bar = baz
  #     ^^^^  ^^^^
  class InstanceVariableTargetNode < Node
    include _Node

    attr_reader name: Symbol

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol) -> InstanceVariableTargetNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol }
    def type: () -> :instance_variable_target_node
            | ...
    def self.type: () -> :instance_variable_target_node
  end

  # Represents writing to an instance variable.
  #
  #     @foo = 1
  #     ^^^^^^^^
  class InstanceVariableWriteNode < Node
    include _Node

    attr_reader name: Symbol
    attr_reader name_loc: Location
    attr_reader value: Prism::node
    attr_reader operator_loc: Location

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc, Prism::node value, Location operator_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?value: Prism::node, ?operator_loc: Location) -> InstanceVariableWriteNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol, name_loc: Location, value: Prism::node, operator_loc: Location }
    def operator: () -> String
    def type: () -> :instance_variable_write_node
            | ...
    def self.type: () -> :instance_variable_write_node
  end

  # Represents an integer number literal.
  #
  #     1
  #     ^
  class IntegerNode < Node
    include _Node

    def binary?: () -> bool
    def decimal?: () -> bool
    def octal?: () -> bool
    def hexadecimal?: () -> bool

    attr_reader value: Integer

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Integer value) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?value: Integer) -> IntegerNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, value: Integer }
    def type: () -> :integer_node
            | ...
    def self.type: () -> :integer_node
  end

  # Represents a regular expression literal that contains interpolation that is being used in the predicate of a conditional to implicitly match against the last line read by an IO object.
  #
  #     if /foo #{bar} baz/ then end
  #        ^^^^^^^^^^^^^^^^
  class InterpolatedMatchLastLineNode < Node
    include _Node

    def ignore_case?: () -> bool
    def extended?: () -> bool
    def multi_line?: () -> bool
    def once?: () -> bool
    def euc_jp?: () -> bool
    def ascii_8bit?: () -> bool
    def windows_31j?: () -> bool
    def utf_8?: () -> bool
    def forced_utf8_encoding?: () -> bool
    def forced_binary_encoding?: () -> bool
    def forced_us_ascii_encoding?: () -> bool

    attr_reader opening_loc: Location
    attr_reader parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode]
    attr_reader closing_loc: Location

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location opening_loc, Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode] parts, Location closing_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?opening_loc: Location, ?parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode], ?closing_loc: Location) -> InterpolatedMatchLastLineNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, opening_loc: Location, parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode], closing_loc: Location }
    def opening: () -> String
    def closing: () -> String
    def type: () -> :interpolated_match_last_line_node
            | ...
    def self.type: () -> :interpolated_match_last_line_node
  end

  # Represents a regular expression literal that contains interpolation.
  #
  #     /foo #{bar} baz/
  #     ^^^^^^^^^^^^^^^^
  class InterpolatedRegularExpressionNode < Node
    include _Node

    def ignore_case?: () -> bool
    def extended?: () -> bool
    def multi_line?: () -> bool
    def once?: () -> bool
    def euc_jp?: () -> bool
    def ascii_8bit?: () -> bool
    def windows_31j?: () -> bool
    def utf_8?: () -> bool
    def forced_utf8_encoding?: () -> bool
    def forced_binary_encoding?: () -> bool
    def forced_us_ascii_encoding?: () -> bool

    attr_reader opening_loc: Location
    attr_reader parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode]
    attr_reader closing_loc: Location

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location opening_loc, Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode] parts, Location closing_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?opening_loc: Location, ?parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode], ?closing_loc: Location) -> InterpolatedRegularExpressionNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, opening_loc: Location, parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode], closing_loc: Location }
    def opening: () -> String
    def closing: () -> String
    def type: () -> :interpolated_regular_expression_node
            | ...
    def self.type: () -> :interpolated_regular_expression_node
  end

  # Represents a string literal that contains interpolation.
  #
  #     "foo #{bar} baz"
  #     ^^^^^^^^^^^^^^^^
  class InterpolatedStringNode < Node
    include _Node

    def frozen?: () -> bool
    def mutable?: () -> bool

    attr_reader opening_loc: Location?
    attr_reader parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode | InterpolatedStringNode | XStringNode]
    attr_reader closing_loc: Location?

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location? opening_loc, Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode | InterpolatedStringNode | XStringNode] parts, Location? closing_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?opening_loc: Location?, ?parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode | InterpolatedStringNode | XStringNode], ?closing_loc: Location?) -> InterpolatedStringNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, opening_loc: Location?, parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode | InterpolatedStringNode | XStringNode], closing_loc: Location? }
    def opening: () -> String?
    def closing: () -> String?
    def type: () -> :interpolated_string_node
            | ...
    def self.type: () -> :interpolated_string_node
  end

  # Represents a symbol literal that contains interpolation.
  #
  #     :"foo #{bar} baz"
  #     ^^^^^^^^^^^^^^^^^
  class InterpolatedSymbolNode < Node
    include _Node

    attr_reader opening_loc: Location?
    attr_reader parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode]
    attr_reader closing_loc: Location?

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location? opening_loc, Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode] parts, Location? closing_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?opening_loc: Location?, ?parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode], ?closing_loc: Location?) -> InterpolatedSymbolNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, opening_loc: Location?, parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode], closing_loc: Location? }
    def opening: () -> String?
    def closing: () -> String?
    def type: () -> :interpolated_symbol_node
            | ...
    def self.type: () -> :interpolated_symbol_node
  end

  # Represents an xstring literal that contains interpolation.
  #
  #     `foo #{bar} baz`
  #     ^^^^^^^^^^^^^^^^
  class InterpolatedXStringNode < Node
    include _Node

    attr_reader opening_loc: Location
    attr_reader parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode]
    attr_reader closing_loc: Location

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location opening_loc, Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode] parts, Location closing_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?opening_loc: Location, ?parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode], ?closing_loc: Location) -> InterpolatedXStringNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, opening_loc: Location, parts: Array[StringNode | EmbeddedStatementsNode | EmbeddedVariableNode], closing_loc: Location }
    def opening: () -> String
    def closing: () -> String
    def type: () -> :interpolated_x_string_node
            | ...
    def self.type: () -> :interpolated_x_string_node
  end

  # Represents reading from the implicit `it` local variable.
  #
  #     -> { it }
  #          ^^
  class ItLocalVariableReadNode < Node
    include _Node


    def initialize: (Source source, Integer node_id, Location location, Integer flags) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer) -> ItLocalVariableReadNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location }
    def type: () -> :it_local_variable_read_node
            | ...
    def self.type: () -> :it_local_variable_read_node
  end

  # Represents an implicit set of parameters through the use of the `it` keyword within a block or lambda.
  #
  #     -> { it + it }
  #     ^^^^^^^^^^^^^^
  class ItParametersNode < Node
    include _Node


    def initialize: (Source source, Integer node_id, Location location, Integer flags) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer) -> ItParametersNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location }
    def type: () -> :it_parameters_node
            | ...
    def self.type: () -> :it_parameters_node
  end

  # Represents a hash literal without opening and closing braces.
  #
  #     foo(a: b)
  #         ^^^^
  class KeywordHashNode < Node
    include _Node

    def symbol_keys?: () -> bool

    attr_reader elements: Array[AssocNode | AssocSplatNode]

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Array[AssocNode | AssocSplatNode] elements) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?elements: Array[AssocNode | AssocSplatNode]) -> KeywordHashNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, elements: Array[AssocNode | AssocSplatNode] }
    def type: () -> :keyword_hash_node
            | ...
    def self.type: () -> :keyword_hash_node
  end

  # Represents a keyword rest parameter to a method, block, or lambda definition.
  #
  #     def a(**b)
  #           ^^^
  #     end
  class KeywordRestParameterNode < Node
    include _Node

    def repeated_parameter?: () -> bool

    attr_reader name: Symbol?
    attr_reader name_loc: Location?
    attr_reader operator_loc: Location

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol? name, Location? name_loc, Location operator_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol?, ?name_loc: Location?, ?operator_loc: Location) -> KeywordRestParameterNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol?, name_loc: Location?, operator_loc: Location }
    def operator: () -> String
    def type: () -> :keyword_rest_parameter_node
            | ...
    def self.type: () -> :keyword_rest_parameter_node
  end

  # Represents using a lambda literal (not the lambda method call).
  #
  #     ->(value) { value * 2 }
  #     ^^^^^^^^^^^^^^^^^^^^^^^
  class LambdaNode < Node
    include _Node

    attr_reader locals: Array[Symbol]
    attr_reader operator_loc: Location
    attr_reader opening_loc: Location
    attr_reader closing_loc: Location
    attr_reader parameters: BlockParametersNode | NumberedParametersNode | ItParametersNode | nil
    attr_reader body: StatementsNode | BeginNode | nil

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Array[Symbol] locals, Location operator_loc, Location opening_loc, Location closing_loc, BlockParametersNode | NumberedParametersNode | ItParametersNode | nil parameters, StatementsNode | BeginNode | nil body) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?locals: Array[Symbol], ?operator_loc: Location, ?opening_loc: Location, ?closing_loc: Location, ?parameters: BlockParametersNode | NumberedParametersNode | ItParametersNode | nil, ?body: StatementsNode | BeginNode | nil) -> LambdaNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, locals: Array[Symbol], operator_loc: Location, opening_loc: Location, closing_loc: Location, parameters: BlockParametersNode | NumberedParametersNode | ItParametersNode | nil, body: StatementsNode | BeginNode | nil }
    def operator: () -> String
    def opening: () -> String
    def closing: () -> String
    def type: () -> :lambda_node
            | ...
    def self.type: () -> :lambda_node
  end

  # Represents the use of the `&&=` operator for assignment to a local variable.
  #
  #     target &&= value
  #     ^^^^^^^^^^^^^^^^
  class LocalVariableAndWriteNode < Node
    include _Node

    attr_reader name_loc: Location
    attr_reader operator_loc: Location
    attr_reader value: Prism::node
    attr_reader name: Symbol
    attr_reader depth: Integer

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location name_loc, Location operator_loc, Prism::node value, Symbol name, Integer depth) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name_loc: Location, ?operator_loc: Location, ?value: Prism::node, ?name: Symbol, ?depth: Integer) -> LocalVariableAndWriteNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name_loc: Location, operator_loc: Location, value: Prism::node, name: Symbol, depth: Integer }
    def operator: () -> String
    def type: () -> :local_variable_and_write_node
            | ...
    def self.type: () -> :local_variable_and_write_node
  end

  # Represents assigning to a local variable using an operator that isn't `=`.
  #
  #     target += value
  #     ^^^^^^^^^^^^^^^
  class LocalVariableOperatorWriteNode < Node
    include _Node

    attr_reader name_loc: Location
    attr_reader binary_operator_loc: Location
    attr_reader value: Prism::node
    attr_reader name: Symbol
    attr_reader binary_operator: Symbol
    attr_reader depth: Integer

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location name_loc, Location binary_operator_loc, Prism::node value, Symbol name, Symbol binary_operator, Integer depth) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name_loc: Location, ?binary_operator_loc: Location, ?value: Prism::node, ?name: Symbol, ?binary_operator: Symbol, ?depth: Integer) -> LocalVariableOperatorWriteNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name_loc: Location, binary_operator_loc: Location, value: Prism::node, name: Symbol, binary_operator: Symbol, depth: Integer }
    def type: () -> :local_variable_operator_write_node
            | ...
    def self.type: () -> :local_variable_operator_write_node
  end

  # Represents the use of the `||=` operator for assignment to a local variable.
  #
  #     target ||= value
  #     ^^^^^^^^^^^^^^^^
  class LocalVariableOrWriteNode < Node
    include _Node

    attr_reader name_loc: Location
    attr_reader operator_loc: Location
    attr_reader value: Prism::node
    attr_reader name: Symbol
    attr_reader depth: Integer

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location name_loc, Location operator_loc, Prism::node value, Symbol name, Integer depth) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name_loc: Location, ?operator_loc: Location, ?value: Prism::node, ?name: Symbol, ?depth: Integer) -> LocalVariableOrWriteNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name_loc: Location, operator_loc: Location, value: Prism::node, name: Symbol, depth: Integer }
    def operator: () -> String
    def type: () -> :local_variable_or_write_node
            | ...
    def self.type: () -> :local_variable_or_write_node
  end

  # Represents reading a local variable. Note that this requires that a local variable of the same name has already been written to in the same scope, otherwise it is parsed as a method call.
  #
  #     foo
  #     ^^^
  class LocalVariableReadNode < Node
    include _Node

    attr_reader name: Symbol
    attr_reader depth: Integer

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name, Integer depth) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?depth: Integer) -> LocalVariableReadNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol, depth: Integer }
    def type: () -> :local_variable_read_node
            | ...
    def self.type: () -> :local_variable_read_node
  end

  # Represents writing to a local variable in a context that doesn't have an explicit value.
  #
  #     foo, bar = baz
  #     ^^^  ^^^
  class LocalVariableTargetNode < Node
    include _Node

    attr_reader name: Symbol
    attr_reader depth: Integer

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name, Integer depth) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?depth: Integer) -> LocalVariableTargetNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol, depth: Integer }
    def type: () -> :local_variable_target_node
            | ...
    def self.type: () -> :local_variable_target_node
  end

  # Represents writing to a local variable.
  #
  #     foo = 1
  #     ^^^^^^^
  class LocalVariableWriteNode < Node
    include _Node

    attr_reader name: Symbol
    attr_reader depth: Integer
    attr_reader name_loc: Location
    attr_reader value: Prism::node
    attr_reader operator_loc: Location

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name, Integer depth, Location name_loc, Prism::node value, Location operator_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?depth: Integer, ?name_loc: Location, ?value: Prism::node, ?operator_loc: Location) -> LocalVariableWriteNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol, depth: Integer, name_loc: Location, value: Prism::node, operator_loc: Location }
    def operator: () -> String
    def type: () -> :local_variable_write_node
            | ...
    def self.type: () -> :local_variable_write_node
  end

  # Represents a regular expression literal used in the predicate of a conditional to implicitly match against the last line read by an IO object.
  #
  #     if /foo/i then end
  #        ^^^^^^
  class MatchLastLineNode < Node
    include _Node

    def ignore_case?: () -> bool
    def extended?: () -> bool
    def multi_line?: () -> bool
    def once?: () -> bool
    def euc_jp?: () -> bool
    def ascii_8bit?: () -> bool
    def windows_31j?: () -> bool
    def utf_8?: () -> bool
    def forced_utf8_encoding?: () -> bool
    def forced_binary_encoding?: () -> bool
    def forced_us_ascii_encoding?: () -> bool

    attr_reader opening_loc: Location
    attr_reader content_loc: Location
    attr_reader closing_loc: Location
    attr_reader unescaped: String

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location opening_loc, Location content_loc, Location closing_loc, String unescaped) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?opening_loc: Location, ?content_loc: Location, ?closing_loc: Location, ?unescaped: String) -> MatchLastLineNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, opening_loc: Location, content_loc: Location, closing_loc: Location, unescaped: String }
    def opening: () -> String
    def content: () -> String
    def closing: () -> String
    def type: () -> :match_last_line_node
            | ...
    def self.type: () -> :match_last_line_node
  end

  # Represents the use of the modifier `in` operator.
  #
  #     foo in bar
  #     ^^^^^^^^^^
  class MatchPredicateNode < Node
    include _Node

    attr_reader value: Prism::node
    attr_reader pattern: Prism::node
    attr_reader operator_loc: Location

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Prism::node value, Prism::node pattern, Location operator_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?value: Prism::node, ?pattern: Prism::node, ?operator_loc: Location) -> MatchPredicateNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, value: Prism::node, pattern: Prism::node, operator_loc: Location }
    def operator: () -> String
    def type: () -> :match_predicate_node
            | ...
    def self.type: () -> :match_predicate_node
  end

  # Represents the use of the `=>` operator.
  #
  #     foo => bar
  #     ^^^^^^^^^^
  class MatchRequiredNode < Node
    include _Node

    attr_reader value: Prism::node
    attr_reader pattern: Prism::node
    attr_reader operator_loc: Location

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Prism::node value, Prism::node pattern, Location operator_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?value: Prism::node, ?pattern: Prism::node, ?operator_loc: Location) -> MatchRequiredNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, value: Prism::node, pattern: Prism::node, operator_loc: Location }
    def operator: () -> String
    def type: () -> :match_required_node
            | ...
    def self.type: () -> :match_required_node
  end

  # Represents writing local variables using a regular expression match with named capture groups.
  #
  #     /(?<foo>bar)/ =~ baz
  #     ^^^^^^^^^^^^^^^^^^^^
  class MatchWriteNode < Node
    include _Node

    attr_reader call: CallNode
    attr_reader targets: Array[LocalVariableTargetNode]

    def initialize: (Source source, Integer node_id, Location location, Integer flags, CallNode call, Array[LocalVariableTargetNode] targets) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?call: CallNode, ?targets: Array[LocalVariableTargetNode]) -> MatchWriteNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, call: CallNode, targets: Array[LocalVariableTargetNode] }
    def type: () -> :match_write_node
            | ...
    def self.type: () -> :match_write_node
  end

  # Represents a node that is missing from the source and results in a syntax error.
  class MissingNode < Node
    include _Node


    def initialize: (Source source, Integer node_id, Location location, Integer flags) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer) -> MissingNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location }
    def type: () -> :missing_node
            | ...
    def self.type: () -> :missing_node
  end

  # Represents a module declaration involving the `module` keyword.
  #
  #     module Foo end
  #     ^^^^^^^^^^^^^^
  class ModuleNode < Node
    include _Node

    attr_reader locals: Array[Symbol]
    attr_reader module_keyword_loc: Location
    attr_reader constant_path: ConstantReadNode | ConstantPathNode | MissingNode
    attr_reader body: StatementsNode | BeginNode | nil
    attr_reader end_keyword_loc: Location
    attr_reader name: Symbol

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Array[Symbol] locals, Location module_keyword_loc, ConstantReadNode | ConstantPathNode | MissingNode constant_path, StatementsNode | BeginNode | nil body, Location end_keyword_loc, Symbol name) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?locals: Array[Symbol], ?module_keyword_loc: Location, ?constant_path: ConstantReadNode | ConstantPathNode | MissingNode, ?body: StatementsNode | BeginNode | nil, ?end_keyword_loc: Location, ?name: Symbol) -> ModuleNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, locals: Array[Symbol], module_keyword_loc: Location, constant_path: ConstantReadNode | ConstantPathNode | MissingNode, body: StatementsNode | BeginNode | nil, end_keyword_loc: Location, name: Symbol }
    def module_keyword: () -> String
    def end_keyword: () -> String
    def type: () -> :module_node
            | ...
    def self.type: () -> :module_node
  end

  # Represents a multi-target expression.
  #
  #     a, (b, c) = 1, 2, 3
  #        ^^^^^^
  #
  # This can be a part of `MultiWriteNode` as above, or the target of a `for` loop
  #
  #     for a, b in [[1, 2], [3, 4]]
  #         ^^^^
  class MultiTargetNode < Node
    include _Node

    attr_reader lefts: Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | RequiredParameterNode | BackReferenceReadNode | NumberedReferenceReadNode]
    attr_reader rest: ImplicitRestNode | SplatNode | nil
    attr_reader rights: Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | RequiredParameterNode | BackReferenceReadNode | NumberedReferenceReadNode]
    attr_reader lparen_loc: Location?
    attr_reader rparen_loc: Location?

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | RequiredParameterNode | BackReferenceReadNode | NumberedReferenceReadNode] lefts, ImplicitRestNode | SplatNode | nil rest, Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | RequiredParameterNode | BackReferenceReadNode | NumberedReferenceReadNode] rights, Location? lparen_loc, Location? rparen_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?lefts: Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | RequiredParameterNode | BackReferenceReadNode | NumberedReferenceReadNode], ?rest: ImplicitRestNode | SplatNode | nil, ?rights: Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | RequiredParameterNode | BackReferenceReadNode | NumberedReferenceReadNode], ?lparen_loc: Location?, ?rparen_loc: Location?) -> MultiTargetNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, lefts: Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | RequiredParameterNode | BackReferenceReadNode | NumberedReferenceReadNode], rest: ImplicitRestNode | SplatNode | nil, rights: Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | RequiredParameterNode | BackReferenceReadNode | NumberedReferenceReadNode], lparen_loc: Location?, rparen_loc: Location? }
    def lparen: () -> String?
    def rparen: () -> String?
    def type: () -> :multi_target_node
            | ...
    def self.type: () -> :multi_target_node
  end

  # Represents a write to a multi-target expression.
  #
  #     a, b, c = 1, 2, 3
  #     ^^^^^^^^^^^^^^^^^
  class MultiWriteNode < Node
    include _Node

    attr_reader lefts: Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | BackReferenceReadNode | NumberedReferenceReadNode]
    attr_reader rest: ImplicitRestNode | SplatNode | nil
    attr_reader rights: Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | BackReferenceReadNode | NumberedReferenceReadNode]
    attr_reader lparen_loc: Location?
    attr_reader rparen_loc: Location?
    attr_reader operator_loc: Location
    attr_reader value: Prism::node

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | BackReferenceReadNode | NumberedReferenceReadNode] lefts, ImplicitRestNode | SplatNode | nil rest, Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | BackReferenceReadNode | NumberedReferenceReadNode] rights, Location? lparen_loc, Location? rparen_loc, Location operator_loc, Prism::node value) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?lefts: Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | BackReferenceReadNode | NumberedReferenceReadNode], ?rest: ImplicitRestNode | SplatNode | nil, ?rights: Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | BackReferenceReadNode | NumberedReferenceReadNode], ?lparen_loc: Location?, ?rparen_loc: Location?, ?operator_loc: Location, ?value: Prism::node) -> MultiWriteNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, lefts: Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | BackReferenceReadNode | NumberedReferenceReadNode], rest: ImplicitRestNode | SplatNode | nil, rights: Array[LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | MultiTargetNode | BackReferenceReadNode | NumberedReferenceReadNode], lparen_loc: Location?, rparen_loc: Location?, operator_loc: Location, value: Prism::node }
    def lparen: () -> String?
    def rparen: () -> String?
    def operator: () -> String
    def type: () -> :multi_write_node
            | ...
    def self.type: () -> :multi_write_node
  end

  # Represents the use of the `next` keyword.
  #
  #     next 1
  #     ^^^^^^
  class NextNode < Node
    include _Node

    attr_reader arguments: ArgumentsNode?
    attr_reader keyword_loc: Location

    def initialize: (Source source, Integer node_id, Location location, Integer flags, ArgumentsNode? arguments, Location keyword_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?arguments: ArgumentsNode?, ?keyword_loc: Location) -> NextNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, arguments: ArgumentsNode?, keyword_loc: Location }
    def keyword: () -> String
    def type: () -> :next_node
            | ...
    def self.type: () -> :next_node
  end

  # Represents the use of the `nil` keyword.
  #
  #     nil
  #     ^^^
  class NilNode < Node
    include _Node


    def initialize: (Source source, Integer node_id, Location location, Integer flags) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer) -> NilNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location }
    def type: () -> :nil_node
            | ...
    def self.type: () -> :nil_node
  end

  # Represents the use of `**nil` inside method arguments.
  #
  #     def a(**nil)
  #           ^^^^^
  #     end
  class NoKeywordsParameterNode < Node
    include _Node

    attr_reader operator_loc: Location
    attr_reader keyword_loc: Location

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location operator_loc, Location keyword_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?operator_loc: Location, ?keyword_loc: Location) -> NoKeywordsParameterNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, operator_loc: Location, keyword_loc: Location }
    def operator: () -> String
    def keyword: () -> String
    def type: () -> :no_keywords_parameter_node
            | ...
    def self.type: () -> :no_keywords_parameter_node
  end

  # Represents an implicit set of parameters through the use of numbered parameters within a block or lambda.
  #
  #     -> { _1 + _2 }
  #     ^^^^^^^^^^^^^^
  class NumberedParametersNode < Node
    include _Node

    attr_reader maximum: Integer

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Integer maximum) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?maximum: Integer) -> NumberedParametersNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, maximum: Integer }
    def type: () -> :numbered_parameters_node
            | ...
    def self.type: () -> :numbered_parameters_node
  end

  # Represents reading a numbered reference to a capture in the previous match.
  #
  #     $1
  #     ^^
  class NumberedReferenceReadNode < Node
    include _Node

    attr_reader number: Integer

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Integer number) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?number: Integer) -> NumberedReferenceReadNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, number: Integer }
    def type: () -> :numbered_reference_read_node
            | ...
    def self.type: () -> :numbered_reference_read_node
  end

  # Represents an optional keyword parameter to a method, block, or lambda definition.
  #
  #     def a(b: 1)
  #           ^^^^
  #     end
  class OptionalKeywordParameterNode < Node
    include _Node

    def repeated_parameter?: () -> bool

    attr_reader name: Symbol
    attr_reader name_loc: Location
    attr_reader value: Prism::node

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc, Prism::node value) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?value: Prism::node) -> OptionalKeywordParameterNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol, name_loc: Location, value: Prism::node }
    def type: () -> :optional_keyword_parameter_node
            | ...
    def self.type: () -> :optional_keyword_parameter_node
  end

  # Represents an optional parameter to a method, block, or lambda definition.
  #
  #     def a(b = 1)
  #           ^^^^^
  #     end
  class OptionalParameterNode < Node
    include _Node

    def repeated_parameter?: () -> bool

    attr_reader name: Symbol
    attr_reader name_loc: Location
    attr_reader operator_loc: Location
    attr_reader value: Prism::node

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc, Location operator_loc, Prism::node value) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location, ?operator_loc: Location, ?value: Prism::node) -> OptionalParameterNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol, name_loc: Location, operator_loc: Location, value: Prism::node }
    def operator: () -> String
    def type: () -> :optional_parameter_node
            | ...
    def self.type: () -> :optional_parameter_node
  end

  # Represents the use of the `||` operator or the `or` keyword.
  #
  #     left or right
  #     ^^^^^^^^^^^^^
  class OrNode < Node
    include _Node

    attr_reader left: Prism::node
    attr_reader right: Prism::node
    attr_reader operator_loc: Location

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Prism::node left, Prism::node right, Location operator_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?left: Prism::node, ?right: Prism::node, ?operator_loc: Location) -> OrNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, left: Prism::node, right: Prism::node, operator_loc: Location }
    def operator: () -> String
    def type: () -> :or_node
            | ...
    def self.type: () -> :or_node
  end

  # Represents the list of parameters on a method, block, or lambda definition.
  #
  #     def a(b, c, d)
  #           ^^^^^^^
  #     end
  class ParametersNode < Node
    include _Node

    attr_reader requireds: Array[RequiredParameterNode | MultiTargetNode]
    attr_reader optionals: Array[OptionalParameterNode]
    attr_reader rest: RestParameterNode | ImplicitRestNode | nil
    attr_reader posts: Array[RequiredParameterNode | MultiTargetNode | KeywordRestParameterNode | NoKeywordsParameterNode | ForwardingParameterNode]
    attr_reader keywords: Array[RequiredKeywordParameterNode | OptionalKeywordParameterNode]
    attr_reader keyword_rest: KeywordRestParameterNode | ForwardingParameterNode | NoKeywordsParameterNode | nil
    attr_reader block: BlockParameterNode?

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Array[RequiredParameterNode | MultiTargetNode] requireds, Array[OptionalParameterNode] optionals, RestParameterNode | ImplicitRestNode | nil rest, Array[RequiredParameterNode | MultiTargetNode | KeywordRestParameterNode | NoKeywordsParameterNode | ForwardingParameterNode] posts, Array[RequiredKeywordParameterNode | OptionalKeywordParameterNode] keywords, KeywordRestParameterNode | ForwardingParameterNode | NoKeywordsParameterNode | nil keyword_rest, BlockParameterNode? block) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?requireds: Array[RequiredParameterNode | MultiTargetNode], ?optionals: Array[OptionalParameterNode], ?rest: RestParameterNode | ImplicitRestNode | nil, ?posts: Array[RequiredParameterNode | MultiTargetNode | KeywordRestParameterNode | NoKeywordsParameterNode | ForwardingParameterNode], ?keywords: Array[RequiredKeywordParameterNode | OptionalKeywordParameterNode], ?keyword_rest: KeywordRestParameterNode | ForwardingParameterNode | NoKeywordsParameterNode | nil, ?block: BlockParameterNode?) -> ParametersNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, requireds: Array[RequiredParameterNode | MultiTargetNode], optionals: Array[OptionalParameterNode], rest: RestParameterNode | ImplicitRestNode | nil, posts: Array[RequiredParameterNode | MultiTargetNode | KeywordRestParameterNode | NoKeywordsParameterNode | ForwardingParameterNode], keywords: Array[RequiredKeywordParameterNode | OptionalKeywordParameterNode], keyword_rest: KeywordRestParameterNode | ForwardingParameterNode | NoKeywordsParameterNode | nil, block: BlockParameterNode? }
    def type: () -> :parameters_node
            | ...
    def self.type: () -> :parameters_node
  end

  # Represents a parenthesized expression
  #
  #     (10 + 34)
  #     ^^^^^^^^^
  class ParenthesesNode < Node
    include _Node

    def multiple_statements?: () -> bool

    attr_reader body: Prism::node?
    attr_reader opening_loc: Location
    attr_reader closing_loc: Location

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Prism::node? body, Location opening_loc, Location closing_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?body: Prism::node?, ?opening_loc: Location, ?closing_loc: Location) -> ParenthesesNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, body: Prism::node?, opening_loc: Location, closing_loc: Location }
    def opening: () -> String
    def closing: () -> String
    def type: () -> :parentheses_node
            | ...
    def self.type: () -> :parentheses_node
  end

  # Represents the use of the `^` operator for pinning an expression in a pattern matching expression.
  #
  #     foo in ^(bar)
  #            ^^^^^^
  class PinnedExpressionNode < Node
    include _Node

    attr_reader expression: Prism::node
    attr_reader operator_loc: Location
    attr_reader lparen_loc: Location
    attr_reader rparen_loc: Location

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Prism::node expression, Location operator_loc, Location lparen_loc, Location rparen_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?expression: Prism::node, ?operator_loc: Location, ?lparen_loc: Location, ?rparen_loc: Location) -> PinnedExpressionNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, expression: Prism::node, operator_loc: Location, lparen_loc: Location, rparen_loc: Location }
    def operator: () -> String
    def lparen: () -> String
    def rparen: () -> String
    def type: () -> :pinned_expression_node
            | ...
    def self.type: () -> :pinned_expression_node
  end

  # Represents the use of the `^` operator for pinning a variable in a pattern matching expression.
  #
  #     foo in ^bar
  #            ^^^^
  class PinnedVariableNode < Node
    include _Node

    attr_reader variable: LocalVariableReadNode | InstanceVariableReadNode | ClassVariableReadNode | GlobalVariableReadNode | BackReferenceReadNode | NumberedReferenceReadNode | ItLocalVariableReadNode | MissingNode
    attr_reader operator_loc: Location

    def initialize: (Source source, Integer node_id, Location location, Integer flags, LocalVariableReadNode | InstanceVariableReadNode | ClassVariableReadNode | GlobalVariableReadNode | BackReferenceReadNode | NumberedReferenceReadNode | ItLocalVariableReadNode | MissingNode variable, Location operator_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?variable: LocalVariableReadNode | InstanceVariableReadNode | ClassVariableReadNode | GlobalVariableReadNode | BackReferenceReadNode | NumberedReferenceReadNode | ItLocalVariableReadNode | MissingNode, ?operator_loc: Location) -> PinnedVariableNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, variable: LocalVariableReadNode | InstanceVariableReadNode | ClassVariableReadNode | GlobalVariableReadNode | BackReferenceReadNode | NumberedReferenceReadNode | ItLocalVariableReadNode | MissingNode, operator_loc: Location }
    def operator: () -> String
    def type: () -> :pinned_variable_node
            | ...
    def self.type: () -> :pinned_variable_node
  end

  # Represents the use of the `END` keyword.
  #
  #     END { foo }
  #     ^^^^^^^^^^^
  class PostExecutionNode < Node
    include _Node

    attr_reader statements: StatementsNode?
    attr_reader keyword_loc: Location
    attr_reader opening_loc: Location
    attr_reader closing_loc: Location

    def initialize: (Source source, Integer node_id, Location location, Integer flags, StatementsNode? statements, Location keyword_loc, Location opening_loc, Location closing_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?statements: StatementsNode?, ?keyword_loc: Location, ?opening_loc: Location, ?closing_loc: Location) -> PostExecutionNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, statements: StatementsNode?, keyword_loc: Location, opening_loc: Location, closing_loc: Location }
    def keyword: () -> String
    def opening: () -> String
    def closing: () -> String
    def type: () -> :post_execution_node
            | ...
    def self.type: () -> :post_execution_node
  end

  # Represents the use of the `BEGIN` keyword.
  #
  #     BEGIN { foo }
  #     ^^^^^^^^^^^^^
  class PreExecutionNode < Node
    include _Node

    attr_reader statements: StatementsNode?
    attr_reader keyword_loc: Location
    attr_reader opening_loc: Location
    attr_reader closing_loc: Location

    def initialize: (Source source, Integer node_id, Location location, Integer flags, StatementsNode? statements, Location keyword_loc, Location opening_loc, Location closing_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?statements: StatementsNode?, ?keyword_loc: Location, ?opening_loc: Location, ?closing_loc: Location) -> PreExecutionNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, statements: StatementsNode?, keyword_loc: Location, opening_loc: Location, closing_loc: Location }
    def keyword: () -> String
    def opening: () -> String
    def closing: () -> String
    def type: () -> :pre_execution_node
            | ...
    def self.type: () -> :pre_execution_node
  end

  # The top level node of any parse tree.
  class ProgramNode < Node
    include _Node

    attr_reader locals: Array[Symbol]
    attr_reader statements: StatementsNode

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Array[Symbol] locals, StatementsNode statements) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?locals: Array[Symbol], ?statements: StatementsNode) -> ProgramNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, locals: Array[Symbol], statements: StatementsNode }
    def type: () -> :program_node
            | ...
    def self.type: () -> :program_node
  end

  # Represents the use of the `..` or `...` operators.
  #
  #     1..2
  #     ^^^^
  #
  #     c if a =~ /left/ ... b =~ /right/
  #          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  class RangeNode < Node
    include _Node

    def exclude_end?: () -> bool

    attr_reader left: Prism::node?
    attr_reader right: Prism::node?
    attr_reader operator_loc: Location

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Prism::node? left, Prism::node? right, Location operator_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?left: Prism::node?, ?right: Prism::node?, ?operator_loc: Location) -> RangeNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, left: Prism::node?, right: Prism::node?, operator_loc: Location }
    def operator: () -> String
    def type: () -> :range_node
            | ...
    def self.type: () -> :range_node
  end

  # Represents a rational number literal.
  #
  #     1.0r
  #     ^^^^
  class RationalNode < Node
    include _Node

    def binary?: () -> bool
    def decimal?: () -> bool
    def octal?: () -> bool
    def hexadecimal?: () -> bool

    attr_reader numerator: Integer
    attr_reader denominator: Integer

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Integer numerator, Integer denominator) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?numerator: Integer, ?denominator: Integer) -> RationalNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, numerator: Integer, denominator: Integer }
    def type: () -> :rational_node
            | ...
    def self.type: () -> :rational_node
  end

  # Represents the use of the `redo` keyword.
  #
  #     redo
  #     ^^^^
  class RedoNode < Node
    include _Node


    def initialize: (Source source, Integer node_id, Location location, Integer flags) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer) -> RedoNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location }
    def type: () -> :redo_node
            | ...
    def self.type: () -> :redo_node
  end

  # Represents a regular expression literal with no interpolation.
  #
  #     /foo/i
  #     ^^^^^^
  class RegularExpressionNode < Node
    include _Node

    def ignore_case?: () -> bool
    def extended?: () -> bool
    def multi_line?: () -> bool
    def once?: () -> bool
    def euc_jp?: () -> bool
    def ascii_8bit?: () -> bool
    def windows_31j?: () -> bool
    def utf_8?: () -> bool
    def forced_utf8_encoding?: () -> bool
    def forced_binary_encoding?: () -> bool
    def forced_us_ascii_encoding?: () -> bool

    attr_reader opening_loc: Location
    attr_reader content_loc: Location
    attr_reader closing_loc: Location
    attr_reader unescaped: String

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location opening_loc, Location content_loc, Location closing_loc, String unescaped) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?opening_loc: Location, ?content_loc: Location, ?closing_loc: Location, ?unescaped: String) -> RegularExpressionNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, opening_loc: Location, content_loc: Location, closing_loc: Location, unescaped: String }
    def opening: () -> String
    def content: () -> String
    def closing: () -> String
    def type: () -> :regular_expression_node
            | ...
    def self.type: () -> :regular_expression_node
  end

  # Represents a required keyword parameter to a method, block, or lambda definition.
  #
  #     def a(b: )
  #           ^^
  #     end
  class RequiredKeywordParameterNode < Node
    include _Node

    def repeated_parameter?: () -> bool

    attr_reader name: Symbol
    attr_reader name_loc: Location

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name, Location name_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol, ?name_loc: Location) -> RequiredKeywordParameterNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol, name_loc: Location }
    def type: () -> :required_keyword_parameter_node
            | ...
    def self.type: () -> :required_keyword_parameter_node
  end

  # Represents a required parameter to a method, block, or lambda definition.
  #
  #     def a(b)
  #           ^
  #     end
  class RequiredParameterNode < Node
    include _Node

    def repeated_parameter?: () -> bool

    attr_reader name: Symbol

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol name) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol) -> RequiredParameterNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol }
    def type: () -> :required_parameter_node
            | ...
    def self.type: () -> :required_parameter_node
  end

  # Represents an expression modified with a rescue.
  #
  #     foo rescue nil
  #     ^^^^^^^^^^^^^^
  class RescueModifierNode < Node
    include _Node

    attr_reader expression: Prism::node
    attr_reader keyword_loc: Location
    attr_reader rescue_expression: Prism::node

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Prism::node expression, Location keyword_loc, Prism::node rescue_expression) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?expression: Prism::node, ?keyword_loc: Location, ?rescue_expression: Prism::node) -> RescueModifierNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, expression: Prism::node, keyword_loc: Location, rescue_expression: Prism::node }
    def keyword: () -> String
    def type: () -> :rescue_modifier_node
            | ...
    def self.type: () -> :rescue_modifier_node
  end

  # Represents a rescue statement.
  #
  #     begin
  #     rescue Foo, *splat, Bar => ex
  #       foo
  #     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  #     end
  #
  # `Foo, *splat, Bar` are in the `exceptions` field. `ex` is in the `reference` field.
  class RescueNode < Node
    include _Node

    attr_reader keyword_loc: Location
    attr_reader exceptions: Array[Prism::node]
    attr_reader operator_loc: Location?
    attr_reader reference: LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | BackReferenceReadNode | NumberedReferenceReadNode | MissingNode | nil
    attr_reader then_keyword_loc: Location?
    attr_reader statements: StatementsNode?
    attr_reader subsequent: RescueNode?

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location keyword_loc, Array[Prism::node] exceptions, Location? operator_loc, LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | BackReferenceReadNode | NumberedReferenceReadNode | MissingNode | nil reference, Location? then_keyword_loc, StatementsNode? statements, RescueNode? subsequent) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?keyword_loc: Location, ?exceptions: Array[Prism::node], ?operator_loc: Location?, ?reference: LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | BackReferenceReadNode | NumberedReferenceReadNode | MissingNode | nil, ?then_keyword_loc: Location?, ?statements: StatementsNode?, ?subsequent: RescueNode?) -> RescueNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, keyword_loc: Location, exceptions: Array[Prism::node], operator_loc: Location?, reference: LocalVariableTargetNode | InstanceVariableTargetNode | ClassVariableTargetNode | GlobalVariableTargetNode | ConstantTargetNode | ConstantPathTargetNode | CallTargetNode | IndexTargetNode | BackReferenceReadNode | NumberedReferenceReadNode | MissingNode | nil, then_keyword_loc: Location?, statements: StatementsNode?, subsequent: RescueNode? }
    def keyword: () -> String
    def operator: () -> String?
    def then_keyword: () -> String?
    def type: () -> :rescue_node
            | ...
    def self.type: () -> :rescue_node
  end

  # Represents a rest parameter to a method, block, or lambda definition.
  #
  #     def a(*b)
  #           ^^
  #     end
  class RestParameterNode < Node
    include _Node

    def repeated_parameter?: () -> bool

    attr_reader name: Symbol?
    attr_reader name_loc: Location?
    attr_reader operator_loc: Location

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Symbol? name, Location? name_loc, Location operator_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?name: Symbol?, ?name_loc: Location?, ?operator_loc: Location) -> RestParameterNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, name: Symbol?, name_loc: Location?, operator_loc: Location }
    def operator: () -> String
    def type: () -> :rest_parameter_node
            | ...
    def self.type: () -> :rest_parameter_node
  end

  # Represents the use of the `retry` keyword.
  #
  #     retry
  #     ^^^^^
  class RetryNode < Node
    include _Node


    def initialize: (Source source, Integer node_id, Location location, Integer flags) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer) -> RetryNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location }
    def type: () -> :retry_node
            | ...
    def self.type: () -> :retry_node
  end

  # Represents the use of the `return` keyword.
  #
  #     return 1
  #     ^^^^^^^^
  class ReturnNode < Node
    include _Node

    attr_reader keyword_loc: Location
    attr_reader arguments: ArgumentsNode?

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location keyword_loc, ArgumentsNode? arguments) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?keyword_loc: Location, ?arguments: ArgumentsNode?) -> ReturnNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, keyword_loc: Location, arguments: ArgumentsNode? }
    def keyword: () -> String
    def type: () -> :return_node
            | ...
    def self.type: () -> :return_node
  end

  # Represents the `self` keyword.
  #
  #     self
  #     ^^^^
  class SelfNode < Node
    include _Node


    def initialize: (Source source, Integer node_id, Location location, Integer flags) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer) -> SelfNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location }
    def type: () -> :self_node
            | ...
    def self.type: () -> :self_node
  end

  # This node wraps a constant write to indicate that when the value is written, it should have its shareability state modified.
  #
  #     # shareable_constant_value: literal
  #     C = { a: 1 }
  #     ^^^^^^^^^^^^
  class ShareableConstantNode < Node
    include _Node

    def literal?: () -> bool
    def experimental_everything?: () -> bool
    def experimental_copy?: () -> bool

    attr_reader write: ConstantWriteNode | ConstantAndWriteNode | ConstantOrWriteNode | ConstantOperatorWriteNode | ConstantPathWriteNode | ConstantPathAndWriteNode | ConstantPathOrWriteNode | ConstantPathOperatorWriteNode

    def initialize: (Source source, Integer node_id, Location location, Integer flags, ConstantWriteNode | ConstantAndWriteNode | ConstantOrWriteNode | ConstantOperatorWriteNode | ConstantPathWriteNode | ConstantPathAndWriteNode | ConstantPathOrWriteNode | ConstantPathOperatorWriteNode write) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?write: ConstantWriteNode | ConstantAndWriteNode | ConstantOrWriteNode | ConstantOperatorWriteNode | ConstantPathWriteNode | ConstantPathAndWriteNode | ConstantPathOrWriteNode | ConstantPathOperatorWriteNode) -> ShareableConstantNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, write: ConstantWriteNode | ConstantAndWriteNode | ConstantOrWriteNode | ConstantOperatorWriteNode | ConstantPathWriteNode | ConstantPathAndWriteNode | ConstantPathOrWriteNode | ConstantPathOperatorWriteNode }
    def type: () -> :shareable_constant_node
            | ...
    def self.type: () -> :shareable_constant_node
  end

  # Represents a singleton class declaration involving the `class` keyword.
  #
  #     class << self end
  #     ^^^^^^^^^^^^^^^^^
  class SingletonClassNode < Node
    include _Node

    attr_reader locals: Array[Symbol]
    attr_reader class_keyword_loc: Location
    attr_reader operator_loc: Location
    attr_reader expression: Prism::node
    attr_reader body: StatementsNode | BeginNode | nil
    attr_reader end_keyword_loc: Location

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Array[Symbol] locals, Location class_keyword_loc, Location operator_loc, Prism::node expression, StatementsNode | BeginNode | nil body, Location end_keyword_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?locals: Array[Symbol], ?class_keyword_loc: Location, ?operator_loc: Location, ?expression: Prism::node, ?body: StatementsNode | BeginNode | nil, ?end_keyword_loc: Location) -> SingletonClassNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, locals: Array[Symbol], class_keyword_loc: Location, operator_loc: Location, expression: Prism::node, body: StatementsNode | BeginNode | nil, end_keyword_loc: Location }
    def class_keyword: () -> String
    def operator: () -> String
    def end_keyword: () -> String
    def type: () -> :singleton_class_node
            | ...
    def self.type: () -> :singleton_class_node
  end

  # Represents the use of the `__ENCODING__` keyword.
  #
  #     __ENCODING__
  #     ^^^^^^^^^^^^
  class SourceEncodingNode < Node
    include _Node


    def initialize: (Source source, Integer node_id, Location location, Integer flags) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer) -> SourceEncodingNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location }
    def type: () -> :source_encoding_node
            | ...
    def self.type: () -> :source_encoding_node
  end

  # Represents the use of the `__FILE__` keyword.
  #
  #     __FILE__
  #     ^^^^^^^^
  class SourceFileNode < Node
    include _Node

    def forced_utf8_encoding?: () -> bool
    def forced_binary_encoding?: () -> bool
    def frozen?: () -> bool
    def mutable?: () -> bool

    attr_reader filepath: String

    def initialize: (Source source, Integer node_id, Location location, Integer flags, String filepath) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?filepath: String) -> SourceFileNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, filepath: String }
    def type: () -> :source_file_node
            | ...
    def self.type: () -> :source_file_node
  end

  # Represents the use of the `__LINE__` keyword.
  #
  #     __LINE__
  #     ^^^^^^^^
  class SourceLineNode < Node
    include _Node


    def initialize: (Source source, Integer node_id, Location location, Integer flags) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer) -> SourceLineNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location }
    def type: () -> :source_line_node
            | ...
    def self.type: () -> :source_line_node
  end

  # Represents the use of the splat operator.
  #
  #     [*a]
  #      ^^
  class SplatNode < Node
    include _Node

    attr_reader operator_loc: Location
    attr_reader expression: Prism::node?

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location operator_loc, Prism::node? expression) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?operator_loc: Location, ?expression: Prism::node?) -> SplatNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, operator_loc: Location, expression: Prism::node? }
    def operator: () -> String
    def type: () -> :splat_node
            | ...
    def self.type: () -> :splat_node
  end

  # Represents a set of statements contained within some scope.
  #
  #     foo; bar; baz
  #     ^^^^^^^^^^^^^
  class StatementsNode < Node
    include _Node

    attr_reader body: Array[Prism::node]

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Array[Prism::node] body) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?body: Array[Prism::node]) -> StatementsNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, body: Array[Prism::node] }
    def type: () -> :statements_node
            | ...
    def self.type: () -> :statements_node
  end

  # Represents a string literal, a string contained within a `%w` list, or plain string content within an interpolated string.
  #
  #     "foo"
  #     ^^^^^
  #
  #     %w[foo]
  #        ^^^
  #
  #     "foo #{bar} baz"
  #      ^^^^      ^^^^
  class StringNode < Node
    include _Node

    def forced_utf8_encoding?: () -> bool
    def forced_binary_encoding?: () -> bool
    def frozen?: () -> bool
    def mutable?: () -> bool

    attr_reader opening_loc: Location?
    attr_reader content_loc: Location
    attr_reader closing_loc: Location?
    attr_reader unescaped: String

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location? opening_loc, Location content_loc, Location? closing_loc, String unescaped) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?opening_loc: Location?, ?content_loc: Location, ?closing_loc: Location?, ?unescaped: String) -> StringNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, opening_loc: Location?, content_loc: Location, closing_loc: Location?, unescaped: String }
    def opening: () -> String?
    def content: () -> String
    def closing: () -> String?
    def type: () -> :string_node
            | ...
    def self.type: () -> :string_node
  end

  # Represents the use of the `super` keyword with parentheses or arguments.
  #
  #     super()
  #     ^^^^^^^
  #
  #     super foo, bar
  #     ^^^^^^^^^^^^^^
  class SuperNode < Node
    include _Node

    attr_reader keyword_loc: Location
    attr_reader lparen_loc: Location?
    attr_reader arguments: ArgumentsNode?
    attr_reader rparen_loc: Location?
    attr_reader block: BlockNode | BlockArgumentNode | nil

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location keyword_loc, Location? lparen_loc, ArgumentsNode? arguments, Location? rparen_loc, BlockNode | BlockArgumentNode | nil block) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?keyword_loc: Location, ?lparen_loc: Location?, ?arguments: ArgumentsNode?, ?rparen_loc: Location?, ?block: BlockNode | BlockArgumentNode | nil) -> SuperNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, keyword_loc: Location, lparen_loc: Location?, arguments: ArgumentsNode?, rparen_loc: Location?, block: BlockNode | BlockArgumentNode | nil }
    def keyword: () -> String
    def lparen: () -> String?
    def rparen: () -> String?
    def type: () -> :super_node
            | ...
    def self.type: () -> :super_node
  end

  # Represents a symbol literal or a symbol contained within a `%i` list.
  #
  #     :foo
  #     ^^^^
  #
  #     %i[foo]
  #        ^^^
  class SymbolNode < Node
    include _Node

    def forced_utf8_encoding?: () -> bool
    def forced_binary_encoding?: () -> bool
    def forced_us_ascii_encoding?: () -> bool

    attr_reader opening_loc: Location?
    attr_reader value_loc: Location?
    attr_reader closing_loc: Location?
    attr_reader unescaped: String

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location? opening_loc, Location? value_loc, Location? closing_loc, String unescaped) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?opening_loc: Location?, ?value_loc: Location?, ?closing_loc: Location?, ?unescaped: String) -> SymbolNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, opening_loc: Location?, value_loc: Location?, closing_loc: Location?, unescaped: String }
    def opening: () -> String?
    def value: () -> String?
    def closing: () -> String?
    def type: () -> :symbol_node
            | ...
    def self.type: () -> :symbol_node
  end

  # Represents the use of the literal `true` keyword.
  #
  #     true
  #     ^^^^
  class TrueNode < Node
    include _Node


    def initialize: (Source source, Integer node_id, Location location, Integer flags) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer) -> TrueNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location }
    def type: () -> :true_node
            | ...
    def self.type: () -> :true_node
  end

  # Represents the use of the `undef` keyword.
  #
  #     undef :foo, :bar, :baz
  #     ^^^^^^^^^^^^^^^^^^^^^^
  class UndefNode < Node
    include _Node

    attr_reader names: Array[SymbolNode | InterpolatedSymbolNode]
    attr_reader keyword_loc: Location

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Array[SymbolNode | InterpolatedSymbolNode] names, Location keyword_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?names: Array[SymbolNode | InterpolatedSymbolNode], ?keyword_loc: Location) -> UndefNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, names: Array[SymbolNode | InterpolatedSymbolNode], keyword_loc: Location }
    def keyword: () -> String
    def type: () -> :undef_node
            | ...
    def self.type: () -> :undef_node
  end

  # Represents the use of the `unless` keyword, either in the block form or the modifier form.
  #
  #     bar unless foo
  #     ^^^^^^^^^^^^^^
  #
  #     unless foo then bar end
  #     ^^^^^^^^^^^^^^^^^^^^^^^
  class UnlessNode < Node
    include _Node

    attr_reader keyword_loc: Location
    attr_reader predicate: Prism::node
    attr_reader then_keyword_loc: Location?
    attr_reader statements: StatementsNode?
    attr_reader else_clause: ElseNode?
    attr_reader end_keyword_loc: Location?

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location keyword_loc, Prism::node predicate, Location? then_keyword_loc, StatementsNode? statements, ElseNode? else_clause, Location? end_keyword_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?keyword_loc: Location, ?predicate: Prism::node, ?then_keyword_loc: Location?, ?statements: StatementsNode?, ?else_clause: ElseNode?, ?end_keyword_loc: Location?) -> UnlessNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, keyword_loc: Location, predicate: Prism::node, then_keyword_loc: Location?, statements: StatementsNode?, else_clause: ElseNode?, end_keyword_loc: Location? }
    def keyword: () -> String
    def then_keyword: () -> String?
    def end_keyword: () -> String?
    def type: () -> :unless_node
            | ...
    def self.type: () -> :unless_node
  end

  # Represents the use of the `until` keyword, either in the block form or the modifier form.
  #
  #     bar until foo
  #     ^^^^^^^^^^^^^
  #
  #     until foo do bar end
  #     ^^^^^^^^^^^^^^^^^^^^
  class UntilNode < Node
    include _Node

    def begin_modifier?: () -> bool

    attr_reader keyword_loc: Location
    attr_reader do_keyword_loc: Location?
    attr_reader closing_loc: Location?
    attr_reader predicate: Prism::node
    attr_reader statements: StatementsNode?

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location keyword_loc, Location? do_keyword_loc, Location? closing_loc, Prism::node predicate, StatementsNode? statements) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?keyword_loc: Location, ?do_keyword_loc: Location?, ?closing_loc: Location?, ?predicate: Prism::node, ?statements: StatementsNode?) -> UntilNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, keyword_loc: Location, do_keyword_loc: Location?, closing_loc: Location?, predicate: Prism::node, statements: StatementsNode? }
    def keyword: () -> String
    def do_keyword: () -> String?
    def closing: () -> String?
    def type: () -> :until_node
            | ...
    def self.type: () -> :until_node
  end

  # Represents the use of the `when` keyword within a case statement.
  #
  #     case true
  #     when true
  #     ^^^^^^^^^
  #     end
  class WhenNode < Node
    include _Node

    attr_reader keyword_loc: Location
    attr_reader conditions: Array[Prism::node]
    attr_reader then_keyword_loc: Location?
    attr_reader statements: StatementsNode?

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location keyword_loc, Array[Prism::node] conditions, Location? then_keyword_loc, StatementsNode? statements) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?keyword_loc: Location, ?conditions: Array[Prism::node], ?then_keyword_loc: Location?, ?statements: StatementsNode?) -> WhenNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, keyword_loc: Location, conditions: Array[Prism::node], then_keyword_loc: Location?, statements: StatementsNode? }
    def keyword: () -> String
    def then_keyword: () -> String?
    def type: () -> :when_node
            | ...
    def self.type: () -> :when_node
  end

  # Represents the use of the `while` keyword, either in the block form or the modifier form.
  #
  #     bar while foo
  #     ^^^^^^^^^^^^^
  #
  #     while foo do bar end
  #     ^^^^^^^^^^^^^^^^^^^^
  class WhileNode < Node
    include _Node

    def begin_modifier?: () -> bool

    attr_reader keyword_loc: Location
    attr_reader do_keyword_loc: Location?
    attr_reader closing_loc: Location?
    attr_reader predicate: Prism::node
    attr_reader statements: StatementsNode?

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location keyword_loc, Location? do_keyword_loc, Location? closing_loc, Prism::node predicate, StatementsNode? statements) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?keyword_loc: Location, ?do_keyword_loc: Location?, ?closing_loc: Location?, ?predicate: Prism::node, ?statements: StatementsNode?) -> WhileNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, keyword_loc: Location, do_keyword_loc: Location?, closing_loc: Location?, predicate: Prism::node, statements: StatementsNode? }
    def keyword: () -> String
    def do_keyword: () -> String?
    def closing: () -> String?
    def type: () -> :while_node
            | ...
    def self.type: () -> :while_node
  end

  # Represents an xstring literal with no interpolation.
  #
  #     `foo`
  #     ^^^^^
  class XStringNode < Node
    include _Node

    def forced_utf8_encoding?: () -> bool
    def forced_binary_encoding?: () -> bool

    attr_reader opening_loc: Location
    attr_reader content_loc: Location
    attr_reader closing_loc: Location
    attr_reader unescaped: String

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location opening_loc, Location content_loc, Location closing_loc, String unescaped) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?opening_loc: Location, ?content_loc: Location, ?closing_loc: Location, ?unescaped: String) -> XStringNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, opening_loc: Location, content_loc: Location, closing_loc: Location, unescaped: String }
    def opening: () -> String
    def content: () -> String
    def closing: () -> String
    def type: () -> :x_string_node
            | ...
    def self.type: () -> :x_string_node
  end

  # Represents the use of the `yield` keyword.
  #
  #     yield 1
  #     ^^^^^^^
  class YieldNode < Node
    include _Node

    attr_reader keyword_loc: Location
    attr_reader lparen_loc: Location?
    attr_reader arguments: ArgumentsNode?
    attr_reader rparen_loc: Location?

    def initialize: (Source source, Integer node_id, Location location, Integer flags, Location keyword_loc, Location? lparen_loc, ArgumentsNode? arguments, Location? rparen_loc) -> void
    def copy: (?node_id: Integer, ?location: Location, ?flags: Integer, ?keyword_loc: Location, ?lparen_loc: Location?, ?arguments: ArgumentsNode?, ?rparen_loc: Location?) -> YieldNode
    def deconstruct_keys: (Array[Symbol] keys) -> { node_id: Integer, location: Location, keyword_loc: Location, lparen_loc: Location?, arguments: ArgumentsNode?, rparen_loc: Location? }
    def keyword: () -> String
    def lparen: () -> String?
    def rparen: () -> String?
    def type: () -> :yield_node
            | ...
    def self.type: () -> :yield_node
  end

  # Flags for arguments nodes.
  module ArgumentsNodeFlags
    # if the arguments contain forwarding
    CONTAINS_FORWARDING: Integer
    # if the arguments contain keywords
    CONTAINS_KEYWORDS: Integer
    # if the arguments contain a keyword splat
    CONTAINS_KEYWORD_SPLAT: Integer
    # if the arguments contain a splat
    CONTAINS_SPLAT: Integer
    # if the arguments contain multiple splats
    CONTAINS_MULTIPLE_SPLATS: Integer
  end

  # Flags for array nodes.
  module ArrayNodeFlags
    # if array contains splat nodes
    CONTAINS_SPLAT: Integer
  end

  # Flags for call nodes.
  module CallNodeFlags
    # &. operator
    SAFE_NAVIGATION: Integer
    # a call that could have been a local variable
    VARIABLE_CALL: Integer
    # a call that is an attribute write, so the value being written should be returned
    ATTRIBUTE_WRITE: Integer
    # a call that ignores method visibility
    IGNORE_VISIBILITY: Integer
  end

  # Flags for nodes that have unescaped content.
  module EncodingFlags
    # internal bytes forced the encoding to UTF-8
    FORCED_UTF8_ENCODING: Integer
    # internal bytes forced the encoding to binary
    FORCED_BINARY_ENCODING: Integer
  end

  # Flags for integer nodes that correspond to the base of the integer.
  module IntegerBaseFlags
    # 0b prefix
    BINARY: Integer
    # 0d or no prefix
    DECIMAL: Integer
    # 0o or 0 prefix
    OCTAL: Integer
    # 0x prefix
    HEXADECIMAL: Integer
  end

  # Flags for interpolated string nodes that indicated mutability if they are also marked as literals.
  module InterpolatedStringNodeFlags
    # frozen by virtue of a `frozen_string_literal: true` comment or `--enable-frozen-string-literal`; only for adjacent string literals like `'a' 'b'`
    FROZEN: Integer
    # mutable by virtue of a `frozen_string_literal: false` comment or `--disable-frozen-string-literal`; only for adjacent string literals like `'a' 'b'`
    MUTABLE: Integer
  end

  # Flags for keyword hash nodes.
  module KeywordHashNodeFlags
    # a keyword hash which only has `AssocNode` elements all with symbol keys, which means the elements can be treated as keyword arguments
    SYMBOL_KEYS: Integer
  end

  # Flags for while and until loop nodes.
  module LoopFlags
    # a loop after a begin statement, so the body is executed first before the condition
    BEGIN_MODIFIER: Integer
  end

  # Flags for parameter nodes.
  module ParameterFlags
    # a parameter name that has been repeated in the method signature
    REPEATED_PARAMETER: Integer
  end

  # Flags for parentheses nodes.
  module ParenthesesNodeFlags
    # parentheses that contain multiple potentially void statements
    MULTIPLE_STATEMENTS: Integer
  end

  # Flags for range and flip-flop nodes.
  module RangeFlags
    # ... operator
    EXCLUDE_END: Integer
  end

  # Flags for regular expression and match last line nodes.
  module RegularExpressionFlags
    # i - ignores the case of characters when matching
    IGNORE_CASE: Integer
    # x - ignores whitespace and allows comments in regular expressions
    EXTENDED: Integer
    # m - allows $ to match the end of lines within strings
    MULTI_LINE: Integer
    # o - only interpolates values into the regular expression once
    ONCE: Integer
    # e - forces the EUC-JP encoding
    EUC_JP: Integer
    # n - forces the ASCII-8BIT encoding
    ASCII_8BIT: Integer
    # s - forces the Windows-31J encoding
    WINDOWS_31J: Integer
    # u - forces the UTF-8 encoding
    UTF_8: Integer
    # internal bytes forced the encoding to UTF-8
    FORCED_UTF8_ENCODING: Integer
    # internal bytes forced the encoding to binary
    FORCED_BINARY_ENCODING: Integer
    # internal bytes forced the encoding to US-ASCII
    FORCED_US_ASCII_ENCODING: Integer
  end

  # Flags for shareable constant nodes.
  module ShareableConstantNodeFlags
    # constant writes that should be modified with shareable constant value literal
    LITERAL: Integer
    # constant writes that should be modified with shareable constant value experimental everything
    EXPERIMENTAL_EVERYTHING: Integer
    # constant writes that should be modified with shareable constant value experimental copy
    EXPERIMENTAL_COPY: Integer
  end

  # Flags for string nodes.
  module StringFlags
    # internal bytes forced the encoding to UTF-8
    FORCED_UTF8_ENCODING: Integer
    # internal bytes forced the encoding to binary
    FORCED_BINARY_ENCODING: Integer
    # frozen by virtue of a `frozen_string_literal: true` comment or `--enable-frozen-string-literal`
    FROZEN: Integer
    # mutable by virtue of a `frozen_string_literal: false` comment or `--disable-frozen-string-literal`
    MUTABLE: Integer
  end

  # Flags for symbol nodes.
  module SymbolFlags
    # internal bytes forced the encoding to UTF-8
    FORCED_UTF8_ENCODING: Integer
    # internal bytes forced the encoding to binary
    FORCED_BINARY_ENCODING: Integer
    # internal bytes forced the encoding to US-ASCII
    FORCED_US_ASCII_ENCODING: Integer
  end

  # The flags that are common to all nodes.
  module NodeFlags
    NEWLINE: Integer
    STATIC_LITERAL: Integer
  end
end
