module Captain
  module Assistants
    class AgentRunnerService
      # Attributes to include in the conversation state
      CONVERSATION_ATTRIBUTES = %i[
        id display_id inbox_id contact_id status priority
        label_list custom_attributes additional_attributes
      ].freeze

      # Attributes to include in the contact state
      CONTACT_ATTRIBUTES = %i[
        id name email phone_number identifier contact_type
        custom_attributes additional_attributes
      ].freeze

      def initialize(assistant:, conversation: nil, callbacks: {})
        @assistant = assistant
        @conversation = conversation
        @callbacks = callbacks
      end

      def generate_response(message_history: [])
        agent = @assistant.agent

        # TODO: Implement callback wiring when Captain::Agent supports it
        # wire_callbacks(agent)

        context_data = prepare_context(message_history)
        user_input = get_last_user_message(message_history)

        result = agent.execute(user_input, context_data)

        format_execution_result(result)
      rescue StandardError => e
        handle_execution_error(e)
      end

      private

      def prepare_context(history)
        {
          conversation_history: format_history(history),
          state: current_state
        }
      end

      def format_history(history)
        history.map do |msg|
          {
            role: msg[:role].to_sym,
            content: parse_content(msg[:content]),
            agent_name: msg[:agent_name]
          }
        end
      end

      def get_last_user_message(history)
        last_msg = history.reverse.find { |m| m[:role] == 'user' }
        return '' unless last_msg

        parse_content(last_msg[:content])
      end

      def parse_content(content)
        return content[:response] || content['response'] || content.to_s if content.is_a?(Hash)
        return content unless content.is_a?(Array)

        content.select { |p| p[:type] == 'text' }.pluck(:text).join(' ')
      end

      def current_state
        state = {
          account_id: @assistant.account_id,
          assistant_id: @assistant.id,
          assistant_config: @assistant.config
        }

        if @conversation
          state[:conversation] = @conversation.attributes.symbolize_keys.slice(*CONVERSATION_ATTRIBUTES)
          state[:contact] = @conversation.contact.attributes.symbolize_keys.slice(*CONTACT_ATTRIBUTES) if @conversation.contact
        end

        state
      end

      def format_execution_result(output)
        Rails.logger.info("Agent execution result: #{output.inspect}")

        normalize_output(output)
        # response['agent_name'] = ... # If we support multi-agent later
      end

      def normalize_output(output)
        if output.is_a?(Hash)
          result = output.with_indifferent_access
          result['reasoning'] ||= 'Generated by Captain AI'
          return result
        end

        {
          'response' => output.to_s,
          'reasoning' => 'Generated by Captain AI'
        }
      end

      def handle_execution_error(error)
        ChatwootExceptionTracker.new(error, account: @conversation&.account).capture_exception
        Rails.logger.error("AgentRunnerService Error: #{error.message}")

        {
          'response' => 'conversation_handoff',
          'reasoning' => "System error: #{error.message}"
        }
      end
    end
  end
end
